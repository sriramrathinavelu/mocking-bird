[{"answer": "", "question": ""},
{"answer": "", "question": ""},
{"answer": "\nAnalysis : It is a typical problem about dynamic programming. Firstly let\u2019s analyze it with recursion. A function f ( i , j ) is defined for the maximal value of gifts when reaching the cell ( i , j ). There are two possible cells before the cell ( i , j ) is reached: One is ( i - 1, j ), and the other is the cell ( i , j -1). Therefore, f ( i , j )= max ( f ( i -1, j ), f ( i , j -1)) + gift[ i , j ].\nEven though it\u2019s a recursive equation, it\u2019s not a good idea to write code in recursion, because there might be many over-lapping sub-problems. A better solution is to solve is with iteration. A 2-D matrix is utilized, and the value in each cell ( i , j ) is the maximal value of gift when reaching the cell ( i , j ) on the board.\nThe iterative solution can be implemented in the following Java code:\n public static int getMaxValue( int [][] values) {\nOptimization\n\nThe maximal value of gifts when reaching the cell ( i , j ) depends on the cells ( i -1, j ) and ( i , j -1) only, so it is not necessary to save the value of the cells in the rows i -2 and above. Therefore, we can replace the 2-D matrix with an array, as the following code shows:\n\n public static int getMaxValue( int [][] values)  {\n     int rows = values.length;\n     int cols = values[0].length;\n\n     int [] maxValues = new int [cols];\n     for ( int i = 0; i < rows; ++i)  {\n         for ( int j = 0; j < cols; ++j)  {\n             int left = 0;\n             int up = 0;\n\n             if (i > 0)  {\n                 up = maxValues[j];\n             }\n\n             if (j > 0)  {\n                 left = maxValues[j - 1];\n             }\n\n             maxValues[j] = Math .max(left, up) +values[i][j];\n         }\n     }\n\n     return maxValues[cols - 1];\n }", "question": "\nQuestion : A board has n * m cells, and there is a gift with some value (value is greater than 0) in every cell. You can get gifts starting from the top-left cell, and move right or down in each step, and finally reach the cell at the bottom-right cell. What\u2019s the maximal value of gifts you can get from the board?\n\n\nFor example, the maximal value of gift from the board above is 53, and the path is highlighted in red."},
{"answer": "\nAnalysis: We have discussed how to store nodes of a path in a stack while traversing a binary tree in the blog \" Paths with Specified Sum in Binary Tree \". The depth of a binary tree is the length of the longest path. This solution works, but it is not the most concise one.\n\nThe depth of a binary tree can be gotten in another way. If a binary tree has only one node, its depth is 1. If the root node of a binary tree has only a left subtree, its depth is the depth of the left subtree plus 1. Similarly, its depth is the depth of the right subtree plus 1 if the root node has only a right subtree. What is the depth if the root node has both left subtree and right subtree? It is the greater value of the depth of the left and right subtrees plus 1.\n\nFor example, the root node of the binary tree in Figure\u00a01 has both left and right subtrees. The depth of the left subtree rooted at node 2 is 3, and the depth of the right subtree rooted at node 3 is 2, so the depth of the whole binary tree is 4; 1 plus the greater value of 3 and 2.\n\nIt is easy to implement this solution recursively, with little modification on the post-order traversal algorithm, as shown below:\n\n int TreeDepth(BinaryTreeNode* pRoot)\n {\n     if (pRoot == NULL)\n         return 0;\n\n     int nLeft = TreeDepth(pRoot->m_pLeft);\n     int nRight = TreeDepth(pRoot->m_pRight);\n\n     return (nLeft > nRight) ? (nLeft + 1) : (nRight +1);\n }\n\n\nAnalysis:\n\nSolution 1: Visiting Nodes for Multiple Times\nAccording to the definition of balanced binary trees, this problem can be solved by getting the depth difference between the left and right subtrees of every node. When a node is visited, the function depth is invoked to get the depth of its left and right subtrees. If the depth different is 1 at most for all nodes in a binary tree, it is balanced. This solution can be implemented based on the TreeDepth discussed in the preceding problem, as shown below:\n\n bool IsBalanced_Solution1(BinaryTreeNode* pRoot)\n {\n     if (pRoot == NULL)\n         return true ;\n\n     int left = TreeDepth(pRoot->m_pLeft);\n     int right = TreeDepth(pRoot->m_pRight);\n     int diff = left - right;\n     if (diff > 1 || diff < -1)\n         return false ;\n\n     return IsBalanced_Solution1(pRoot->m_pLeft)\n         && IsBalanced_Solution1(pRoot->m_pRight);\n }  \nThis solution looks concise, but it is inefficient because it visits some nodes for multiple times. Take the binary tree in Figure\u00a01 as an example. When the function TreeDepth takes the node 2 as a parameter, it visits nodes 4, 5, and 7. When it verifies whether the binary tree rooted at node 2 is balanced, it visits nodes 4, 5, and 7 again. Obviously, we could improve performance if nodes are visited only once.\n\nSolution 2: Visiting Every Node Only Once\n\nIf a binary tree is scanned with the post-order algorithm, its left and right subtrees are traversed before the root node. If we record the depth of the currently visited node (the depth of a node is the maximum length of paths from the node to its leaf nodes), we can verify whether the subtree rooted at the currently visited node is balanced. If any subtree is unbalanced, the whole tree is unbalanced.\n\nThis new solution can be implemented as shown in below:\n\nbool IsBalanced_Solution2(BinaryTreeNode* pRoot)\n {\n     int depth = 0;\n     return IsBalanced(pRoot, &depth);\n }\n\n bool IsBalanced(BinaryTreeNode* pRoot, int * pDepth)\n {\n     if (pRoot == NULL)\n     {\n         *pDepth = 0;\n         return true ;\n     }\n\n     int left, right;\n     if (IsBalanced(pRoot->m_pLeft, &left) && IsBalanced(pRoot->m_pRight, &right))\n     {\n         int diff = left - right;\n         if (diff <= 1 && diff >= -1)\n         {\n             *pDepth = 1 + (left > right ? left : right);\n             return true ;\n         }\n     }\n\n     return false ;\n }\n\n\nAfter verifying left and right subtrees of a node, the solution verifies the subtree rooted at the current visited node and passes the depth to verify its parent node. When the recursive process returns to the root node finally, the whole binary tree is verified.\n\n", "question": "\nQuestion 1 : How do you get the depth of a binary tree? Nodes from the root to a leaf form a path. Depth of a binary tree is the maximum length of all paths. For example, the depth of the binary tree in Figure\u00a01 is 4, with the longest path through nodes 1, 2, 5, and 7.\n\nQuestion 2: How do you verify whether a binary tree is balanced? If the depth difference between a left subtree and right subtree of any node in a binary tree is not greater than 1, it is balanced. For instance, the binary tree in Figure\u00a01 is balanced.\n"},
{"answer": "", "question": ""},
{"answer": "\nAnalysis: All numbers in the matrix are scanned one by one. When a 1 is met, a group of 1s has been found, and then all 1s in the group are flipped to 0s.\nTherefore, the overall function to count the groups of 1s in a matrix can be implemented in the following C++ code:\n     int group = 0;\n     return group;\nLet\u2019s move on to flip 1s inside a group. Actually, it is an application of the seed filling algorithm. When we are going to flip a group starting from an entry, we take the entry as a seed and push it into a stack. At each step, we get an entry from the top of the stack, flip it, and then push its neighboring entries into the stack. The process continues until the stack is empty. The following code implements this algorithm:\n         int row = topIndex / cols;\n         // up", "question": ""},
{"answer": "\nAnalysis: Binary search tree is an important data structure. It has a specific character: Each node is greater than or equal to nodes in its left sub-tree, and less than or equal to nodes in its right sub-tree.\n\nSolution 1: Verify value range of each node\n\nIf a binary search tree is scanned with pre-order traversal algorithm, the value in a root node is accessed to at first. After the root node is visited, it begins to scan nodes in the left sub-tree. The value of left sub-tree nodes should be less than or equal to the value of the root node. If value of a left sub-tree node is greater than the value of the root node, it violates the definition of binary search tree. It is similar for the right sub-tree.\n\nTherefore, when it visits a node in binary search tree, it narrows the value range of left sub-tree and right sub-tree under the current visited node. All nodes are visited with the pre-order traversal algorithm, and their value is verified. If value in any node violates its corresponding range, it is not a binary search tree.\n\nThe following sample code is implemented based on this pre-order traversal solution:\n\nbool isBST_Solution1(BinaryTreeNode* pRoot)\n{\nint min = numeric_limits< int >::min();\nint max = numeric_limits< int >::max();\nreturn isBSTCore_Solution1(pRoot, min, max);\n}\n\nbool isBSTCore_Solution1(BinaryTreeNode* pRoot, int min, int max)\n{\nif (pRoot == NULL)\nreturn true ;\n\nif (pRoot->nValue < min || pRoot->nValue > max)\nreturn false ;\n\nreturn isBSTCore_Solution1(pRoot->pLeft, min, pRoot->nValue)\n&& isBSTCore_Solution1(pRoot->pRight, pRoot->nValue, max);\n}\n\nIn the code above, value of each node should be in the range between min and max . The value of the current visited node is the maximal value of its left sub-tree, and the minimal value of its right sub-tree, so it updates the min and max arguments and verifies sub-trees recursively.\n\nSolution 2: Increasing in-order traversal sequence\n\nThe first solution is based on pre-order traversal algorithm. Let us have another try on in-order traversal. The in-order traversal sequence of the binary search tree in Figure 1 is: 4, 6, 8, 10, 12, 14 and 16. It is noticeable that the sequence is increasingly sorted.\n\nTherefore, a new solution is available: Nodes in a binary tree is scanned with in-order traversal, and compare value of each node against the value of the previously visited node. If the value of the previously visited node is greater than the value of current node, it breaks the definition of binary tree.\n\nThis solution might be implemented in C++ as the following code:\n\nbool isBST_Solution2(BinaryTreeNode* pRoot)\n{\nint prev = numeric_limits< int >::min();\nreturn isBSTCore_Solution2(pRoot, prev);\n}\n\nbool isBSTCore_Solution2(BinaryTreeNode* pRoot, int& prev)\n{\nif (pRoot == NULL)\nreturn true ;\n\nreturn isBSTCore_Solution2(pRoot->pLeft, prev) // previous node\n&& (pRoot->nValue >= prev) // current node\n&& isBSTCore_Solution2(pRoot->pRight, prev = pRoot->nValue); // next node\n}\n\nThe argument prev of the function isBSTCore_Solution2 above is the value of the previously visited node in pre_order traversal.", "question": "\nQuestion: How to verify whether a binary tree is a binary search tree?\n\nFor example, the tree in Figure 1 is a binary search tree.\n\n\nA node in binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pRight;\n};\n"},
{"answer": "\nAnalysis: If we scan all integers in the array from beginning to end, we may check whether every element equals its index. Obviously, this solution costs O( n ) time.\nSince numbers are sorted in the array, let's try to utilize the binary search algorithm to optimize. Supposing we reach the i th element in the array at some step. If the value of element is also i , it is a target integer and let's return it.\nWhat would happen when the value m is greater than the index i ? For any k ( k >0), the value of element with index i + k should be greater than or equal to m + k , because integers are unique and increasingly sorted in the array. Additionally because m > k , m + k > i + k . Therefore, every element on the right side of index i should be greater than its index in such a case.\nSimilarly, when the value of element with index i is less than i ,\u00a0every integer on the left side should be less than its index. Please prove it if you are interested.\nTherefore, we could reduce the search scope to half for the next step, and it is a typical process for binary search. The solution can be implemented with the following Java code:\n public static int getNumberSameAsIndex( int [] numbers) {\n     if (numbers == null || numbers.length == 0) {\n         return -1;\n     }\n        \n     int left = 0;\n     int right = numbers.length - 1;\n     while (left <= right) {\n         int middle = left + ((right - left) >>> 1);\n         if (numbers[middle] == middle) {\n             return middle;\n         }\n            \n         if (numbers[middle] > middle) {\n             right = middle - 1;\n         }\n         else {\n             left= middle + 1;\n         }\n     }\n        \n     return -1;\n }", "question": "\nProblem: Integers in an array are unique and increasingly sorted. Please write a function/method to find an integer from the array who equals to its index. For example, in the array {-3, -1, 1, 3, 5}, the number 3 equals its index 3."},
{"answer": "", "question": ""},
{"answer": "\nAnalysis : It is a popular interview question. Similar to the problem to get the K th node from end is a list, it has a solution with two pointers.\n\nTwo pointers are initialized at the head of list. One pointer forwards once at each step, and the other forwards twice at each step. If the faster pointer meets the slower one again, there is a loop in the list. Otherwise there is no loop if the faster one reaches the end of list.\n\nThe sample code below is implemented according to this solution. The faster pointer is pFast , and the slower one is pSlow .\n\nbool HasLoop(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn false ;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn false ;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn true ;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn false ;\n}\n\n\nAnalysis : Inspired by the solution of the first problem, we can also solve this problem with two pointers.\n\n\nTwo pointers are initialized at the head of a list. If there are n nodes in the loop, the first pointer forwards n steps firstly. And then they forward together, at same speed. When the second pointer reaches the entry node of loop, the first one travels around the loop and returns back to entry node.\n\nLet us take the list in Figure 1 as an example. Two pointers, P1 and P2 are firstly initialized at the head node of the list (Figure 2-a). There are 4 nodes in the loop of list, so P1 moves 4 steps ahead, and reaches the node with value 5 (Figure 2-b). And then these two pointers move for 2 steps, and they meet at the node with value 3, which is the entry node of the loop.\n\nThe only problem is how to get the numbers in a loop. Let go back to the solution of the first question. We define two pointers, and the faster one meets the slower one if there is a loop. Actually, the meeting node should be inside the loop. Therefore, we can move forward from the meeting node and get the number of nodes in the loop when we arrive at the meeting node again.\n\nThe following function MeetingNode gets the meeting node of two pointers if there is a loop in a list, which is a minor modification of the previous HasLoop :\n\nListNode* MeetingNode(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn NULL;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn NULL;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn pFast;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn NULL;\n}\n\nWe can get the number of nodes in a loop of a list, and the entry node of loop after we know the meeting node, as shown below:\n\nListNode* EntryNodeOfLoop(ListNode* pHead)\n{\nListNode* meetingNode = MeetingNode(pHead);\nif (meetingNode == NULL)\nreturn NULL;\n\n// get the number of nodes in loop\nint nodesInLoop = 1;\nListNode* pNode1 = meetingNode;\nwhile (pNode1->m_pNext != meetingNode)\n{\npNode1 = pNode1->m_pNext;\n++nodesInLoop;\n}\n\n// move pNode1\npNode1 = pHead;\nfor ( int i = 0; i < nodesInLoop; ++i)\npNode1 = pNode1->m_pNext;\n\n// move pNode1 and pNode2\nListNode* pNode2 = pHead;\nwhile (pNode1 != pNode2)\n{\npNode1 = pNode1->m_pNext;\npNode2 = pNode2->m_pNext;\n}\n\nreturn pNode1;\n}", "question": "\nQuestion 1 : How to check whether there is a loop in a linked list? For example, the list in Figure 1 has a loop.\n\nA node in list is defined as the following structure:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n\n\nQuestion 2 : If there is a loop in a linked list, how to get the entry node of the loop? The entry node is the first node in the loop from head of list. For instance, the entry node of loop in the list of Figure 1 is the node with value 3.\n"},
{"answer": "\nAnalysis: Since numbers come from a stream, the count of numbers is dynamic, and increases over time. If a data container is defined for the numbers from a stream, new numbers will be inserted into the container when they are deserialized. Let us find an appropriate data structure for such a data container.\n\nAn array is the simplest choice. The array should be sorted, because we are going to get its median. Even though it only costs O(lg n ) time to find the position to be inserted with binary search algorithm, it costs O( n ) time to insert a number into a sorted array, because O( n ) numbers will be moved if there are n numbers in the array. It is very efficient to get the median, since it only takes O(1) time to access to a number in an array with an index.\n\nA sorted list is another choice. It takes O( n ) time to find the appropriate position to insert a new number. Additionally, the time to get the median can be optimized to O(1) if we define two pointers which points to the central one or two elements.\n\nA better choice available is a binary search tree, because it only costs O(lg n ) on average to insert a new node. However, the time complexity is O( n ) for the worst cases, when numbers are inserted in sorted (increasingly or decreasingly) order. To get the median number from a binary search tree, auxiliary data to record the number of nodes of its sub-tree is necessary for each node. It also requires O(lg n ) time to get the median node on overage, but O( n ) time for the worst cases.\n\nWe may utilize a balanced binary search tree, AVL, to avoid the worst cases. Usually the balance factor of a node in AVL trees is the height difference between its right sub-tree and left sub-tree. We may modify a little bit here: Define the balance factor as the difference of number of nodes between its right sub-tree and left sub-tree. It costs O(lg n ) time to insert a new node into an AVL, and O(1) time to get the median for all cases.\n\nAn AVL is efficient, but it is not implemented unfortunately in libraries of the most common programming languages. It is also very difficult for candidates to implement the left/right rotation of AVL trees in dozens of minutes during interview. Let us looks for better solutions.\n\nAs shown in Figure 1, if all numbers are sorted, the numbers which are related to the median are indexed by P1 and P2. If the count of numbers is odd, P1 and P2 point to the same central number. If the count is even, P1 and P2 point to two numbers in middle.\n\nMedian can be get or calculated with the numbers pointed by P1 are P2. It is noticeable that all numbers are divided into two parts. The numbers in the first half are less than the numbers in the second half. Moreover, the number indexed by P1 is the greatest number in the first half, and the number indexed by P2 is the least one in the second half.\nTherefore, numbers in the first half are inserted into a max heap, and numbers in the second half are inserted into a min heap. It costs O(lg n ) time to insert a number into a heap. Since the median can be get or calculated with the root of a min heap and a max heap, it only takes O(1) time.\n\nTable 1 compares the solutions above with a sorted array, a sorted list, a binary search tree, an AVL tree, as well as a min heap and a max heap.\nType for Data Container Time to Insert Time to Get Median Sorted Array O( n ) O(1) Sorted List O( n ) O(1) Binary Search Tree O(lg n ) on   average, O( n ) for the worst cases O(lg n ) on average,   O( n ) for the worst cases AVL O(lg n ) O(1) Max Heap and Min Heap O(lg n ) O(1)\nType for Data Container\nTime to Insert\nTime to Get Median\nSorted Array\nO( n )\nO(1)\nSorted List\nO( n )\nO(1)\nBinary Search Tree\nO(lg n ) on   average, O( n ) for the worst cases\nO(lg n ) on average,   O( n ) for the worst cases\nAVL\nO(lg n )\nO(1)\nMax Heap and Min Heap\nO(lg n )\nO(1)\nTable 1: Summary of solutions with a sorted array, a sorted list, a binary search tree, an AVL tree, as well as a min heap and a max heap.\n\nLet us consider the implementation details. All numbers should be evenly divided into two parts, so the count of number in min heap and max heap should diff 1 at most. To achieve such a division, a new number is inserted into the min heap if the count of existing numbers is even; otherwise it is inserted into the max heap.\n\nWe also should make sure that the numbers in the max heap are less than the numbers in the min heap. Supposing the count of existing numbers is even, a new number will be inserted into the min heap. If the new number is less than some numbers in the max heap, it violates our rule that all numbers in the min heap should be greater than numbers in the min heap.\n\nIn such a case, we can insert the new number into the max heap first, and then pop the greatest number from the max heap, and push it into the min heap. Since the number pushed into the min heap is the former greatest number in the max heap, all numbers in the min heap are greater than numbers in the max heap with the newly inserted number.\n\nThe situation is similar when the count of existing numbers is odd and the new number to be inserted is greater than some numbers in the min heap. Please analyze the insertion process carefully by yourself.\n\nThe following is sample code in C++. Even though there are no types for heaps in STL, we can build heaps with vectors utilizing function push_heap and pop_heap . Comparing functor less and greater are employed for max heaps and min heaps correspondingly.\n\ntemplate < typename T> class DynamicArray\n{\npublic :\nvoid Insert(T num)\n{\nif (((minHeap.size() + maxHeap.size()) & 1) == 0)\n{\nif (maxHeap.size() > 0 && num < maxHeap[0])\n{\nmaxHeap.push_back(num);\npush_heap(maxHeap.begin(), maxHeap.end(), less<T>());\n\nnum = maxHeap[0];\n\npop_heap(maxHeap.begin(), maxHeap.end(), less<T>());\nmaxHeap.pop_back();\n}\n\nminHeap.push_back(num);\npush_heap(minHeap.begin(), minHeap.end(), greater<T>());\n}\nelse\n{\nif (minHeap.size() > 0 && minHeap[0] < num)\n{\nminHeap.push_back(num);\npush_heap(minHeap.begin(), minHeap.end(), greater<T>());\n\nnum = minHeap[0];\n\npop_heap(minHeap.begin(), minHeap.end(), greater<T>());\nminHeap.pop_back();\n}\n\nmaxHeap.push_back(num);\npush_heap(maxHeap.begin(), maxHeap.end(), less<T>());\n}\n}\n\nint GetMedian()\n{\nint size = minHeap.size() + maxHeap.size();\nif (size == 0)\nthrow exception( \"No numbers are available\" );\n\nT median = 0;\nif (size & 1 == 1)\nmedian = minHeap[0];\nelse\nmedian = (minHeap[0] + maxHeap[0]) / 2;\n\nreturn median;\n}\n\nprivate :\nvector<T> minHeap;\nvector<T> maxHeap;\n};\n\nIn the code above, function Insert is used to insert a new number deserialized from a stream, and GetMedian is used to get the median of the existing numbers dynamically.", "question": "\nQuestion: How to get the median from a stream of numbers at any time? The median is middle value of numbers. If the count of numbers is even, the median is defined as the average value of the two numbers in middle.\n"},
{"answer": "\nAnalysis: It is a classic interview questions to get numbers in Fibonacci sequences. We have different solutions for it, and their performance varies a lot.\n\nSolution 1: Inefficient recursive solution\n\nFibonacci sequences are taken as examples to lecture recursive functions in many C/C++ textbooks, so most of candidates are familiar with the recursive solution. They feel confident and delighted when they meet this problem during interviews, because the can write the following code in short time:\n\nlong long Fibonacci( unsigned int n)\n{\nif (n <= 0)\nreturn 0;\n\nif (n == 1)\nreturn 1;\n\nreturn Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n\nOur textbooks take Fibonacci sequences as examples for recursive functions does not necessarily mean that recursion is a good solution for Fibonacci sequences. Interviewers may tell candidates that the performance of this recursive solution is quite bad, and ask them to analyze root causes.\n\nLet us take f(10) as an example to analyze the recursive process. We have to get f(9) and f(8) before we get f(10). Meanwhile, f(8) and f(7) are needed before we get f(9). The dependency can be visualized in a tree as shown in Figure 1:\n\n\n\nIt is not difficult to notice that there are many duplicate nodes in the tree in Figure 1. The number of duplicated nodes increases dramatically when n increases. \u00a0Readers may have a try on the 100 th number if Fibonacci sequences to have intuitive ideas about how slow this recursive solution is.\n\nSolution 2: Practical Solution with O(n) efficiency\n\nIt is easy to optimize performance fortunately if we calculate from bottom. That is to say, we get f(2) based on f(0) and f(1), and get f(3) based on f(1) and f(2). We follow this pattern till we get f(n). It is obvious that its time complexity is O(n). Its corresponding code is shown below:\n\nlong long Fibonacci( unsigned n)\n{\nint result[2] = {0, 1};\nif (n < 2)\nreturn result[n];\n\nlong long fibNMinusOne = 1;\nlong long fibNMinusTwo = 0;\nlong long fibN = 0;\nfor ( unsigned int i = 2; i <= n; ++ i)\n{\nfibN = fibNMinusOne + fibNMinusTwo;\n\nfibNMinusTwo = fibNMinusOne;\nfibNMinusOne = fibN;\n}\n\nreturn fibN;\n}\n\nSolution 3: O( log n) solution\n\nUsually interviewers expect the O(n) solution above. However, there is an O( log n) solution available, which is based on an uncommon equation as shown below:\n\n\nIt is not difficult to prove this equation vithmathematical induction. Interested readers may have try.\n\nNow the only problem is how to calculate power of a matrix . We can calculate power with exponent n in O( log n) time with the following equation:\n\n\n\n\n\nThe source code to get power of a matrix looks complicated, which is listed below:\n\n#include <cassert>\n\nstruct Matrix2By2\n{\nMatrix2By2\n(\nlong long m00 = 0,\nlong long m01 = 0,\nlong long m10 = 0,\nlong long m11 = 0\n)\n:m_00(m00), m_01(m01), m_10(m10), m_11(m11)\n{\n}\n\nlong long m_00;\nlong long m_01;\nlong long m_10;\nlong long m_11;\n};\n\nMatrix2By2 MatrixMultiply\n(\nconst Matrix2By2& matrix1,\nconst Matrix2By2& matrix2\n)\n{\nreturn Matrix2By2(\nmatrix1.m_00 * matrix2.m_00 + matrix1.m_01 * matrix2.m_10,\nmatrix1.m_00 * matrix2.m_01 + matrix1.m_01 * matrix2.m_11,\nmatrix1.m_10 * matrix2.m_00 + matrix1.m_11 * matrix2.m_10,\nmatrix1.m_10 * matrix2.m_01 + matrix1.m_11 * matrix2.m_11);\n}\n\nMatrix2By2 MatrixPower( unsigned int n)\n{\nassert(n > 0);\n\nMatrix2By2 matrix;\nif (n == 1)\n{\nmatrix = Matrix2By2(1, 1, 1, 0);\n}\nelse if (n % 2 == 0)\n{\nmatrix = MatrixPower(n / 2);\nmatrix = MatrixMultiply(matrix, matrix);\n}\nelse if (n % 2 == 1)\n{\nmatrix = MatrixPower((n - 1) / 2);\nmatrix = MatrixMultiply(matrix, matrix);\nmatrix = MatrixMultiply(matrix, Matrix2By2(1, 1, 1, 0));\n}\n\nreturn matrix;\n}\n\nlong long Fibonacci( unsigned int n)\n{\nint result[2] = {0, 1};\nif (n < 2)\nreturn result[n];\n\nMatrix2By2 PowerNMinus2 = MatrixPower(n - 1);\nreturn PowerNMinus2.m_00;\n}\n\nEven though it cost only O( log n) time in theory, its hidden constant parameter is quite big, so it is not treated as a practical solution in real software development. Additionally, it is not a recommended solution during interviews since its implementation code is very complex.", "question": "\nProblem: Please implement a function which returns the n th number in Fibonacci sequences with an input n. Fibonacci sequence is defined as:\n\n\n\n"},
{"answer": "\nAnalysis: Path in a binary tree is a new concept for many candidates, so it is not a simple question for them. We may try to find the hidden rules with concrete examples. Let us take the binary tree in Figure 1 as an example.\n\nSince paths always start from a root node, we traverse from a root node in a binary tree. We have three traversal orders, pre-order, in-order and post-order, and we firstly visit a root node with pre-order traversal.\n\nAccording to the pre-order traversal process on the binary tree in Figure 1, we visit the node 5 after visiting the root node 10. Since a binary tree node does not have a pointer to its parent node, we do not know what nodes have been visited when we reach the node 5 if we do not save the visited node on the path. Therefore, we could insert the current node into a path when we reach it during traversal. The path contains two nodes with value 10 and 5 when we are visiting the node 5. Then we insert the node 4 into the path too when we reach it. We have reached a leaf node, and the sum of three nodes in the path is 19. Since it is not same as the input number 22, current path is not a qualified one.\nWe should continue to traverse other nodes. Before visiting other nodes, we should return back to the node 5, and then reach the node 7. It can be noticed that node 4 is no longer in the path from node 10 to node 7, so we should remove it from the path. When we are visiting node 7, we insert it into the path, which contains three nodes now. Since the sum of value of these three nodes is 22, the path is qualified.\n\nLastly we are going to visit the node 12. We should return back to node 5 then back to node 10 before we visit node 12. When we return back from a child node to its parent node, we remove the child node from the path. When we reach the node 12 eventually, the path contains two nodes, one is node 10 and the other is node 12. Since the sum of value of these two nodes is 22, the path is qualified too.\n\nWe can summarize the whole process above with the Table 1:\n\nStep Operation Is it a leaf? Path Sum of nodes value 1 Visit node 10 No node 10 10 2 Visit node 5 No node 10, node 5 15 3 Visit node 4 Yes node 10, node 5, node 4 19 4 Return to node 5 node 10, node 5 15 5 Visit node 7 Yes node 10, node 5, node 7 22 6 Return to node 5 node 10, node 5 15 7 Return to node 10 node 10 10 8 Visit node 12 Yes node 10, node 12 22\nStep\nOperation\nIs it a leaf?\nPath\nSum of nodes value\n1\nVisit node 10\nNo\nnode 10\n10\n2\nVisit node 5\nNo\nnode 10, node 5\n15\n3\nVisit node 4\nYes\nnode 10, node 5, node 4\n19\n4\nReturn to node 5\n\nnode 10, node 5\n15\n5\nVisit node 7\nYes\nnode 10, node 5, node 7\n22\n6\nReturn to node 5\n\nnode 10, node 5\n15\n7\nReturn to node 10\n\nnode 10\n10\n8\nVisit node 12\nYes\nnode 10, node 12\n22\nTable 1: The process to traverse the binary tree in Figure 1\n\nIt is time to summarize some rules with the example above. When we visit a node with pre-order traversal order, we insert it into the path, and accumulate its value to sum .\u00a0 When the node is a leaf and sum is same as the input number, the path is qualified and we need to print it. We continue to visit its children if the current node is not a leaf. After we finish visiting the current node, a recursive function will return back to its parent node automatically, so we should remove the current node from the path before a function returns to make sure the nodes in the path is same as the path from root node to its parent node. The data structure to save paths should be a stack, because paths should be consistent to the recursion status and recursion is essentially pushing and popping in a call stack.\nHere is some sample code for this problem:\n\nvoid FindPath(BinaryTreeNode* pRoot, int expectedSum)\n{\nif (pRoot == NULL)\nreturn ;\n\nstd::vector< int > path;\nint currentSum = 0;\nFindPath(pRoot, expectedSum, path, currentSum);\n}\n\nvoid FindPath\n(\nBinaryTreeNode*\u00a0\u00a0 pRoot,\nint expectedSum,\nstd::vector< int >&\u00a0path,\nint currentSum\n)\n{\ncurrentSum += pRoot->m_nValue;\npath.push_back(pRoot->m_nValue);\n\n// Print the path is the current node is a leaf\n// and the sum of all nodes value is same as expectedSum\nbool isLeaf = pRoot->m_pLeft == NULL && pRoot->m_pRight == NULL;\nif (currentSum == expectedSum && isLeaf)\n{\nprintf( \"A path is found: \" );\nstd::vector< int >::iterator iter = path.begin();\nfor (; iter != path.end(); ++ iter)\nprintf( \"%d\\t\" , *iter);\n\nprintf( \"\\n\" );\n}\n\n// If it is not a leaf, continue visition its children\nif (pRoot->m_pLeft != NULL)\nFindPath(pRoot->m_pLeft, expectedSum, path, currentSum);\nif (pRoot->m_pRight != NULL)\nFindPath(pRoot->m_pRight, expectedSum, path, currentSum);\n\n// Before returning back to its parent, remove it from path,\npath.pop_back();\n}\n\nIn the code above, we save path with a vector in STL actually. We use function push_back to insert a node and pop_back to remove a node to assure it is \u201cFirst in Last out\u201d in a path. The reason we don\u2019t utilize a stack in STL is that we can only get an element at the top of a stack, but we need to get all nodes when we print a path. Therefore, std::stack is not the best choice for us.", "question": "\nQuestion: All nodes along children pointers from root to leaf nodes form a path in a binary tree. Given a binary tree and a number, please print out all of paths where the sum of all nodes value is same as the given number. The node of binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n\nFor instance, if inputs are the binary tree in Figure 1 and a number 22, two paths with be printed: One is the path contains node 10 and 12, and the other contains 10, 5 and 7."},
{"answer": "\nAnalysis : An array has two ends, so each of the two stacks may grow from an end in the array. Figure 1 below shows the initial status of the array and two stacks (assuming the capacity of the array is 10).\nFigure 2: The status after three items are pushed into the first stack and two items are pushed into the second stack\n\ufeffNo more items can be pushed into stacks when two top items are adjacent to each other, because all space in the array has been occupied.\nOur solution can be implemented with the following C++ class: template < typename T, int capacity> class TwoStacks { public : TwoStacks() { topFirst = -1; topSecond = capacity; } T top( int stackIndex) { validateIndex(stackIndex); if (empty(stackIndex)) throw new exception( \"The stack is empty.\" ); if (stackIndex == 0) return items[topFirst]; return items[topSecond]; } void push( int stackIndex, T item) { validateIndex(stackIndex); if (full()) throw new exception( \"All space has been occupied.\" ); if (stackIndex == 0) items[++topFirst] = item; else items[--topSecond] = item; } void pop( int stackIndex) { validateIndex(stackIndex); if (empty(stackIndex)) throw new exception( \"The stack is empty.\" ); if (stackIndex == 0) --topFirst; else ++topSecond; } bool empty( int stackIndex) { if (stackIndex == 0 && topFirst == -1) return true ; if (stackIndex == 1 && topSecond == capacity) return true ; return false ; } private : bool full() { return (topFirst >= topSecond - 1); } void validateIndex( int stackIndex) { if (stackIndex < 0 || stackIndex > 1) throw new exception( \"Invalid Stack Index.\" ); } private : T items[capacity]; int topFirst; int topSecond; };\ntemplate < typename T, int capacity> class TwoStacks\n{\npublic :\nTwoStacks()\n{\ntopFirst = -1;\ntopSecond = capacity;\n}\n\nT top( int stackIndex)\n{\nvalidateIndex(stackIndex);\nif (empty(stackIndex))\nthrow new exception( \"The stack is empty.\" );\n\nif (stackIndex == 0)\nreturn items[topFirst];\nreturn items[topSecond];\n}\n\nvoid push( int stackIndex, T item)\n{\nvalidateIndex(stackIndex);\nif (full())\nthrow new exception( \"All space has been occupied.\" );\n\nif (stackIndex == 0)\nitems[++topFirst] = item;\nelse\nitems[--topSecond] = item;\n}\n\nvoid pop( int stackIndex)\n{\nvalidateIndex(stackIndex);\nif (empty(stackIndex))\nthrow new exception( \"The stack is empty.\" );\n\nif (stackIndex == 0)\n--topFirst;\nelse\n++topSecond;\n}\n\nbool empty( int stackIndex)\n{\nif (stackIndex == 0 && topFirst == -1)\nreturn true ;\nif (stackIndex == 1 && topSecond == capacity)\nreturn true ;\nreturn false ;\n}\n\nprivate :\nbool full()\n{\nreturn (topFirst >= topSecond - 1);\n}\n\nvoid validateIndex( int stackIndex)\n{\nif (stackIndex < 0 || stackIndex > 1)\nthrow new exception( \"Invalid Stack Index.\" );\n}\n\nprivate :\nT items[capacity];\nint topFirst;\nint topSecond;\n};\n\nAnalysis : An array only has two ends, so we need new strategies to implement more than two stacks in a single array.\nWe may implement the array like a list, where each item in the array has a link to another item. When an item has not been occupied by any stacks and it is available, it is linked to the next available item. When an item is pushed into a stack, it is linked to the previous item in the stack. That\u2019s to say, there are n + 1 list in total in the system if there are n stacks sharing an array, a list for the available space left in the array, and a list for each stack.\nLet\u2019s take three stacks sharing an array with capacity 10 as an example. Figure 3 shows the initial status for the array and stacks. Each item in the array has two blocks, one for item data and the other for the index of another block.\n\n\nAs shown in Figure 3, each item is linked to the next item (the link block of the i th item is i +1). The head of list for available items in the array points to the item at position 0, which is the Ava pointer in the figure. Since three stacks are empty, their top (Top1, Top2 and Top3 in the figure) are initialized as -1.\n\nLet\u2019s try to push an item a into the first stack. Currently the first available item is at the position 0, so we set its data block as a . The link block of the item is 1, which means the next available item is at the position 1, so we update the Ava pointer to the position 1. Additionally, the link block of the item at the position 1 should be updated to -1, the previous top index of the first stack. Lastly, we update to top index of the first stack to 0. The status of the array and stacks are shown in Figure 4.\nLet\u2019s push two more items b and c into the first stack. The operations are similar as before, and the status is shown in Figure 5.\nIn the next step we are going to push another d into the second stack. Most operations are similar as before. The link block in the item at the position 3 is updated to -1, since the second stack is empty before and its top index is -1 previously. And then the top index of the second stack is updated to 3. The status after adding d into the second stack is shown in Figure 6.\n\nIf we continue to push three more item e , f , and g into the second stack, the status is shown in Figure 7.\n\nAt this time we are going to pop an item from the first stack. Since the top index of the first stack is 2, the item to be popped off is at the position 2. The link value in that item is 1, which means the previous top in the first stack is at the position 1 in the array, so we update the top index of the first stack as 1. Now the item at the position 2 becomes available, it should be linked to the list for available items. We move the Ava pointer to 2, and then update the link value of the item at the position 2 as 7, which is the previous head position of the list for available items. The status is shown in Figure 8.\nIf we pop an item off the second stack, the item at the position 6 will be linked to the list for available items too. Figure 9 depicts the status after the related operations.\nIf we push h into the third stack, it will be placed into the item at the position 6 because Ava points to that item. The next available item is at the position 2 (the link value in the item at the position 6). Therefore, the head of the list for available items points to location 2, as shown in Figure 10.\nLet\u2019s continue to push four more items into the third stack, i , j , k , and l . The status after these four items are pushed is shown in Figure 11. At this time, there are two items in the first stack ( a and b ), three items in the second stack ( d , e and f ), and five items in the third stack ( h , i , j , k , and l ). Please note that items inside a stack are not necessarily adjacent.\nAfter l is pushed into the item at the position 9, the Ava pointer is update to -1 (the previous link value in the item at the position 9), which means all items in the array have been occupied by stacks. We can\u2019t push more items until some items are popped off.\nThe source code in C++ to implement stacks sharing an array is listed below:\n template < typename T, int capacity, int count> class Stacks\n {\n\npublic :\n\nStacks()\n\n{\n\nint i;\n         for (i = 0; i < capacity - 1; ++i)\n            items[i].link = i + 1;\n        items[i].link = -1;\n        emptyHead = 0;\n\n         for (i = 0; i < count; ++i)\n            stackHead[i] = -1;\n     }\n\n     T top( int stackIndex)\n     {\n         validateIndex(stackIndex);\n         if (empty(stackIndex))\n             throw new exception( \"The stack is empty.\" );\n\n         return items[stackHead[stackIndex]].data;\n     }\n\n     void push( int stackIndex, const T& item)\n     {\n        validateIndex(stackIndex);\n         if (full())\n             throw new exception( \"All space has been occupied.\" );\n\n        Item<T>& block = items[emptyHead];\n         int nextEmpty = block.link;\n\n        block.data = item;\n        block.link = stackHead[stackIndex];\n        stackHead[stackIndex] = emptyHead;\n\n        emptyHead = nextEmpty;\n     }\n\n     void pop( int stackIndex)\n     {\n        validateIndex(stackIndex);\n         if (empty(stackIndex))\n             throw new exception( \"The stack is empty.\" );\n\n         Item<T>& block =items[stackHead[stackIndex]];\n         int nextItem = block.link;\n\n        block.link = emptyHead;         emptyHead = stackHead[stackIndex];         stackHead[stackIndex] = nextItem;\n        block.link = emptyHead;         emptyHead = stackHead[stackIndex];\n     }\n\n     bool empty( int stackIndex)\n     {\n         return (stackHead[stackIndex] < 0);\n     }\n\n private :\n     void validateIndex( int stackIndex)\n     {\n         if (stackIndex < 0 || stackIndex >= count)\n             throw new exception( \"Invalid index of stack.\" );\n     }\n\n     bool full()\n     {\n         return (emptyHead < 0);\n     }\n\n private :\n     template < typename T> struct Item\n     {\n         Tdata;\n         int link;\n     };\n\n private :\n    Item<T> items[capacity];\n     int emptyHead;\n     int stackHead[count];\n };\n\n", "question": "\nProblem 2 : How can you implement n ( n > 2) stacks in a single array, where no stack overflows until no space left in the entire array space? Analysis : An array only has two ends, so we need new strategies to implement more than two stacks in a single array. We may implement the array like a list, where each item in the array has a link to another item. When an item has not been occupied by any stacks and it is available, it is linked to the next available item. When an item is pushed into a stack, it is linked to the previous item in the stack. That\u2019s to say, there are n + 1 list in total in the system if there are n stacks sharing an array, a list for the available space left in the array, and a list for each stack. Let\u2019s take three stacks sharing an array with capacity 10 as an example. Figure 3 shows the initial status for the array and stacks. Each item in the array has two blocks, one for item data and the other for the index of another block.\nProblem 2 : How can you implement n ( n > 2) stacks in a single array, where no stack overflows until no space left in the entire array space?"},
{"answer": "\nAnalysis: Firstly let\u2019s analyze this problem with the brute-force solution: All elements in the array are scanned one by one. When an element is scanned, we take is as A[ j ], and check whether there is a smaller element on its left side (A[ i ]), and a greater element on its right side (A[ k ]).\nSince it takes O( n ) time to scan numbers on two sides of each A[ j ], the overall time of this solution is O( n 2 ) on an array with n elements.\n\nSolution 1: O(n) time efficiency with O(n) space consumption\nAs our analysis above, for each element A[ j ], we need to know whether there is a smaller element on its left side. If there is not a smaller element on the left side, A[ j ] itself is the smallest of all elements from the leftmost element to A[ j ]. If there is a smaller element on the left side, the smallest of all elements from the leftmost element to A[ j ] is on the left side of A[ j ].\nTherefore, we could construct an auxiliary array B. The element B[ j ] stores the index of the smallest element of elements from the leftmost element to A[ j ]. The array B can be constructed based on elements in A from left to right.\nSimilarly, we could also construct another auxiliary array C. The element C[ j ] stores the index of the greatest element of elements from the rightmost element to A[ j ]. The array C can be constructed based on elements in A from right to left.\nWhen an element A[ j ] is scanned, the index j is compared with B[ j ] and C[ j ]. if B[ j ]< j (there is a smaller element on the left side) and j <C[ j ] (there is a greater element on the right side), three increasing elements have been found.\nThis solution can be implemented with the following C/C++ code:\n void increasingIndex_1( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     int * minIndex = new int [length];\n     int index = 0;\n    minIndex[0] = 0;\n     int t;\n     for (t = 1; t < length; ++t)\n     {\n         if (nums[t] < nums[index])\n            index = t;\n        minIndex[t] = index;\n     }\n\n     int * maxIndex = new int [length];\n     index =length - 1;\n     for (t = length - 1; t >= 0; --t)\n     {\n         if (nums[t] > nums[index])\n            index = t;\n        maxIndex[t] = index;\n     }\n\n     for (t = 1; t < length - 1; ++t)\n     {\n         if (minIndex[t] < t && maxIndex[t] > t)\n             break ;\n     }\n     if (t < length - 1)\n     {\n         *i =minIndex[t];\n         *j =t;\n         *k =maxIndex[t];\n     }\n     else\n     {\n         *i =*j = *k = -1;\n     }\n\n     delete [] minIndex;\n     delete [] maxIndex;\n }\n\nSolution 2: O(n) time efficiency with O(1) space consumption\nIn order to find an even more efficient solution, let\u2019s scan all elements in an array and try to find three increasing elements. The array {3, 2, 5, 1, 4, 7, 9, 6, 8} is taken as an example to simulate the process.\nAt first, all elements A[ i ], A[ j ], and A[ k ] have not been found, so three indexes i , j , and k are initialized as -1.\nThe number 3 is the first number to be scanned, and A[ i ] is updated as 3.\nThe next number to be scanned is the number 2. Notice that 2 is less than 3, and it is a better candidate of A[ i ]. The less A[ i ] is, the larger range A[ j ] and A[ k ] will have. Therefore, A[ i ] is updated as 2.\nLet\u2019s continue to scan the next number 5. Since 5 is greater the current A[ i ], it is a candidate of A[ j ]. A[ j ] is updated as 5.\nThe number 1 is scanned in the next round. Because 1 is less than the current A[ j ], it cannot be A[ k ]. Additionally, the number 1 is a candidate to be A[ i ] or A[ j ] in the future since it is less than the current A[ i ] and A[ j ]. However, neither A[ i ] nor A[ j ] can be updated as 1 at this time. If A[ i ] is updated as 1, A[ i ]<A[ j ] but i > j . If A[ j ] is updated as 1, A[ i ]>A[ j ]. Therefore, we store the number 1 into another variable named t .\nWe move on to scan the next number 4. Notice that the number 4 is less than A[ j ] again. At this time we have two numbers 1 (the stored variable t ) and 4, so we have a new pair of numbers to be A[ i ] and A[ j ]. A[ i ] and A[ j ] are updated as 1 and 4 respectively.\nThe next number, 7, is greater than the current A[ j ], so A[ k ] is updated as 7. The process terminates.\nThe following table summarizes the step-by-step analysis above:\nStep\nScanned Number\nA[ i ]\nA[ j ]\nA[ k ]\nt\nOperation\n1\n3\n3\n-1\n-1\n-1\nUpdate A[ i ]\n2\n2\n2\n-1\n-1\n-1\nUpdate A[ i ]\n3\n5\n2\n5\n-1\n-1\nUpdate A[ j ]\n4\n1\n2\n5\n-1\n1\nUpdate t\n5\n4\n1\n4\n-1\n-1\nUpdate A[ i ], A[ j ] and t\n6\n7\n1\n4\n7\n-1\nUpdate A[ k ]. Terminate.\nThe strategy of this solution is to store as less value to A[ i ] and A[ j ] as possible, in order to enlarge the value range for steps in the future.\nWith our step-by-step analysis, we could implement this solution with the following C++ code:\n void increasingIndex_2( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     *i = *j =*k = -1;\n     int backup = -1;\n\n     int index;\n     for (index = 0; index < length; ++index)\n     {\n         if (*i == -1)\n         {\n            *i = index;\n         }\n         else if (*j == -1)\n         {\n             if (nums[index] > nums[*i])\n                *j = index;\n             else\n                *i = index;\n         }\n         else if (nums[index]> nums[*j])\n         {\n            *k = index;\n             break ;\n         }\n         else if (nums[index]< nums[*j])\n         {\n             if (backup != -1)\n             {\n                 if (nums[index] > nums[backup])\n                {\n                    *i = backup;\n                    *j = index;\n                    backup = -1;\n                }\n                 else if (nums[index] < nums[backup])\n                {\n                    backup = index;\n                }\n             }\n             else if (nums[index]< nums[*j])\n                backup = index;\n         }\n     }\n     if (index == length)\n         *i =*j = *k = -1;\n }\n", "question": "\nProblem: Given an array of integers A, please find three indexes i , j , k , such that i < j < k and A[ i ]<A[ j ]<A[ k ].\n"},
{"answer": "\nAnalysis: This is a typical problem which can be solved by dynamic programming. We have two strategies to analyze and solve this problem\n\nSolution 1: Split at any space between two characters\n\nGiven a substring of str , starting from the index i and ending at the index j (denoted as str [ i : j ]), we define a function f ( i , j ) to denote the minimal number of splits to partition the substring str [ i : j ] into a set of palindromes. If the substring is a palindrome itself, we don\u2019t have to split so f ( i , j ) is 0. If the substring is not a palindrome, the substring is split between two characters k and k +1. f ( i , j )= f ( i , k )+ f ( k +1, j )+1 under such conditions. Therefore, f ( i , j ) can be defined with the following equation:\n\n\nThe value of f (0, n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nIf the equation is calculated recursively, its complexity grows exponentially with the length n . A better choice is to calculate in bottom-up order with a 2D matrix with size n \u00d7 n . The following C++ code implements this solution:\n\n int minSplit_1( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length * length];\n    \n     for ( int i = 0; i <length; ++i)\n        split[i * length + i] = 0;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         for ( int j = length -i; j > 0; --j)\n         {\n             int row = length - i - j;\n             int col = row + i;\n             if (isPalindrome(str, row, col))\n             {\n                split[row * length + col] = 0;\n             }\n             else\n             {\n                 int min = 0x7FFFFFFF;\n                 for ( int k = row; k < col; ++k)\n                {\n                     int temp1 = split[row * length + k];\n                     int temp2 = split[(k + 1) * length +col];\n                     if (min> temp1 + temp2 + 1)\n                         min = temp1 + temp2 +1;\n                }\n                split[row * length + col] = min;\n             }\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nSolution 2: Split only before a palindrome\n\nWe split the string str with another strategy. Given a substring ending at the index i , str [0, i], we do not have to split if the substring is a palindrome itself. Otherwise it is split between two characters at index j and j +1 only if the substring str [ j +1, i ] is a palindrome. Therefore, an equation f ( i ) can be defined as the following:\n\n\nThe value of f ( n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nWe could utilize a 1D array to solve this equation in bottom-up order, as listed in the following code:\n\n int minSplit_2( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length];\n     for ( int i = 0; i <length; ++i)\n        split[i] = i;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         if (isPalindrome(str, 0, i))\n         {\n            split[i] = 0;\n             continue ;\n         }\n\n         for ( int j = 0; j <i; ++j)\n         {\n             if (isPalindrome(str, j + 1, i) && split[i]> split[j] + 1)\n                split[i] = split[j] + 1;\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nOptimization to verify palindromes:\n\nUsually it costs O( n ) time to check whether a string with length n is a palindrome, and the typical implementation looks like the following code:\n\n bool isPalindrome( const string& str, int begin, int end)\n {\n     for ( int i = begin; i< end - (i - begin); ++i)\n     {\n         if (str[i] != str[end - (i - begin)])\n             return false ;\n     }\n\n     return true ;\n }\n\nBoth solutions above cost O( n 3 ) time. The first solution contains three nesting for-loops. The function isPalindrome is inside two nesting for-loops.\n\nIf we could reduce the cost of isPalindrome to O(1), the time complexity of the second solution would be O( n 2 ).\n\nNotice that the substring str [ i , j ] is a palindrome only if the characters at index i and j , and str [ i +1, j -1] is also a palindrome. We could build a 2D table accordingly to store whether every substring of str is a palindrome or not during the preprocessing. With such a table, the function isPalindrome can verify the substring str [ i , j ] in O(1) time.\n\n", "question": "\nProblem: A string can be partitioned into some substrings, such that each substring is a palindrome. For example, there are a few strategies to split the string \u201cabbab\u201d into palindrome substrings, such as: \u201cabba\u201d|\u201db\u201d, \u201ca\u201d|\u201db\u201d|\u201dbab\u201d and \u201ca\u201d|\u201dbb\u201d|\u201da\u201d|\u201db\u201d.\n\nGiven a string str , please get the minimal numbers of splits to partition it into palindromes. The minimal number of splits to partition the string \u201cabbab\u201d into a set of palindromes is 1.\n"},
{"answer": "\nAnalysis: Lots of pointer operations are necessary to solve problems related to linked lists. Interviewers know that many candidates are prone to make mistakes on pointer operations, so they like problems of linked list to qualify candidates\u2019 programming abilities. During interviews, we had better analyze and design carefully rather than begin to code hastily. It is much better to write robust code with comprehensive analysis than write code quickly with many errors.\n\nDirection of pointers should be adjusted in order to reverse a linked list. We may utilize figures to analyze visually the complex steps to adjust pointers. As shown in the list in Figure 1-a, node h, i and j are three adjacent nodes. Let us assume pointers of all nodes prior to h have been reversed after some operations and all m_pNext point to their previous nodes. We are going to reverse the m_pNext pointer in node i. The status of list is shown in Figure 1-b.\n\n\nIt is noticeable that m_pNext in node i points to its previous node h, the list is broken and we cannot visit the node j anymore. We should save the node j before the m_pNext pointer of node i is adjusted to prevent the list becoming broken.\n\nWhen we adjust the pointer in node i, we need to access to node h since m_pNext of node i is adjusted to point to node h. Meanwhile, we also need to access to node j because it is necessary to save it otherwise the list will be broken. Therefore, three pointers should be declared in our code, which point to the current visited node, its previous node and its next node.\n\nLastly we should get the head node of the reversed list. Obviously head in the reversed list should be tail of the original list. Which pointer is tail? It should be a node whose m_pNext is NULL .\nWith comprehensive analysis above, we are ready to write code, which is shown below:\n\nListNode* ReverseList(ListNode* pHead)\n{\nListNode* pReversedHead = NULL;\nListNode* pNode = pHead;\nListNode* pPrev = NULL;\nwhile (pNode != NULL)\n{\nListNode* pNext = pNode->m_pNext;\n\nif (pNext == NULL)\npReversedHead = pNode;\n\npNode->m_pNext = pPrev;\n\npPrev = pNode;\npNode = pNext;\n}\n\nreturn pReversedHead;", "question": "\nProblem: Implement a function to reverse a linked list, and return the head of the reversed list. A list node is defined as below:\nstruct ListNode\n{\nint m_nKey;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: We have discussed how to store nodes of a path in a stack while traversing a binary tree in the blog \" Paths with Specified Sum in Binary Tree \". The depth of a binary tree is the length of the longest path. This solution works, but it is not the most concise one.\n\nThe depth of a binary tree can be gotten in another way. If a binary tree has only one node, its depth is 1. If the root node of a binary tree has only a left subtree, its depth is the depth of the left subtree plus 1. Similarly, its depth is the depth of the right subtree plus 1 if the root node has only a right subtree. What is the depth if the root node has both left subtree and right subtree? It is the greater value of the depth of the left and right subtrees plus 1.\n\nFor example, the root node of the binary tree in Figure\u00a01 has both left and right subtrees. The depth of the left subtree rooted at node 2 is 3, and the depth of the right subtree rooted at node 3 is 2, so the depth of the whole binary tree is 4; 1 plus the greater value of 3 and 2.\n\nIt is easy to implement this solution recursively, with little modification on the post-order traversal algorithm, as shown below:\n\n int TreeDepth(BinaryTreeNode* pRoot)\n {\n     if (pRoot == NULL)\n         return 0;\n\n     int nLeft = TreeDepth(pRoot->m_pLeft);\n     int nRight = TreeDepth(pRoot->m_pRight);\n\n     return (nLeft > nRight) ? (nLeft + 1) : (nRight +1);\n }\n\n\nAnalysis:\n\nSolution 1: Visiting Nodes for Multiple Times\nAccording to the definition of balanced binary trees, this problem can be solved by getting the depth difference between the left and right subtrees of every node. When a node is visited, the function depth is invoked to get the depth of its left and right subtrees. If the depth different is 1 at most for all nodes in a binary tree, it is balanced. This solution can be implemented based on the TreeDepth discussed in the preceding problem, as shown below:\n\n bool IsBalanced_Solution1(BinaryTreeNode* pRoot)\n {\n     if (pRoot == NULL)\n         return true ;\n\n     int left = TreeDepth(pRoot->m_pLeft);\n     int right = TreeDepth(pRoot->m_pRight);\n     int diff = left - right;\n     if (diff > 1 || diff < -1)\n         return false ;\n\n     return IsBalanced_Solution1(pRoot->m_pLeft)\n         && IsBalanced_Solution1(pRoot->m_pRight);\n }  \nThis solution looks concise, but it is inefficient because it visits some nodes for multiple times. Take the binary tree in Figure\u00a01 as an example. When the function TreeDepth takes the node 2 as a parameter, it visits nodes 4, 5, and 7. When it verifies whether the binary tree rooted at node 2 is balanced, it visits nodes 4, 5, and 7 again. Obviously, we could improve performance if nodes are visited only once.\n\nSolution 2: Visiting Every Node Only Once\n\nIf a binary tree is scanned with the post-order algorithm, its left and right subtrees are traversed before the root node. If we record the depth of the currently visited node (the depth of a node is the maximum length of paths from the node to its leaf nodes), we can verify whether the subtree rooted at the currently visited node is balanced. If any subtree is unbalanced, the whole tree is unbalanced.\n\nThis new solution can be implemented as shown in below:\n\nbool IsBalanced_Solution2(BinaryTreeNode* pRoot)\n {\n     int depth = 0;\n     return IsBalanced(pRoot, &depth);\n }\n\n bool IsBalanced(BinaryTreeNode* pRoot, int * pDepth)\n {\n     if (pRoot == NULL)\n     {\n         *pDepth = 0;\n         return true ;\n     }\n\n     int left, right;\n     if (IsBalanced(pRoot->m_pLeft, &left) && IsBalanced(pRoot->m_pRight, &right))\n     {\n         int diff = left - right;\n         if (diff <= 1 && diff >= -1)\n         {\n             *pDepth = 1 + (left > right ? left : right);\n             return true ;\n         }\n     }\n\n     return false ;\n }\n\n\nAfter verifying left and right subtrees of a node, the solution verifies the subtree rooted at the current visited node and passes the depth to verify its parent node. When the recursive process returns to the root node finally, the whole binary tree is verified.\n\n", "question": "\nQuestion 1 : How do you get the depth of a binary tree? Nodes from the root to a leaf form a path. Depth of a binary tree is the maximum length of all paths. For example, the depth of the binary tree in Figure\u00a01 is 4, with the longest path through nodes 1, 2, 5, and 7.\n\nQuestion 2: How do you verify whether a binary tree is balanced? If the depth difference between a left subtree and right subtree of any node in a binary tree is not greater than 1, it is balanced. For instance, the binary tree in Figure\u00a01 is balanced.\n"},
{"answer": "", "question": ""},
{"answer": "\nAnalysis: If we scan all integers in the array from beginning to end, we may check whether every element equals its index. Obviously, this solution costs O( n ) time.\nSince numbers are sorted in the array, let's try to utilize the binary search algorithm to optimize. Supposing we reach the i th element in the array at some step. If the value of element is also i , it is a target integer and let's return it.\nWhat would happen when the value m is greater than the index i ? For any k ( k >0), the value of element with index i + k should be greater than or equal to m + k , because integers are unique and increasingly sorted in the array. Additionally because m > k , m + k > i + k . Therefore, every element on the right side of index i should be greater than its index in such a case.\nSimilarly, when the value of element with index i is less than i ,\u00a0every integer on the left side should be less than its index. Please prove it if you are interested.\nTherefore, we could reduce the search scope to half for the next step, and it is a typical process for binary search. The solution can be implemented with the following Java code:\n public static int getNumberSameAsIndex( int [] numbers) {\n     if (numbers == null || numbers.length == 0) {\n         return -1;\n     }\n        \n     int left = 0;\n     int right = numbers.length - 1;\n     while (left <= right) {\n         int middle = left + ((right - left) >>> 1);\n         if (numbers[middle] == middle) {\n             return middle;\n         }\n            \n         if (numbers[middle] > middle) {\n             right = middle - 1;\n         }\n         else {\n             left= middle + 1;\n         }\n     }\n        \n     return -1;\n }", "question": "\nProblem: Integers in an array are unique and increasingly sorted. Please write a function/method to find an integer from the array who equals to its index. For example, in the array {-3, -1, 1, 3, 5}, the number 3 equals its index 3."},
{"answer": "", "question": ""},
{"answer": "\nAnalysis: If we scan all integers in the array from beginning to end, we may check whether every element equals its index. Obviously, this solution costs O( n ) time.\nSince numbers are sorted in the array, let's try to utilize the binary search algorithm to optimize. Supposing we reach the i th element in the array at some step. If the value of element is also i , it is a target integer and let's return it.\nWhat would happen when the value m is greater than the index i ? For any k ( k >0), the value of element with index i + k should be greater than or equal to m + k , because integers are unique and increasingly sorted in the array. Additionally because m > k , m + k > i + k . Therefore, every element on the right side of index i should be greater than its index in such a case.\nSimilarly, when the value of element with index i is less than i ,\u00a0every integer on the left side should be less than its index. Please prove it if you are interested.\nTherefore, we could reduce the search scope to half for the next step, and it is a typical process for binary search. The solution can be implemented with the following Java code:\n public static int getNumberSameAsIndex( int [] numbers) {\n     if (numbers == null || numbers.length == 0) {\n         return -1;\n     }\n        \n     int left = 0;\n     int right = numbers.length - 1;\n     while (left <= right) {\n         int middle = left + ((right - left) >>> 1);\n         if (numbers[middle] == middle) {\n             return middle;\n         }\n            \n         if (numbers[middle] > middle) {\n             right = middle - 1;\n         }\n         else {\n             left= middle + 1;\n         }\n     }\n        \n     return -1;\n }", "question": "\nProblem: Integers in an array are unique and increasingly sorted. Please write a function/method to find an integer from the array who equals to its index. For example, in the array {-3, -1, 1, 3, 5}, the number 3 equals its index 3."},
{"answer": "", "question": ""},
{"answer": "\nAnalysis: If we scan all integers in the array from beginning to end, we may check whether every element equals its index. Obviously, this solution costs O( n ) time.\nSince numbers are sorted in the array, let's try to utilize the binary search algorithm to optimize. Supposing we reach the i th element in the array at some step. If the value of element is also i , it is a target integer and let's return it.\nWhat would happen when the value m is greater than the index i ? For any k ( k >0), the value of element with index i + k should be greater than or equal to m + k , because integers are unique and increasingly sorted in the array. Additionally because m > k , m + k > i + k . Therefore, every element on the right side of index i should be greater than its index in such a case.\nSimilarly, when the value of element with index i is less than i ,\u00a0every integer on the left side should be less than its index. Please prove it if you are interested.\nTherefore, we could reduce the search scope to half for the next step, and it is a typical process for binary search. The solution can be implemented with the following Java code:\n public static int getNumberSameAsIndex( int [] numbers) {\n     if (numbers == null || numbers.length == 0) {\n         return -1;\n     }\n        \n     int left = 0;\n     int right = numbers.length - 1;\n     while (left <= right) {\n         int middle = left + ((right - left) >>> 1);\n         if (numbers[middle] == middle) {\n             return middle;\n         }\n            \n         if (numbers[middle] > middle) {\n             right = middle - 1;\n         }\n         else {\n             left= middle + 1;\n         }\n     }\n        \n     return -1;\n }", "question": "\nProblem: Integers in an array are unique and increasingly sorted. Please write a function/method to find an integer from the array who equals to its index. For example, in the array {-3, -1, 1, 3, 5}, the number 3 equals its index 3."},
{"answer": "\nAnalysis: This problem is not meaningful during software development since usually we do not have such rigorous limitations. However, many interviewers believe that it is useful to test candidates\u2019 ability of divergent thinking. Ability of divergent thinking reflects the depth and width of programming understanding.\n\nBesides equation n(n+1)/2 to get 1+2+\u2026+n, we only have two approaches: Iteration and recursion. Since key words for and while are forbidden, we cannot utilize iteration directly any more. In a recursive function, we need to use key word if or conditional operators to check whether we should continue or stop recursion. Unfortunately, both of them are also forbidden.\n\nSolution 1: Based on Constructors\n\nLet us firstly focus on iterations. An iteration is actually only to repeat n times, and we can achieve it without key words for and while . We can define a class, and then create n instances of it. Therefore, its constructor and destructor will be definitely called n times. If we implement calculation operations inside the constructor, it will iterate for n times. The following code is based on this solution:\n\nclass Temp\n{\npublic :\nTemp() { ++ N; Sum += N; }\n\nstatic void Reset() { N = 0; Sum = 0; }\nstatic unsigned int GetSum() { return Sum; }\n\nprivate :\nstatic unsigned int N;\nstatic unsigned int Sum;\n};\n\nunsigned int Temp::N = 0;\nunsigned int Temp::Sum = 0;\n\nunsigned int Sum_Solution1( unsigned int n)\n{\nTemp::Reset();\n\nTemp *a = new Temp[n];\ndelete []a;\na = NULL;\n\nreturn Temp::GetSum();\n}\n\nSolution 2: Based on Virtual Functions\n\nWe secondly focus on recursion. We cannot determine to continue or stop recursion inside a single function. How about to define two functions, one for normal operations and the other as a terminator? We may use Boolean variables since we are going to select a function out of two. When the Boolean variable is true (1), the operational function will be selected. When it is false (0), the terminal function will be selected.\n\nWe have to convert integer variables into Boolean variables. It is an easy task since it can be achieved with two not operations (!!n). Non-zero numbers will be true with two not operations and zero will be false .\n\nclass A;\nA* Array[2];\n\nclass A\n{\npublic :\nvirtual unsigned int Sum ( unsigned int n)\n{\nreturn 0;\n}\n};\n\nclass B: public A\n{\npublic :\nvirtual unsigned int Sum ( unsigned int n)\n{\nreturn Array[!!n]->Sum(n-1) + n;\n}\n};\n\nint Sum_Solution2( int n)\n{\nA a;\nB b;\nArray[0] = &a;\nArray[1] = &b;\n\nint value = Array[1]->Sum(n);\n\nreturn value;\n}\n\nThis solution is based on virtual functions. The function B::Sum is called when variable n is not zero, while the function A::Sum , which acts as a terminator, is called when n equals to zero.\n\nSolution 3: Based on Function Pointers\n\nThere are no virtual functions in native C programming environment, so we have to simulate them with function pointers. The code below may be more straightforward:\ntypedef unsigned int (*fun)( unsigned int );\n\nunsigned int Solution3_Teminator( unsigned int n)\n{\nreturn 0;\n}\n\nunsigned int Sum_Solution3( unsigned int n)\n{\nstatic fun f[2] = {Solution3_Teminator, Sum_Solution3};\nreturn n + f[!!n](n - 1);\n}\n\nSolution 4: Based on Template Classes\n\nWe can also utilize compiler to simulate recursive calculate. Let us have a look at the following code:\ntemplate < unsigned int n> struct Sum_Solution4\n{\nenum Value { N = Sum_Solution4<n - 1>::N + n};\n};\n\ntemplate <> struct Sum_Solution4<1>\n{\nenum Value { N = 1};\n};\n\nThe value of Sum_Solution4<100>::N is the result of 1+2+\u2026+100. When compilers see Sum_Solution4<100> , it will generate code for the template class Sum_Solution4 with parameter 100. A class Sum _S olution4 <99> is needed to generate the class Sum_Solution4<100> since Sum _Solution4<100>::N= Sum _Solution4 <99>::N+100 . The recursive process stops when it reaches the Sum_Solution4<1> because it has been defined explicitly.\n", "question": "\nProblem: Calculate 1+2+\u2026+n without multiplication, division, key words for , while , if , else , switch , case , as well as conditional operator (A ? B : C).\n"},
{"answer": "\nAnalysis: It is a classic interview questions to get numbers in Fibonacci sequences. We have different solutions for it, and their performance varies a lot.\n\nSolution 1: Inefficient recursive solution\n\nFibonacci sequences are taken as examples to lecture recursive functions in many C/C++ textbooks, so most of candidates are familiar with the recursive solution. They feel confident and delighted when they meet this problem during interviews, because the can write the following code in short time:\n\nlong long Fibonacci( unsigned int n)\n{\nif (n <= 0)\nreturn 0;\n\nif (n == 1)\nreturn 1;\n\nreturn Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n\nOur textbooks take Fibonacci sequences as examples for recursive functions does not necessarily mean that recursion is a good solution for Fibonacci sequences. Interviewers may tell candidates that the performance of this recursive solution is quite bad, and ask them to analyze root causes.\n\nLet us take f(10) as an example to analyze the recursive process. We have to get f(9) and f(8) before we get f(10). Meanwhile, f(8) and f(7) are needed before we get f(9). The dependency can be visualized in a tree as shown in Figure 1:\n\n\n\nIt is not difficult to notice that there are many duplicate nodes in the tree in Figure 1. The number of duplicated nodes increases dramatically when n increases. \u00a0Readers may have a try on the 100 th number if Fibonacci sequences to have intuitive ideas about how slow this recursive solution is.\n\nSolution 2: Practical Solution with O(n) efficiency\n\nIt is easy to optimize performance fortunately if we calculate from bottom. That is to say, we get f(2) based on f(0) and f(1), and get f(3) based on f(1) and f(2). We follow this pattern till we get f(n). It is obvious that its time complexity is O(n). Its corresponding code is shown below:\n\nlong long Fibonacci( unsigned n)\n{\nint result[2] = {0, 1};\nif (n < 2)\nreturn result[n];\n\nlong long fibNMinusOne = 1;\nlong long fibNMinusTwo = 0;\nlong long fibN = 0;\nfor ( unsigned int i = 2; i <= n; ++ i)\n{\nfibN = fibNMinusOne + fibNMinusTwo;\n\nfibNMinusTwo = fibNMinusOne;\nfibNMinusOne = fibN;\n}\n\nreturn fibN;\n}\n\nSolution 3: O( log n) solution\n\nUsually interviewers expect the O(n) solution above. However, there is an O( log n) solution available, which is based on an uncommon equation as shown below:\n\n\nIt is not difficult to prove this equation vithmathematical induction. Interested readers may have try.\n\nNow the only problem is how to calculate power of a matrix . We can calculate power with exponent n in O( log n) time with the following equation:\n\n\n\n\n\nThe source code to get power of a matrix looks complicated, which is listed below:\n\n#include <cassert>\n\nstruct Matrix2By2\n{\nMatrix2By2\n(\nlong long m00 = 0,\nlong long m01 = 0,\nlong long m10 = 0,\nlong long m11 = 0\n)\n:m_00(m00), m_01(m01), m_10(m10), m_11(m11)\n{\n}\n\nlong long m_00;\nlong long m_01;\nlong long m_10;\nlong long m_11;\n};\n\nMatrix2By2 MatrixMultiply\n(\nconst Matrix2By2& matrix1,\nconst Matrix2By2& matrix2\n)\n{\nreturn Matrix2By2(\nmatrix1.m_00 * matrix2.m_00 + matrix1.m_01 * matrix2.m_10,\nmatrix1.m_00 * matrix2.m_01 + matrix1.m_01 * matrix2.m_11,\nmatrix1.m_10 * matrix2.m_00 + matrix1.m_11 * matrix2.m_10,\nmatrix1.m_10 * matrix2.m_01 + matrix1.m_11 * matrix2.m_11);\n}\n\nMatrix2By2 MatrixPower( unsigned int n)\n{\nassert(n > 0);\n\nMatrix2By2 matrix;\nif (n == 1)\n{\nmatrix = Matrix2By2(1, 1, 1, 0);\n}\nelse if (n % 2 == 0)\n{\nmatrix = MatrixPower(n / 2);\nmatrix = MatrixMultiply(matrix, matrix);\n}\nelse if (n % 2 == 1)\n{\nmatrix = MatrixPower((n - 1) / 2);\nmatrix = MatrixMultiply(matrix, matrix);\nmatrix = MatrixMultiply(matrix, Matrix2By2(1, 1, 1, 0));\n}\n\nreturn matrix;\n}\n\nlong long Fibonacci( unsigned int n)\n{\nint result[2] = {0, 1};\nif (n < 2)\nreturn result[n];\n\nMatrix2By2 PowerNMinus2 = MatrixPower(n - 1);\nreturn PowerNMinus2.m_00;\n}\n\nEven though it cost only O( log n) time in theory, its hidden constant parameter is quite big, so it is not treated as a practical solution in real software development. Additionally, it is not a recommended solution during interviews since its implementation code is very complex.", "question": "\nProblem: Please implement a function which returns the n th number in Fibonacci sequences with an input n. Fibonacci sequence is defined as:\n\n\n\n"},
{"answer": "\nAnalysis: It is a classic interview questions to get numbers in Fibonacci sequences. We have different solutions for it, and their performance varies a lot.\n\nSolution 1: Inefficient recursive solution\n\nFibonacci sequences are taken as examples to lecture recursive functions in many C/C++ textbooks, so most of candidates are familiar with the recursive solution. They feel confident and delighted when they meet this problem during interviews, because the can write the following code in short time:\n\nlong long Fibonacci( unsigned int n)\n{\nif (n <= 0)\nreturn 0;\n\nif (n == 1)\nreturn 1;\n\nreturn Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n\nOur textbooks take Fibonacci sequences as examples for recursive functions does not necessarily mean that recursion is a good solution for Fibonacci sequences. Interviewers may tell candidates that the performance of this recursive solution is quite bad, and ask them to analyze root causes.\n\nLet us take f(10) as an example to analyze the recursive process. We have to get f(9) and f(8) before we get f(10). Meanwhile, f(8) and f(7) are needed before we get f(9). The dependency can be visualized in a tree as shown in Figure 1:\n\n\n\nIt is not difficult to notice that there are many duplicate nodes in the tree in Figure 1. The number of duplicated nodes increases dramatically when n increases. \u00a0Readers may have a try on the 100 th number if Fibonacci sequences to have intuitive ideas about how slow this recursive solution is.\n\nSolution 2: Practical Solution with O(n) efficiency\n\nIt is easy to optimize performance fortunately if we calculate from bottom. That is to say, we get f(2) based on f(0) and f(1), and get f(3) based on f(1) and f(2). We follow this pattern till we get f(n). It is obvious that its time complexity is O(n). Its corresponding code is shown below:\n\nlong long Fibonacci( unsigned n)\n{\nint result[2] = {0, 1};\nif (n < 2)\nreturn result[n];\n\nlong long fibNMinusOne = 1;\nlong long fibNMinusTwo = 0;\nlong long fibN = 0;\nfor ( unsigned int i = 2; i <= n; ++ i)\n{\nfibN = fibNMinusOne + fibNMinusTwo;\n\nfibNMinusTwo = fibNMinusOne;\nfibNMinusOne = fibN;\n}\n\nreturn fibN;\n}\n\nSolution 3: O( log n) solution\n\nUsually interviewers expect the O(n) solution above. However, there is an O( log n) solution available, which is based on an uncommon equation as shown below:\n\n\nIt is not difficult to prove this equation vithmathematical induction. Interested readers may have try.\n\nNow the only problem is how to calculate power of a matrix . We can calculate power with exponent n in O( log n) time with the following equation:\n\n\n\n\n\nThe source code to get power of a matrix looks complicated, which is listed below:\n\n#include <cassert>\n\nstruct Matrix2By2\n{\nMatrix2By2\n(\nlong long m00 = 0,\nlong long m01 = 0,\nlong long m10 = 0,\nlong long m11 = 0\n)\n:m_00(m00), m_01(m01), m_10(m10), m_11(m11)\n{\n}\n\nlong long m_00;\nlong long m_01;\nlong long m_10;\nlong long m_11;\n};\n\nMatrix2By2 MatrixMultiply\n(\nconst Matrix2By2& matrix1,\nconst Matrix2By2& matrix2\n)\n{\nreturn Matrix2By2(\nmatrix1.m_00 * matrix2.m_00 + matrix1.m_01 * matrix2.m_10,\nmatrix1.m_00 * matrix2.m_01 + matrix1.m_01 * matrix2.m_11,\nmatrix1.m_10 * matrix2.m_00 + matrix1.m_11 * matrix2.m_10,\nmatrix1.m_10 * matrix2.m_01 + matrix1.m_11 * matrix2.m_11);\n}\n\nMatrix2By2 MatrixPower( unsigned int n)\n{\nassert(n > 0);\n\nMatrix2By2 matrix;\nif (n == 1)\n{\nmatrix = Matrix2By2(1, 1, 1, 0);\n}\nelse if (n % 2 == 0)\n{\nmatrix = MatrixPower(n / 2);\nmatrix = MatrixMultiply(matrix, matrix);\n}\nelse if (n % 2 == 1)\n{\nmatrix = MatrixPower((n - 1) / 2);\nmatrix = MatrixMultiply(matrix, matrix);\nmatrix = MatrixMultiply(matrix, Matrix2By2(1, 1, 1, 0));\n}\n\nreturn matrix;\n}\n\nlong long Fibonacci( unsigned int n)\n{\nint result[2] = {0, 1};\nif (n < 2)\nreturn result[n];\n\nMatrix2By2 PowerNMinus2 = MatrixPower(n - 1);\nreturn PowerNMinus2.m_00;\n}\n\nEven though it cost only O( log n) time in theory, its hidden constant parameter is quite big, so it is not treated as a practical solution in real software development. Additionally, it is not a recommended solution during interviews since its implementation code is very complex.", "question": "\nProblem: Please implement a function which returns the n th number in Fibonacci sequences with an input n. Fibonacci sequence is defined as:\n\n\n\n"},
{"answer": "\nAnalysis: We are going to introduce two solutions for this problem here, one is classic and quite intuitive and the other is very creative.\n\nSolution 1: Simulate a circle with a looped linked list\n\nBecause a circle is mentioned in the problem, an intuitive solution is to simulate a circle with some data structures. Looped linked can fulfill such a purpose. We may create a looped list with n nodes, and then delete the m th node at every time from it.\n\nWe can implement the looped list based on the std::list in the C++ standard template library. It should be noticed that std::list itself is not looped. When an iterator reaches end of a list, we need to reset it to its head. It behaves like a circle with such a little trick. The sample source code of this solution is shown below:\n\nint LastRemaining( unsigned int n, unsigned int m)\n{\nif (n < 1 || m < 1)\nreturn -1;\n\nunsigned int i = 0;\n\nlist< int > numbers;\nfor (i = 0; i < n; ++ i)\nnumbers.push_back(i);\n\nlist< int >::iterator current = numbers.begin();\nwhile (numbers.size() > 1)\n{\nfor ( int i = 1; i < m; ++ i)\n{\ncurrent ++;\nif (current == numbers.end())\ncurrent = numbers.begin();\n}\n\nlist< int >::iterator next = ++ current;\nif (next == numbers.end())\nnext = numbers.begin();\n\n-- current;\nnumbers.erase(current);\ncurrent = next;\n}\n\nreturn *(current);\n}\n\nIf we analyze the code above carefully, we can notice that a looped list is scanned for many times. Of cause, repeatedly scanning has negative impacts on time efficiency. In this solution, traversal with m steps are necessary to delete a node, so the time complexity is O(mn) for a looped list. Meanwhile, it requires a list with n nodes to simulate a circle, so the space complexity is O(n).\n\nSolution 2: Analyze the pattern of deleted numbers\n\nFirstly, let us define a function f(n, m), which stands for the last remaining number in a circle which has n numbers 0, 1, \u2026, n-1 and the m th number is deleted at each time.\n\nThe first deleted number in the circle is (m-1)%n, which is denoted as k for simplicity. The n-1 numbers after k is deleted are 0, 1, \u2026, k-1, k+1, \u2026, n-1. The last remaining number is also a function about n and m. The pattern of new sequence is different from the pattern of the original sequence, which begins with 0, so the function differs from the function f, which can be denoted as f\u2019(n-1, m). The last remaining number of the original sequence should be the last remaining number of the sequence deleting k, so f(n, m)=f\u2019(n-1, m).\n\nSince we count the next m th number from k+1, the sequence might be also viewed as k+1, \u2026, n-1, 0, 1, \u2026, k-1. We project this sequence of numbers into a new sequence in range of 0 and n-2:\n\nk+1\n\u2192\n0\nk+2\n\u2192\n1\n\u2026\n\n\nn-1\n\u2192\nn-k-2\n0\n\u2192\nn-k-1\n1\n\u2192\nn-k\n\u2026\n\n\nk-1\n\u2192\nn-2\nIf the projection is denoted as p, p(x)=(x-k-1%n, and the reversed projection is p -1 (x)=(x+k+1)%n.\nThe projected sequence has the same format as the original sequence because they both begin from 0. Therefore, its last remaining number is the projected sequence also follows rules of function f. We denoted as f(n-1, m).\n\nThe last remaining number of the sequence before projection is f\u2019(n-1, m)= p -1 [f(n-1, m)]=[f(n-1, m)+k+1]%n. Since k=(m-1)%n, f(n, m )=f\u2019(n-1,m)=[f(n-1, m)+m]%n.\n\nA recursive equation is found after complex analysis. We can get last remaining number in a list with n numbers based on the last remaining number in a list with n-1 numbers. When n=1 (there is only one number 0 in the list), the last remaining number is obviously 0. The rules can be summarized as:\n\n\nThe equation can be implemented based on both recursion and iteration. The following code is based on iteration:\n\nint LastRemaining( unsigned int n, unsigned int m)\n{\nif (n < 1 || m < 1)\nreturn -1;\n\nint last = 0;\nfor ( int i = 2; i <= n; i ++)\nlast = (last + m) % i;\n\nreturn last;\n}\n\nEven though the analysis is quite complex, its corresponding code is very simple. That is beauty of mathematics. More importantly, its time complexity is O(n) and space complexity is O(1), so it is much better than the first solution in both time and memory efficiency.", "question": "\nProblem: If we delete the m th number from a circle which is composed of numbers 0, 1, \u2026, n-1 counting from 0 at every time, what is the last number?\n\nFor example, a circle is composed of five numbers 0, 1, 2, 3, 4 as shown in Figure 1. If we delete the 3 rd number at every time, the deleted numbers are in order of 2, 0, 4, 1, so the last remaining number is 3."},
{"answer": "\nAnalysis: Since numbers come from a stream, the count of numbers is dynamic, and increases over time. If a data container is defined for the numbers from a stream, new numbers will be inserted into the container when they are deserialized. Let us find an appropriate data structure for such a data container.\n\nAn array is the simplest choice. The array should be sorted, because we are going to get its median. Even though it only costs O(lg n ) time to find the position to be inserted with binary search algorithm, it costs O( n ) time to insert a number into a sorted array, because O( n ) numbers will be moved if there are n numbers in the array. It is very efficient to get the median, since it only takes O(1) time to access to a number in an array with an index.\n\nA sorted list is another choice. It takes O( n ) time to find the appropriate position to insert a new number. Additionally, the time to get the median can be optimized to O(1) if we define two pointers which points to the central one or two elements.\n\nA better choice available is a binary search tree, because it only costs O(lg n ) on average to insert a new node. However, the time complexity is O( n ) for the worst cases, when numbers are inserted in sorted (increasingly or decreasingly) order. To get the median number from a binary search tree, auxiliary data to record the number of nodes of its sub-tree is necessary for each node. It also requires O(lg n ) time to get the median node on overage, but O( n ) time for the worst cases.\n\nWe may utilize a balanced binary search tree, AVL, to avoid the worst cases. Usually the balance factor of a node in AVL trees is the height difference between its right sub-tree and left sub-tree. We may modify a little bit here: Define the balance factor as the difference of number of nodes between its right sub-tree and left sub-tree. It costs O(lg n ) time to insert a new node into an AVL, and O(1) time to get the median for all cases.\n\nAn AVL is efficient, but it is not implemented unfortunately in libraries of the most common programming languages. It is also very difficult for candidates to implement the left/right rotation of AVL trees in dozens of minutes during interview. Let us looks for better solutions.\n\nAs shown in Figure 1, if all numbers are sorted, the numbers which are related to the median are indexed by P1 and P2. If the count of numbers is odd, P1 and P2 point to the same central number. If the count is even, P1 and P2 point to two numbers in middle.\n\nMedian can be get or calculated with the numbers pointed by P1 are P2. It is noticeable that all numbers are divided into two parts. The numbers in the first half are less than the numbers in the second half. Moreover, the number indexed by P1 is the greatest number in the first half, and the number indexed by P2 is the least one in the second half.\nTherefore, numbers in the first half are inserted into a max heap, and numbers in the second half are inserted into a min heap. It costs O(lg n ) time to insert a number into a heap. Since the median can be get or calculated with the root of a min heap and a max heap, it only takes O(1) time.\n\nTable 1 compares the solutions above with a sorted array, a sorted list, a binary search tree, an AVL tree, as well as a min heap and a max heap.\nType for Data Container Time to Insert Time to Get Median Sorted Array O( n ) O(1) Sorted List O( n ) O(1) Binary Search Tree O(lg n ) on   average, O( n ) for the worst cases O(lg n ) on average,   O( n ) for the worst cases AVL O(lg n ) O(1) Max Heap and Min Heap O(lg n ) O(1)\nType for Data Container\nTime to Insert\nTime to Get Median\nSorted Array\nO( n )\nO(1)\nSorted List\nO( n )\nO(1)\nBinary Search Tree\nO(lg n ) on   average, O( n ) for the worst cases\nO(lg n ) on average,   O( n ) for the worst cases\nAVL\nO(lg n )\nO(1)\nMax Heap and Min Heap\nO(lg n )\nO(1)\nTable 1: Summary of solutions with a sorted array, a sorted list, a binary search tree, an AVL tree, as well as a min heap and a max heap.\n\nLet us consider the implementation details. All numbers should be evenly divided into two parts, so the count of number in min heap and max heap should diff 1 at most. To achieve such a division, a new number is inserted into the min heap if the count of existing numbers is even; otherwise it is inserted into the max heap.\n\nWe also should make sure that the numbers in the max heap are less than the numbers in the min heap. Supposing the count of existing numbers is even, a new number will be inserted into the min heap. If the new number is less than some numbers in the max heap, it violates our rule that all numbers in the min heap should be greater than numbers in the min heap.\n\nIn such a case, we can insert the new number into the max heap first, and then pop the greatest number from the max heap, and push it into the min heap. Since the number pushed into the min heap is the former greatest number in the max heap, all numbers in the min heap are greater than numbers in the max heap with the newly inserted number.\n\nThe situation is similar when the count of existing numbers is odd and the new number to be inserted is greater than some numbers in the min heap. Please analyze the insertion process carefully by yourself.\n\nThe following is sample code in C++. Even though there are no types for heaps in STL, we can build heaps with vectors utilizing function push_heap and pop_heap . Comparing functor less and greater are employed for max heaps and min heaps correspondingly.\n\ntemplate < typename T> class DynamicArray\n{\npublic :\nvoid Insert(T num)\n{\nif (((minHeap.size() + maxHeap.size()) & 1) == 0)\n{\nif (maxHeap.size() > 0 && num < maxHeap[0])\n{\nmaxHeap.push_back(num);\npush_heap(maxHeap.begin(), maxHeap.end(), less<T>());\n\nnum = maxHeap[0];\n\npop_heap(maxHeap.begin(), maxHeap.end(), less<T>());\nmaxHeap.pop_back();\n}\n\nminHeap.push_back(num);\npush_heap(minHeap.begin(), minHeap.end(), greater<T>());\n}\nelse\n{\nif (minHeap.size() > 0 && minHeap[0] < num)\n{\nminHeap.push_back(num);\npush_heap(minHeap.begin(), minHeap.end(), greater<T>());\n\nnum = minHeap[0];\n\npop_heap(minHeap.begin(), minHeap.end(), greater<T>());\nminHeap.pop_back();\n}\n\nmaxHeap.push_back(num);\npush_heap(maxHeap.begin(), maxHeap.end(), less<T>());\n}\n}\n\nint GetMedian()\n{\nint size = minHeap.size() + maxHeap.size();\nif (size == 0)\nthrow exception( \"No numbers are available\" );\n\nT median = 0;\nif (size & 1 == 1)\nmedian = minHeap[0];\nelse\nmedian = (minHeap[0] + maxHeap[0]) / 2;\n\nreturn median;\n}\n\nprivate :\nvector<T> minHeap;\nvector<T> maxHeap;\n};\n\nIn the code above, function Insert is used to insert a new number deserialized from a stream, and GetMedian is used to get the median of the existing numbers dynamically.", "question": "\nQuestion: How to get the median from a stream of numbers at any time? The median is middle value of numbers. If the count of numbers is even, the median is defined as the average value of the two numbers in middle.\n"},
{"answer": "\nAnalysis: Since numbers come from a stream, the count of numbers is dynamic, and increases over time. If a data container is defined for the numbers from a stream, new numbers will be inserted into the container when they are deserialized. Let us find an appropriate data structure for such a data container.\n\nAn array is the simplest choice. The array should be sorted, because we are going to get its median. Even though it only costs O(lg n ) time to find the position to be inserted with binary search algorithm, it costs O( n ) time to insert a number into a sorted array, because O( n ) numbers will be moved if there are n numbers in the array. It is very efficient to get the median, since it only takes O(1) time to access to a number in an array with an index.\n\nA sorted list is another choice. It takes O( n ) time to find the appropriate position to insert a new number. Additionally, the time to get the median can be optimized to O(1) if we define two pointers which points to the central one or two elements.\n\nA better choice available is a binary search tree, because it only costs O(lg n ) on average to insert a new node. However, the time complexity is O( n ) for the worst cases, when numbers are inserted in sorted (increasingly or decreasingly) order. To get the median number from a binary search tree, auxiliary data to record the number of nodes of its sub-tree is necessary for each node. It also requires O(lg n ) time to get the median node on overage, but O( n ) time for the worst cases.\n\nWe may utilize a balanced binary search tree, AVL, to avoid the worst cases. Usually the balance factor of a node in AVL trees is the height difference between its right sub-tree and left sub-tree. We may modify a little bit here: Define the balance factor as the difference of number of nodes between its right sub-tree and left sub-tree. It costs O(lg n ) time to insert a new node into an AVL, and O(1) time to get the median for all cases.\n\nAn AVL is efficient, but it is not implemented unfortunately in libraries of the most common programming languages. It is also very difficult for candidates to implement the left/right rotation of AVL trees in dozens of minutes during interview. Let us looks for better solutions.\n\nAs shown in Figure 1, if all numbers are sorted, the numbers which are related to the median are indexed by P1 and P2. If the count of numbers is odd, P1 and P2 point to the same central number. If the count is even, P1 and P2 point to two numbers in middle.\n\nMedian can be get or calculated with the numbers pointed by P1 are P2. It is noticeable that all numbers are divided into two parts. The numbers in the first half are less than the numbers in the second half. Moreover, the number indexed by P1 is the greatest number in the first half, and the number indexed by P2 is the least one in the second half.\nTherefore, numbers in the first half are inserted into a max heap, and numbers in the second half are inserted into a min heap. It costs O(lg n ) time to insert a number into a heap. Since the median can be get or calculated with the root of a min heap and a max heap, it only takes O(1) time.\n\nTable 1 compares the solutions above with a sorted array, a sorted list, a binary search tree, an AVL tree, as well as a min heap and a max heap.\nType for Data Container Time to Insert Time to Get Median Sorted Array O( n ) O(1) Sorted List O( n ) O(1) Binary Search Tree O(lg n ) on   average, O( n ) for the worst cases O(lg n ) on average,   O( n ) for the worst cases AVL O(lg n ) O(1) Max Heap and Min Heap O(lg n ) O(1)\nType for Data Container\nTime to Insert\nTime to Get Median\nSorted Array\nO( n )\nO(1)\nSorted List\nO( n )\nO(1)\nBinary Search Tree\nO(lg n ) on   average, O( n ) for the worst cases\nO(lg n ) on average,   O( n ) for the worst cases\nAVL\nO(lg n )\nO(1)\nMax Heap and Min Heap\nO(lg n )\nO(1)\nTable 1: Summary of solutions with a sorted array, a sorted list, a binary search tree, an AVL tree, as well as a min heap and a max heap.\n\nLet us consider the implementation details. All numbers should be evenly divided into two parts, so the count of number in min heap and max heap should diff 1 at most. To achieve such a division, a new number is inserted into the min heap if the count of existing numbers is even; otherwise it is inserted into the max heap.\n\nWe also should make sure that the numbers in the max heap are less than the numbers in the min heap. Supposing the count of existing numbers is even, a new number will be inserted into the min heap. If the new number is less than some numbers in the max heap, it violates our rule that all numbers in the min heap should be greater than numbers in the min heap.\n\nIn such a case, we can insert the new number into the max heap first, and then pop the greatest number from the max heap, and push it into the min heap. Since the number pushed into the min heap is the former greatest number in the max heap, all numbers in the min heap are greater than numbers in the max heap with the newly inserted number.\n\nThe situation is similar when the count of existing numbers is odd and the new number to be inserted is greater than some numbers in the min heap. Please analyze the insertion process carefully by yourself.\n\nThe following is sample code in C++. Even though there are no types for heaps in STL, we can build heaps with vectors utilizing function push_heap and pop_heap . Comparing functor less and greater are employed for max heaps and min heaps correspondingly.\n\ntemplate < typename T> class DynamicArray\n{\npublic :\nvoid Insert(T num)\n{\nif (((minHeap.size() + maxHeap.size()) & 1) == 0)\n{\nif (maxHeap.size() > 0 && num < maxHeap[0])\n{\nmaxHeap.push_back(num);\npush_heap(maxHeap.begin(), maxHeap.end(), less<T>());\n\nnum = maxHeap[0];\n\npop_heap(maxHeap.begin(), maxHeap.end(), less<T>());\nmaxHeap.pop_back();\n}\n\nminHeap.push_back(num);\npush_heap(minHeap.begin(), minHeap.end(), greater<T>());\n}\nelse\n{\nif (minHeap.size() > 0 && minHeap[0] < num)\n{\nminHeap.push_back(num);\npush_heap(minHeap.begin(), minHeap.end(), greater<T>());\n\nnum = minHeap[0];\n\npop_heap(minHeap.begin(), minHeap.end(), greater<T>());\nminHeap.pop_back();\n}\n\nmaxHeap.push_back(num);\npush_heap(maxHeap.begin(), maxHeap.end(), less<T>());\n}\n}\n\nint GetMedian()\n{\nint size = minHeap.size() + maxHeap.size();\nif (size == 0)\nthrow exception( \"No numbers are available\" );\n\nT median = 0;\nif (size & 1 == 1)\nmedian = minHeap[0];\nelse\nmedian = (minHeap[0] + maxHeap[0]) / 2;\n\nreturn median;\n}\n\nprivate :\nvector<T> minHeap;\nvector<T> maxHeap;\n};\n\nIn the code above, function Insert is used to insert a new number deserialized from a stream, and GetMedian is used to get the median of the existing numbers dynamically.", "question": "\nQuestion: How to get the median from a stream of numbers at any time? The median is middle value of numbers. If the count of numbers is even, the median is defined as the average value of the two numbers in middle.\n"},
{"answer": "\nAnalysis: It is a classic interview questions to get numbers in Fibonacci sequences. We have different solutions for it, and their performance varies a lot.\n\nSolution 1: Inefficient recursive solution\n\nFibonacci sequences are taken as examples to lecture recursive functions in many C/C++ textbooks, so most of candidates are familiar with the recursive solution. They feel confident and delighted when they meet this problem during interviews, because the can write the following code in short time:\n\nlong long Fibonacci( unsigned int n)\n{\nif (n <= 0)\nreturn 0;\n\nif (n == 1)\nreturn 1;\n\nreturn Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n\nOur textbooks take Fibonacci sequences as examples for recursive functions does not necessarily mean that recursion is a good solution for Fibonacci sequences. Interviewers may tell candidates that the performance of this recursive solution is quite bad, and ask them to analyze root causes.\n\nLet us take f(10) as an example to analyze the recursive process. We have to get f(9) and f(8) before we get f(10). Meanwhile, f(8) and f(7) are needed before we get f(9). The dependency can be visualized in a tree as shown in Figure 1:\n\n\n\nIt is not difficult to notice that there are many duplicate nodes in the tree in Figure 1. The number of duplicated nodes increases dramatically when n increases. \u00a0Readers may have a try on the 100 th number if Fibonacci sequences to have intuitive ideas about how slow this recursive solution is.\n\nSolution 2: Practical Solution with O(n) efficiency\n\nIt is easy to optimize performance fortunately if we calculate from bottom. That is to say, we get f(2) based on f(0) and f(1), and get f(3) based on f(1) and f(2). We follow this pattern till we get f(n). It is obvious that its time complexity is O(n). Its corresponding code is shown below:\n\nlong long Fibonacci( unsigned n)\n{\nint result[2] = {0, 1};\nif (n < 2)\nreturn result[n];\n\nlong long fibNMinusOne = 1;\nlong long fibNMinusTwo = 0;\nlong long fibN = 0;\nfor ( unsigned int i = 2; i <= n; ++ i)\n{\nfibN = fibNMinusOne + fibNMinusTwo;\n\nfibNMinusTwo = fibNMinusOne;\nfibNMinusOne = fibN;\n}\n\nreturn fibN;\n}\n\nSolution 3: O( log n) solution\n\nUsually interviewers expect the O(n) solution above. However, there is an O( log n) solution available, which is based on an uncommon equation as shown below:\n\n\nIt is not difficult to prove this equation vithmathematical induction. Interested readers may have try.\n\nNow the only problem is how to calculate power of a matrix . We can calculate power with exponent n in O( log n) time with the following equation:\n\n\n\n\n\nThe source code to get power of a matrix looks complicated, which is listed below:\n\n#include <cassert>\n\nstruct Matrix2By2\n{\nMatrix2By2\n(\nlong long m00 = 0,\nlong long m01 = 0,\nlong long m10 = 0,\nlong long m11 = 0\n)\n:m_00(m00), m_01(m01), m_10(m10), m_11(m11)\n{\n}\n\nlong long m_00;\nlong long m_01;\nlong long m_10;\nlong long m_11;\n};\n\nMatrix2By2 MatrixMultiply\n(\nconst Matrix2By2& matrix1,\nconst Matrix2By2& matrix2\n)\n{\nreturn Matrix2By2(\nmatrix1.m_00 * matrix2.m_00 + matrix1.m_01 * matrix2.m_10,\nmatrix1.m_00 * matrix2.m_01 + matrix1.m_01 * matrix2.m_11,\nmatrix1.m_10 * matrix2.m_00 + matrix1.m_11 * matrix2.m_10,\nmatrix1.m_10 * matrix2.m_01 + matrix1.m_11 * matrix2.m_11);\n}\n\nMatrix2By2 MatrixPower( unsigned int n)\n{\nassert(n > 0);\n\nMatrix2By2 matrix;\nif (n == 1)\n{\nmatrix = Matrix2By2(1, 1, 1, 0);\n}\nelse if (n % 2 == 0)\n{\nmatrix = MatrixPower(n / 2);\nmatrix = MatrixMultiply(matrix, matrix);\n}\nelse if (n % 2 == 1)\n{\nmatrix = MatrixPower((n - 1) / 2);\nmatrix = MatrixMultiply(matrix, matrix);\nmatrix = MatrixMultiply(matrix, Matrix2By2(1, 1, 1, 0));\n}\n\nreturn matrix;\n}\n\nlong long Fibonacci( unsigned int n)\n{\nint result[2] = {0, 1};\nif (n < 2)\nreturn result[n];\n\nMatrix2By2 PowerNMinus2 = MatrixPower(n - 1);\nreturn PowerNMinus2.m_00;\n}\n\nEven though it cost only O( log n) time in theory, its hidden constant parameter is quite big, so it is not treated as a practical solution in real software development. Additionally, it is not a recommended solution during interviews since its implementation code is very complex.", "question": "\nProblem: Please implement a function which returns the n th number in Fibonacci sequences with an input n. Fibonacci sequence is defined as:\n\n\n\n"},
{"answer": "\nAnalysis: This is a typical problem which can be solved by dynamic programming. We have two strategies to analyze and solve this problem\n\nSolution 1: Split at any space between two characters\n\nGiven a substring of str , starting from the index i and ending at the index j (denoted as str [ i : j ]), we define a function f ( i , j ) to denote the minimal number of splits to partition the substring str [ i : j ] into a set of palindromes. If the substring is a palindrome itself, we don\u2019t have to split so f ( i , j ) is 0. If the substring is not a palindrome, the substring is split between two characters k and k +1. f ( i , j )= f ( i , k )+ f ( k +1, j )+1 under such conditions. Therefore, f ( i , j ) can be defined with the following equation:\n\n\nThe value of f (0, n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nIf the equation is calculated recursively, its complexity grows exponentially with the length n . A better choice is to calculate in bottom-up order with a 2D matrix with size n \u00d7 n . The following C++ code implements this solution:\n\n int minSplit_1( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length * length];\n    \n     for ( int i = 0; i <length; ++i)\n        split[i * length + i] = 0;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         for ( int j = length -i; j > 0; --j)\n         {\n             int row = length - i - j;\n             int col = row + i;\n             if (isPalindrome(str, row, col))\n             {\n                split[row * length + col] = 0;\n             }\n             else\n             {\n                 int min = 0x7FFFFFFF;\n                 for ( int k = row; k < col; ++k)\n                {\n                     int temp1 = split[row * length + k];\n                     int temp2 = split[(k + 1) * length +col];\n                     if (min> temp1 + temp2 + 1)\n                         min = temp1 + temp2 +1;\n                }\n                split[row * length + col] = min;\n             }\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nSolution 2: Split only before a palindrome\n\nWe split the string str with another strategy. Given a substring ending at the index i , str [0, i], we do not have to split if the substring is a palindrome itself. Otherwise it is split between two characters at index j and j +1 only if the substring str [ j +1, i ] is a palindrome. Therefore, an equation f ( i ) can be defined as the following:\n\n\nThe value of f ( n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nWe could utilize a 1D array to solve this equation in bottom-up order, as listed in the following code:\n\n int minSplit_2( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length];\n     for ( int i = 0; i <length; ++i)\n        split[i] = i;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         if (isPalindrome(str, 0, i))\n         {\n            split[i] = 0;\n             continue ;\n         }\n\n         for ( int j = 0; j <i; ++j)\n         {\n             if (isPalindrome(str, j + 1, i) && split[i]> split[j] + 1)\n                split[i] = split[j] + 1;\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nOptimization to verify palindromes:\n\nUsually it costs O( n ) time to check whether a string with length n is a palindrome, and the typical implementation looks like the following code:\n\n bool isPalindrome( const string& str, int begin, int end)\n {\n     for ( int i = begin; i< end - (i - begin); ++i)\n     {\n         if (str[i] != str[end - (i - begin)])\n             return false ;\n     }\n\n     return true ;\n }\n\nBoth solutions above cost O( n 3 ) time. The first solution contains three nesting for-loops. The function isPalindrome is inside two nesting for-loops.\n\nIf we could reduce the cost of isPalindrome to O(1), the time complexity of the second solution would be O( n 2 ).\n\nNotice that the substring str [ i , j ] is a palindrome only if the characters at index i and j , and str [ i +1, j -1] is also a palindrome. We could build a 2D table accordingly to store whether every substring of str is a palindrome or not during the preprocessing. With such a table, the function isPalindrome can verify the substring str [ i , j ] in O(1) time.\n\n", "question": "\nProblem: A string can be partitioned into some substrings, such that each substring is a palindrome. For example, there are a few strategies to split the string \u201cabbab\u201d into palindrome substrings, such as: \u201cabba\u201d|\u201db\u201d, \u201ca\u201d|\u201db\u201d|\u201dbab\u201d and \u201ca\u201d|\u201dbb\u201d|\u201da\u201d|\u201db\u201d.\n\nGiven a string str , please get the minimal numbers of splits to partition it into palindromes. The minimal number of splits to partition the string \u201cabbab\u201d into a set of palindromes is 1.\n"},
{"answer": "\nAnalysis: This is a typical problem which can be solved by dynamic programming. We have two strategies to analyze and solve this problem\n\nSolution 1: Split at any space between two characters\n\nGiven a substring of str , starting from the index i and ending at the index j (denoted as str [ i : j ]), we define a function f ( i , j ) to denote the minimal number of splits to partition the substring str [ i : j ] into a set of palindromes. If the substring is a palindrome itself, we don\u2019t have to split so f ( i , j ) is 0. If the substring is not a palindrome, the substring is split between two characters k and k +1. f ( i , j )= f ( i , k )+ f ( k +1, j )+1 under such conditions. Therefore, f ( i , j ) can be defined with the following equation:\n\n\nThe value of f (0, n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nIf the equation is calculated recursively, its complexity grows exponentially with the length n . A better choice is to calculate in bottom-up order with a 2D matrix with size n \u00d7 n . The following C++ code implements this solution:\n\n int minSplit_1( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length * length];\n    \n     for ( int i = 0; i <length; ++i)\n        split[i * length + i] = 0;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         for ( int j = length -i; j > 0; --j)\n         {\n             int row = length - i - j;\n             int col = row + i;\n             if (isPalindrome(str, row, col))\n             {\n                split[row * length + col] = 0;\n             }\n             else\n             {\n                 int min = 0x7FFFFFFF;\n                 for ( int k = row; k < col; ++k)\n                {\n                     int temp1 = split[row * length + k];\n                     int temp2 = split[(k + 1) * length +col];\n                     if (min> temp1 + temp2 + 1)\n                         min = temp1 + temp2 +1;\n                }\n                split[row * length + col] = min;\n             }\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nSolution 2: Split only before a palindrome\n\nWe split the string str with another strategy. Given a substring ending at the index i , str [0, i], we do not have to split if the substring is a palindrome itself. Otherwise it is split between two characters at index j and j +1 only if the substring str [ j +1, i ] is a palindrome. Therefore, an equation f ( i ) can be defined as the following:\n\n\nThe value of f ( n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nWe could utilize a 1D array to solve this equation in bottom-up order, as listed in the following code:\n\n int minSplit_2( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length];\n     for ( int i = 0; i <length; ++i)\n        split[i] = i;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         if (isPalindrome(str, 0, i))\n         {\n            split[i] = 0;\n             continue ;\n         }\n\n         for ( int j = 0; j <i; ++j)\n         {\n             if (isPalindrome(str, j + 1, i) && split[i]> split[j] + 1)\n                split[i] = split[j] + 1;\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nOptimization to verify palindromes:\n\nUsually it costs O( n ) time to check whether a string with length n is a palindrome, and the typical implementation looks like the following code:\n\n bool isPalindrome( const string& str, int begin, int end)\n {\n     for ( int i = begin; i< end - (i - begin); ++i)\n     {\n         if (str[i] != str[end - (i - begin)])\n             return false ;\n     }\n\n     return true ;\n }\n\nBoth solutions above cost O( n 3 ) time. The first solution contains three nesting for-loops. The function isPalindrome is inside two nesting for-loops.\n\nIf we could reduce the cost of isPalindrome to O(1), the time complexity of the second solution would be O( n 2 ).\n\nNotice that the substring str [ i , j ] is a palindrome only if the characters at index i and j , and str [ i +1, j -1] is also a palindrome. We could build a 2D table accordingly to store whether every substring of str is a palindrome or not during the preprocessing. With such a table, the function isPalindrome can verify the substring str [ i , j ] in O(1) time.\n\n", "question": "\nProblem: A string can be partitioned into some substrings, such that each substring is a palindrome. For example, there are a few strategies to split the string \u201cabbab\u201d into palindrome substrings, such as: \u201cabba\u201d|\u201db\u201d, \u201ca\u201d|\u201db\u201d|\u201dbab\u201d and \u201ca\u201d|\u201dbb\u201d|\u201da\u201d|\u201db\u201d.\n\nGiven a string str , please get the minimal numbers of splits to partition it into palindromes. The minimal number of splits to partition the string \u201cabbab\u201d into a set of palindromes is 1.\n"},
{"answer": "\nAnalysis: This is a typical problem which can be solved by dynamic programming. We have two strategies to analyze and solve this problem\n\nSolution 1: Split at any space between two characters\n\nGiven a substring of str , starting from the index i and ending at the index j (denoted as str [ i : j ]), we define a function f ( i , j ) to denote the minimal number of splits to partition the substring str [ i : j ] into a set of palindromes. If the substring is a palindrome itself, we don\u2019t have to split so f ( i , j ) is 0. If the substring is not a palindrome, the substring is split between two characters k and k +1. f ( i , j )= f ( i , k )+ f ( k +1, j )+1 under such conditions. Therefore, f ( i , j ) can be defined with the following equation:\n\n\nThe value of f (0, n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nIf the equation is calculated recursively, its complexity grows exponentially with the length n . A better choice is to calculate in bottom-up order with a 2D matrix with size n \u00d7 n . The following C++ code implements this solution:\n\n int minSplit_1( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length * length];\n    \n     for ( int i = 0; i <length; ++i)\n        split[i * length + i] = 0;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         for ( int j = length -i; j > 0; --j)\n         {\n             int row = length - i - j;\n             int col = row + i;\n             if (isPalindrome(str, row, col))\n             {\n                split[row * length + col] = 0;\n             }\n             else\n             {\n                 int min = 0x7FFFFFFF;\n                 for ( int k = row; k < col; ++k)\n                {\n                     int temp1 = split[row * length + k];\n                     int temp2 = split[(k + 1) * length +col];\n                     if (min> temp1 + temp2 + 1)\n                         min = temp1 + temp2 +1;\n                }\n                split[row * length + col] = min;\n             }\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nSolution 2: Split only before a palindrome\n\nWe split the string str with another strategy. Given a substring ending at the index i , str [0, i], we do not have to split if the substring is a palindrome itself. Otherwise it is split between two characters at index j and j +1 only if the substring str [ j +1, i ] is a palindrome. Therefore, an equation f ( i ) can be defined as the following:\n\n\nThe value of f ( n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nWe could utilize a 1D array to solve this equation in bottom-up order, as listed in the following code:\n\n int minSplit_2( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length];\n     for ( int i = 0; i <length; ++i)\n        split[i] = i;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         if (isPalindrome(str, 0, i))\n         {\n            split[i] = 0;\n             continue ;\n         }\n\n         for ( int j = 0; j <i; ++j)\n         {\n             if (isPalindrome(str, j + 1, i) && split[i]> split[j] + 1)\n                split[i] = split[j] + 1;\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nOptimization to verify palindromes:\n\nUsually it costs O( n ) time to check whether a string with length n is a palindrome, and the typical implementation looks like the following code:\n\n bool isPalindrome( const string& str, int begin, int end)\n {\n     for ( int i = begin; i< end - (i - begin); ++i)\n     {\n         if (str[i] != str[end - (i - begin)])\n             return false ;\n     }\n\n     return true ;\n }\n\nBoth solutions above cost O( n 3 ) time. The first solution contains three nesting for-loops. The function isPalindrome is inside two nesting for-loops.\n\nIf we could reduce the cost of isPalindrome to O(1), the time complexity of the second solution would be O( n 2 ).\n\nNotice that the substring str [ i , j ] is a palindrome only if the characters at index i and j , and str [ i +1, j -1] is also a palindrome. We could build a 2D table accordingly to store whether every substring of str is a palindrome or not during the preprocessing. With such a table, the function isPalindrome can verify the substring str [ i , j ] in O(1) time.\n\n", "question": "\nProblem: A string can be partitioned into some substrings, such that each substring is a palindrome. For example, there are a few strategies to split the string \u201cabbab\u201d into palindrome substrings, such as: \u201cabba\u201d|\u201db\u201d, \u201ca\u201d|\u201db\u201d|\u201dbab\u201d and \u201ca\u201d|\u201dbb\u201d|\u201da\u201d|\u201db\u201d.\n\nGiven a string str , please get the minimal numbers of splits to partition it into palindromes. The minimal number of splits to partition the string \u201cabbab\u201d into a set of palindromes is 1.\n"},
{"answer": "\nAnalysis: This is a typical problem which can be solved by dynamic programming. We have two strategies to analyze and solve this problem\n\nSolution 1: Split at any space between two characters\n\nGiven a substring of str , starting from the index i and ending at the index j (denoted as str [ i : j ]), we define a function f ( i , j ) to denote the minimal number of splits to partition the substring str [ i : j ] into a set of palindromes. If the substring is a palindrome itself, we don\u2019t have to split so f ( i , j ) is 0. If the substring is not a palindrome, the substring is split between two characters k and k +1. f ( i , j )= f ( i , k )+ f ( k +1, j )+1 under such conditions. Therefore, f ( i , j ) can be defined with the following equation:\n\n\nThe value of f (0, n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nIf the equation is calculated recursively, its complexity grows exponentially with the length n . A better choice is to calculate in bottom-up order with a 2D matrix with size n \u00d7 n . The following C++ code implements this solution:\n\n int minSplit_1( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length * length];\n    \n     for ( int i = 0; i <length; ++i)\n        split[i * length + i] = 0;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         for ( int j = length -i; j > 0; --j)\n         {\n             int row = length - i - j;\n             int col = row + i;\n             if (isPalindrome(str, row, col))\n             {\n                split[row * length + col] = 0;\n             }\n             else\n             {\n                 int min = 0x7FFFFFFF;\n                 for ( int k = row; k < col; ++k)\n                {\n                     int temp1 = split[row * length + k];\n                     int temp2 = split[(k + 1) * length +col];\n                     if (min> temp1 + temp2 + 1)\n                         min = temp1 + temp2 +1;\n                }\n                split[row * length + col] = min;\n             }\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nSolution 2: Split only before a palindrome\n\nWe split the string str with another strategy. Given a substring ending at the index i , str [0, i], we do not have to split if the substring is a palindrome itself. Otherwise it is split between two characters at index j and j +1 only if the substring str [ j +1, i ] is a palindrome. Therefore, an equation f ( i ) can be defined as the following:\n\n\nThe value of f ( n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nWe could utilize a 1D array to solve this equation in bottom-up order, as listed in the following code:\n\n int minSplit_2( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length];\n     for ( int i = 0; i <length; ++i)\n        split[i] = i;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         if (isPalindrome(str, 0, i))\n         {\n            split[i] = 0;\n             continue ;\n         }\n\n         for ( int j = 0; j <i; ++j)\n         {\n             if (isPalindrome(str, j + 1, i) && split[i]> split[j] + 1)\n                split[i] = split[j] + 1;\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nOptimization to verify palindromes:\n\nUsually it costs O( n ) time to check whether a string with length n is a palindrome, and the typical implementation looks like the following code:\n\n bool isPalindrome( const string& str, int begin, int end)\n {\n     for ( int i = begin; i< end - (i - begin); ++i)\n     {\n         if (str[i] != str[end - (i - begin)])\n             return false ;\n     }\n\n     return true ;\n }\n\nBoth solutions above cost O( n 3 ) time. The first solution contains three nesting for-loops. The function isPalindrome is inside two nesting for-loops.\n\nIf we could reduce the cost of isPalindrome to O(1), the time complexity of the second solution would be O( n 2 ).\n\nNotice that the substring str [ i , j ] is a palindrome only if the characters at index i and j , and str [ i +1, j -1] is also a palindrome. We could build a 2D table accordingly to store whether every substring of str is a palindrome or not during the preprocessing. With such a table, the function isPalindrome can verify the substring str [ i , j ] in O(1) time.\n\n", "question": "\nProblem: A string can be partitioned into some substrings, such that each substring is a palindrome. For example, there are a few strategies to split the string \u201cabbab\u201d into palindrome substrings, such as: \u201cabba\u201d|\u201db\u201d, \u201ca\u201d|\u201db\u201d|\u201dbab\u201d and \u201ca\u201d|\u201dbb\u201d|\u201da\u201d|\u201db\u201d.\n\nGiven a string str , please get the minimal numbers of splits to partition it into palindromes. The minimal number of splits to partition the string \u201cabbab\u201d into a set of palindromes is 1.\n"},
{"answer": "\nAnalysis: This is a typical problem which can be solved by dynamic programming. We have two strategies to analyze and solve this problem\n\nSolution 1: Split at any space between two characters\n\nGiven a substring of str , starting from the index i and ending at the index j (denoted as str [ i : j ]), we define a function f ( i , j ) to denote the minimal number of splits to partition the substring str [ i : j ] into a set of palindromes. If the substring is a palindrome itself, we don\u2019t have to split so f ( i , j ) is 0. If the substring is not a palindrome, the substring is split between two characters k and k +1. f ( i , j )= f ( i , k )+ f ( k +1, j )+1 under such conditions. Therefore, f ( i , j ) can be defined with the following equation:\n\n\nThe value of f (0, n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nIf the equation is calculated recursively, its complexity grows exponentially with the length n . A better choice is to calculate in bottom-up order with a 2D matrix with size n \u00d7 n . The following C++ code implements this solution:\n\n int minSplit_1( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length * length];\n    \n     for ( int i = 0; i <length; ++i)\n        split[i * length + i] = 0;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         for ( int j = length -i; j > 0; --j)\n         {\n             int row = length - i - j;\n             int col = row + i;\n             if (isPalindrome(str, row, col))\n             {\n                split[row * length + col] = 0;\n             }\n             else\n             {\n                 int min = 0x7FFFFFFF;\n                 for ( int k = row; k < col; ++k)\n                {\n                     int temp1 = split[row * length + k];\n                     int temp2 = split[(k + 1) * length +col];\n                     if (min> temp1 + temp2 + 1)\n                         min = temp1 + temp2 +1;\n                }\n                split[row * length + col] = min;\n             }\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nSolution 2: Split only before a palindrome\n\nWe split the string str with another strategy. Given a substring ending at the index i , str [0, i], we do not have to split if the substring is a palindrome itself. Otherwise it is split between two characters at index j and j +1 only if the substring str [ j +1, i ] is a palindrome. Therefore, an equation f ( i ) can be defined as the following:\n\n\nThe value of f ( n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nWe could utilize a 1D array to solve this equation in bottom-up order, as listed in the following code:\n\n int minSplit_2( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length];\n     for ( int i = 0; i <length; ++i)\n        split[i] = i;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         if (isPalindrome(str, 0, i))\n         {\n            split[i] = 0;\n             continue ;\n         }\n\n         for ( int j = 0; j <i; ++j)\n         {\n             if (isPalindrome(str, j + 1, i) && split[i]> split[j] + 1)\n                split[i] = split[j] + 1;\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nOptimization to verify palindromes:\n\nUsually it costs O( n ) time to check whether a string with length n is a palindrome, and the typical implementation looks like the following code:\n\n bool isPalindrome( const string& str, int begin, int end)\n {\n     for ( int i = begin; i< end - (i - begin); ++i)\n     {\n         if (str[i] != str[end - (i - begin)])\n             return false ;\n     }\n\n     return true ;\n }\n\nBoth solutions above cost O( n 3 ) time. The first solution contains three nesting for-loops. The function isPalindrome is inside two nesting for-loops.\n\nIf we could reduce the cost of isPalindrome to O(1), the time complexity of the second solution would be O( n 2 ).\n\nNotice that the substring str [ i , j ] is a palindrome only if the characters at index i and j , and str [ i +1, j -1] is also a palindrome. We could build a 2D table accordingly to store whether every substring of str is a palindrome or not during the preprocessing. With such a table, the function isPalindrome can verify the substring str [ i , j ] in O(1) time.\n\n", "question": "\nProblem: A string can be partitioned into some substrings, such that each substring is a palindrome. For example, there are a few strategies to split the string \u201cabbab\u201d into palindrome substrings, such as: \u201cabba\u201d|\u201db\u201d, \u201ca\u201d|\u201db\u201d|\u201dbab\u201d and \u201ca\u201d|\u201dbb\u201d|\u201da\u201d|\u201db\u201d.\n\nGiven a string str , please get the minimal numbers of splits to partition it into palindromes. The minimal number of splits to partition the string \u201cabbab\u201d into a set of palindromes is 1.\n"},
{"answer": "\nAnalysis: Firstly let\u2019s analyze this problem with the brute-force solution: All elements in the array are scanned one by one. When an element is scanned, we take is as A[ j ], and check whether there is a smaller element on its left side (A[ i ]), and a greater element on its right side (A[ k ]).\nSince it takes O( n ) time to scan numbers on two sides of each A[ j ], the overall time of this solution is O( n 2 ) on an array with n elements.\n\nSolution 1: O(n) time efficiency with O(n) space consumption\nAs our analysis above, for each element A[ j ], we need to know whether there is a smaller element on its left side. If there is not a smaller element on the left side, A[ j ] itself is the smallest of all elements from the leftmost element to A[ j ]. If there is a smaller element on the left side, the smallest of all elements from the leftmost element to A[ j ] is on the left side of A[ j ].\nTherefore, we could construct an auxiliary array B. The element B[ j ] stores the index of the smallest element of elements from the leftmost element to A[ j ]. The array B can be constructed based on elements in A from left to right.\nSimilarly, we could also construct another auxiliary array C. The element C[ j ] stores the index of the greatest element of elements from the rightmost element to A[ j ]. The array C can be constructed based on elements in A from right to left.\nWhen an element A[ j ] is scanned, the index j is compared with B[ j ] and C[ j ]. if B[ j ]< j (there is a smaller element on the left side) and j <C[ j ] (there is a greater element on the right side), three increasing elements have been found.\nThis solution can be implemented with the following C/C++ code:\n void increasingIndex_1( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     int * minIndex = new int [length];\n     int index = 0;\n    minIndex[0] = 0;\n     int t;\n     for (t = 1; t < length; ++t)\n     {\n         if (nums[t] < nums[index])\n            index = t;\n        minIndex[t] = index;\n     }\n\n     int * maxIndex = new int [length];\n     index =length - 1;\n     for (t = length - 1; t >= 0; --t)\n     {\n         if (nums[t] > nums[index])\n            index = t;\n        maxIndex[t] = index;\n     }\n\n     for (t = 1; t < length - 1; ++t)\n     {\n         if (minIndex[t] < t && maxIndex[t] > t)\n             break ;\n     }\n     if (t < length - 1)\n     {\n         *i =minIndex[t];\n         *j =t;\n         *k =maxIndex[t];\n     }\n     else\n     {\n         *i =*j = *k = -1;\n     }\n\n     delete [] minIndex;\n     delete [] maxIndex;\n }\n\nSolution 2: O(n) time efficiency with O(1) space consumption\nIn order to find an even more efficient solution, let\u2019s scan all elements in an array and try to find three increasing elements. The array {3, 2, 5, 1, 4, 7, 9, 6, 8} is taken as an example to simulate the process.\nAt first, all elements A[ i ], A[ j ], and A[ k ] have not been found, so three indexes i , j , and k are initialized as -1.\nThe number 3 is the first number to be scanned, and A[ i ] is updated as 3.\nThe next number to be scanned is the number 2. Notice that 2 is less than 3, and it is a better candidate of A[ i ]. The less A[ i ] is, the larger range A[ j ] and A[ k ] will have. Therefore, A[ i ] is updated as 2.\nLet\u2019s continue to scan the next number 5. Since 5 is greater the current A[ i ], it is a candidate of A[ j ]. A[ j ] is updated as 5.\nThe number 1 is scanned in the next round. Because 1 is less than the current A[ j ], it cannot be A[ k ]. Additionally, the number 1 is a candidate to be A[ i ] or A[ j ] in the future since it is less than the current A[ i ] and A[ j ]. However, neither A[ i ] nor A[ j ] can be updated as 1 at this time. If A[ i ] is updated as 1, A[ i ]<A[ j ] but i > j . If A[ j ] is updated as 1, A[ i ]>A[ j ]. Therefore, we store the number 1 into another variable named t .\nWe move on to scan the next number 4. Notice that the number 4 is less than A[ j ] again. At this time we have two numbers 1 (the stored variable t ) and 4, so we have a new pair of numbers to be A[ i ] and A[ j ]. A[ i ] and A[ j ] are updated as 1 and 4 respectively.\nThe next number, 7, is greater than the current A[ j ], so A[ k ] is updated as 7. The process terminates.\nThe following table summarizes the step-by-step analysis above:\nStep\nScanned Number\nA[ i ]\nA[ j ]\nA[ k ]\nt\nOperation\n1\n3\n3\n-1\n-1\n-1\nUpdate A[ i ]\n2\n2\n2\n-1\n-1\n-1\nUpdate A[ i ]\n3\n5\n2\n5\n-1\n-1\nUpdate A[ j ]\n4\n1\n2\n5\n-1\n1\nUpdate t\n5\n4\n1\n4\n-1\n-1\nUpdate A[ i ], A[ j ] and t\n6\n7\n1\n4\n7\n-1\nUpdate A[ k ]. Terminate.\nThe strategy of this solution is to store as less value to A[ i ] and A[ j ] as possible, in order to enlarge the value range for steps in the future.\nWith our step-by-step analysis, we could implement this solution with the following C++ code:\n void increasingIndex_2( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     *i = *j =*k = -1;\n     int backup = -1;\n\n     int index;\n     for (index = 0; index < length; ++index)\n     {\n         if (*i == -1)\n         {\n            *i = index;\n         }\n         else if (*j == -1)\n         {\n             if (nums[index] > nums[*i])\n                *j = index;\n             else\n                *i = index;\n         }\n         else if (nums[index]> nums[*j])\n         {\n            *k = index;\n             break ;\n         }\n         else if (nums[index]< nums[*j])\n         {\n             if (backup != -1)\n             {\n                 if (nums[index] > nums[backup])\n                {\n                    *i = backup;\n                    *j = index;\n                    backup = -1;\n                }\n                 else if (nums[index] < nums[backup])\n                {\n                    backup = index;\n                }\n             }\n             else if (nums[index]< nums[*j])\n                backup = index;\n         }\n     }\n     if (index == length)\n         *i =*j = *k = -1;\n }\n", "question": "\nProblem: Given an array of integers A, please find three indexes i , j , k , such that i < j < k and A[ i ]<A[ j ]<A[ k ].\n"},
{"answer": "\nAnalysis: It\u2019s not difficult to get all substrings of a string, and to check whether a substring has duplicated characters. The only concern about this brute-force strategy is performance. A string with n characters has O( n 2 ) substrings, and it costs O( n ) time to check whether a substring has duplication. Therefore, the overall cost is O( n 3 ).\n\nWe may improve the efficiency with dynamic programming. Let\u2019s denote the length of longest substring ending with the i th character by L ( i ).\n\nWe scan the string one character after another. When the i th character is scanned, L ( i -1) is already know. If the i th character has not appeared before, L ( i ) should be L ( i -1)+1. It\u2019s more complex when the i th character is duplicated. Firstly we get the distance between the i th character and its previous occurrence. If the distance is greater than L ( i -1), the character is not in longest substring without duplication ending with the ( i -1) th character, so L ( i ) should also be L ( i -1)+1. If the distance is less than L ( i -1), L ( i ) is the distance, and it means between the two occurrence of the i th character there are no other duplicated characters.\n\nThis solution can be implemented in Java as the following code:\n\n public static int longestSubstringWithoutDuplication(String str) {\n     int curLength = 0;\n     int maxLength = 0;\n\n     int position[] = new int [26];\n     for ( int i = 0; i < 26; ++i) {\n         position[i] = -1;\n     }\n\n     for ( int i = 0; i < str.length(); ++i) {\n         int prevIndex = position[str.charAt(i) - 'a' ];\n         if (prevIndex < 0 || i - prevIndex > curLength) {\n             ++curLength;\n         }\n         else {\n             if (curLength > maxLength) {\n                 maxLength = curLength;\n             }\n\n             curLength = i - prevIndex;\n         }\n         position[str.charAt(i) - 'a' ] = i;\n     }\n\n     if (curLength > maxLength) {\n         maxLength = curLength;\n     }\n\n     return maxLength;\n }\n\n L ( i ) is implemented as curLength in the code above. Aninteger array is used to store the positions of each character.\n\n", "question": "\nProblem: Given a string, please get the length of the longest substring which does not have duplicated characters. Supposing all characters in the string are in the range from \u2018a\u2019 to \u2018z\u2019.\n"},
{"answer": "\nAnalysis: Lots of pointer operations are necessary to solve problems related to linked lists. Interviewers know that many candidates are prone to make mistakes on pointer operations, so they like problems of linked list to qualify candidates\u2019 programming abilities. During interviews, we had better analyze and design carefully rather than begin to code hastily. It is much better to write robust code with comprehensive analysis than write code quickly with many errors.\n\nDirection of pointers should be adjusted in order to reverse a linked list. We may utilize figures to analyze visually the complex steps to adjust pointers. As shown in the list in Figure 1-a, node h, i and j are three adjacent nodes. Let us assume pointers of all nodes prior to h have been reversed after some operations and all m_pNext point to their previous nodes. We are going to reverse the m_pNext pointer in node i. The status of list is shown in Figure 1-b.\n\n\nIt is noticeable that m_pNext in node i points to its previous node h, the list is broken and we cannot visit the node j anymore. We should save the node j before the m_pNext pointer of node i is adjusted to prevent the list becoming broken.\n\nWhen we adjust the pointer in node i, we need to access to node h since m_pNext of node i is adjusted to point to node h. Meanwhile, we also need to access to node j because it is necessary to save it otherwise the list will be broken. Therefore, three pointers should be declared in our code, which point to the current visited node, its previous node and its next node.\n\nLastly we should get the head node of the reversed list. Obviously head in the reversed list should be tail of the original list. Which pointer is tail? It should be a node whose m_pNext is NULL .\nWith comprehensive analysis above, we are ready to write code, which is shown below:\n\nListNode* ReverseList(ListNode* pHead)\n{\nListNode* pReversedHead = NULL;\nListNode* pNode = pHead;\nListNode* pPrev = NULL;\nwhile (pNode != NULL)\n{\nListNode* pNext = pNode->m_pNext;\n\nif (pNext == NULL)\npReversedHead = pNode;\n\npNode->m_pNext = pPrev;\n\npPrev = pNode;\npNode = pNext;\n}\n\nreturn pReversedHead;", "question": "\nProblem: Implement a function to reverse a linked list, and return the head of the reversed list. A list node is defined as below:\nstruct ListNode\n{\nint m_nKey;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: Lots of pointer operations are necessary to solve problems related to linked lists. Interviewers know that many candidates are prone to make mistakes on pointer operations, so they like problems of linked list to qualify candidates\u2019 programming abilities. During interviews, we had better analyze and design carefully rather than begin to code hastily. It is much better to write robust code with comprehensive analysis than write code quickly with many errors.\n\nDirection of pointers should be adjusted in order to reverse a linked list. We may utilize figures to analyze visually the complex steps to adjust pointers. As shown in the list in Figure 1-a, node h, i and j are three adjacent nodes. Let us assume pointers of all nodes prior to h have been reversed after some operations and all m_pNext point to their previous nodes. We are going to reverse the m_pNext pointer in node i. The status of list is shown in Figure 1-b.\n\n\nIt is noticeable that m_pNext in node i points to its previous node h, the list is broken and we cannot visit the node j anymore. We should save the node j before the m_pNext pointer of node i is adjusted to prevent the list becoming broken.\n\nWhen we adjust the pointer in node i, we need to access to node h since m_pNext of node i is adjusted to point to node h. Meanwhile, we also need to access to node j because it is necessary to save it otherwise the list will be broken. Therefore, three pointers should be declared in our code, which point to the current visited node, its previous node and its next node.\n\nLastly we should get the head node of the reversed list. Obviously head in the reversed list should be tail of the original list. Which pointer is tail? It should be a node whose m_pNext is NULL .\nWith comprehensive analysis above, we are ready to write code, which is shown below:\n\nListNode* ReverseList(ListNode* pHead)\n{\nListNode* pReversedHead = NULL;\nListNode* pNode = pHead;\nListNode* pPrev = NULL;\nwhile (pNode != NULL)\n{\nListNode* pNext = pNode->m_pNext;\n\nif (pNext == NULL)\npReversedHead = pNode;\n\npNode->m_pNext = pPrev;\n\npPrev = pNode;\npNode = pNext;\n}\n\nreturn pReversedHead;", "question": "\nProblem: Implement a function to reverse a linked list, and return the head of the reversed list. A list node is defined as below:\nstruct ListNode\n{\nint m_nKey;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: Lots of pointer operations are necessary to solve problems related to linked lists. Interviewers know that many candidates are prone to make mistakes on pointer operations, so they like problems of linked list to qualify candidates\u2019 programming abilities. During interviews, we had better analyze and design carefully rather than begin to code hastily. It is much better to write robust code with comprehensive analysis than write code quickly with many errors.\n\nDirection of pointers should be adjusted in order to reverse a linked list. We may utilize figures to analyze visually the complex steps to adjust pointers. As shown in the list in Figure 1-a, node h, i and j are three adjacent nodes. Let us assume pointers of all nodes prior to h have been reversed after some operations and all m_pNext point to their previous nodes. We are going to reverse the m_pNext pointer in node i. The status of list is shown in Figure 1-b.\n\n\nIt is noticeable that m_pNext in node i points to its previous node h, the list is broken and we cannot visit the node j anymore. We should save the node j before the m_pNext pointer of node i is adjusted to prevent the list becoming broken.\n\nWhen we adjust the pointer in node i, we need to access to node h since m_pNext of node i is adjusted to point to node h. Meanwhile, we also need to access to node j because it is necessary to save it otherwise the list will be broken. Therefore, three pointers should be declared in our code, which point to the current visited node, its previous node and its next node.\n\nLastly we should get the head node of the reversed list. Obviously head in the reversed list should be tail of the original list. Which pointer is tail? It should be a node whose m_pNext is NULL .\nWith comprehensive analysis above, we are ready to write code, which is shown below:\n\nListNode* ReverseList(ListNode* pHead)\n{\nListNode* pReversedHead = NULL;\nListNode* pNode = pHead;\nListNode* pPrev = NULL;\nwhile (pNode != NULL)\n{\nListNode* pNext = pNode->m_pNext;\n\nif (pNext == NULL)\npReversedHead = pNode;\n\npNode->m_pNext = pPrev;\n\npPrev = pNode;\npNode = pNext;\n}\n\nreturn pReversedHead;", "question": "\nProblem: Implement a function to reverse a linked list, and return the head of the reversed list. A list node is defined as below:\nstruct ListNode\n{\nint m_nKey;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: Lots of pointer operations are necessary to solve problems related to linked lists. Interviewers know that many candidates are prone to make mistakes on pointer operations, so they like problems of linked list to qualify candidates\u2019 programming abilities. During interviews, we had better analyze and design carefully rather than begin to code hastily. It is much better to write robust code with comprehensive analysis than write code quickly with many errors.\n\nDirection of pointers should be adjusted in order to reverse a linked list. We may utilize figures to analyze visually the complex steps to adjust pointers. As shown in the list in Figure 1-a, node h, i and j are three adjacent nodes. Let us assume pointers of all nodes prior to h have been reversed after some operations and all m_pNext point to their previous nodes. We are going to reverse the m_pNext pointer in node i. The status of list is shown in Figure 1-b.\n\n\nIt is noticeable that m_pNext in node i points to its previous node h, the list is broken and we cannot visit the node j anymore. We should save the node j before the m_pNext pointer of node i is adjusted to prevent the list becoming broken.\n\nWhen we adjust the pointer in node i, we need to access to node h since m_pNext of node i is adjusted to point to node h. Meanwhile, we also need to access to node j because it is necessary to save it otherwise the list will be broken. Therefore, three pointers should be declared in our code, which point to the current visited node, its previous node and its next node.\n\nLastly we should get the head node of the reversed list. Obviously head in the reversed list should be tail of the original list. Which pointer is tail? It should be a node whose m_pNext is NULL .\nWith comprehensive analysis above, we are ready to write code, which is shown below:\n\nListNode* ReverseList(ListNode* pHead)\n{\nListNode* pReversedHead = NULL;\nListNode* pNode = pHead;\nListNode* pPrev = NULL;\nwhile (pNode != NULL)\n{\nListNode* pNext = pNode->m_pNext;\n\nif (pNext == NULL)\npReversedHead = pNode;\n\npNode->m_pNext = pPrev;\n\npPrev = pNode;\npNode = pNext;\n}\n\nreturn pReversedHead;", "question": "\nProblem: Implement a function to reverse a linked list, and return the head of the reversed list. A list node is defined as below:\nstruct ListNode\n{\nint m_nKey;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: Lots of pointer operations are necessary to solve problems related to linked lists. Interviewers know that many candidates are prone to make mistakes on pointer operations, so they like problems of linked list to qualify candidates\u2019 programming abilities. During interviews, we had better analyze and design carefully rather than begin to code hastily. It is much better to write robust code with comprehensive analysis than write code quickly with many errors.\n\nDirection of pointers should be adjusted in order to reverse a linked list. We may utilize figures to analyze visually the complex steps to adjust pointers. As shown in the list in Figure 1-a, node h, i and j are three adjacent nodes. Let us assume pointers of all nodes prior to h have been reversed after some operations and all m_pNext point to their previous nodes. We are going to reverse the m_pNext pointer in node i. The status of list is shown in Figure 1-b.\n\n\nIt is noticeable that m_pNext in node i points to its previous node h, the list is broken and we cannot visit the node j anymore. We should save the node j before the m_pNext pointer of node i is adjusted to prevent the list becoming broken.\n\nWhen we adjust the pointer in node i, we need to access to node h since m_pNext of node i is adjusted to point to node h. Meanwhile, we also need to access to node j because it is necessary to save it otherwise the list will be broken. Therefore, three pointers should be declared in our code, which point to the current visited node, its previous node and its next node.\n\nLastly we should get the head node of the reversed list. Obviously head in the reversed list should be tail of the original list. Which pointer is tail? It should be a node whose m_pNext is NULL .\nWith comprehensive analysis above, we are ready to write code, which is shown below:\n\nListNode* ReverseList(ListNode* pHead)\n{\nListNode* pReversedHead = NULL;\nListNode* pNode = pHead;\nListNode* pPrev = NULL;\nwhile (pNode != NULL)\n{\nListNode* pNext = pNode->m_pNext;\n\nif (pNext == NULL)\npReversedHead = pNode;\n\npNode->m_pNext = pPrev;\n\npPrev = pNode;\npNode = pNext;\n}\n\nreturn pReversedHead;", "question": "\nProblem: Implement a function to reverse a linked list, and return the head of the reversed list. A list node is defined as below:\nstruct ListNode\n{\nint m_nKey;\nListNode* m_pNext;\n};\n"}][{"answer": "", "question": ""},
{"answer": "\nAnalysis: If we scan all integers in the array from beginning to end, we may check whether every element equals its index. Obviously, this solution costs O( n ) time.\nSince numbers are sorted in the array, let's try to utilize the binary search algorithm to optimize. Supposing we reach the i th element in the array at some step. If the value of element is also i , it is a target integer and let's return it.\nWhat would happen when the value m is greater than the index i ? For any k ( k >0), the value of element with index i + k should be greater than or equal to m + k , because integers are unique and increasingly sorted in the array. Additionally because m > k , m + k > i + k . Therefore, every element on the right side of index i should be greater than its index in such a case.\nSimilarly, when the value of element with index i is less than i ,\u00a0every integer on the left side should be less than its index. Please prove it if you are interested.\nTherefore, we could reduce the search scope to half for the next step, and it is a typical process for binary search. The solution can be implemented with the following Java code:\n public static int getNumberSameAsIndex( int [] numbers) {\n     if (numbers == null || numbers.length == 0) {\n         return -1;\n     }\n        \n     int left = 0;\n     int right = numbers.length - 1;\n     while (left <= right) {\n         int middle = left + ((right - left) >>> 1);\n         if (numbers[middle] == middle) {\n             return middle;\n         }\n            \n         if (numbers[middle] > middle) {\n             right = middle - 1;\n         }\n         else {\n             left= middle + 1;\n         }\n     }\n        \n     return -1;\n }", "question": "\nProblem: Integers in an array are unique and increasingly sorted. Please write a function/method to find an integer from the array who equals to its index. For example, in the array {-3, -1, 1, 3, 5}, the number 3 equals its index 3."},
{"answer": "\nAnalysis : It is a typical problem about dynamic programming. Firstly let\u2019s analyze it with recursion. A function f ( i , j ) is defined for the maximal value of gifts when reaching the cell ( i , j ). There are two possible cells before the cell ( i , j ) is reached: One is ( i - 1, j ), and the other is the cell ( i , j -1). Therefore, f ( i , j )= max ( f ( i -1, j ), f ( i , j -1)) + gift[ i , j ].\nEven though it\u2019s a recursive equation, it\u2019s not a good idea to write code in recursion, because there might be many over-lapping sub-problems. A better solution is to solve is with iteration. A 2-D matrix is utilized, and the value in each cell ( i , j ) is the maximal value of gift when reaching the cell ( i , j ) on the board.\nThe iterative solution can be implemented in the following Java code:\n public static int getMaxValue( int [][] values) {\nOptimization\n\nThe maximal value of gifts when reaching the cell ( i , j ) depends on the cells ( i -1, j ) and ( i , j -1) only, so it is not necessary to save the value of the cells in the rows i -2 and above. Therefore, we can replace the 2-D matrix with an array, as the following code shows:\n\n public static int getMaxValue( int [][] values)  {\n     int rows = values.length;\n     int cols = values[0].length;\n\n     int [] maxValues = new int [cols];\n     for ( int i = 0; i < rows; ++i)  {\n         for ( int j = 0; j < cols; ++j)  {\n             int left = 0;\n             int up = 0;\n\n             if (i > 0)  {\n                 up = maxValues[j];\n             }\n\n             if (j > 0)  {\n                 left = maxValues[j - 1];\n             }\n\n             maxValues[j] = Math .max(left, up) +values[i][j];\n         }\n     }\n\n     return maxValues[cols - 1];\n }", "question": "\nQuestion : A board has n * m cells, and there is a gift with some value (value is greater than 0) in every cell. You can get gifts starting from the top-left cell, and move right or down in each step, and finally reach the cell at the bottom-right cell. What\u2019s the maximal value of gifts you can get from the board?\n\n\nFor example, the maximal value of gift from the board above is 53, and the path is highlighted in red."},
{"answer": "", "question": ""},
{"answer": "\nAnalysis: We have discussed how to store nodes of a path in a stack while traversing a binary tree in the blog \" Paths with Specified Sum in Binary Tree \". The depth of a binary tree is the length of the longest path. This solution works, but it is not the most concise one.\n\nThe depth of a binary tree can be gotten in another way. If a binary tree has only one node, its depth is 1. If the root node of a binary tree has only a left subtree, its depth is the depth of the left subtree plus 1. Similarly, its depth is the depth of the right subtree plus 1 if the root node has only a right subtree. What is the depth if the root node has both left subtree and right subtree? It is the greater value of the depth of the left and right subtrees plus 1.\n\nFor example, the root node of the binary tree in Figure\u00a01 has both left and right subtrees. The depth of the left subtree rooted at node 2 is 3, and the depth of the right subtree rooted at node 3 is 2, so the depth of the whole binary tree is 4; 1 plus the greater value of 3 and 2.\n\nIt is easy to implement this solution recursively, with little modification on the post-order traversal algorithm, as shown below:\n\n int TreeDepth(BinaryTreeNode* pRoot)\n {\n     if (pRoot == NULL)\n         return 0;\n\n     int nLeft = TreeDepth(pRoot->m_pLeft);\n     int nRight = TreeDepth(pRoot->m_pRight);\n\n     return (nLeft > nRight) ? (nLeft + 1) : (nRight +1);\n }\n\n\nAnalysis:\n\nSolution 1: Visiting Nodes for Multiple Times\nAccording to the definition of balanced binary trees, this problem can be solved by getting the depth difference between the left and right subtrees of every node. When a node is visited, the function depth is invoked to get the depth of its left and right subtrees. If the depth different is 1 at most for all nodes in a binary tree, it is balanced. This solution can be implemented based on the TreeDepth discussed in the preceding problem, as shown below:\n\n bool IsBalanced_Solution1(BinaryTreeNode* pRoot)\n {\n     if (pRoot == NULL)\n         return true ;\n\n     int left = TreeDepth(pRoot->m_pLeft);\n     int right = TreeDepth(pRoot->m_pRight);\n     int diff = left - right;\n     if (diff > 1 || diff < -1)\n         return false ;\n\n     return IsBalanced_Solution1(pRoot->m_pLeft)\n         && IsBalanced_Solution1(pRoot->m_pRight);\n }  \nThis solution looks concise, but it is inefficient because it visits some nodes for multiple times. Take the binary tree in Figure\u00a01 as an example. When the function TreeDepth takes the node 2 as a parameter, it visits nodes 4, 5, and 7. When it verifies whether the binary tree rooted at node 2 is balanced, it visits nodes 4, 5, and 7 again. Obviously, we could improve performance if nodes are visited only once.\n\nSolution 2: Visiting Every Node Only Once\n\nIf a binary tree is scanned with the post-order algorithm, its left and right subtrees are traversed before the root node. If we record the depth of the currently visited node (the depth of a node is the maximum length of paths from the node to its leaf nodes), we can verify whether the subtree rooted at the currently visited node is balanced. If any subtree is unbalanced, the whole tree is unbalanced.\n\nThis new solution can be implemented as shown in below:\n\nbool IsBalanced_Solution2(BinaryTreeNode* pRoot)\n {\n     int depth = 0;\n     return IsBalanced(pRoot, &depth);\n }\n\n bool IsBalanced(BinaryTreeNode* pRoot, int * pDepth)\n {\n     if (pRoot == NULL)\n     {\n         *pDepth = 0;\n         return true ;\n     }\n\n     int left, right;\n     if (IsBalanced(pRoot->m_pLeft, &left) && IsBalanced(pRoot->m_pRight, &right))\n     {\n         int diff = left - right;\n         if (diff <= 1 && diff >= -1)\n         {\n             *pDepth = 1 + (left > right ? left : right);\n             return true ;\n         }\n     }\n\n     return false ;\n }\n\n\nAfter verifying left and right subtrees of a node, the solution verifies the subtree rooted at the current visited node and passes the depth to verify its parent node. When the recursive process returns to the root node finally, the whole binary tree is verified.\n\n", "question": "\nQuestion 1 : How do you get the depth of a binary tree? Nodes from the root to a leaf form a path. Depth of a binary tree is the maximum length of all paths. For example, the depth of the binary tree in Figure\u00a01 is 4, with the longest path through nodes 1, 2, 5, and 7.\n\nQuestion 2: How do you verify whether a binary tree is balanced? If the depth difference between a left subtree and right subtree of any node in a binary tree is not greater than 1, it is balanced. For instance, the binary tree in Figure\u00a01 is balanced.\n"},
{"answer": "", "question": ""},
{"answer": "", "question": ""},
{"answer": "\nAnalysis: All numbers in the matrix are scanned one by one. When a 1 is met, a group of 1s has been found, and then all 1s in the group are flipped to 0s.\nTherefore, the overall function to count the groups of 1s in a matrix can be implemented in the following C++ code:\n     int group = 0;\n     return group;\nLet\u2019s move on to flip 1s inside a group. Actually, it is an application of the seed filling algorithm. When we are going to flip a group starting from an entry, we take the entry as a seed and push it into a stack. At each step, we get an entry from the top of the stack, flip it, and then push its neighboring entries into the stack. The process continues until the stack is empty. The following code implements this algorithm:\n         int row = topIndex / cols;\n         // up", "question": ""},
{"answer": "\nAnalysis: Binary search tree is an important data structure. It has a specific character: Each node is greater than or equal to nodes in its left sub-tree, and less than or equal to nodes in its right sub-tree.\n\nSolution 1: Verify value range of each node\n\nIf a binary search tree is scanned with pre-order traversal algorithm, the value in a root node is accessed to at first. After the root node is visited, it begins to scan nodes in the left sub-tree. The value of left sub-tree nodes should be less than or equal to the value of the root node. If value of a left sub-tree node is greater than the value of the root node, it violates the definition of binary search tree. It is similar for the right sub-tree.\n\nTherefore, when it visits a node in binary search tree, it narrows the value range of left sub-tree and right sub-tree under the current visited node. All nodes are visited with the pre-order traversal algorithm, and their value is verified. If value in any node violates its corresponding range, it is not a binary search tree.\n\nThe following sample code is implemented based on this pre-order traversal solution:\n\nbool isBST_Solution1(BinaryTreeNode* pRoot)\n{\nint min = numeric_limits< int >::min();\nint max = numeric_limits< int >::max();\nreturn isBSTCore_Solution1(pRoot, min, max);\n}\n\nbool isBSTCore_Solution1(BinaryTreeNode* pRoot, int min, int max)\n{\nif (pRoot == NULL)\nreturn true ;\n\nif (pRoot->nValue < min || pRoot->nValue > max)\nreturn false ;\n\nreturn isBSTCore_Solution1(pRoot->pLeft, min, pRoot->nValue)\n&& isBSTCore_Solution1(pRoot->pRight, pRoot->nValue, max);\n}\n\nIn the code above, value of each node should be in the range between min and max . The value of the current visited node is the maximal value of its left sub-tree, and the minimal value of its right sub-tree, so it updates the min and max arguments and verifies sub-trees recursively.\n\nSolution 2: Increasing in-order traversal sequence\n\nThe first solution is based on pre-order traversal algorithm. Let us have another try on in-order traversal. The in-order traversal sequence of the binary search tree in Figure 1 is: 4, 6, 8, 10, 12, 14 and 16. It is noticeable that the sequence is increasingly sorted.\n\nTherefore, a new solution is available: Nodes in a binary tree is scanned with in-order traversal, and compare value of each node against the value of the previously visited node. If the value of the previously visited node is greater than the value of current node, it breaks the definition of binary tree.\n\nThis solution might be implemented in C++ as the following code:\n\nbool isBST_Solution2(BinaryTreeNode* pRoot)\n{\nint prev = numeric_limits< int >::min();\nreturn isBSTCore_Solution2(pRoot, prev);\n}\n\nbool isBSTCore_Solution2(BinaryTreeNode* pRoot, int& prev)\n{\nif (pRoot == NULL)\nreturn true ;\n\nreturn isBSTCore_Solution2(pRoot->pLeft, prev) // previous node\n&& (pRoot->nValue >= prev) // current node\n&& isBSTCore_Solution2(pRoot->pRight, prev = pRoot->nValue); // next node\n}\n\nThe argument prev of the function isBSTCore_Solution2 above is the value of the previously visited node in pre_order traversal.", "question": "\nQuestion: How to verify whether a binary tree is a binary search tree?\n\nFor example, the tree in Figure 1 is a binary search tree.\n\n\nA node in binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pRight;\n};\n"},
{"answer": "\nAnalysis : It is a popular interview question. Similar to the problem to get the K th node from end is a list, it has a solution with two pointers.\n\nTwo pointers are initialized at the head of list. One pointer forwards once at each step, and the other forwards twice at each step. If the faster pointer meets the slower one again, there is a loop in the list. Otherwise there is no loop if the faster one reaches the end of list.\n\nThe sample code below is implemented according to this solution. The faster pointer is pFast , and the slower one is pSlow .\n\nbool HasLoop(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn false ;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn false ;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn true ;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn false ;\n}\n\n\nAnalysis : Inspired by the solution of the first problem, we can also solve this problem with two pointers.\n\n\nTwo pointers are initialized at the head of a list. If there are n nodes in the loop, the first pointer forwards n steps firstly. And then they forward together, at same speed. When the second pointer reaches the entry node of loop, the first one travels around the loop and returns back to entry node.\n\nLet us take the list in Figure 1 as an example. Two pointers, P1 and P2 are firstly initialized at the head node of the list (Figure 2-a). There are 4 nodes in the loop of list, so P1 moves 4 steps ahead, and reaches the node with value 5 (Figure 2-b). And then these two pointers move for 2 steps, and they meet at the node with value 3, which is the entry node of the loop.\n\nThe only problem is how to get the numbers in a loop. Let go back to the solution of the first question. We define two pointers, and the faster one meets the slower one if there is a loop. Actually, the meeting node should be inside the loop. Therefore, we can move forward from the meeting node and get the number of nodes in the loop when we arrive at the meeting node again.\n\nThe following function MeetingNode gets the meeting node of two pointers if there is a loop in a list, which is a minor modification of the previous HasLoop :\n\nListNode* MeetingNode(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn NULL;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn NULL;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn pFast;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn NULL;\n}\n\nWe can get the number of nodes in a loop of a list, and the entry node of loop after we know the meeting node, as shown below:\n\nListNode* EntryNodeOfLoop(ListNode* pHead)\n{\nListNode* meetingNode = MeetingNode(pHead);\nif (meetingNode == NULL)\nreturn NULL;\n\n// get the number of nodes in loop\nint nodesInLoop = 1;\nListNode* pNode1 = meetingNode;\nwhile (pNode1->m_pNext != meetingNode)\n{\npNode1 = pNode1->m_pNext;\n++nodesInLoop;\n}\n\n// move pNode1\npNode1 = pHead;\nfor ( int i = 0; i < nodesInLoop; ++i)\npNode1 = pNode1->m_pNext;\n\n// move pNode1 and pNode2\nListNode* pNode2 = pHead;\nwhile (pNode1 != pNode2)\n{\npNode1 = pNode1->m_pNext;\npNode2 = pNode2->m_pNext;\n}\n\nreturn pNode1;\n}", "question": "\nQuestion 1 : How to check whether there is a loop in a linked list? For example, the list in Figure 1 has a loop.\n\nA node in list is defined as the following structure:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n\n\nQuestion 2 : If there is a loop in a linked list, how to get the entry node of the loop? The entry node is the first node in the loop from head of list. For instance, the entry node of loop in the list of Figure 1 is the node with value 3.\n"},
{"answer": "\nAnalysis: Since numbers come from a stream, the count of numbers is dynamic, and increases over time. If a data container is defined for the numbers from a stream, new numbers will be inserted into the container when they are deserialized. Let us find an appropriate data structure for such a data container.\n\nAn array is the simplest choice. The array should be sorted, because we are going to get its median. Even though it only costs O(lg n ) time to find the position to be inserted with binary search algorithm, it costs O( n ) time to insert a number into a sorted array, because O( n ) numbers will be moved if there are n numbers in the array. It is very efficient to get the median, since it only takes O(1) time to access to a number in an array with an index.\n\nA sorted list is another choice. It takes O( n ) time to find the appropriate position to insert a new number. Additionally, the time to get the median can be optimized to O(1) if we define two pointers which points to the central one or two elements.\n\nA better choice available is a binary search tree, because it only costs O(lg n ) on average to insert a new node. However, the time complexity is O( n ) for the worst cases, when numbers are inserted in sorted (increasingly or decreasingly) order. To get the median number from a binary search tree, auxiliary data to record the number of nodes of its sub-tree is necessary for each node. It also requires O(lg n ) time to get the median node on overage, but O( n ) time for the worst cases.\n\nWe may utilize a balanced binary search tree, AVL, to avoid the worst cases. Usually the balance factor of a node in AVL trees is the height difference between its right sub-tree and left sub-tree. We may modify a little bit here: Define the balance factor as the difference of number of nodes between its right sub-tree and left sub-tree. It costs O(lg n ) time to insert a new node into an AVL, and O(1) time to get the median for all cases.\n\nAn AVL is efficient, but it is not implemented unfortunately in libraries of the most common programming languages. It is also very difficult for candidates to implement the left/right rotation of AVL trees in dozens of minutes during interview. Let us looks for better solutions.\n\nAs shown in Figure 1, if all numbers are sorted, the numbers which are related to the median are indexed by P1 and P2. If the count of numbers is odd, P1 and P2 point to the same central number. If the count is even, P1 and P2 point to two numbers in middle.\n\nMedian can be get or calculated with the numbers pointed by P1 are P2. It is noticeable that all numbers are divided into two parts. The numbers in the first half are less than the numbers in the second half. Moreover, the number indexed by P1 is the greatest number in the first half, and the number indexed by P2 is the least one in the second half.\nTherefore, numbers in the first half are inserted into a max heap, and numbers in the second half are inserted into a min heap. It costs O(lg n ) time to insert a number into a heap. Since the median can be get or calculated with the root of a min heap and a max heap, it only takes O(1) time.\n\nTable 1 compares the solutions above with a sorted array, a sorted list, a binary search tree, an AVL tree, as well as a min heap and a max heap.\nType for Data Container Time to Insert Time to Get Median Sorted Array O( n ) O(1) Sorted List O( n ) O(1) Binary Search Tree O(lg n ) on   average, O( n ) for the worst cases O(lg n ) on average,   O( n ) for the worst cases AVL O(lg n ) O(1) Max Heap and Min Heap O(lg n ) O(1)\nType for Data Container\nTime to Insert\nTime to Get Median\nSorted Array\nO( n )\nO(1)\nSorted List\nO( n )\nO(1)\nBinary Search Tree\nO(lg n ) on   average, O( n ) for the worst cases\nO(lg n ) on average,   O( n ) for the worst cases\nAVL\nO(lg n )\nO(1)\nMax Heap and Min Heap\nO(lg n )\nO(1)\nTable 1: Summary of solutions with a sorted array, a sorted list, a binary search tree, an AVL tree, as well as a min heap and a max heap.\n\nLet us consider the implementation details. All numbers should be evenly divided into two parts, so the count of number in min heap and max heap should diff 1 at most. To achieve such a division, a new number is inserted into the min heap if the count of existing numbers is even; otherwise it is inserted into the max heap.\n\nWe also should make sure that the numbers in the max heap are less than the numbers in the min heap. Supposing the count of existing numbers is even, a new number will be inserted into the min heap. If the new number is less than some numbers in the max heap, it violates our rule that all numbers in the min heap should be greater than numbers in the min heap.\n\nIn such a case, we can insert the new number into the max heap first, and then pop the greatest number from the max heap, and push it into the min heap. Since the number pushed into the min heap is the former greatest number in the max heap, all numbers in the min heap are greater than numbers in the max heap with the newly inserted number.\n\nThe situation is similar when the count of existing numbers is odd and the new number to be inserted is greater than some numbers in the min heap. Please analyze the insertion process carefully by yourself.\n\nThe following is sample code in C++. Even though there are no types for heaps in STL, we can build heaps with vectors utilizing function push_heap and pop_heap . Comparing functor less and greater are employed for max heaps and min heaps correspondingly.\n\ntemplate < typename T> class DynamicArray\n{\npublic :\nvoid Insert(T num)\n{\nif (((minHeap.size() + maxHeap.size()) & 1) == 0)\n{\nif (maxHeap.size() > 0 && num < maxHeap[0])\n{\nmaxHeap.push_back(num);\npush_heap(maxHeap.begin(), maxHeap.end(), less<T>());\n\nnum = maxHeap[0];\n\npop_heap(maxHeap.begin(), maxHeap.end(), less<T>());\nmaxHeap.pop_back();\n}\n\nminHeap.push_back(num);\npush_heap(minHeap.begin(), minHeap.end(), greater<T>());\n}\nelse\n{\nif (minHeap.size() > 0 && minHeap[0] < num)\n{\nminHeap.push_back(num);\npush_heap(minHeap.begin(), minHeap.end(), greater<T>());\n\nnum = minHeap[0];\n\npop_heap(minHeap.begin(), minHeap.end(), greater<T>());\nminHeap.pop_back();\n}\n\nmaxHeap.push_back(num);\npush_heap(maxHeap.begin(), maxHeap.end(), less<T>());\n}\n}\n\nint GetMedian()\n{\nint size = minHeap.size() + maxHeap.size();\nif (size == 0)\nthrow exception( \"No numbers are available\" );\n\nT median = 0;\nif (size & 1 == 1)\nmedian = minHeap[0];\nelse\nmedian = (minHeap[0] + maxHeap[0]) / 2;\n\nreturn median;\n}\n\nprivate :\nvector<T> minHeap;\nvector<T> maxHeap;\n};\n\nIn the code above, function Insert is used to insert a new number deserialized from a stream, and GetMedian is used to get the median of the existing numbers dynamically.", "question": "\nQuestion: How to get the median from a stream of numbers at any time? The median is middle value of numbers. If the count of numbers is even, the median is defined as the average value of the two numbers in middle.\n"},
{"answer": "\nAnalysis: It is a classic interview questions to get numbers in Fibonacci sequences. We have different solutions for it, and their performance varies a lot.\n\nSolution 1: Inefficient recursive solution\n\nFibonacci sequences are taken as examples to lecture recursive functions in many C/C++ textbooks, so most of candidates are familiar with the recursive solution. They feel confident and delighted when they meet this problem during interviews, because the can write the following code in short time:\n\nlong long Fibonacci( unsigned int n)\n{\nif (n <= 0)\nreturn 0;\n\nif (n == 1)\nreturn 1;\n\nreturn Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n\nOur textbooks take Fibonacci sequences as examples for recursive functions does not necessarily mean that recursion is a good solution for Fibonacci sequences. Interviewers may tell candidates that the performance of this recursive solution is quite bad, and ask them to analyze root causes.\n\nLet us take f(10) as an example to analyze the recursive process. We have to get f(9) and f(8) before we get f(10). Meanwhile, f(8) and f(7) are needed before we get f(9). The dependency can be visualized in a tree as shown in Figure 1:\n\n\n\nIt is not difficult to notice that there are many duplicate nodes in the tree in Figure 1. The number of duplicated nodes increases dramatically when n increases. \u00a0Readers may have a try on the 100 th number if Fibonacci sequences to have intuitive ideas about how slow this recursive solution is.\n\nSolution 2: Practical Solution with O(n) efficiency\n\nIt is easy to optimize performance fortunately if we calculate from bottom. That is to say, we get f(2) based on f(0) and f(1), and get f(3) based on f(1) and f(2). We follow this pattern till we get f(n). It is obvious that its time complexity is O(n). Its corresponding code is shown below:\n\nlong long Fibonacci( unsigned n)\n{\nint result[2] = {0, 1};\nif (n < 2)\nreturn result[n];\n\nlong long fibNMinusOne = 1;\nlong long fibNMinusTwo = 0;\nlong long fibN = 0;\nfor ( unsigned int i = 2; i <= n; ++ i)\n{\nfibN = fibNMinusOne + fibNMinusTwo;\n\nfibNMinusTwo = fibNMinusOne;\nfibNMinusOne = fibN;\n}\n\nreturn fibN;\n}\n\nSolution 3: O( log n) solution\n\nUsually interviewers expect the O(n) solution above. However, there is an O( log n) solution available, which is based on an uncommon equation as shown below:\n\n\nIt is not difficult to prove this equation vithmathematical induction. Interested readers may have try.\n\nNow the only problem is how to calculate power of a matrix . We can calculate power with exponent n in O( log n) time with the following equation:\n\n\n\n\n\nThe source code to get power of a matrix looks complicated, which is listed below:\n\n#include <cassert>\n\nstruct Matrix2By2\n{\nMatrix2By2\n(\nlong long m00 = 0,\nlong long m01 = 0,\nlong long m10 = 0,\nlong long m11 = 0\n)\n:m_00(m00), m_01(m01), m_10(m10), m_11(m11)\n{\n}\n\nlong long m_00;\nlong long m_01;\nlong long m_10;\nlong long m_11;\n};\n\nMatrix2By2 MatrixMultiply\n(\nconst Matrix2By2& matrix1,\nconst Matrix2By2& matrix2\n)\n{\nreturn Matrix2By2(\nmatrix1.m_00 * matrix2.m_00 + matrix1.m_01 * matrix2.m_10,\nmatrix1.m_00 * matrix2.m_01 + matrix1.m_01 * matrix2.m_11,\nmatrix1.m_10 * matrix2.m_00 + matrix1.m_11 * matrix2.m_10,\nmatrix1.m_10 * matrix2.m_01 + matrix1.m_11 * matrix2.m_11);\n}\n\nMatrix2By2 MatrixPower( unsigned int n)\n{\nassert(n > 0);\n\nMatrix2By2 matrix;\nif (n == 1)\n{\nmatrix = Matrix2By2(1, 1, 1, 0);\n}\nelse if (n % 2 == 0)\n{\nmatrix = MatrixPower(n / 2);\nmatrix = MatrixMultiply(matrix, matrix);\n}\nelse if (n % 2 == 1)\n{\nmatrix = MatrixPower((n - 1) / 2);\nmatrix = MatrixMultiply(matrix, matrix);\nmatrix = MatrixMultiply(matrix, Matrix2By2(1, 1, 1, 0));\n}\n\nreturn matrix;\n}\n\nlong long Fibonacci( unsigned int n)\n{\nint result[2] = {0, 1};\nif (n < 2)\nreturn result[n];\n\nMatrix2By2 PowerNMinus2 = MatrixPower(n - 1);\nreturn PowerNMinus2.m_00;\n}\n\nEven though it cost only O( log n) time in theory, its hidden constant parameter is quite big, so it is not treated as a practical solution in real software development. Additionally, it is not a recommended solution during interviews since its implementation code is very complex.", "question": "\nProblem: Please implement a function which returns the n th number in Fibonacci sequences with an input n. Fibonacci sequence is defined as:\n\n\n\n"},
{"answer": "\nAnalysis: Lots of pointer operations are necessary to solve problems related to linked lists. Interviewers know that many candidates are prone to make mistakes on pointer operations, so they like problems of linked list to qualify candidates\u2019 programming abilities. During interviews, we had better analyze and design carefully rather than begin to code hastily. It is much better to write robust code with comprehensive analysis than write code quickly with many errors.\n\nDirection of pointers should be adjusted in order to reverse a linked list. We may utilize figures to analyze visually the complex steps to adjust pointers. As shown in the list in Figure 1-a, node h, i and j are three adjacent nodes. Let us assume pointers of all nodes prior to h have been reversed after some operations and all m_pNext point to their previous nodes. We are going to reverse the m_pNext pointer in node i. The status of list is shown in Figure 1-b.\n\n\nIt is noticeable that m_pNext in node i points to its previous node h, the list is broken and we cannot visit the node j anymore. We should save the node j before the m_pNext pointer of node i is adjusted to prevent the list becoming broken.\n\nWhen we adjust the pointer in node i, we need to access to node h since m_pNext of node i is adjusted to point to node h. Meanwhile, we also need to access to node j because it is necessary to save it otherwise the list will be broken. Therefore, three pointers should be declared in our code, which point to the current visited node, its previous node and its next node.\n\nLastly we should get the head node of the reversed list. Obviously head in the reversed list should be tail of the original list. Which pointer is tail? It should be a node whose m_pNext is NULL .\nWith comprehensive analysis above, we are ready to write code, which is shown below:\n\nListNode* ReverseList(ListNode* pHead)\n{\nListNode* pReversedHead = NULL;\nListNode* pNode = pHead;\nListNode* pPrev = NULL;\nwhile (pNode != NULL)\n{\nListNode* pNext = pNode->m_pNext;\n\nif (pNext == NULL)\npReversedHead = pNode;\n\npNode->m_pNext = pPrev;\n\npPrev = pNode;\npNode = pNext;\n}\n\nreturn pReversedHead;", "question": "\nProblem: Implement a function to reverse a linked list, and return the head of the reversed list. A list node is defined as below:\nstruct ListNode\n{\nint m_nKey;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: Path in a binary tree is a new concept for many candidates, so it is not a simple question for them. We may try to find the hidden rules with concrete examples. Let us take the binary tree in Figure 1 as an example.\n\nSince paths always start from a root node, we traverse from a root node in a binary tree. We have three traversal orders, pre-order, in-order and post-order, and we firstly visit a root node with pre-order traversal.\n\nAccording to the pre-order traversal process on the binary tree in Figure 1, we visit the node 5 after visiting the root node 10. Since a binary tree node does not have a pointer to its parent node, we do not know what nodes have been visited when we reach the node 5 if we do not save the visited node on the path. Therefore, we could insert the current node into a path when we reach it during traversal. The path contains two nodes with value 10 and 5 when we are visiting the node 5. Then we insert the node 4 into the path too when we reach it. We have reached a leaf node, and the sum of three nodes in the path is 19. Since it is not same as the input number 22, current path is not a qualified one.\nWe should continue to traverse other nodes. Before visiting other nodes, we should return back to the node 5, and then reach the node 7. It can be noticed that node 4 is no longer in the path from node 10 to node 7, so we should remove it from the path. When we are visiting node 7, we insert it into the path, which contains three nodes now. Since the sum of value of these three nodes is 22, the path is qualified.\n\nLastly we are going to visit the node 12. We should return back to node 5 then back to node 10 before we visit node 12. When we return back from a child node to its parent node, we remove the child node from the path. When we reach the node 12 eventually, the path contains two nodes, one is node 10 and the other is node 12. Since the sum of value of these two nodes is 22, the path is qualified too.\n\nWe can summarize the whole process above with the Table 1:\n\nStep Operation Is it a leaf? Path Sum of nodes value 1 Visit node 10 No node 10 10 2 Visit node 5 No node 10, node 5 15 3 Visit node 4 Yes node 10, node 5, node 4 19 4 Return to node 5 node 10, node 5 15 5 Visit node 7 Yes node 10, node 5, node 7 22 6 Return to node 5 node 10, node 5 15 7 Return to node 10 node 10 10 8 Visit node 12 Yes node 10, node 12 22\nStep\nOperation\nIs it a leaf?\nPath\nSum of nodes value\n1\nVisit node 10\nNo\nnode 10\n10\n2\nVisit node 5\nNo\nnode 10, node 5\n15\n3\nVisit node 4\nYes\nnode 10, node 5, node 4\n19\n4\nReturn to node 5\n\nnode 10, node 5\n15\n5\nVisit node 7\nYes\nnode 10, node 5, node 7\n22\n6\nReturn to node 5\n\nnode 10, node 5\n15\n7\nReturn to node 10\n\nnode 10\n10\n8\nVisit node 12\nYes\nnode 10, node 12\n22\nTable 1: The process to traverse the binary tree in Figure 1\n\nIt is time to summarize some rules with the example above. When we visit a node with pre-order traversal order, we insert it into the path, and accumulate its value to sum .\u00a0 When the node is a leaf and sum is same as the input number, the path is qualified and we need to print it. We continue to visit its children if the current node is not a leaf. After we finish visiting the current node, a recursive function will return back to its parent node automatically, so we should remove the current node from the path before a function returns to make sure the nodes in the path is same as the path from root node to its parent node. The data structure to save paths should be a stack, because paths should be consistent to the recursion status and recursion is essentially pushing and popping in a call stack.\nHere is some sample code for this problem:\n\nvoid FindPath(BinaryTreeNode* pRoot, int expectedSum)\n{\nif (pRoot == NULL)\nreturn ;\n\nstd::vector< int > path;\nint currentSum = 0;\nFindPath(pRoot, expectedSum, path, currentSum);\n}\n\nvoid FindPath\n(\nBinaryTreeNode*\u00a0\u00a0 pRoot,\nint expectedSum,\nstd::vector< int >&\u00a0path,\nint currentSum\n)\n{\ncurrentSum += pRoot->m_nValue;\npath.push_back(pRoot->m_nValue);\n\n// Print the path is the current node is a leaf\n// and the sum of all nodes value is same as expectedSum\nbool isLeaf = pRoot->m_pLeft == NULL && pRoot->m_pRight == NULL;\nif (currentSum == expectedSum && isLeaf)\n{\nprintf( \"A path is found: \" );\nstd::vector< int >::iterator iter = path.begin();\nfor (; iter != path.end(); ++ iter)\nprintf( \"%d\\t\" , *iter);\n\nprintf( \"\\n\" );\n}\n\n// If it is not a leaf, continue visition its children\nif (pRoot->m_pLeft != NULL)\nFindPath(pRoot->m_pLeft, expectedSum, path, currentSum);\nif (pRoot->m_pRight != NULL)\nFindPath(pRoot->m_pRight, expectedSum, path, currentSum);\n\n// Before returning back to its parent, remove it from path,\npath.pop_back();\n}\n\nIn the code above, we save path with a vector in STL actually. We use function push_back to insert a node and pop_back to remove a node to assure it is \u201cFirst in Last out\u201d in a path. The reason we don\u2019t utilize a stack in STL is that we can only get an element at the top of a stack, but we need to get all nodes when we print a path. Therefore, std::stack is not the best choice for us.", "question": "\nQuestion: All nodes along children pointers from root to leaf nodes form a path in a binary tree. Given a binary tree and a number, please print out all of paths where the sum of all nodes value is same as the given number. The node of binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n\nFor instance, if inputs are the binary tree in Figure 1 and a number 22, two paths with be printed: One is the path contains node 10 and 12, and the other contains 10, 5 and 7."},
{"answer": "\nAnalysis : An array has two ends, so each of the two stacks may grow from an end in the array. Figure 1 below shows the initial status of the array and two stacks (assuming the capacity of the array is 10).\nFigure 2: The status after three items are pushed into the first stack and two items are pushed into the second stack\n\ufeffNo more items can be pushed into stacks when two top items are adjacent to each other, because all space in the array has been occupied.\nOur solution can be implemented with the following C++ class: template < typename T, int capacity> class TwoStacks { public : TwoStacks() { topFirst = -1; topSecond = capacity; } T top( int stackIndex) { validateIndex(stackIndex); if (empty(stackIndex)) throw new exception( \"The stack is empty.\" ); if (stackIndex == 0) return items[topFirst]; return items[topSecond]; } void push( int stackIndex, T item) { validateIndex(stackIndex); if (full()) throw new exception( \"All space has been occupied.\" ); if (stackIndex == 0) items[++topFirst] = item; else items[--topSecond] = item; } void pop( int stackIndex) { validateIndex(stackIndex); if (empty(stackIndex)) throw new exception( \"The stack is empty.\" ); if (stackIndex == 0) --topFirst; else ++topSecond; } bool empty( int stackIndex) { if (stackIndex == 0 && topFirst == -1) return true ; if (stackIndex == 1 && topSecond == capacity) return true ; return false ; } private : bool full() { return (topFirst >= topSecond - 1); } void validateIndex( int stackIndex) { if (stackIndex < 0 || stackIndex > 1) throw new exception( \"Invalid Stack Index.\" ); } private : T items[capacity]; int topFirst; int topSecond; };\ntemplate < typename T, int capacity> class TwoStacks\n{\npublic :\nTwoStacks()\n{\ntopFirst = -1;\ntopSecond = capacity;\n}\n\nT top( int stackIndex)\n{\nvalidateIndex(stackIndex);\nif (empty(stackIndex))\nthrow new exception( \"The stack is empty.\" );\n\nif (stackIndex == 0)\nreturn items[topFirst];\nreturn items[topSecond];\n}\n\nvoid push( int stackIndex, T item)\n{\nvalidateIndex(stackIndex);\nif (full())\nthrow new exception( \"All space has been occupied.\" );\n\nif (stackIndex == 0)\nitems[++topFirst] = item;\nelse\nitems[--topSecond] = item;\n}\n\nvoid pop( int stackIndex)\n{\nvalidateIndex(stackIndex);\nif (empty(stackIndex))\nthrow new exception( \"The stack is empty.\" );\n\nif (stackIndex == 0)\n--topFirst;\nelse\n++topSecond;\n}\n\nbool empty( int stackIndex)\n{\nif (stackIndex == 0 && topFirst == -1)\nreturn true ;\nif (stackIndex == 1 && topSecond == capacity)\nreturn true ;\nreturn false ;\n}\n\nprivate :\nbool full()\n{\nreturn (topFirst >= topSecond - 1);\n}\n\nvoid validateIndex( int stackIndex)\n{\nif (stackIndex < 0 || stackIndex > 1)\nthrow new exception( \"Invalid Stack Index.\" );\n}\n\nprivate :\nT items[capacity];\nint topFirst;\nint topSecond;\n};\n\nAnalysis : An array only has two ends, so we need new strategies to implement more than two stacks in a single array.\nWe may implement the array like a list, where each item in the array has a link to another item. When an item has not been occupied by any stacks and it is available, it is linked to the next available item. When an item is pushed into a stack, it is linked to the previous item in the stack. That\u2019s to say, there are n + 1 list in total in the system if there are n stacks sharing an array, a list for the available space left in the array, and a list for each stack.\nLet\u2019s take three stacks sharing an array with capacity 10 as an example. Figure 3 shows the initial status for the array and stacks. Each item in the array has two blocks, one for item data and the other for the index of another block.\n\n\nAs shown in Figure 3, each item is linked to the next item (the link block of the i th item is i +1). The head of list for available items in the array points to the item at position 0, which is the Ava pointer in the figure. Since three stacks are empty, their top (Top1, Top2 and Top3 in the figure) are initialized as -1.\n\nLet\u2019s try to push an item a into the first stack. Currently the first available item is at the position 0, so we set its data block as a . The link block of the item is 1, which means the next available item is at the position 1, so we update the Ava pointer to the position 1. Additionally, the link block of the item at the position 1 should be updated to -1, the previous top index of the first stack. Lastly, we update to top index of the first stack to 0. The status of the array and stacks are shown in Figure 4.\nLet\u2019s push two more items b and c into the first stack. The operations are similar as before, and the status is shown in Figure 5.\nIn the next step we are going to push another d into the second stack. Most operations are similar as before. The link block in the item at the position 3 is updated to -1, since the second stack is empty before and its top index is -1 previously. And then the top index of the second stack is updated to 3. The status after adding d into the second stack is shown in Figure 6.\n\nIf we continue to push three more item e , f , and g into the second stack, the status is shown in Figure 7.\n\nAt this time we are going to pop an item from the first stack. Since the top index of the first stack is 2, the item to be popped off is at the position 2. The link value in that item is 1, which means the previous top in the first stack is at the position 1 in the array, so we update the top index of the first stack as 1. Now the item at the position 2 becomes available, it should be linked to the list for available items. We move the Ava pointer to 2, and then update the link value of the item at the position 2 as 7, which is the previous head position of the list for available items. The status is shown in Figure 8.\nIf we pop an item off the second stack, the item at the position 6 will be linked to the list for available items too. Figure 9 depicts the status after the related operations.\nIf we push h into the third stack, it will be placed into the item at the position 6 because Ava points to that item. The next available item is at the position 2 (the link value in the item at the position 6). Therefore, the head of the list for available items points to location 2, as shown in Figure 10.\nLet\u2019s continue to push four more items into the third stack, i , j , k , and l . The status after these four items are pushed is shown in Figure 11. At this time, there are two items in the first stack ( a and b ), three items in the second stack ( d , e and f ), and five items in the third stack ( h , i , j , k , and l ). Please note that items inside a stack are not necessarily adjacent.\nAfter l is pushed into the item at the position 9, the Ava pointer is update to -1 (the previous link value in the item at the position 9), which means all items in the array have been occupied by stacks. We can\u2019t push more items until some items are popped off.\nThe source code in C++ to implement stacks sharing an array is listed below:\n template < typename T, int capacity, int count> class Stacks\n {\n\npublic :\n\nStacks()\n\n{\n\nint i;\n         for (i = 0; i < capacity - 1; ++i)\n            items[i].link = i + 1;\n        items[i].link = -1;\n        emptyHead = 0;\n\n         for (i = 0; i < count; ++i)\n            stackHead[i] = -1;\n     }\n\n     T top( int stackIndex)\n     {\n         validateIndex(stackIndex);\n         if (empty(stackIndex))\n             throw new exception( \"The stack is empty.\" );\n\n         return items[stackHead[stackIndex]].data;\n     }\n\n     void push( int stackIndex, const T& item)\n     {\n        validateIndex(stackIndex);\n         if (full())\n             throw new exception( \"All space has been occupied.\" );\n\n        Item<T>& block = items[emptyHead];\n         int nextEmpty = block.link;\n\n        block.data = item;\n        block.link = stackHead[stackIndex];\n        stackHead[stackIndex] = emptyHead;\n\n        emptyHead = nextEmpty;\n     }\n\n     void pop( int stackIndex)\n     {\n        validateIndex(stackIndex);\n         if (empty(stackIndex))\n             throw new exception( \"The stack is empty.\" );\n\n         Item<T>& block =items[stackHead[stackIndex]];\n         int nextItem = block.link;\n\n        block.link = emptyHead;         emptyHead = stackHead[stackIndex];         stackHead[stackIndex] = nextItem;\n        block.link = emptyHead;         emptyHead = stackHead[stackIndex];\n     }\n\n     bool empty( int stackIndex)\n     {\n         return (stackHead[stackIndex] < 0);\n     }\n\n private :\n     void validateIndex( int stackIndex)\n     {\n         if (stackIndex < 0 || stackIndex >= count)\n             throw new exception( \"Invalid index of stack.\" );\n     }\n\n     bool full()\n     {\n         return (emptyHead < 0);\n     }\n\n private :\n     template < typename T> struct Item\n     {\n         Tdata;\n         int link;\n     };\n\n private :\n    Item<T> items[capacity];\n     int emptyHead;\n     int stackHead[count];\n };\n\n", "question": "\nProblem 2 : How can you implement n ( n > 2) stacks in a single array, where no stack overflows until no space left in the entire array space? Analysis : An array only has two ends, so we need new strategies to implement more than two stacks in a single array. We may implement the array like a list, where each item in the array has a link to another item. When an item has not been occupied by any stacks and it is available, it is linked to the next available item. When an item is pushed into a stack, it is linked to the previous item in the stack. That\u2019s to say, there are n + 1 list in total in the system if there are n stacks sharing an array, a list for the available space left in the array, and a list for each stack. Let\u2019s take three stacks sharing an array with capacity 10 as an example. Figure 3 shows the initial status for the array and stacks. Each item in the array has two blocks, one for item data and the other for the index of another block.\nProblem 2 : How can you implement n ( n > 2) stacks in a single array, where no stack overflows until no space left in the entire array space?"},
{"answer": "\nAnalysis: Firstly let\u2019s analyze this problem with the brute-force solution: All elements in the array are scanned one by one. When an element is scanned, we take is as A[ j ], and check whether there is a smaller element on its left side (A[ i ]), and a greater element on its right side (A[ k ]).\nSince it takes O( n ) time to scan numbers on two sides of each A[ j ], the overall time of this solution is O( n 2 ) on an array with n elements.\n\nSolution 1: O(n) time efficiency with O(n) space consumption\nAs our analysis above, for each element A[ j ], we need to know whether there is a smaller element on its left side. If there is not a smaller element on the left side, A[ j ] itself is the smallest of all elements from the leftmost element to A[ j ]. If there is a smaller element on the left side, the smallest of all elements from the leftmost element to A[ j ] is on the left side of A[ j ].\nTherefore, we could construct an auxiliary array B. The element B[ j ] stores the index of the smallest element of elements from the leftmost element to A[ j ]. The array B can be constructed based on elements in A from left to right.\nSimilarly, we could also construct another auxiliary array C. The element C[ j ] stores the index of the greatest element of elements from the rightmost element to A[ j ]. The array C can be constructed based on elements in A from right to left.\nWhen an element A[ j ] is scanned, the index j is compared with B[ j ] and C[ j ]. if B[ j ]< j (there is a smaller element on the left side) and j <C[ j ] (there is a greater element on the right side), three increasing elements have been found.\nThis solution can be implemented with the following C/C++ code:\n void increasingIndex_1( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     int * minIndex = new int [length];\n     int index = 0;\n    minIndex[0] = 0;\n     int t;\n     for (t = 1; t < length; ++t)\n     {\n         if (nums[t] < nums[index])\n            index = t;\n        minIndex[t] = index;\n     }\n\n     int * maxIndex = new int [length];\n     index =length - 1;\n     for (t = length - 1; t >= 0; --t)\n     {\n         if (nums[t] > nums[index])\n            index = t;\n        maxIndex[t] = index;\n     }\n\n     for (t = 1; t < length - 1; ++t)\n     {\n         if (minIndex[t] < t && maxIndex[t] > t)\n             break ;\n     }\n     if (t < length - 1)\n     {\n         *i =minIndex[t];\n         *j =t;\n         *k =maxIndex[t];\n     }\n     else\n     {\n         *i =*j = *k = -1;\n     }\n\n     delete [] minIndex;\n     delete [] maxIndex;\n }\n\nSolution 2: O(n) time efficiency with O(1) space consumption\nIn order to find an even more efficient solution, let\u2019s scan all elements in an array and try to find three increasing elements. The array {3, 2, 5, 1, 4, 7, 9, 6, 8} is taken as an example to simulate the process.\nAt first, all elements A[ i ], A[ j ], and A[ k ] have not been found, so three indexes i , j , and k are initialized as -1.\nThe number 3 is the first number to be scanned, and A[ i ] is updated as 3.\nThe next number to be scanned is the number 2. Notice that 2 is less than 3, and it is a better candidate of A[ i ]. The less A[ i ] is, the larger range A[ j ] and A[ k ] will have. Therefore, A[ i ] is updated as 2.\nLet\u2019s continue to scan the next number 5. Since 5 is greater the current A[ i ], it is a candidate of A[ j ]. A[ j ] is updated as 5.\nThe number 1 is scanned in the next round. Because 1 is less than the current A[ j ], it cannot be A[ k ]. Additionally, the number 1 is a candidate to be A[ i ] or A[ j ] in the future since it is less than the current A[ i ] and A[ j ]. However, neither A[ i ] nor A[ j ] can be updated as 1 at this time. If A[ i ] is updated as 1, A[ i ]<A[ j ] but i > j . If A[ j ] is updated as 1, A[ i ]>A[ j ]. Therefore, we store the number 1 into another variable named t .\nWe move on to scan the next number 4. Notice that the number 4 is less than A[ j ] again. At this time we have two numbers 1 (the stored variable t ) and 4, so we have a new pair of numbers to be A[ i ] and A[ j ]. A[ i ] and A[ j ] are updated as 1 and 4 respectively.\nThe next number, 7, is greater than the current A[ j ], so A[ k ] is updated as 7. The process terminates.\nThe following table summarizes the step-by-step analysis above:\nStep\nScanned Number\nA[ i ]\nA[ j ]\nA[ k ]\nt\nOperation\n1\n3\n3\n-1\n-1\n-1\nUpdate A[ i ]\n2\n2\n2\n-1\n-1\n-1\nUpdate A[ i ]\n3\n5\n2\n5\n-1\n-1\nUpdate A[ j ]\n4\n1\n2\n5\n-1\n1\nUpdate t\n5\n4\n1\n4\n-1\n-1\nUpdate A[ i ], A[ j ] and t\n6\n7\n1\n4\n7\n-1\nUpdate A[ k ]. Terminate.\nThe strategy of this solution is to store as less value to A[ i ] and A[ j ] as possible, in order to enlarge the value range for steps in the future.\nWith our step-by-step analysis, we could implement this solution with the following C++ code:\n void increasingIndex_2( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     *i = *j =*k = -1;\n     int backup = -1;\n\n     int index;\n     for (index = 0; index < length; ++index)\n     {\n         if (*i == -1)\n         {\n            *i = index;\n         }\n         else if (*j == -1)\n         {\n             if (nums[index] > nums[*i])\n                *j = index;\n             else\n                *i = index;\n         }\n         else if (nums[index]> nums[*j])\n         {\n            *k = index;\n             break ;\n         }\n         else if (nums[index]< nums[*j])\n         {\n             if (backup != -1)\n             {\n                 if (nums[index] > nums[backup])\n                {\n                    *i = backup;\n                    *j = index;\n                    backup = -1;\n                }\n                 else if (nums[index] < nums[backup])\n                {\n                    backup = index;\n                }\n             }\n             else if (nums[index]< nums[*j])\n                backup = index;\n         }\n     }\n     if (index == length)\n         *i =*j = *k = -1;\n }\n", "question": "\nProblem: Given an array of integers A, please find three indexes i , j , k , such that i < j < k and A[ i ]<A[ j ]<A[ k ].\n"},
{"answer": "", "question": ""},
{"answer": "\nAnalysis: This is a typical problem which can be solved by dynamic programming. We have two strategies to analyze and solve this problem\n\nSolution 1: Split at any space between two characters\n\nGiven a substring of str , starting from the index i and ending at the index j (denoted as str [ i : j ]), we define a function f ( i , j ) to denote the minimal number of splits to partition the substring str [ i : j ] into a set of palindromes. If the substring is a palindrome itself, we don\u2019t have to split so f ( i , j ) is 0. If the substring is not a palindrome, the substring is split between two characters k and k +1. f ( i , j )= f ( i , k )+ f ( k +1, j )+1 under such conditions. Therefore, f ( i , j ) can be defined with the following equation:\n\n\nThe value of f (0, n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nIf the equation is calculated recursively, its complexity grows exponentially with the length n . A better choice is to calculate in bottom-up order with a 2D matrix with size n \u00d7 n . The following C++ code implements this solution:\n\n int minSplit_1( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length * length];\n    \n     for ( int i = 0; i <length; ++i)\n        split[i * length + i] = 0;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         for ( int j = length -i; j > 0; --j)\n         {\n             int row = length - i - j;\n             int col = row + i;\n             if (isPalindrome(str, row, col))\n             {\n                split[row * length + col] = 0;\n             }\n             else\n             {\n                 int min = 0x7FFFFFFF;\n                 for ( int k = row; k < col; ++k)\n                {\n                     int temp1 = split[row * length + k];\n                     int temp2 = split[(k + 1) * length +col];\n                     if (min> temp1 + temp2 + 1)\n                         min = temp1 + temp2 +1;\n                }\n                split[row * length + col] = min;\n             }\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nSolution 2: Split only before a palindrome\n\nWe split the string str with another strategy. Given a substring ending at the index i , str [0, i], we do not have to split if the substring is a palindrome itself. Otherwise it is split between two characters at index j and j +1 only if the substring str [ j +1, i ] is a palindrome. Therefore, an equation f ( i ) can be defined as the following:\n\n\nThe value of f ( n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nWe could utilize a 1D array to solve this equation in bottom-up order, as listed in the following code:\n\n int minSplit_2( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length];\n     for ( int i = 0; i <length; ++i)\n        split[i] = i;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         if (isPalindrome(str, 0, i))\n         {\n            split[i] = 0;\n             continue ;\n         }\n\n         for ( int j = 0; j <i; ++j)\n         {\n             if (isPalindrome(str, j + 1, i) && split[i]> split[j] + 1)\n                split[i] = split[j] + 1;\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nOptimization to verify palindromes:\n\nUsually it costs O( n ) time to check whether a string with length n is a palindrome, and the typical implementation looks like the following code:\n\n bool isPalindrome( const string& str, int begin, int end)\n {\n     for ( int i = begin; i< end - (i - begin); ++i)\n     {\n         if (str[i] != str[end - (i - begin)])\n             return false ;\n     }\n\n     return true ;\n }\n\nBoth solutions above cost O( n 3 ) time. The first solution contains three nesting for-loops. The function isPalindrome is inside two nesting for-loops.\n\nIf we could reduce the cost of isPalindrome to O(1), the time complexity of the second solution would be O( n 2 ).\n\nNotice that the substring str [ i , j ] is a palindrome only if the characters at index i and j , and str [ i +1, j -1] is also a palindrome. We could build a 2D table accordingly to store whether every substring of str is a palindrome or not during the preprocessing. With such a table, the function isPalindrome can verify the substring str [ i , j ] in O(1) time.\n\n", "question": "\nProblem: A string can be partitioned into some substrings, such that each substring is a palindrome. For example, there are a few strategies to split the string \u201cabbab\u201d into palindrome substrings, such as: \u201cabba\u201d|\u201db\u201d, \u201ca\u201d|\u201db\u201d|\u201dbab\u201d and \u201ca\u201d|\u201dbb\u201d|\u201da\u201d|\u201db\u201d.\n\nGiven a string str , please get the minimal numbers of splits to partition it into palindromes. The minimal number of splits to partition the string \u201cabbab\u201d into a set of palindromes is 1.\n"},
{"answer": "\nAnalysis: A function f ( i ) is defined to denote the maximal stolen value from the first house to the i th house, and the value contained in the i th house is denoted as v i . When the thief reaches the i th house, he has two choices: to steal or not. Therefore, f ( i ) can be defined with the following equation:\n\nIt would be much more efficient to calculate in bottom-up order than to calculate recursively. It looks like a 1D array with size n is needed, but actually it is only necessary to cache two values for f ( i -1) and f ( i -2) to calculate f ( i ).\n\n\nThis algorithm can be implemented with the following C++ code:\n\n int maxStolenValue( const vector< int >& values)\n {\n     int length = values.size();\n     if (length == 0)\n         return 0;\n\n     int value1 = values[0];\n     if (length == 1)\n         return value1;\n\n     int value2 = max< int >(values[0],values[1]);\n     if (length == 2)\n         return value2;\n\n     int value;\n     for ( int i = 2; i <length; ++i)\n     {\n         value= max< int >(value2, value1 + values[i]);\n        value1 = value2;\n        value2 = value;\n     }\n\n     return value;\n }\n\n", "question": "\nProblem: There are n houses built in a line, each of which contains some value in it. A thief is going to steal the maximal value in these houses, but he cannot steal in two adjacent houses because the owner of a stolen house will tell his two neighbors on the left and right side. What is the maximal stolen value?\n\nFor example, if there are four houses with values {6, 1, 2, 7}, the maximal stolen value is 13 when the first and fourth houses are stolen.\n"},
{"answer": "\nAnalysis: In a list with n nodes, its k th node from end should be the (n-k+1) th node from its head. Therefore, if we know the number of nodes n in a list, we can get the required node with n-k+1 steps from its head. How to get the number n? It is easy if we scan the whole list from beginning to end.\n\nThe solution above needs to scan a list twice: We get the total number of nodes with the first scan, and reach the k th node from end with the second scan. Unfortunately, interviewers usually expect a solution which only scans a list once.\n\nWe have a better solution to get the k th node from end with two pointers. Firstly we move a pointer (denoted as P1) k-1 steps beginning from the head of a list. And then we move another pointer (denoted as P2) beginning from the head, and continue moving the P1 forward at same speed. Since the distance of these two pointers is always k-1, P2 reaches the k th node from end when P1 reaches the tail of a list. It scans a list only once, and it is more efficient than the previous solution.\n\n\n\nFigure 1: Get the 3 rd node from end of a list with 6 nodes\n\nIt simulates the process to get the 3 rd node from end of a list with 6 nodes in Figure 1. We firstly move P1 2 steps (2=3-1) to reach the 3 rd node (Figure 1-a). Then P2 points to the head of a list (Figure 1-b). We move two pointers at the same speed, when the P1 reaches the tail, what P2 points is the 3 rd node from end (Figure 1-c).\n\nThe sample code of the solutions with two pointers is shown below:\n\nListNode* FindKthToTail(ListNode* pListHead, unsigned int k)\n{\nif (pListHead == NULL || k == 0)\nreturn NULL;\n\nListNode *pAhead = pListHead;\nListNode *pBehind = NULL;\n\nfor ( unsigned int i = 0; i < k - 1; ++ i)\n{\nif (pAhead->m_pNext != NULL)\npAhead = pAhead->m_pNext;\nelse\n{\nreturn NULL;\n}\n}\n\npBehind = pListHead;\nwhile (pAhead->m_pNext != NULL)\n{\npAhead = pAhead->m_pNext;\npBehind = pBehind->m_pNext;\n}\n\nreturn pBehind;", "question": "\nProblem: Get the K th node from end of a linked list. It counts from 1 here, so the 1 st node from end is the tail of list.\n\nFor instance, given a linked list with 6 nodes, whose value are 1, 2, 3, 4, 5, 6, its 3 rd node from end is the node with value 4.\n\nA node in the list is defined as:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: It is a typical problem about backtracking, which can be solved by storing a path into a stack.\n\nFirstly, it is necessary to define a structure for 2-D positions, as below:\n\nstruct Position\n{\nint x;\nint y;\n};\n\nThe movements of four directions can be defined accordingly:\n\nPosition up = {0, -1};\nPosition right = {1, 0};\nPosition down = {0, 1};\nPosition left = {-1, 0};\nPosition dir[] ={up, right, down, left};\n\nSince paths can start from any entry in a matrix, we have to scan every cell to check whether the character in it is identical to the first character of the string. If it is identical, we begin to explore a path from such a cell.\n\nA path is defined as a stack. When a cell on path is found, we push its position into the stack. Additionally, we also define a matrix of Boolean masks to void entering a cell twice, which is denoted as visited . Based on these considerations, the skeleton of solution can be implemented as the following:\n\nbool hasPath( char * matrix, int rows, int cols, char * str)\n{\nif (matrix == NULL || rows < 1 || cols < 1 || str == NULL)\nreturn false ;\n\nbool *visited = new bool [rows * cols];\nmemset(visited, 0, rows * cols);\n\nfor ( int row = 0; row < rows; ++row)\n{\nfor ( int column = 0; column < cols; ++column)\n{\nif (matrix[row * cols + column] != str[0])\ncontinue ;\n\nstd::stack<Position> path;\nPosition position = {column, row};\npath.push(position);\nvisited[row * cols + column] = true ;\n\nif (hasPathCore(matrix, rows, cols, str, path, visited))\nreturn true ;\n}\n}\n\nreturn false ;\n}\n\nNow let us analyze how to explore a path in details. Supposing we have already found k characters on a path, and we are going to explore the next step. We stand at the cell corresponding to the k th character of the path, and check whether the character in its neighboring cell at up, right, down, and left side is identical to the ( k +1) th character of the string.\n\nIf there is a neighboring cell whose value is identical to the ( k +1) th character of the string, we continue exploring the next step.\n\nIf there is no such a neighboring cell whose value is identical to the ( k +1) th character of the string, it means the cell corresponding to the k th character should not on a path. Therefore, we pop it off a path, and start to explore other directions on the ( k -1) th character.\n\nBased on the analysis above, the function hasPathCore can be defined as:\n\nbool hasPathCore( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited)\n{\nif (str[path.size()] == '\\0' )\nreturn true ;\n\nif (getNext(matrix, rows, cols, str, path, visited, 0))\nreturn hasPathCore(matrix, rows, cols, str, path, visited);\n\nbool hasNext = popAndGetNext(matrix, rows, cols, str, path, visited);\nwhile (!hasNext && !path.empty())\nhasNext = popAndGetNext(matrix, rows, cols, str, path, visited);\n\nif (!path.empty())\nreturn hasPathCore(matrix, rows, cols, str, path, visited);\n\nreturn false ;\n}\n\nThe function getNext is defined to explore the ( k +1) th character on a path. When it returns true , it means the ( k +1) th character on a path has been found. Otherwise, we have to pop the k th character off. The function getNext is implemented as below:\n\nbool getNext( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited, int start)\n{\nfor ( int i = start; i < sizeof (dir) / sizeof (Position); ++i)\n{\nPosition next = {path.top().x + dir[i].x, path.top().y + dir[i].y};\nif (next.x >= 0 && next.x < cols\n&& next.y >=0 && next.y < rows\n&& matrix[next.y * cols + next.x] == str[path.size()]\n&& !visited[next.y * cols + next.x])\n{\npath.push(next);\nvisited[next.y * cols + next.x] = true ;\n\nreturn true ;\n}\n}\n\nreturn false ;\n}\n\nWhen we found that the k th character should not be on a path, we call the function popAndGetNext to pop it off, and try on other directions from the ( k -1) th character. This function is implemented as below:\n\nbool popAndGetNext( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited)\n{\nPosition toBePoped = path.top();\npath.pop();\nvisited[toBePoped.y * cols + toBePoped.x] = false ;\n\nbool hasNext = false ;\nif (path.size() >= 1)\n{\nPosition previous = path.top();\nint deltaX = toBePoped.x - previous.x;\nint deltaY = toBePoped.y - previous.y;\nfor ( int i = 0; (i < sizeof (dir) / sizeof (Position) && !hasNext); ++i)\n{\nif (deltaX != dir[i].x || deltaY != dir[i].y)\ncontinue ;\n\nhasNext = getNext(matrix, rows, cols, str, path, visited, i + 1);\n}\n}\n\nreturn hasNext;", "question": "\nQuestion: How to implement a function to check whether there is a path for a string in a matrix of characters?\u00a0 It moves to left, right, up and down in a matrix, and a cell for a movement. The path can start from any entry in a matrix. If a cell is occupied by a character of a string on the path, it cannot be occupied by another character again.\n\nFor example, the matrix below with three rows and four columns has a path for the string \u201cBCCED\u201d (as highlighted in the matrix). It does not have a path for the string \u201cABCB\u201d, because the first \u201cB\u201d in the string occupies the \u201cB\u201d cell in the matrix, and the second \u201cB\u201d in the string cannot enter into the same cell again.\n\nA\nB\nC\nE\nS\nF\nC\nS\nA\nD\nE\nE\n"},
{"answer": "", "question": ""},
{"answer": "", "question": ""},
{"answer": "", "question": ""},
{"answer": "", "question": ""},
{"answer": "", "question": ""},
{"answer": "", "question": ""},
{"answer": "\nAnalysis: We are going to introduce two solutions for this problem here, one is classic and quite intuitive and the other is very creative.\n\nSolution 1: Simulate a circle with a looped linked list\n\nBecause a circle is mentioned in the problem, an intuitive solution is to simulate a circle with some data structures. Looped linked can fulfill such a purpose. We may create a looped list with n nodes, and then delete the m th node at every time from it.\n\nWe can implement the looped list based on the std::list in the C++ standard template library. It should be noticed that std::list itself is not looped. When an iterator reaches end of a list, we need to reset it to its head. It behaves like a circle with such a little trick. The sample source code of this solution is shown below:\n\nint LastRemaining( unsigned int n, unsigned int m)\n{\nif (n < 1 || m < 1)\nreturn -1;\n\nunsigned int i = 0;\n\nlist< int > numbers;\nfor (i = 0; i < n; ++ i)\nnumbers.push_back(i);\n\nlist< int >::iterator current = numbers.begin();\nwhile (numbers.size() > 1)\n{\nfor ( int i = 1; i < m; ++ i)\n{\ncurrent ++;\nif (current == numbers.end())\ncurrent = numbers.begin();\n}\n\nlist< int >::iterator next = ++ current;\nif (next == numbers.end())\nnext = numbers.begin();\n\n-- current;\nnumbers.erase(current);\ncurrent = next;\n}\n\nreturn *(current);\n}\n\nIf we analyze the code above carefully, we can notice that a looped list is scanned for many times. Of cause, repeatedly scanning has negative impacts on time efficiency. In this solution, traversal with m steps are necessary to delete a node, so the time complexity is O(mn) for a looped list. Meanwhile, it requires a list with n nodes to simulate a circle, so the space complexity is O(n).\n\nSolution 2: Analyze the pattern of deleted numbers\n\nFirstly, let us define a function f(n, m), which stands for the last remaining number in a circle which has n numbers 0, 1, \u2026, n-1 and the m th number is deleted at each time.\n\nThe first deleted number in the circle is (m-1)%n, which is denoted as k for simplicity. The n-1 numbers after k is deleted are 0, 1, \u2026, k-1, k+1, \u2026, n-1. The last remaining number is also a function about n and m. The pattern of new sequence is different from the pattern of the original sequence, which begins with 0, so the function differs from the function f, which can be denoted as f\u2019(n-1, m). The last remaining number of the original sequence should be the last remaining number of the sequence deleting k, so f(n, m)=f\u2019(n-1, m).\n\nSince we count the next m th number from k+1, the sequence might be also viewed as k+1, \u2026, n-1, 0, 1, \u2026, k-1. We project this sequence of numbers into a new sequence in range of 0 and n-2:\n\nk+1\n\u2192\n0\nk+2\n\u2192\n1\n\u2026\n\n\nn-1\n\u2192\nn-k-2\n0\n\u2192\nn-k-1\n1\n\u2192\nn-k\n\u2026\n\n\nk-1\n\u2192\nn-2\nIf the projection is denoted as p, p(x)=(x-k-1%n, and the reversed projection is p -1 (x)=(x+k+1)%n.\nThe projected sequence has the same format as the original sequence because they both begin from 0. Therefore, its last remaining number is the projected sequence also follows rules of function f. We denoted as f(n-1, m).\n\nThe last remaining number of the sequence before projection is f\u2019(n-1, m)= p -1 [f(n-1, m)]=[f(n-1, m)+k+1]%n. Since k=(m-1)%n, f(n, m )=f\u2019(n-1,m)=[f(n-1, m)+m]%n.\n\nA recursive equation is found after complex analysis. We can get last remaining number in a list with n numbers based on the last remaining number in a list with n-1 numbers. When n=1 (there is only one number 0 in the list), the last remaining number is obviously 0. The rules can be summarized as:\n\n\nThe equation can be implemented based on both recursion and iteration. The following code is based on iteration:\n\nint LastRemaining( unsigned int n, unsigned int m)\n{\nif (n < 1 || m < 1)\nreturn -1;\n\nint last = 0;\nfor ( int i = 2; i <= n; i ++)\nlast = (last + m) % i;\n\nreturn last;\n}\n\nEven though the analysis is quite complex, its corresponding code is very simple. That is beauty of mathematics. More importantly, its time complexity is O(n) and space complexity is O(1), so it is much better than the first solution in both time and memory efficiency.", "question": "\nProblem: If we delete the m th number from a circle which is composed of numbers 0, 1, \u2026, n-1 counting from 0 at every time, what is the last number?\n\nFor example, a circle is composed of five numbers 0, 1, 2, 3, 4 as shown in Figure 1. If we delete the 3 rd number at every time, the deleted numbers are in order of 2, 0, 4, 1, so the last remaining number is 3."},
{"answer": "\nAnalysis: This problem is not meaningful during software development since usually we do not have such rigorous limitations. However, many interviewers believe that it is useful to test candidates\u2019 ability of divergent thinking. Ability of divergent thinking reflects the depth and width of programming understanding.\n\nBesides equation n(n+1)/2 to get 1+2+\u2026+n, we only have two approaches: Iteration and recursion. Since key words for and while are forbidden, we cannot utilize iteration directly any more. In a recursive function, we need to use key word if or conditional operators to check whether we should continue or stop recursion. Unfortunately, both of them are also forbidden.\n\nSolution 1: Based on Constructors\n\nLet us firstly focus on iterations. An iteration is actually only to repeat n times, and we can achieve it without key words for and while . We can define a class, and then create n instances of it. Therefore, its constructor and destructor will be definitely called n times. If we implement calculation operations inside the constructor, it will iterate for n times. The following code is based on this solution:\n\nclass Temp\n{\npublic :\nTemp() { ++ N; Sum += N; }\n\nstatic void Reset() { N = 0; Sum = 0; }\nstatic unsigned int GetSum() { return Sum; }\n\nprivate :\nstatic unsigned int N;\nstatic unsigned int Sum;\n};\n\nunsigned int Temp::N = 0;\nunsigned int Temp::Sum = 0;\n\nunsigned int Sum_Solution1( unsigned int n)\n{\nTemp::Reset();\n\nTemp *a = new Temp[n];\ndelete []a;\na = NULL;\n\nreturn Temp::GetSum();\n}\n\nSolution 2: Based on Virtual Functions\n\nWe secondly focus on recursion. We cannot determine to continue or stop recursion inside a single function. How about to define two functions, one for normal operations and the other as a terminator? We may use Boolean variables since we are going to select a function out of two. When the Boolean variable is true (1), the operational function will be selected. When it is false (0), the terminal function will be selected.\n\nWe have to convert integer variables into Boolean variables. It is an easy task since it can be achieved with two not operations (!!n). Non-zero numbers will be true with two not operations and zero will be false .\n\nclass A;\nA* Array[2];\n\nclass A\n{\npublic :\nvirtual unsigned int Sum ( unsigned int n)\n{\nreturn 0;\n}\n};\n\nclass B: public A\n{\npublic :\nvirtual unsigned int Sum ( unsigned int n)\n{\nreturn Array[!!n]->Sum(n-1) + n;\n}\n};\n\nint Sum_Solution2( int n)\n{\nA a;\nB b;\nArray[0] = &a;\nArray[1] = &b;\n\nint value = Array[1]->Sum(n);\n\nreturn value;\n}\n\nThis solution is based on virtual functions. The function B::Sum is called when variable n is not zero, while the function A::Sum , which acts as a terminator, is called when n equals to zero.\n\nSolution 3: Based on Function Pointers\n\nThere are no virtual functions in native C programming environment, so we have to simulate them with function pointers. The code below may be more straightforward:\ntypedef unsigned int (*fun)( unsigned int );\n\nunsigned int Solution3_Teminator( unsigned int n)\n{\nreturn 0;\n}\n\nunsigned int Sum_Solution3( unsigned int n)\n{\nstatic fun f[2] = {Solution3_Teminator, Sum_Solution3};\nreturn n + f[!!n](n - 1);\n}\n\nSolution 4: Based on Template Classes\n\nWe can also utilize compiler to simulate recursive calculate. Let us have a look at the following code:\ntemplate < unsigned int n> struct Sum_Solution4\n{\nenum Value { N = Sum_Solution4<n - 1>::N + n};\n};\n\ntemplate <> struct Sum_Solution4<1>\n{\nenum Value { N = 1};\n};\n\nThe value of Sum_Solution4<100>::N is the result of 1+2+\u2026+100. When compilers see Sum_Solution4<100> , it will generate code for the template class Sum_Solution4 with parameter 100. A class Sum _S olution4 <99> is needed to generate the class Sum_Solution4<100> since Sum _Solution4<100>::N= Sum _Solution4 <99>::N+100 . The recursive process stops when it reaches the Sum_Solution4<1> because it has been defined explicitly.\n", "question": "\nProblem: Calculate 1+2+\u2026+n without multiplication, division, key words for , while , if , else , switch , case , as well as conditional operator (A ? B : C).\n"},
{"answer": "\nAnalysis: It is a classic interview questions to get numbers in Fibonacci sequences. We have different solutions for it, and their performance varies a lot.\n\nSolution 1: Inefficient recursive solution\n\nFibonacci sequences are taken as examples to lecture recursive functions in many C/C++ textbooks, so most of candidates are familiar with the recursive solution. They feel confident and delighted when they meet this problem during interviews, because the can write the following code in short time:\n\nlong long Fibonacci( unsigned int n)\n{\nif (n <= 0)\nreturn 0;\n\nif (n == 1)\nreturn 1;\n\nreturn Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n\nOur textbooks take Fibonacci sequences as examples for recursive functions does not necessarily mean that recursion is a good solution for Fibonacci sequences. Interviewers may tell candidates that the performance of this recursive solution is quite bad, and ask them to analyze root causes.\n\nLet us take f(10) as an example to analyze the recursive process. We have to get f(9) and f(8) before we get f(10). Meanwhile, f(8) and f(7) are needed before we get f(9). The dependency can be visualized in a tree as shown in Figure 1:\n\n\n\nIt is not difficult to notice that there are many duplicate nodes in the tree in Figure 1. The number of duplicated nodes increases dramatically when n increases. \u00a0Readers may have a try on the 100 th number if Fibonacci sequences to have intuitive ideas about how slow this recursive solution is.\n\nSolution 2: Practical Solution with O(n) efficiency\n\nIt is easy to optimize performance fortunately if we calculate from bottom. That is to say, we get f(2) based on f(0) and f(1), and get f(3) based on f(1) and f(2). We follow this pattern till we get f(n). It is obvious that its time complexity is O(n). Its corresponding code is shown below:\n\nlong long Fibonacci( unsigned n)\n{\nint result[2] = {0, 1};\nif (n < 2)\nreturn result[n];\n\nlong long fibNMinusOne = 1;\nlong long fibNMinusTwo = 0;\nlong long fibN = 0;\nfor ( unsigned int i = 2; i <= n; ++ i)\n{\nfibN = fibNMinusOne + fibNMinusTwo;\n\nfibNMinusTwo = fibNMinusOne;\nfibNMinusOne = fibN;\n}\n\nreturn fibN;\n}\n\nSolution 3: O( log n) solution\n\nUsually interviewers expect the O(n) solution above. However, there is an O( log n) solution available, which is based on an uncommon equation as shown below:\n\n\nIt is not difficult to prove this equation vithmathematical induction. Interested readers may have try.\n\nNow the only problem is how to calculate power of a matrix . We can calculate power with exponent n in O( log n) time with the following equation:\n\n\n\n\n\nThe source code to get power of a matrix looks complicated, which is listed below:\n\n#include <cassert>\n\nstruct Matrix2By2\n{\nMatrix2By2\n(\nlong long m00 = 0,\nlong long m01 = 0,\nlong long m10 = 0,\nlong long m11 = 0\n)\n:m_00(m00), m_01(m01), m_10(m10), m_11(m11)\n{\n}\n\nlong long m_00;\nlong long m_01;\nlong long m_10;\nlong long m_11;\n};\n\nMatrix2By2 MatrixMultiply\n(\nconst Matrix2By2& matrix1,\nconst Matrix2By2& matrix2\n)\n{\nreturn Matrix2By2(\nmatrix1.m_00 * matrix2.m_00 + matrix1.m_01 * matrix2.m_10,\nmatrix1.m_00 * matrix2.m_01 + matrix1.m_01 * matrix2.m_11,\nmatrix1.m_10 * matrix2.m_00 + matrix1.m_11 * matrix2.m_10,\nmatrix1.m_10 * matrix2.m_01 + matrix1.m_11 * matrix2.m_11);\n}\n\nMatrix2By2 MatrixPower( unsigned int n)\n{\nassert(n > 0);\n\nMatrix2By2 matrix;\nif (n == 1)\n{\nmatrix = Matrix2By2(1, 1, 1, 0);\n}\nelse if (n % 2 == 0)\n{\nmatrix = MatrixPower(n / 2);\nmatrix = MatrixMultiply(matrix, matrix);\n}\nelse if (n % 2 == 1)\n{\nmatrix = MatrixPower((n - 1) / 2);\nmatrix = MatrixMultiply(matrix, matrix);\nmatrix = MatrixMultiply(matrix, Matrix2By2(1, 1, 1, 0));\n}\n\nreturn matrix;\n}\n\nlong long Fibonacci( unsigned int n)\n{\nint result[2] = {0, 1};\nif (n < 2)\nreturn result[n];\n\nMatrix2By2 PowerNMinus2 = MatrixPower(n - 1);\nreturn PowerNMinus2.m_00;\n}\n\nEven though it cost only O( log n) time in theory, its hidden constant parameter is quite big, so it is not treated as a practical solution in real software development. Additionally, it is not a recommended solution during interviews since its implementation code is very complex.", "question": "\nProblem: Please implement a function which returns the n th number in Fibonacci sequences with an input n. Fibonacci sequence is defined as:\n\n\n\n"},
{"answer": "\nAnalysis: It is a classic interview questions to get numbers in Fibonacci sequences. We have different solutions for it, and their performance varies a lot.\n\nSolution 1: Inefficient recursive solution\n\nFibonacci sequences are taken as examples to lecture recursive functions in many C/C++ textbooks, so most of candidates are familiar with the recursive solution. They feel confident and delighted when they meet this problem during interviews, because the can write the following code in short time:\n\nlong long Fibonacci( unsigned int n)\n{\nif (n <= 0)\nreturn 0;\n\nif (n == 1)\nreturn 1;\n\nreturn Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n\nOur textbooks take Fibonacci sequences as examples for recursive functions does not necessarily mean that recursion is a good solution for Fibonacci sequences. Interviewers may tell candidates that the performance of this recursive solution is quite bad, and ask them to analyze root causes.\n\nLet us take f(10) as an example to analyze the recursive process. We have to get f(9) and f(8) before we get f(10). Meanwhile, f(8) and f(7) are needed before we get f(9). The dependency can be visualized in a tree as shown in Figure 1:\n\n\n\nIt is not difficult to notice that there are many duplicate nodes in the tree in Figure 1. The number of duplicated nodes increases dramatically when n increases. \u00a0Readers may have a try on the 100 th number if Fibonacci sequences to have intuitive ideas about how slow this recursive solution is.\n\nSolution 2: Practical Solution with O(n) efficiency\n\nIt is easy to optimize performance fortunately if we calculate from bottom. That is to say, we get f(2) based on f(0) and f(1), and get f(3) based on f(1) and f(2). We follow this pattern till we get f(n). It is obvious that its time complexity is O(n). Its corresponding code is shown below:\n\nlong long Fibonacci( unsigned n)\n{\nint result[2] = {0, 1};\nif (n < 2)\nreturn result[n];\n\nlong long fibNMinusOne = 1;\nlong long fibNMinusTwo = 0;\nlong long fibN = 0;\nfor ( unsigned int i = 2; i <= n; ++ i)\n{\nfibN = fibNMinusOne + fibNMinusTwo;\n\nfibNMinusTwo = fibNMinusOne;\nfibNMinusOne = fibN;\n}\n\nreturn fibN;\n}\n\nSolution 3: O( log n) solution\n\nUsually interviewers expect the O(n) solution above. However, there is an O( log n) solution available, which is based on an uncommon equation as shown below:\n\n\nIt is not difficult to prove this equation vithmathematical induction. Interested readers may have try.\n\nNow the only problem is how to calculate power of a matrix . We can calculate power with exponent n in O( log n) time with the following equation:\n\n\n\n\n\nThe source code to get power of a matrix looks complicated, which is listed below:\n\n#include <cassert>\n\nstruct Matrix2By2\n{\nMatrix2By2\n(\nlong long m00 = 0,\nlong long m01 = 0,\nlong long m10 = 0,\nlong long m11 = 0\n)\n:m_00(m00), m_01(m01), m_10(m10), m_11(m11)\n{\n}\n\nlong long m_00;\nlong long m_01;\nlong long m_10;\nlong long m_11;\n};\n\nMatrix2By2 MatrixMultiply\n(\nconst Matrix2By2& matrix1,\nconst Matrix2By2& matrix2\n)\n{\nreturn Matrix2By2(\nmatrix1.m_00 * matrix2.m_00 + matrix1.m_01 * matrix2.m_10,\nmatrix1.m_00 * matrix2.m_01 + matrix1.m_01 * matrix2.m_11,\nmatrix1.m_10 * matrix2.m_00 + matrix1.m_11 * matrix2.m_10,\nmatrix1.m_10 * matrix2.m_01 + matrix1.m_11 * matrix2.m_11);\n}\n\nMatrix2By2 MatrixPower( unsigned int n)\n{\nassert(n > 0);\n\nMatrix2By2 matrix;\nif (n == 1)\n{\nmatrix = Matrix2By2(1, 1, 1, 0);\n}\nelse if (n % 2 == 0)\n{\nmatrix = MatrixPower(n / 2);\nmatrix = MatrixMultiply(matrix, matrix);\n}\nelse if (n % 2 == 1)\n{\nmatrix = MatrixPower((n - 1) / 2);\nmatrix = MatrixMultiply(matrix, matrix);\nmatrix = MatrixMultiply(matrix, Matrix2By2(1, 1, 1, 0));\n}\n\nreturn matrix;\n}\n\nlong long Fibonacci( unsigned int n)\n{\nint result[2] = {0, 1};\nif (n < 2)\nreturn result[n];\n\nMatrix2By2 PowerNMinus2 = MatrixPower(n - 1);\nreturn PowerNMinus2.m_00;\n}\n\nEven though it cost only O( log n) time in theory, its hidden constant parameter is quite big, so it is not treated as a practical solution in real software development. Additionally, it is not a recommended solution during interviews since its implementation code is very complex.", "question": "\nProblem: Please implement a function which returns the n th number in Fibonacci sequences with an input n. Fibonacci sequence is defined as:\n\n\n\n"},
{"answer": "\nAnalysis: It is a classic interview questions to get numbers in Fibonacci sequences. We have different solutions for it, and their performance varies a lot.\n\nSolution 1: Inefficient recursive solution\n\nFibonacci sequences are taken as examples to lecture recursive functions in many C/C++ textbooks, so most of candidates are familiar with the recursive solution. They feel confident and delighted when they meet this problem during interviews, because the can write the following code in short time:\n\nlong long Fibonacci( unsigned int n)\n{\nif (n <= 0)\nreturn 0;\n\nif (n == 1)\nreturn 1;\n\nreturn Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n\nOur textbooks take Fibonacci sequences as examples for recursive functions does not necessarily mean that recursion is a good solution for Fibonacci sequences. Interviewers may tell candidates that the performance of this recursive solution is quite bad, and ask them to analyze root causes.\n\nLet us take f(10) as an example to analyze the recursive process. We have to get f(9) and f(8) before we get f(10). Meanwhile, f(8) and f(7) are needed before we get f(9). The dependency can be visualized in a tree as shown in Figure 1:\n\n\n\nIt is not difficult to notice that there are many duplicate nodes in the tree in Figure 1. The number of duplicated nodes increases dramatically when n increases. \u00a0Readers may have a try on the 100 th number if Fibonacci sequences to have intuitive ideas about how slow this recursive solution is.\n\nSolution 2: Practical Solution with O(n) efficiency\n\nIt is easy to optimize performance fortunately if we calculate from bottom. That is to say, we get f(2) based on f(0) and f(1), and get f(3) based on f(1) and f(2). We follow this pattern till we get f(n). It is obvious that its time complexity is O(n). Its corresponding code is shown below:\n\nlong long Fibonacci( unsigned n)\n{\nint result[2] = {0, 1};\nif (n < 2)\nreturn result[n];\n\nlong long fibNMinusOne = 1;\nlong long fibNMinusTwo = 0;\nlong long fibN = 0;\nfor ( unsigned int i = 2; i <= n; ++ i)\n{\nfibN = fibNMinusOne + fibNMinusTwo;\n\nfibNMinusTwo = fibNMinusOne;\nfibNMinusOne = fibN;\n}\n\nreturn fibN;\n}\n\nSolution 3: O( log n) solution\n\nUsually interviewers expect the O(n) solution above. However, there is an O( log n) solution available, which is based on an uncommon equation as shown below:\n\n\nIt is not difficult to prove this equation vithmathematical induction. Interested readers may have try.\n\nNow the only problem is how to calculate power of a matrix . We can calculate power with exponent n in O( log n) time with the following equation:\n\n\n\n\n\nThe source code to get power of a matrix looks complicated, which is listed below:\n\n#include <cassert>\n\nstruct Matrix2By2\n{\nMatrix2By2\n(\nlong long m00 = 0,\nlong long m01 = 0,\nlong long m10 = 0,\nlong long m11 = 0\n)\n:m_00(m00), m_01(m01), m_10(m10), m_11(m11)\n{\n}\n\nlong long m_00;\nlong long m_01;\nlong long m_10;\nlong long m_11;\n};\n\nMatrix2By2 MatrixMultiply\n(\nconst Matrix2By2& matrix1,\nconst Matrix2By2& matrix2\n)\n{\nreturn Matrix2By2(\nmatrix1.m_00 * matrix2.m_00 + matrix1.m_01 * matrix2.m_10,\nmatrix1.m_00 * matrix2.m_01 + matrix1.m_01 * matrix2.m_11,\nmatrix1.m_10 * matrix2.m_00 + matrix1.m_11 * matrix2.m_10,\nmatrix1.m_10 * matrix2.m_01 + matrix1.m_11 * matrix2.m_11);\n}\n\nMatrix2By2 MatrixPower( unsigned int n)\n{\nassert(n > 0);\n\nMatrix2By2 matrix;\nif (n == 1)\n{\nmatrix = Matrix2By2(1, 1, 1, 0);\n}\nelse if (n % 2 == 0)\n{\nmatrix = MatrixPower(n / 2);\nmatrix = MatrixMultiply(matrix, matrix);\n}\nelse if (n % 2 == 1)\n{\nmatrix = MatrixPower((n - 1) / 2);\nmatrix = MatrixMultiply(matrix, matrix);\nmatrix = MatrixMultiply(matrix, Matrix2By2(1, 1, 1, 0));\n}\n\nreturn matrix;\n}\n\nlong long Fibonacci( unsigned int n)\n{\nint result[2] = {0, 1};\nif (n < 2)\nreturn result[n];\n\nMatrix2By2 PowerNMinus2 = MatrixPower(n - 1);\nreturn PowerNMinus2.m_00;\n}\n\nEven though it cost only O( log n) time in theory, its hidden constant parameter is quite big, so it is not treated as a practical solution in real software development. Additionally, it is not a recommended solution during interviews since its implementation code is very complex.", "question": "\nProblem: Please implement a function which returns the n th number in Fibonacci sequences with an input n. Fibonacci sequence is defined as:\n\n\n\n"},
{"answer": "\nAnalysis: As we know, the binary search algorithm is suitable to search a number in a sorted array. Since the input array for this problem is partially sorted, we may also have a try with binary search.\n\nLet us try to get the middle number in an array. The middle number of array {1, 2, 3, 4, 5, 10, 9, 8, 7, 6} is 5 (the fourth number). It is greater than its previous number 4, and less than its next number 10, so it is in the increasing sub-array. Therefore, numbers before 5 can be discarded in the next round of search.\n\nThe remaining numbers for the next round of search are {5, 10, 9, 8, 7, 6}, and the number 9 is in the middle of them. Since 9 is less than is previous number 10 and greater than its next number 8, it is in the decreasing sub-array. Therefore, numbers after 9 can be discarded in the next round of search.\n\nThe remaining numbers for the next round of search are {5, 10, 9}, and the number 10 is in the middle. It is noticeable that number 10 is greater than its previous number 5 and greater than its next number 9, so it is the maximum number. That is to say, the number 10 is the turning number in the input array.\n\nWe can see the process above is actually a classic binary search. Therefore, we can implement the required function based on binary search algorithm, as listed below:\n\nint TurningNumberIndex( int * numbers, int length)\n{\nif (numbers == NULL || length <= 2)\nreturn -1;\n\nint left = 0;\nint right = length - 1;\nwhile (right > left + 1)\n{\nint middle = (left + right) / 2;\nif (middle == 0 || middle == length - 1)\nreturn -1;\n\nif (numbers[middle] > numbers[middle - 1] &&\nnumbers[middle] > numbers[middle + 1])\nreturn middle;\nelse if (numbers[middle] > numbers[middle - 1] &&\nnumbers[middle] < numbers[middle + 1])\nleft = middle;\nelse\nright = middle;\n}\n\nreturn -1;\n}", "question": "\nProblem: Turning number is the maximum number in an array which increases and then decreases. This kind of array is also named unimodal array. Please write a function which gets the index of the turning number in such an array.\n\nFor example, the turning number in array {1, 2, 3, 4, 5, 10, 9, 8, 7, 6} is 10, so its index 5 is the expected output.\n"},
{"answer": "\nAnalysis: It looks difficult to get rules of left rotation on a string. Fortunately, the 7 th problem in this series \u201c Reverse Words in a Sentence \u201d can give us some hints.\n\nIf we input a sentence with two words \u201chello world\u201d for the problem \u201cReverse Words in a Sentence\u201d, the reversed result should be \u201cworld hello\u201d. It is noticeable that the result \u201cworld hello\u201d can be viewed as a rotated result of \u201chello world\u201d. It becomes \u201cworld hello\u201d when we move some leading characters of string \u201chello world\u201d to its ending. Therefore, this problem is quite similar to problem \u201cReverse Words in a Sentence\u201d.\n\nLet us take a string \u201cabcdefg\u201d as an example. We divide it into two parts: the first part contains the two leading characters \u201cab\u201d, and the second part contains all other characters \u201ccdefg\u201d. We firstly reverse these two parts separately, and the whole string becomes \u201cbagfedc\u201d. It becomes \u201ccdefgab\u201d if we reverse the whole string, which is the expected result of left rotation with 2.\n\nAccording to the analysis above, we can see that left rotation of a string can be implemented calling a Reverse function three times to reverse a segment or whole string. The sample code is shown below:\n\nchar * LeftRotateString( char * pStr, int n)\n{\nif (pStr != NULL)\n{\nint nLength = static_cast < int >(strlen(pStr));\nif (nLength > 0 && n > 0 && n < nLength)\n{\nchar * pFirstStart = pStr;\nchar * pFirstEnd = pStr + n - 1;\nchar * pSecondStart = pStr + n;\nchar * pSecondEnd = pStr + nLength - 1;\n\n// Reverse the n leading characters\nReverse(pFirstStart, pFirstEnd);\n// Reverse other characters\nReverse(pSecondStart, pSecondEnd);\n// Reverse the whole string\nReverse(pFirstStart, pSecondEnd);\n}\n}\n\nreturn pStr;\n}\n\nThe function Reverse is shown in \u201c Reverse Words in a Sentence \u201d, so we are not going to repeat it here.", "question": "\nProblem: Left rotation of a string is to move some leading characters to its tail. Please implement a function to rotate a string.\n\nFor example, if the input string is \u201cabcdefg\u201d and a number 2, the rotated result is \u201ccdefgab\u201d.\n"},
{"answer": "\nAnalysis: An intuitive solution for this problem is to check whether every number in the first array (denoted as array1 ) is in the second array (denoted as array2 ). If the length of array1 is m , and the length of array2 is n , its overall time complexity is O( m * n ) based on linear search. We have two better solutions.\n\nSolution 1: With O( m + n ) Time\n\nIt is noticeable that the two input arrays are sorted. Supposing a number number1 in array1 equals to a number number2 in array2 , the numbers after number1 in array1 should be greater than the numbers before number2 in array2 . Therefore, it is not necessary to compare the numbers after number1 in array1 with numbers before number2 in array2 . It improves efficiency since many comparisons are eliminated.\n\nThe sample code for this solution is shown below:\n\nvoid GetIntersection_solution1( const vector< int >& array1,\nconst vector< int >& array2,\nvector< int >& intersection)\n{\nvector< int >::const_iterator iter1 = array1.begin();\nvector< int >::const_iterator iter2 = array2.begin();\n\nintersection.clear();\n\nwhile (iter1 != array1.end() && iter2 != array2.end())\n{\nif (*iter1 == *iter2)\n{\nintersection.push_back(*iter1);\n++ iter1;\n++ iter2;\n}\nelse if (*iter1 < *iter2)\n++ iter1;\nelse\n++ iter2;\n}\n}\n\nSince it only requires to scan two arrays once, its time complexity is O( m + n ).\n\nSolution 2: With O( n log m ) Time\n\nAs we know, a binary search algorithm requires O(log m ) time to find a number in an array with length m . Therefore, if we search each number of an array with length n from an array with length m , its overall time complexity is O( n log m ). If m is much greater than n , O( n log m ) is actually less than O( m + n ). Therefore, we can implement a new and better solution based on binary search in such a situation.\n\nFor instance, the following same code is suitable when array1 is much longer than array2 .\n\n/* === Supposing array1 is much longer than array2 === */\nvoid GetIntersection_solution2( const vector< int >& array1,\nconst vector< int >& array2,\nvector< int >& intersection)\n{\nintersection.clear();\n\nvector< int >::const_iterator iter1 = array1.begin();\nwhile (iter1 != array1.end())\n{\nif (binary_search(array2.begin(), array2.end(), *iter1))\nintersection.push_back(*iter1);\n}\n}", "question": "\nProblem: Please implement a function which gets the intersection of two sorted arrays. Assuming numbers in each array are unique.\n\nFor example, if the two sorted arrays as input are {1, 4, 7, 10, 13} and {1, 3, 5, 7, 9}, it returns an intersection array with numbers {1, 7}.\n"},
{"answer": "\nAnalysis: It\u2019s not difficult to get all substrings of a string, and to check whether a substring has duplicated characters. The only concern about this brute-force strategy is performance. A string with n characters has O( n 2 ) substrings, and it costs O( n ) time to check whether a substring has duplication. Therefore, the overall cost is O( n 3 ).\n\nWe may improve the efficiency with dynamic programming. Let\u2019s denote the length of longest substring ending with the i th character by L ( i ).\n\nWe scan the string one character after another. When the i th character is scanned, L ( i -1) is already know. If the i th character has not appeared before, L ( i ) should be L ( i -1)+1. It\u2019s more complex when the i th character is duplicated. Firstly we get the distance between the i th character and its previous occurrence. If the distance is greater than L ( i -1), the character is not in longest substring without duplication ending with the ( i -1) th character, so L ( i ) should also be L ( i -1)+1. If the distance is less than L ( i -1), L ( i ) is the distance, and it means between the two occurrence of the i th character there are no other duplicated characters.\n\nThis solution can be implemented in Java as the following code:\n\n public static int longestSubstringWithoutDuplication(String str) {\n     int curLength = 0;\n     int maxLength = 0;\n\n     int position[] = new int [26];\n     for ( int i = 0; i < 26; ++i) {\n         position[i] = -1;\n     }\n\n     for ( int i = 0; i < str.length(); ++i) {\n         int prevIndex = position[str.charAt(i) - 'a' ];\n         if (prevIndex < 0 || i - prevIndex > curLength) {\n             ++curLength;\n         }\n         else {\n             if (curLength > maxLength) {\n                 maxLength = curLength;\n             }\n\n             curLength = i - prevIndex;\n         }\n         position[str.charAt(i) - 'a' ] = i;\n     }\n\n     if (curLength > maxLength) {\n         maxLength = curLength;\n     }\n\n     return maxLength;\n }\n\n L ( i ) is implemented as curLength in the code above. Aninteger array is used to store the positions of each character.\n\n", "question": "\nProblem: Given a string, please get the length of the longest substring which does not have duplicated characters. Supposing all characters in the string are in the range from \u2018a\u2019 to \u2018z\u2019.\n"},
{"answer": "\nAnalysis: Path in a binary tree is a new concept for many candidates, so it is not a simple question for them. We may try to find the hidden rules with concrete examples. Let us take the binary tree in Figure 1 as an example.\n\nSince paths always start from a root node, we traverse from a root node in a binary tree. We have three traversal orders, pre-order, in-order and post-order, and we firstly visit a root node with pre-order traversal.\n\nAccording to the pre-order traversal process on the binary tree in Figure 1, we visit the node 5 after visiting the root node 10. Since a binary tree node does not have a pointer to its parent node, we do not know what nodes have been visited when we reach the node 5 if we do not save the visited node on the path. Therefore, we could insert the current node into a path when we reach it during traversal. The path contains two nodes with value 10 and 5 when we are visiting the node 5. Then we insert the node 4 into the path too when we reach it. We have reached a leaf node, and the sum of three nodes in the path is 19. Since it is not same as the input number 22, current path is not a qualified one.\nWe should continue to traverse other nodes. Before visiting other nodes, we should return back to the node 5, and then reach the node 7. It can be noticed that node 4 is no longer in the path from node 10 to node 7, so we should remove it from the path. When we are visiting node 7, we insert it into the path, which contains three nodes now. Since the sum of value of these three nodes is 22, the path is qualified.\n\nLastly we are going to visit the node 12. We should return back to node 5 then back to node 10 before we visit node 12. When we return back from a child node to its parent node, we remove the child node from the path. When we reach the node 12 eventually, the path contains two nodes, one is node 10 and the other is node 12. Since the sum of value of these two nodes is 22, the path is qualified too.\n\nWe can summarize the whole process above with the Table 1:\n\nStep Operation Is it a leaf? Path Sum of nodes value 1 Visit node 10 No node 10 10 2 Visit node 5 No node 10, node 5 15 3 Visit node 4 Yes node 10, node 5, node 4 19 4 Return to node 5 node 10, node 5 15 5 Visit node 7 Yes node 10, node 5, node 7 22 6 Return to node 5 node 10, node 5 15 7 Return to node 10 node 10 10 8 Visit node 12 Yes node 10, node 12 22\nStep\nOperation\nIs it a leaf?\nPath\nSum of nodes value\n1\nVisit node 10\nNo\nnode 10\n10\n2\nVisit node 5\nNo\nnode 10, node 5\n15\n3\nVisit node 4\nYes\nnode 10, node 5, node 4\n19\n4\nReturn to node 5\n\nnode 10, node 5\n15\n5\nVisit node 7\nYes\nnode 10, node 5, node 7\n22\n6\nReturn to node 5\n\nnode 10, node 5\n15\n7\nReturn to node 10\n\nnode 10\n10\n8\nVisit node 12\nYes\nnode 10, node 12\n22\nTable 1: The process to traverse the binary tree in Figure 1\n\nIt is time to summarize some rules with the example above. When we visit a node with pre-order traversal order, we insert it into the path, and accumulate its value to sum .\u00a0 When the node is a leaf and sum is same as the input number, the path is qualified and we need to print it. We continue to visit its children if the current node is not a leaf. After we finish visiting the current node, a recursive function will return back to its parent node automatically, so we should remove the current node from the path before a function returns to make sure the nodes in the path is same as the path from root node to its parent node. The data structure to save paths should be a stack, because paths should be consistent to the recursion status and recursion is essentially pushing and popping in a call stack.\nHere is some sample code for this problem:\n\nvoid FindPath(BinaryTreeNode* pRoot, int expectedSum)\n{\nif (pRoot == NULL)\nreturn ;\n\nstd::vector< int > path;\nint currentSum = 0;\nFindPath(pRoot, expectedSum, path, currentSum);\n}\n\nvoid FindPath\n(\nBinaryTreeNode*\u00a0\u00a0 pRoot,\nint expectedSum,\nstd::vector< int >&\u00a0path,\nint currentSum\n)\n{\ncurrentSum += pRoot->m_nValue;\npath.push_back(pRoot->m_nValue);\n\n// Print the path is the current node is a leaf\n// and the sum of all nodes value is same as expectedSum\nbool isLeaf = pRoot->m_pLeft == NULL && pRoot->m_pRight == NULL;\nif (currentSum == expectedSum && isLeaf)\n{\nprintf( \"A path is found: \" );\nstd::vector< int >::iterator iter = path.begin();\nfor (; iter != path.end(); ++ iter)\nprintf( \"%d\\t\" , *iter);\n\nprintf( \"\\n\" );\n}\n\n// If it is not a leaf, continue visition its children\nif (pRoot->m_pLeft != NULL)\nFindPath(pRoot->m_pLeft, expectedSum, path, currentSum);\nif (pRoot->m_pRight != NULL)\nFindPath(pRoot->m_pRight, expectedSum, path, currentSum);\n\n// Before returning back to its parent, remove it from path,\npath.pop_back();\n}\n\nIn the code above, we save path with a vector in STL actually. We use function push_back to insert a node and pop_back to remove a node to assure it is \u201cFirst in Last out\u201d in a path. The reason we don\u2019t utilize a stack in STL is that we can only get an element at the top of a stack, but we need to get all nodes when we print a path. Therefore, std::stack is not the best choice for us.", "question": "\nQuestion: All nodes along children pointers from root to leaf nodes form a path in a binary tree. Given a binary tree and a number, please print out all of paths where the sum of all nodes value is same as the given number. The node of binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n\nFor instance, if inputs are the binary tree in Figure 1 and a number 22, two paths with be printed: One is the path contains node 10 and 12, and the other contains 10, 5 and 7."},
{"answer": "\nAnalysis: Path in a binary tree is a new concept for many candidates, so it is not a simple question for them. We may try to find the hidden rules with concrete examples. Let us take the binary tree in Figure 1 as an example.\n\nSince paths always start from a root node, we traverse from a root node in a binary tree. We have three traversal orders, pre-order, in-order and post-order, and we firstly visit a root node with pre-order traversal.\n\nAccording to the pre-order traversal process on the binary tree in Figure 1, we visit the node 5 after visiting the root node 10. Since a binary tree node does not have a pointer to its parent node, we do not know what nodes have been visited when we reach the node 5 if we do not save the visited node on the path. Therefore, we could insert the current node into a path when we reach it during traversal. The path contains two nodes with value 10 and 5 when we are visiting the node 5. Then we insert the node 4 into the path too when we reach it. We have reached a leaf node, and the sum of three nodes in the path is 19. Since it is not same as the input number 22, current path is not a qualified one.\nWe should continue to traverse other nodes. Before visiting other nodes, we should return back to the node 5, and then reach the node 7. It can be noticed that node 4 is no longer in the path from node 10 to node 7, so we should remove it from the path. When we are visiting node 7, we insert it into the path, which contains three nodes now. Since the sum of value of these three nodes is 22, the path is qualified.\n\nLastly we are going to visit the node 12. We should return back to node 5 then back to node 10 before we visit node 12. When we return back from a child node to its parent node, we remove the child node from the path. When we reach the node 12 eventually, the path contains two nodes, one is node 10 and the other is node 12. Since the sum of value of these two nodes is 22, the path is qualified too.\n\nWe can summarize the whole process above with the Table 1:\n\nStep Operation Is it a leaf? Path Sum of nodes value 1 Visit node 10 No node 10 10 2 Visit node 5 No node 10, node 5 15 3 Visit node 4 Yes node 10, node 5, node 4 19 4 Return to node 5 node 10, node 5 15 5 Visit node 7 Yes node 10, node 5, node 7 22 6 Return to node 5 node 10, node 5 15 7 Return to node 10 node 10 10 8 Visit node 12 Yes node 10, node 12 22\nStep\nOperation\nIs it a leaf?\nPath\nSum of nodes value\n1\nVisit node 10\nNo\nnode 10\n10\n2\nVisit node 5\nNo\nnode 10, node 5\n15\n3\nVisit node 4\nYes\nnode 10, node 5, node 4\n19\n4\nReturn to node 5\n\nnode 10, node 5\n15\n5\nVisit node 7\nYes\nnode 10, node 5, node 7\n22\n6\nReturn to node 5\n\nnode 10, node 5\n15\n7\nReturn to node 10\n\nnode 10\n10\n8\nVisit node 12\nYes\nnode 10, node 12\n22\nTable 1: The process to traverse the binary tree in Figure 1\n\nIt is time to summarize some rules with the example above. When we visit a node with pre-order traversal order, we insert it into the path, and accumulate its value to sum .\u00a0 When the node is a leaf and sum is same as the input number, the path is qualified and we need to print it. We continue to visit its children if the current node is not a leaf. After we finish visiting the current node, a recursive function will return back to its parent node automatically, so we should remove the current node from the path before a function returns to make sure the nodes in the path is same as the path from root node to its parent node. The data structure to save paths should be a stack, because paths should be consistent to the recursion status and recursion is essentially pushing and popping in a call stack.\nHere is some sample code for this problem:\n\nvoid FindPath(BinaryTreeNode* pRoot, int expectedSum)\n{\nif (pRoot == NULL)\nreturn ;\n\nstd::vector< int > path;\nint currentSum = 0;\nFindPath(pRoot, expectedSum, path, currentSum);\n}\n\nvoid FindPath\n(\nBinaryTreeNode*\u00a0\u00a0 pRoot,\nint expectedSum,\nstd::vector< int >&\u00a0path,\nint currentSum\n)\n{\ncurrentSum += pRoot->m_nValue;\npath.push_back(pRoot->m_nValue);\n\n// Print the path is the current node is a leaf\n// and the sum of all nodes value is same as expectedSum\nbool isLeaf = pRoot->m_pLeft == NULL && pRoot->m_pRight == NULL;\nif (currentSum == expectedSum && isLeaf)\n{\nprintf( \"A path is found: \" );\nstd::vector< int >::iterator iter = path.begin();\nfor (; iter != path.end(); ++ iter)\nprintf( \"%d\\t\" , *iter);\n\nprintf( \"\\n\" );\n}\n\n// If it is not a leaf, continue visition its children\nif (pRoot->m_pLeft != NULL)\nFindPath(pRoot->m_pLeft, expectedSum, path, currentSum);\nif (pRoot->m_pRight != NULL)\nFindPath(pRoot->m_pRight, expectedSum, path, currentSum);\n\n// Before returning back to its parent, remove it from path,\npath.pop_back();\n}\n\nIn the code above, we save path with a vector in STL actually. We use function push_back to insert a node and pop_back to remove a node to assure it is \u201cFirst in Last out\u201d in a path. The reason we don\u2019t utilize a stack in STL is that we can only get an element at the top of a stack, but we need to get all nodes when we print a path. Therefore, std::stack is not the best choice for us.", "question": "\nQuestion: All nodes along children pointers from root to leaf nodes form a path in a binary tree. Given a binary tree and a number, please print out all of paths where the sum of all nodes value is same as the given number. The node of binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n\nFor instance, if inputs are the binary tree in Figure 1 and a number 22, two paths with be printed: One is the path contains node 10 and 12, and the other contains 10, 5 and 7."},
{"answer": "\nAnalysis: The na\u00efve solution is sort the n input numbers increasingly, and the least k numbers should be the first k numbers. Since it needs to sort, its time complexity is O(n log n) . Interviewers will ask us explore more efficient solutions.\n\nSolution 1: O( n log k ) time efficiency, be suitable for data with huge size\n\nA data container with capacity k is firstly created to store the least k numbers, and then a number is read out of the n input numbers at each time. \u00a0\u00a0If the container has less than k numbers, the number read at current round (denoted as num ) is inserted into container directly. If it contains k numbers already, num cannot be inserted directly any more. However, it may replace an existing number in the container. \u00a0We get the maximum number of the k numbers in the container, and compare it with num . If num is less than the maximum number, we replace the maximum number with num . Otherwise we discard num , since we already have k numbers in the container which are all less than num and it cannot be one of the least k numbers.\n\nThree steps may be required when a number is read and the container is full: The first step is to find the maximum number, secondly we may delete the maximum number, and at last we may insert a new number. The second and third steps are optional, which depend on whether the number read at current round is greater than the maximum number in container or not. If we implement the data container as a binary tree, it costs O(log k ) time for these three steps. Therefore, the overall time complexity is O( n log k ) for n input numbers.\n\nWe have different choices for the data container. Since we need to get the maximum number out of k numbers, it intuitively might a maximum heap. In a maximum heap, its root is always greater than its children, so it costs O(1) time to get the maximum number. However, it takes O(log k ) time to insert and delete a number.\n\nWe have to write a lot of code for a maximum heap, and it is too difficult in the dozens-of-minute interview. We can also implement it as a red-black tree. A red-black tree classifies its nodes into red and black categories, and assure that it is somewhat balanced based on a set of rules. Therefore, it costs O(log k ) time to find, insert and delete a number. The classes set and multiset in STL are all based on red-black trees. We may use data containers in STL directly if our interviewers are not against it. The following sample code is based on the multiset in STL:\n\ntypedef multiset< int , greater< int > >\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 intSet;\ntypedef multiset< int , greater< int > >::iterator\u00a0 setIterator;\n\nvoid GetLeastNumbers( const vector< int >& data, intSet& leastNumbers, int k)\n{\nleastNumbers.clear();\n\nif (k < 1 || data.size() < k)\nreturn ;\n\nvector< int >::const_iterator iter = data.begin();\nfor (; iter != data.end(); ++ iter)\n{\nif ((leastNumbers.size()) < k)\nleastNumbers.insert(*iter);\n\nelse\n{\nsetIterator iterGreatest = leastNumbers.begin();\n\nif (*iter < *(leastNumbers.begin()))\n{\nleastNumbers.erase(iterGreatest);\nleastNumbers.insert(*iter);\n}\n}\n}\n}\n\nSolution 2: O( n ) time efficiency, be suitable only when we can reorder the input\n\nWe can also utilize the function Partition in quick sort to solve this problem with a hypothesis. It assumes that n input numbers are contained in an array. If it takes the k -th number as a pilot to partition the input array, all of numbers less than the k -th number should be at the left side and other greater ones should be at the right side. The k numbers at the left side are the least k numbers after the partition. We can develop the following code according to this solution:\n\nvoid GetLeastNumbers( int * input, int n, int * output, int k)\n{\nif (input == NULL || output == NULL || k > n || n <= 0 || k <= 0)\nreturn ;\n\nint start = 0;\nint end = n - 1;\nint index = Partition(input, n, start, end);\nwhile (index != k - 1)\n{\nif (index > k - 1)\n{\nend = index - 1;\nindex = Partition(input, n, start, end);\n}\nelse\n{\nstart = index + 1;\nindex = Partition(input, n, start, end);\n}\n}\n\nfor ( int i = 0; i < k; ++i)\noutput[i] = input[i];\n}\n\nComparison between two solutions\n\nThe second solution based on the function Partition costs only O( n ) time, so it is more efficient than the first one. However, it has two obvious limitations: One limitation is that it needs to load all input numbers into an array, and the other is that we have to reorder the input numbers.\nEven though the first takes more time, the second solution does have the two limitations as the first one. It is not required to reorder the input numbers ( data in the code above). We read a number from data at each round, and all write operations are taken in the container leastNumbers . It does not require loading all input number into memory at one time, so it is suitable for huge-size data. Supposing our interview asks us get the least k numbers from a huge-size input. Obviously we cannot load all data with huge size into limited memory at one time. We can read a number from auxiliary space (such as disk) at each round with the first solution, and determine whether we need to insert it into the container leastNumbers . It works once memory can accommodate leastNumbers , so it is especially works when n is huge and k is small.\n\nThe characters of these two solutions can be summarized in Table 1:\n\nFirst Solution Second Solution Time complexity O( n *log k ) O( n ) Reorder input   numbers? No Yes Suitable for   huge-size data? Yes No\n\nFirst Solution\nSecond Solution\nTime complexity\nO( n *log k )\nO( n )\nReorder input   numbers?\nNo\nYes\nSuitable for   huge-size data?\nYes\nNo\nTable 1: Pros and cons of two solutions\n", "question": "\nQuestion: Please find out the least k numbers out of n numbers. For example, if given the 8 numbers 4, 5, 1, 6, 2, 7, 3 and 8, please return the least 4 numbers 1, 2, 3 and 4.\n"},
{"answer": "\nAnalysis: This is a typical problem which can be solved by dynamic programming. We have two strategies to analyze and solve this problem\n\nSolution 1: Split at any space between two characters\n\nGiven a substring of str , starting from the index i and ending at the index j (denoted as str [ i : j ]), we define a function f ( i , j ) to denote the minimal number of splits to partition the substring str [ i : j ] into a set of palindromes. If the substring is a palindrome itself, we don\u2019t have to split so f ( i , j ) is 0. If the substring is not a palindrome, the substring is split between two characters k and k +1. f ( i , j )= f ( i , k )+ f ( k +1, j )+1 under such conditions. Therefore, f ( i , j ) can be defined with the following equation:\n\n\nThe value of f (0, n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nIf the equation is calculated recursively, its complexity grows exponentially with the length n . A better choice is to calculate in bottom-up order with a 2D matrix with size n \u00d7 n . The following C++ code implements this solution:\n\n int minSplit_1( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length * length];\n    \n     for ( int i = 0; i <length; ++i)\n        split[i * length + i] = 0;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         for ( int j = length -i; j > 0; --j)\n         {\n             int row = length - i - j;\n             int col = row + i;\n             if (isPalindrome(str, row, col))\n             {\n                split[row * length + col] = 0;\n             }\n             else\n             {\n                 int min = 0x7FFFFFFF;\n                 for ( int k = row; k < col; ++k)\n                {\n                     int temp1 = split[row * length + k];\n                     int temp2 = split[(k + 1) * length +col];\n                     if (min> temp1 + temp2 + 1)\n                         min = temp1 + temp2 +1;\n                }\n                split[row * length + col] = min;\n             }\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nSolution 2: Split only before a palindrome\n\nWe split the string str with another strategy. Given a substring ending at the index i , str [0, i], we do not have to split if the substring is a palindrome itself. Otherwise it is split between two characters at index j and j +1 only if the substring str [ j +1, i ] is a palindrome. Therefore, an equation f ( i ) can be defined as the following:\n\n\nThe value of f ( n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nWe could utilize a 1D array to solve this equation in bottom-up order, as listed in the following code:\n\n int minSplit_2( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length];\n     for ( int i = 0; i <length; ++i)\n        split[i] = i;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         if (isPalindrome(str, 0, i))\n         {\n            split[i] = 0;\n             continue ;\n         }\n\n         for ( int j = 0; j <i; ++j)\n         {\n             if (isPalindrome(str, j + 1, i) && split[i]> split[j] + 1)\n                split[i] = split[j] + 1;\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nOptimization to verify palindromes:\n\nUsually it costs O( n ) time to check whether a string with length n is a palindrome, and the typical implementation looks like the following code:\n\n bool isPalindrome( const string& str, int begin, int end)\n {\n     for ( int i = begin; i< end - (i - begin); ++i)\n     {\n         if (str[i] != str[end - (i - begin)])\n             return false ;\n     }\n\n     return true ;\n }\n\nBoth solutions above cost O( n 3 ) time. The first solution contains three nesting for-loops. The function isPalindrome is inside two nesting for-loops.\n\nIf we could reduce the cost of isPalindrome to O(1), the time complexity of the second solution would be O( n 2 ).\n\nNotice that the substring str [ i , j ] is a palindrome only if the characters at index i and j , and str [ i +1, j -1] is also a palindrome. We could build a 2D table accordingly to store whether every substring of str is a palindrome or not during the preprocessing. With such a table, the function isPalindrome can verify the substring str [ i , j ] in O(1) time.\n\n", "question": "\nProblem: A string can be partitioned into some substrings, such that each substring is a palindrome. For example, there are a few strategies to split the string \u201cabbab\u201d into palindrome substrings, such as: \u201cabba\u201d|\u201db\u201d, \u201ca\u201d|\u201db\u201d|\u201dbab\u201d and \u201ca\u201d|\u201dbb\u201d|\u201da\u201d|\u201db\u201d.\n\nGiven a string str , please get the minimal numbers of splits to partition it into palindromes. The minimal number of splits to partition the string \u201cabbab\u201d into a set of palindromes is 1.\n"},
{"answer": "\nAnalysis: Every pair of two adjacent numbers in an arithmetic sequence has exactly same difference. For example, 1, 3, 5, and 7 is an arithmetic sequence, and the pairs (1, 3), (3, 5), and (5, 7) have the same difference 2.\n\nThere are n ( n -1)/2 pairs out of an array with n elements. These pairs can be categorized into a set of groups, of which each group of pairs have the same difference. For example, the pairs of numbers in the array {1, 6, 3, 5, 9, 7} can be categorized into groups:\n\nDifference -1: (6, 5) Difference 2: (1, 3), (3, 5), (5, 7) Difference 3: (6, 9) \u2026\n\nTherefore, a hash table can be defined for the groups. The key in the hash table is the difference of pairs, and the value in the hash table is a list of pairs with same difference. The code to build the hash table can be implemented in C# as the following:\n\n internal class Pair\n {\n     public int First { get ; set ; }\n     public int Second { get ; set ; }\n }\n\n private static Dictionary < int , List < Pair >> BuildHashTable( int [] numbers)\n {\n     var hashTable = new Dictionary < int , List < Pair >>();\n     for ( int i = 0; i < numbers.Length; ++i)\n     {\n         for ( int j = i + 1; j < numbers.Length; ++j)\n         {\n             Pair pair = new Pair\n             {\n                 First = i,\n                 Second = j\n             };\n\n             int diff = numbers[j] - numbers[i];\n             if (hashTable.Keys.Contains(diff))\n             {\n                 hashTable[diff].Add(pair);\n             }\n             else\n             {\n                 List < Pair > newValue = new List < Pair >();\n                 newValue.Add(pair);\n                 hashTable[diff] = newValue;\n             }\n         }\n     }\n\n     return hashTable;\n }\n\nIn the code above, the values of the hash table is pairs of indexes, rather than elements themselves of the array. The pairs are sorted according to their first elements.\n\nThe next step is to get the length of pairs with each difference. A list of pairs with difference k is got given a key k in the hash table. If an element A[ i ] is m th element is an arithmetic sequence with a common difference k , and there is a pair (A[ i ], A[ j ]) ( j > i ) in the list of pairs, the element A[ j ] should be the m + 1 th elemement in the arithmetic sequence.\n\nTherefore, the code to get the max length of all arithmetic sequences can be implemented as:\n\n private static int Analyze( Dictionary < int , List < Pair >> hashTable, int lengthOfNumbers)\n {\n     int maxLength = 0;\n     foreach ( var key in hashTable.Keys)\n     {\n         int [] lengths = new int [lengthOfNumbers];\n         for ( int i = 0; i < lengthOfNumbers; ++i)\n         {\n             lengths[i] = 1;\n         }\n\n         foreach ( Pair pair in hashTable[key])\n         {\n             lengths[pair.Second] =lengths[pair.First] + 1;\n         }\n\n         foreach ( var length in lengths)\n         {\n             if (length > maxLength)\n             {\n                 maxLength = length;\n             }\n         }\n     }\n\n     return maxLength;\n }\n\n public static int GetMaxLengthOfArithmeticSequence( int [] numbers)\n {\n     var hashTable = BuildHashTable(numbers);\n     return Analyze(hashTable, numbers.Length);\n }\n\n\nAs mentioned above, there are O( n 2 ) pairs in an array with n elements. Therefore, the time and space efficiencies of this solution is O( n 2 ) given an array with n elements.\n\n\nAnalysis: Different from the previous problem, there are no limitations on the order of arithmetic sequence. Consequently, we can sort the array before we try to get the maximal length of arithmetic sequences. The code is almost same as before, except for the revision that there is an additional line of code to sort the array, as listed below:\n\n public static int GetMaxLengthOfArithmeticSequence( int [] numbers)\n {\n     Array .Sort(numbers);\n     var hashTable = BuildHashTable(numbers);\n     return Analyze(hashTable, numbers.Length);\n }\n\n\n\nAnalysis: The solution to solve the above problems cost O( n 2 ) time and space. Therefore, we need a new solution to solve this problem.\n\nA consecutive can\u2019t have duplicated elements. A hash set, of which every element is unique, can be built from the input array. When a number is located in the set, we try to locate its consecutive neighbors. For instance, when the number 6 is found in the set, we try to find the number 5 and 7 in the set, and then we get a consecutive sequence 5, 6, and 7.\n\nThis solution can be implemented in C# code as listed below:\n\n public static int GetMaxLengthConsecutiveSequence( int [] numbers)\n {\n     HashSet < int > set = BuildHashSet(numbers);\n     return AnalyzeHashSet(set);\n }\n\n private static HashSet < int > BuildHashSet( int [] numbers)\n {\n     var set = new HashSet < int >();\n     foreach ( int number in numbers)\n     {\n         set.Add(number);\n     }\n\n     return set;\n }\n\n private static int AnalyzeHashSet( HashSet < int > set)\n {\n     int maxCount = 0;\n     while (set.Count > 0)\n     {\n         int number = set.First();\n         int count = 0;\n         int toDelete = number;\n\n         while (set.Remove(toDelete))\n         {\n             count++;\n             toDelete++;\n         }\n\n         toDelete = number - 1;\n         while (set.Remove(toDelete))\n         {\n             count++;\n             toDelete--;\n         }\n\n         if (count > maxCount)\n         {\n             maxCount = count;\n         }\n     }\n\n     return maxCount;\n }\n\nEvery number in the input array is added into and removed from the array only once, so the time and space efficiency is O( n ) if there are n numbers in the array.\n\n\n\n", "question": "\nQuestion 1: Given an array, please get the length of the longest arithmetic sequence. The element order in the arithmetic sequence should be same as the element order in the array. For example, in the array {1, 6, 3, 5, 9, 7}, the longest arithmetic sequence is 1, 3, 5, and 7, whose elements have same order as they are in the array, and the length is 4.\n\n\nQuestion 2: Given an array, please get the length of the longest arithmetic sequence. The element order in the arithmetic sequence is not necessarily same as the element order in the array. For example, in the array {1, 6, 3, 5, 9, 7}, the longest arithmetic sequence is 1, 3, 5, 7, and 9, and the length is 5.\n\n\nQuestion 3: Given an array, please get the length of the longest consecutive sequence. A consecutive sequence is an arithmetic sequence with common difference 1. The element order in the consecutive sequence is not necessarily same as the element order in the array. The solution should not cost more than O( n ) time and space if the length of the input array is n . For example, in the array {1, 6, 3, 5, 9, 7}, the longest consecutive sequence is 5, 6, and 7 whose length is 3.\n"},
{"answer": "\nAnalysis: A function f ( i ) is defined to denote the maximal stolen value from the first house to the i th house, and the value contained in the i th house is denoted as v i . When the thief reaches the i th house, he has two choices: to steal or not. Therefore, f ( i ) can be defined with the following equation:\n\nIt would be much more efficient to calculate in bottom-up order than to calculate recursively. It looks like a 1D array with size n is needed, but actually it is only necessary to cache two values for f ( i -1) and f ( i -2) to calculate f ( i ).\n\n\nThis algorithm can be implemented with the following C++ code:\n\n int maxStolenValue( const vector< int >& values)\n {\n     int length = values.size();\n     if (length == 0)\n         return 0;\n\n     int value1 = values[0];\n     if (length == 1)\n         return value1;\n\n     int value2 = max< int >(values[0],values[1]);\n     if (length == 2)\n         return value2;\n\n     int value;\n     for ( int i = 2; i <length; ++i)\n     {\n         value= max< int >(value2, value1 + values[i]);\n        value1 = value2;\n        value2 = value;\n     }\n\n     return value;\n }\n\n", "question": "\nProblem: There are n houses built in a line, each of which contains some value in it. A thief is going to steal the maximal value in these houses, but he cannot steal in two adjacent houses because the owner of a stolen house will tell his two neighbors on the left and right side. What is the maximal stolen value?\n\nFor example, if there are four houses with values {6, 1, 2, 7}, the maximal stolen value is 13 when the first and fourth houses are stolen.\n"},
{"answer": "\nAnalysis: A function f ( i ) is defined to denote the maximal stolen value from the first house to the i th house, and the value contained in the i th house is denoted as v i . When the thief reaches the i th house, he has two choices: to steal or not. Therefore, f ( i ) can be defined with the following equation:\n\nIt would be much more efficient to calculate in bottom-up order than to calculate recursively. It looks like a 1D array with size n is needed, but actually it is only necessary to cache two values for f ( i -1) and f ( i -2) to calculate f ( i ).\n\n\nThis algorithm can be implemented with the following C++ code:\n\n int maxStolenValue( const vector< int >& values)\n {\n     int length = values.size();\n     if (length == 0)\n         return 0;\n\n     int value1 = values[0];\n     if (length == 1)\n         return value1;\n\n     int value2 = max< int >(values[0],values[1]);\n     if (length == 2)\n         return value2;\n\n     int value;\n     for ( int i = 2; i <length; ++i)\n     {\n         value= max< int >(value2, value1 + values[i]);\n        value1 = value2;\n        value2 = value;\n     }\n\n     return value;\n }\n\n", "question": "\nProblem: There are n houses built in a line, each of which contains some value in it. A thief is going to steal the maximal value in these houses, but he cannot steal in two adjacent houses because the owner of a stolen house will tell his two neighbors on the left and right side. What is the maximal stolen value?\n\nFor example, if there are four houses with values {6, 1, 2, 7}, the maximal stolen value is 13 when the first and fourth houses are stolen.\n"},
{"answer": "\nAnalysis: It is a typical problem about backtracking, which can be solved by storing a path into a stack.\n\nFirstly, it is necessary to define a structure for 2-D positions, as below:\n\nstruct Position\n{\nint x;\nint y;\n};\n\nThe movements of four directions can be defined accordingly:\n\nPosition up = {0, -1};\nPosition right = {1, 0};\nPosition down = {0, 1};\nPosition left = {-1, 0};\nPosition dir[] ={up, right, down, left};\n\nSince paths can start from any entry in a matrix, we have to scan every cell to check whether the character in it is identical to the first character of the string. If it is identical, we begin to explore a path from such a cell.\n\nA path is defined as a stack. When a cell on path is found, we push its position into the stack. Additionally, we also define a matrix of Boolean masks to void entering a cell twice, which is denoted as visited . Based on these considerations, the skeleton of solution can be implemented as the following:\n\nbool hasPath( char * matrix, int rows, int cols, char * str)\n{\nif (matrix == NULL || rows < 1 || cols < 1 || str == NULL)\nreturn false ;\n\nbool *visited = new bool [rows * cols];\nmemset(visited, 0, rows * cols);\n\nfor ( int row = 0; row < rows; ++row)\n{\nfor ( int column = 0; column < cols; ++column)\n{\nif (matrix[row * cols + column] != str[0])\ncontinue ;\n\nstd::stack<Position> path;\nPosition position = {column, row};\npath.push(position);\nvisited[row * cols + column] = true ;\n\nif (hasPathCore(matrix, rows, cols, str, path, visited))\nreturn true ;\n}\n}\n\nreturn false ;\n}\n\nNow let us analyze how to explore a path in details. Supposing we have already found k characters on a path, and we are going to explore the next step. We stand at the cell corresponding to the k th character of the path, and check whether the character in its neighboring cell at up, right, down, and left side is identical to the ( k +1) th character of the string.\n\nIf there is a neighboring cell whose value is identical to the ( k +1) th character of the string, we continue exploring the next step.\n\nIf there is no such a neighboring cell whose value is identical to the ( k +1) th character of the string, it means the cell corresponding to the k th character should not on a path. Therefore, we pop it off a path, and start to explore other directions on the ( k -1) th character.\n\nBased on the analysis above, the function hasPathCore can be defined as:\n\nbool hasPathCore( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited)\n{\nif (str[path.size()] == '\\0' )\nreturn true ;\n\nif (getNext(matrix, rows, cols, str, path, visited, 0))\nreturn hasPathCore(matrix, rows, cols, str, path, visited);\n\nbool hasNext = popAndGetNext(matrix, rows, cols, str, path, visited);\nwhile (!hasNext && !path.empty())\nhasNext = popAndGetNext(matrix, rows, cols, str, path, visited);\n\nif (!path.empty())\nreturn hasPathCore(matrix, rows, cols, str, path, visited);\n\nreturn false ;\n}\n\nThe function getNext is defined to explore the ( k +1) th character on a path. When it returns true , it means the ( k +1) th character on a path has been found. Otherwise, we have to pop the k th character off. The function getNext is implemented as below:\n\nbool getNext( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited, int start)\n{\nfor ( int i = start; i < sizeof (dir) / sizeof (Position); ++i)\n{\nPosition next = {path.top().x + dir[i].x, path.top().y + dir[i].y};\nif (next.x >= 0 && next.x < cols\n&& next.y >=0 && next.y < rows\n&& matrix[next.y * cols + next.x] == str[path.size()]\n&& !visited[next.y * cols + next.x])\n{\npath.push(next);\nvisited[next.y * cols + next.x] = true ;\n\nreturn true ;\n}\n}\n\nreturn false ;\n}\n\nWhen we found that the k th character should not be on a path, we call the function popAndGetNext to pop it off, and try on other directions from the ( k -1) th character. This function is implemented as below:\n\nbool popAndGetNext( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited)\n{\nPosition toBePoped = path.top();\npath.pop();\nvisited[toBePoped.y * cols + toBePoped.x] = false ;\n\nbool hasNext = false ;\nif (path.size() >= 1)\n{\nPosition previous = path.top();\nint deltaX = toBePoped.x - previous.x;\nint deltaY = toBePoped.y - previous.y;\nfor ( int i = 0; (i < sizeof (dir) / sizeof (Position) && !hasNext); ++i)\n{\nif (deltaX != dir[i].x || deltaY != dir[i].y)\ncontinue ;\n\nhasNext = getNext(matrix, rows, cols, str, path, visited, i + 1);\n}\n}\n\nreturn hasNext;", "question": "\nQuestion: How to implement a function to check whether there is a path for a string in a matrix of characters?\u00a0 It moves to left, right, up and down in a matrix, and a cell for a movement. The path can start from any entry in a matrix. If a cell is occupied by a character of a string on the path, it cannot be occupied by another character again.\n\nFor example, the matrix below with three rows and four columns has a path for the string \u201cBCCED\u201d (as highlighted in the matrix). It does not have a path for the string \u201cABCB\u201d, because the first \u201cB\u201d in the string occupies the \u201cB\u201d cell in the matrix, and the second \u201cB\u201d in the string cannot enter into the same cell again.\n\nA\nB\nC\nE\nS\nF\nC\nS\nA\nD\nE\nE\n"},
{"answer": "\nAnalysis: It is a typical problem about backtracking, which can be solved by storing a path into a stack.\n\nFirstly, it is necessary to define a structure for 2-D positions, as below:\n\nstruct Position\n{\nint x;\nint y;\n};\n\nThe movements of four directions can be defined accordingly:\n\nPosition up = {0, -1};\nPosition right = {1, 0};\nPosition down = {0, 1};\nPosition left = {-1, 0};\nPosition dir[] ={up, right, down, left};\n\nSince paths can start from any entry in a matrix, we have to scan every cell to check whether the character in it is identical to the first character of the string. If it is identical, we begin to explore a path from such a cell.\n\nA path is defined as a stack. When a cell on path is found, we push its position into the stack. Additionally, we also define a matrix of Boolean masks to void entering a cell twice, which is denoted as visited . Based on these considerations, the skeleton of solution can be implemented as the following:\n\nbool hasPath( char * matrix, int rows, int cols, char * str)\n{\nif (matrix == NULL || rows < 1 || cols < 1 || str == NULL)\nreturn false ;\n\nbool *visited = new bool [rows * cols];\nmemset(visited, 0, rows * cols);\n\nfor ( int row = 0; row < rows; ++row)\n{\nfor ( int column = 0; column < cols; ++column)\n{\nif (matrix[row * cols + column] != str[0])\ncontinue ;\n\nstd::stack<Position> path;\nPosition position = {column, row};\npath.push(position);\nvisited[row * cols + column] = true ;\n\nif (hasPathCore(matrix, rows, cols, str, path, visited))\nreturn true ;\n}\n}\n\nreturn false ;\n}\n\nNow let us analyze how to explore a path in details. Supposing we have already found k characters on a path, and we are going to explore the next step. We stand at the cell corresponding to the k th character of the path, and check whether the character in its neighboring cell at up, right, down, and left side is identical to the ( k +1) th character of the string.\n\nIf there is a neighboring cell whose value is identical to the ( k +1) th character of the string, we continue exploring the next step.\n\nIf there is no such a neighboring cell whose value is identical to the ( k +1) th character of the string, it means the cell corresponding to the k th character should not on a path. Therefore, we pop it off a path, and start to explore other directions on the ( k -1) th character.\n\nBased on the analysis above, the function hasPathCore can be defined as:\n\nbool hasPathCore( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited)\n{\nif (str[path.size()] == '\\0' )\nreturn true ;\n\nif (getNext(matrix, rows, cols, str, path, visited, 0))\nreturn hasPathCore(matrix, rows, cols, str, path, visited);\n\nbool hasNext = popAndGetNext(matrix, rows, cols, str, path, visited);\nwhile (!hasNext && !path.empty())\nhasNext = popAndGetNext(matrix, rows, cols, str, path, visited);\n\nif (!path.empty())\nreturn hasPathCore(matrix, rows, cols, str, path, visited);\n\nreturn false ;\n}\n\nThe function getNext is defined to explore the ( k +1) th character on a path. When it returns true , it means the ( k +1) th character on a path has been found. Otherwise, we have to pop the k th character off. The function getNext is implemented as below:\n\nbool getNext( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited, int start)\n{\nfor ( int i = start; i < sizeof (dir) / sizeof (Position); ++i)\n{\nPosition next = {path.top().x + dir[i].x, path.top().y + dir[i].y};\nif (next.x >= 0 && next.x < cols\n&& next.y >=0 && next.y < rows\n&& matrix[next.y * cols + next.x] == str[path.size()]\n&& !visited[next.y * cols + next.x])\n{\npath.push(next);\nvisited[next.y * cols + next.x] = true ;\n\nreturn true ;\n}\n}\n\nreturn false ;\n}\n\nWhen we found that the k th character should not be on a path, we call the function popAndGetNext to pop it off, and try on other directions from the ( k -1) th character. This function is implemented as below:\n\nbool popAndGetNext( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited)\n{\nPosition toBePoped = path.top();\npath.pop();\nvisited[toBePoped.y * cols + toBePoped.x] = false ;\n\nbool hasNext = false ;\nif (path.size() >= 1)\n{\nPosition previous = path.top();\nint deltaX = toBePoped.x - previous.x;\nint deltaY = toBePoped.y - previous.y;\nfor ( int i = 0; (i < sizeof (dir) / sizeof (Position) && !hasNext); ++i)\n{\nif (deltaX != dir[i].x || deltaY != dir[i].y)\ncontinue ;\n\nhasNext = getNext(matrix, rows, cols, str, path, visited, i + 1);\n}\n}\n\nreturn hasNext;", "question": "\nQuestion: How to implement a function to check whether there is a path for a string in a matrix of characters?\u00a0 It moves to left, right, up and down in a matrix, and a cell for a movement. The path can start from any entry in a matrix. If a cell is occupied by a character of a string on the path, it cannot be occupied by another character again.\n\nFor example, the matrix below with three rows and four columns has a path for the string \u201cBCCED\u201d (as highlighted in the matrix). It does not have a path for the string \u201cABCB\u201d, because the first \u201cB\u201d in the string occupies the \u201cB\u201d cell in the matrix, and the second \u201cB\u201d in the string cannot enter into the same cell again.\n\nA\nB\nC\nE\nS\nF\nC\nS\nA\nD\nE\nE\n"},
{"answer": "\nAnalysis: It is a typical problem about backtracking, which can be solved by storing a path into a stack.\n\nFirstly, it is necessary to define a structure for 2-D positions, as below:\n\nstruct Position\n{\nint x;\nint y;\n};\n\nThe movements of four directions can be defined accordingly:\n\nPosition up = {0, -1};\nPosition right = {1, 0};\nPosition down = {0, 1};\nPosition left = {-1, 0};\nPosition dir[] ={up, right, down, left};\n\nSince paths can start from any entry in a matrix, we have to scan every cell to check whether the character in it is identical to the first character of the string. If it is identical, we begin to explore a path from such a cell.\n\nA path is defined as a stack. When a cell on path is found, we push its position into the stack. Additionally, we also define a matrix of Boolean masks to void entering a cell twice, which is denoted as visited . Based on these considerations, the skeleton of solution can be implemented as the following:\n\nbool hasPath( char * matrix, int rows, int cols, char * str)\n{\nif (matrix == NULL || rows < 1 || cols < 1 || str == NULL)\nreturn false ;\n\nbool *visited = new bool [rows * cols];\nmemset(visited, 0, rows * cols);\n\nfor ( int row = 0; row < rows; ++row)\n{\nfor ( int column = 0; column < cols; ++column)\n{\nif (matrix[row * cols + column] != str[0])\ncontinue ;\n\nstd::stack<Position> path;\nPosition position = {column, row};\npath.push(position);\nvisited[row * cols + column] = true ;\n\nif (hasPathCore(matrix, rows, cols, str, path, visited))\nreturn true ;\n}\n}\n\nreturn false ;\n}\n\nNow let us analyze how to explore a path in details. Supposing we have already found k characters on a path, and we are going to explore the next step. We stand at the cell corresponding to the k th character of the path, and check whether the character in its neighboring cell at up, right, down, and left side is identical to the ( k +1) th character of the string.\n\nIf there is a neighboring cell whose value is identical to the ( k +1) th character of the string, we continue exploring the next step.\n\nIf there is no such a neighboring cell whose value is identical to the ( k +1) th character of the string, it means the cell corresponding to the k th character should not on a path. Therefore, we pop it off a path, and start to explore other directions on the ( k -1) th character.\n\nBased on the analysis above, the function hasPathCore can be defined as:\n\nbool hasPathCore( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited)\n{\nif (str[path.size()] == '\\0' )\nreturn true ;\n\nif (getNext(matrix, rows, cols, str, path, visited, 0))\nreturn hasPathCore(matrix, rows, cols, str, path, visited);\n\nbool hasNext = popAndGetNext(matrix, rows, cols, str, path, visited);\nwhile (!hasNext && !path.empty())\nhasNext = popAndGetNext(matrix, rows, cols, str, path, visited);\n\nif (!path.empty())\nreturn hasPathCore(matrix, rows, cols, str, path, visited);\n\nreturn false ;\n}\n\nThe function getNext is defined to explore the ( k +1) th character on a path. When it returns true , it means the ( k +1) th character on a path has been found. Otherwise, we have to pop the k th character off. The function getNext is implemented as below:\n\nbool getNext( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited, int start)\n{\nfor ( int i = start; i < sizeof (dir) / sizeof (Position); ++i)\n{\nPosition next = {path.top().x + dir[i].x, path.top().y + dir[i].y};\nif (next.x >= 0 && next.x < cols\n&& next.y >=0 && next.y < rows\n&& matrix[next.y * cols + next.x] == str[path.size()]\n&& !visited[next.y * cols + next.x])\n{\npath.push(next);\nvisited[next.y * cols + next.x] = true ;\n\nreturn true ;\n}\n}\n\nreturn false ;\n}\n\nWhen we found that the k th character should not be on a path, we call the function popAndGetNext to pop it off, and try on other directions from the ( k -1) th character. This function is implemented as below:\n\nbool popAndGetNext( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited)\n{\nPosition toBePoped = path.top();\npath.pop();\nvisited[toBePoped.y * cols + toBePoped.x] = false ;\n\nbool hasNext = false ;\nif (path.size() >= 1)\n{\nPosition previous = path.top();\nint deltaX = toBePoped.x - previous.x;\nint deltaY = toBePoped.y - previous.y;\nfor ( int i = 0; (i < sizeof (dir) / sizeof (Position) && !hasNext); ++i)\n{\nif (deltaX != dir[i].x || deltaY != dir[i].y)\ncontinue ;\n\nhasNext = getNext(matrix, rows, cols, str, path, visited, i + 1);\n}\n}\n\nreturn hasNext;", "question": "\nQuestion: How to implement a function to check whether there is a path for a string in a matrix of characters?\u00a0 It moves to left, right, up and down in a matrix, and a cell for a movement. The path can start from any entry in a matrix. If a cell is occupied by a character of a string on the path, it cannot be occupied by another character again.\n\nFor example, the matrix below with three rows and four columns has a path for the string \u201cBCCED\u201d (as highlighted in the matrix). It does not have a path for the string \u201cABCB\u201d, because the first \u201cB\u201d in the string occupies the \u201cB\u201d cell in the matrix, and the second \u201cB\u201d in the string cannot enter into the same cell again.\n\nA\nB\nC\nE\nS\nF\nC\nS\nA\nD\nE\nE\n"},
{"answer": "\nAnalysis: It is a typical problem about backtracking, which can be solved by storing a path into a stack.\n\nFirstly, it is necessary to define a structure for 2-D positions, as below:\n\nstruct Position\n{\nint x;\nint y;\n};\n\nThe movements of four directions can be defined accordingly:\n\nPosition up = {0, -1};\nPosition right = {1, 0};\nPosition down = {0, 1};\nPosition left = {-1, 0};\nPosition dir[] ={up, right, down, left};\n\nSince paths can start from any entry in a matrix, we have to scan every cell to check whether the character in it is identical to the first character of the string. If it is identical, we begin to explore a path from such a cell.\n\nA path is defined as a stack. When a cell on path is found, we push its position into the stack. Additionally, we also define a matrix of Boolean masks to void entering a cell twice, which is denoted as visited . Based on these considerations, the skeleton of solution can be implemented as the following:\n\nbool hasPath( char * matrix, int rows, int cols, char * str)\n{\nif (matrix == NULL || rows < 1 || cols < 1 || str == NULL)\nreturn false ;\n\nbool *visited = new bool [rows * cols];\nmemset(visited, 0, rows * cols);\n\nfor ( int row = 0; row < rows; ++row)\n{\nfor ( int column = 0; column < cols; ++column)\n{\nif (matrix[row * cols + column] != str[0])\ncontinue ;\n\nstd::stack<Position> path;\nPosition position = {column, row};\npath.push(position);\nvisited[row * cols + column] = true ;\n\nif (hasPathCore(matrix, rows, cols, str, path, visited))\nreturn true ;\n}\n}\n\nreturn false ;\n}\n\nNow let us analyze how to explore a path in details. Supposing we have already found k characters on a path, and we are going to explore the next step. We stand at the cell corresponding to the k th character of the path, and check whether the character in its neighboring cell at up, right, down, and left side is identical to the ( k +1) th character of the string.\n\nIf there is a neighboring cell whose value is identical to the ( k +1) th character of the string, we continue exploring the next step.\n\nIf there is no such a neighboring cell whose value is identical to the ( k +1) th character of the string, it means the cell corresponding to the k th character should not on a path. Therefore, we pop it off a path, and start to explore other directions on the ( k -1) th character.\n\nBased on the analysis above, the function hasPathCore can be defined as:\n\nbool hasPathCore( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited)\n{\nif (str[path.size()] == '\\0' )\nreturn true ;\n\nif (getNext(matrix, rows, cols, str, path, visited, 0))\nreturn hasPathCore(matrix, rows, cols, str, path, visited);\n\nbool hasNext = popAndGetNext(matrix, rows, cols, str, path, visited);\nwhile (!hasNext && !path.empty())\nhasNext = popAndGetNext(matrix, rows, cols, str, path, visited);\n\nif (!path.empty())\nreturn hasPathCore(matrix, rows, cols, str, path, visited);\n\nreturn false ;\n}\n\nThe function getNext is defined to explore the ( k +1) th character on a path. When it returns true , it means the ( k +1) th character on a path has been found. Otherwise, we have to pop the k th character off. The function getNext is implemented as below:\n\nbool getNext( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited, int start)\n{\nfor ( int i = start; i < sizeof (dir) / sizeof (Position); ++i)\n{\nPosition next = {path.top().x + dir[i].x, path.top().y + dir[i].y};\nif (next.x >= 0 && next.x < cols\n&& next.y >=0 && next.y < rows\n&& matrix[next.y * cols + next.x] == str[path.size()]\n&& !visited[next.y * cols + next.x])\n{\npath.push(next);\nvisited[next.y * cols + next.x] = true ;\n\nreturn true ;\n}\n}\n\nreturn false ;\n}\n\nWhen we found that the k th character should not be on a path, we call the function popAndGetNext to pop it off, and try on other directions from the ( k -1) th character. This function is implemented as below:\n\nbool popAndGetNext( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited)\n{\nPosition toBePoped = path.top();\npath.pop();\nvisited[toBePoped.y * cols + toBePoped.x] = false ;\n\nbool hasNext = false ;\nif (path.size() >= 1)\n{\nPosition previous = path.top();\nint deltaX = toBePoped.x - previous.x;\nint deltaY = toBePoped.y - previous.y;\nfor ( int i = 0; (i < sizeof (dir) / sizeof (Position) && !hasNext); ++i)\n{\nif (deltaX != dir[i].x || deltaY != dir[i].y)\ncontinue ;\n\nhasNext = getNext(matrix, rows, cols, str, path, visited, i + 1);\n}\n}\n\nreturn hasNext;", "question": "\nQuestion: How to implement a function to check whether there is a path for a string in a matrix of characters?\u00a0 It moves to left, right, up and down in a matrix, and a cell for a movement. The path can start from any entry in a matrix. If a cell is occupied by a character of a string on the path, it cannot be occupied by another character again.\n\nFor example, the matrix below with three rows and four columns has a path for the string \u201cBCCED\u201d (as highlighted in the matrix). It does not have a path for the string \u201cABCB\u201d, because the first \u201cB\u201d in the string occupies the \u201cB\u201d cell in the matrix, and the second \u201cB\u201d in the string cannot enter into the same cell again.\n\nA\nB\nC\nE\nS\nF\nC\nS\nA\nD\nE\nE\n"},
{"answer": "\nAnalysis: It is a typical problem about backtracking, which can be solved by storing a path into a stack.\n\nFirstly, it is necessary to define a structure for 2-D positions, as below:\n\nstruct Position\n{\nint x;\nint y;\n};\n\nThe movements of four directions can be defined accordingly:\n\nPosition up = {0, -1};\nPosition right = {1, 0};\nPosition down = {0, 1};\nPosition left = {-1, 0};\nPosition dir[] ={up, right, down, left};\n\nSince paths can start from any entry in a matrix, we have to scan every cell to check whether the character in it is identical to the first character of the string. If it is identical, we begin to explore a path from such a cell.\n\nA path is defined as a stack. When a cell on path is found, we push its position into the stack. Additionally, we also define a matrix of Boolean masks to void entering a cell twice, which is denoted as visited . Based on these considerations, the skeleton of solution can be implemented as the following:\n\nbool hasPath( char * matrix, int rows, int cols, char * str)\n{\nif (matrix == NULL || rows < 1 || cols < 1 || str == NULL)\nreturn false ;\n\nbool *visited = new bool [rows * cols];\nmemset(visited, 0, rows * cols);\n\nfor ( int row = 0; row < rows; ++row)\n{\nfor ( int column = 0; column < cols; ++column)\n{\nif (matrix[row * cols + column] != str[0])\ncontinue ;\n\nstd::stack<Position> path;\nPosition position = {column, row};\npath.push(position);\nvisited[row * cols + column] = true ;\n\nif (hasPathCore(matrix, rows, cols, str, path, visited))\nreturn true ;\n}\n}\n\nreturn false ;\n}\n\nNow let us analyze how to explore a path in details. Supposing we have already found k characters on a path, and we are going to explore the next step. We stand at the cell corresponding to the k th character of the path, and check whether the character in its neighboring cell at up, right, down, and left side is identical to the ( k +1) th character of the string.\n\nIf there is a neighboring cell whose value is identical to the ( k +1) th character of the string, we continue exploring the next step.\n\nIf there is no such a neighboring cell whose value is identical to the ( k +1) th character of the string, it means the cell corresponding to the k th character should not on a path. Therefore, we pop it off a path, and start to explore other directions on the ( k -1) th character.\n\nBased on the analysis above, the function hasPathCore can be defined as:\n\nbool hasPathCore( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited)\n{\nif (str[path.size()] == '\\0' )\nreturn true ;\n\nif (getNext(matrix, rows, cols, str, path, visited, 0))\nreturn hasPathCore(matrix, rows, cols, str, path, visited);\n\nbool hasNext = popAndGetNext(matrix, rows, cols, str, path, visited);\nwhile (!hasNext && !path.empty())\nhasNext = popAndGetNext(matrix, rows, cols, str, path, visited);\n\nif (!path.empty())\nreturn hasPathCore(matrix, rows, cols, str, path, visited);\n\nreturn false ;\n}\n\nThe function getNext is defined to explore the ( k +1) th character on a path. When it returns true , it means the ( k +1) th character on a path has been found. Otherwise, we have to pop the k th character off. The function getNext is implemented as below:\n\nbool getNext( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited, int start)\n{\nfor ( int i = start; i < sizeof (dir) / sizeof (Position); ++i)\n{\nPosition next = {path.top().x + dir[i].x, path.top().y + dir[i].y};\nif (next.x >= 0 && next.x < cols\n&& next.y >=0 && next.y < rows\n&& matrix[next.y * cols + next.x] == str[path.size()]\n&& !visited[next.y * cols + next.x])\n{\npath.push(next);\nvisited[next.y * cols + next.x] = true ;\n\nreturn true ;\n}\n}\n\nreturn false ;\n}\n\nWhen we found that the k th character should not be on a path, we call the function popAndGetNext to pop it off, and try on other directions from the ( k -1) th character. This function is implemented as below:\n\nbool popAndGetNext( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited)\n{\nPosition toBePoped = path.top();\npath.pop();\nvisited[toBePoped.y * cols + toBePoped.x] = false ;\n\nbool hasNext = false ;\nif (path.size() >= 1)\n{\nPosition previous = path.top();\nint deltaX = toBePoped.x - previous.x;\nint deltaY = toBePoped.y - previous.y;\nfor ( int i = 0; (i < sizeof (dir) / sizeof (Position) && !hasNext); ++i)\n{\nif (deltaX != dir[i].x || deltaY != dir[i].y)\ncontinue ;\n\nhasNext = getNext(matrix, rows, cols, str, path, visited, i + 1);\n}\n}\n\nreturn hasNext;", "question": "\nQuestion: How to implement a function to check whether there is a path for a string in a matrix of characters?\u00a0 It moves to left, right, up and down in a matrix, and a cell for a movement. The path can start from any entry in a matrix. If a cell is occupied by a character of a string on the path, it cannot be occupied by another character again.\n\nFor example, the matrix below with three rows and four columns has a path for the string \u201cBCCED\u201d (as highlighted in the matrix). It does not have a path for the string \u201cABCB\u201d, because the first \u201cB\u201d in the string occupies the \u201cB\u201d cell in the matrix, and the second \u201cB\u201d in the string cannot enter into the same cell again.\n\nA\nB\nC\nE\nS\nF\nC\nS\nA\nD\nE\nE\n"},
{"answer": "\nAnalysis: It is a typical problem about backtracking, which can be solved by storing a path into a stack.\n\nFirstly, it is necessary to define a structure for 2-D positions, as below:\n\nstruct Position\n{\nint x;\nint y;\n};\n\nThe movements of four directions can be defined accordingly:\n\nPosition up = {0, -1};\nPosition right = {1, 0};\nPosition down = {0, 1};\nPosition left = {-1, 0};\nPosition dir[] ={up, right, down, left};\n\nSince paths can start from any entry in a matrix, we have to scan every cell to check whether the character in it is identical to the first character of the string. If it is identical, we begin to explore a path from such a cell.\n\nA path is defined as a stack. When a cell on path is found, we push its position into the stack. Additionally, we also define a matrix of Boolean masks to void entering a cell twice, which is denoted as visited . Based on these considerations, the skeleton of solution can be implemented as the following:\n\nbool hasPath( char * matrix, int rows, int cols, char * str)\n{\nif (matrix == NULL || rows < 1 || cols < 1 || str == NULL)\nreturn false ;\n\nbool *visited = new bool [rows * cols];\nmemset(visited, 0, rows * cols);\n\nfor ( int row = 0; row < rows; ++row)\n{\nfor ( int column = 0; column < cols; ++column)\n{\nif (matrix[row * cols + column] != str[0])\ncontinue ;\n\nstd::stack<Position> path;\nPosition position = {column, row};\npath.push(position);\nvisited[row * cols + column] = true ;\n\nif (hasPathCore(matrix, rows, cols, str, path, visited))\nreturn true ;\n}\n}\n\nreturn false ;\n}\n\nNow let us analyze how to explore a path in details. Supposing we have already found k characters on a path, and we are going to explore the next step. We stand at the cell corresponding to the k th character of the path, and check whether the character in its neighboring cell at up, right, down, and left side is identical to the ( k +1) th character of the string.\n\nIf there is a neighboring cell whose value is identical to the ( k +1) th character of the string, we continue exploring the next step.\n\nIf there is no such a neighboring cell whose value is identical to the ( k +1) th character of the string, it means the cell corresponding to the k th character should not on a path. Therefore, we pop it off a path, and start to explore other directions on the ( k -1) th character.\n\nBased on the analysis above, the function hasPathCore can be defined as:\n\nbool hasPathCore( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited)\n{\nif (str[path.size()] == '\\0' )\nreturn true ;\n\nif (getNext(matrix, rows, cols, str, path, visited, 0))\nreturn hasPathCore(matrix, rows, cols, str, path, visited);\n\nbool hasNext = popAndGetNext(matrix, rows, cols, str, path, visited);\nwhile (!hasNext && !path.empty())\nhasNext = popAndGetNext(matrix, rows, cols, str, path, visited);\n\nif (!path.empty())\nreturn hasPathCore(matrix, rows, cols, str, path, visited);\n\nreturn false ;\n}\n\nThe function getNext is defined to explore the ( k +1) th character on a path. When it returns true , it means the ( k +1) th character on a path has been found. Otherwise, we have to pop the k th character off. The function getNext is implemented as below:\n\nbool getNext( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited, int start)\n{\nfor ( int i = start; i < sizeof (dir) / sizeof (Position); ++i)\n{\nPosition next = {path.top().x + dir[i].x, path.top().y + dir[i].y};\nif (next.x >= 0 && next.x < cols\n&& next.y >=0 && next.y < rows\n&& matrix[next.y * cols + next.x] == str[path.size()]\n&& !visited[next.y * cols + next.x])\n{\npath.push(next);\nvisited[next.y * cols + next.x] = true ;\n\nreturn true ;\n}\n}\n\nreturn false ;\n}\n\nWhen we found that the k th character should not be on a path, we call the function popAndGetNext to pop it off, and try on other directions from the ( k -1) th character. This function is implemented as below:\n\nbool popAndGetNext( char * matrix, int rows, int cols, char * str, std::stack<Position>& path, bool * visited)\n{\nPosition toBePoped = path.top();\npath.pop();\nvisited[toBePoped.y * cols + toBePoped.x] = false ;\n\nbool hasNext = false ;\nif (path.size() >= 1)\n{\nPosition previous = path.top();\nint deltaX = toBePoped.x - previous.x;\nint deltaY = toBePoped.y - previous.y;\nfor ( int i = 0; (i < sizeof (dir) / sizeof (Position) && !hasNext); ++i)\n{\nif (deltaX != dir[i].x || deltaY != dir[i].y)\ncontinue ;\n\nhasNext = getNext(matrix, rows, cols, str, path, visited, i + 1);\n}\n}\n\nreturn hasNext;", "question": "\nQuestion: How to implement a function to check whether there is a path for a string in a matrix of characters?\u00a0 It moves to left, right, up and down in a matrix, and a cell for a movement. The path can start from any entry in a matrix. If a cell is occupied by a character of a string on the path, it cannot be occupied by another character again.\n\nFor example, the matrix below with three rows and four columns has a path for the string \u201cBCCED\u201d (as highlighted in the matrix). It does not have a path for the string \u201cABCB\u201d, because the first \u201cB\u201d in the string occupies the \u201cB\u201d cell in the matrix, and the second \u201cB\u201d in the string cannot enter into the same cell again.\n\nA\nB\nC\nE\nS\nF\nC\nS\nA\nD\nE\nE\n"},
{"answer": "\nAnalysis: In a list with n nodes, its k th node from end should be the (n-k+1) th node from its head. Therefore, if we know the number of nodes n in a list, we can get the required node with n-k+1 steps from its head. How to get the number n? It is easy if we scan the whole list from beginning to end.\n\nThe solution above needs to scan a list twice: We get the total number of nodes with the first scan, and reach the k th node from end with the second scan. Unfortunately, interviewers usually expect a solution which only scans a list once.\n\nWe have a better solution to get the k th node from end with two pointers. Firstly we move a pointer (denoted as P1) k-1 steps beginning from the head of a list. And then we move another pointer (denoted as P2) beginning from the head, and continue moving the P1 forward at same speed. Since the distance of these two pointers is always k-1, P2 reaches the k th node from end when P1 reaches the tail of a list. It scans a list only once, and it is more efficient than the previous solution.\n\n\n\nFigure 1: Get the 3 rd node from end of a list with 6 nodes\n\nIt simulates the process to get the 3 rd node from end of a list with 6 nodes in Figure 1. We firstly move P1 2 steps (2=3-1) to reach the 3 rd node (Figure 1-a). Then P2 points to the head of a list (Figure 1-b). We move two pointers at the same speed, when the P1 reaches the tail, what P2 points is the 3 rd node from end (Figure 1-c).\n\nThe sample code of the solutions with two pointers is shown below:\n\nListNode* FindKthToTail(ListNode* pListHead, unsigned int k)\n{\nif (pListHead == NULL || k == 0)\nreturn NULL;\n\nListNode *pAhead = pListHead;\nListNode *pBehind = NULL;\n\nfor ( unsigned int i = 0; i < k - 1; ++ i)\n{\nif (pAhead->m_pNext != NULL)\npAhead = pAhead->m_pNext;\nelse\n{\nreturn NULL;\n}\n}\n\npBehind = pListHead;\nwhile (pAhead->m_pNext != NULL)\n{\npAhead = pAhead->m_pNext;\npBehind = pBehind->m_pNext;\n}\n\nreturn pBehind;", "question": "\nProblem: Get the K th node from end of a linked list. It counts from 1 here, so the 1 st node from end is the tail of list.\n\nFor instance, given a linked list with 6 nodes, whose value are 1, 2, 3, 4, 5, 6, its 3 rd node from end is the node with value 4.\n\nA node in the list is defined as:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: An intuitive solution for this problem is to check whether every number in the first array (denoted as array1 ) is in the second array (denoted as array2 ). If the length of array1 is m , and the length of array2 is n , its overall time complexity is O( m * n ) based on linear search. We have two better solutions.\n\nSolution 1: With O( m + n ) Time\n\nIt is noticeable that the two input arrays are sorted. Supposing a number number1 in array1 equals to a number number2 in array2 , the numbers after number1 in array1 should be greater than the numbers before number2 in array2 . Therefore, it is not necessary to compare the numbers after number1 in array1 with numbers before number2 in array2 . It improves efficiency since many comparisons are eliminated.\n\nThe sample code for this solution is shown below:\n\nvoid GetIntersection_solution1( const vector< int >& array1,\nconst vector< int >& array2,\nvector< int >& intersection)\n{\nvector< int >::const_iterator iter1 = array1.begin();\nvector< int >::const_iterator iter2 = array2.begin();\n\nintersection.clear();\n\nwhile (iter1 != array1.end() && iter2 != array2.end())\n{\nif (*iter1 == *iter2)\n{\nintersection.push_back(*iter1);\n++ iter1;\n++ iter2;\n}\nelse if (*iter1 < *iter2)\n++ iter1;\nelse\n++ iter2;\n}\n}\n\nSince it only requires to scan two arrays once, its time complexity is O( m + n ).\n\nSolution 2: With O( n log m ) Time\n\nAs we know, a binary search algorithm requires O(log m ) time to find a number in an array with length m . Therefore, if we search each number of an array with length n from an array with length m , its overall time complexity is O( n log m ). If m is much greater than n , O( n log m ) is actually less than O( m + n ). Therefore, we can implement a new and better solution based on binary search in such a situation.\n\nFor instance, the following same code is suitable when array1 is much longer than array2 .\n\n/* === Supposing array1 is much longer than array2 === */\nvoid GetIntersection_solution2( const vector< int >& array1,\nconst vector< int >& array2,\nvector< int >& intersection)\n{\nintersection.clear();\n\nvector< int >::const_iterator iter1 = array1.begin();\nwhile (iter1 != array1.end())\n{\nif (binary_search(array2.begin(), array2.end(), *iter1))\nintersection.push_back(*iter1);\n}\n}", "question": "\nProblem: Please implement a function which gets the intersection of two sorted arrays. Assuming numbers in each array are unique.\n\nFor example, if the two sorted arrays as input are {1, 4, 7, 10, 13} and {1, 3, 5, 7, 9}, it returns an intersection array with numbers {1, 7}.\n"},
{"answer": "\nAnalysis: An intuitive solution for this problem is to check whether every number in the first array (denoted as array1 ) is in the second array (denoted as array2 ). If the length of array1 is m , and the length of array2 is n , its overall time complexity is O( m * n ) based on linear search. We have two better solutions.\n\nSolution 1: With O( m + n ) Time\n\nIt is noticeable that the two input arrays are sorted. Supposing a number number1 in array1 equals to a number number2 in array2 , the numbers after number1 in array1 should be greater than the numbers before number2 in array2 . Therefore, it is not necessary to compare the numbers after number1 in array1 with numbers before number2 in array2 . It improves efficiency since many comparisons are eliminated.\n\nThe sample code for this solution is shown below:\n\nvoid GetIntersection_solution1( const vector< int >& array1,\nconst vector< int >& array2,\nvector< int >& intersection)\n{\nvector< int >::const_iterator iter1 = array1.begin();\nvector< int >::const_iterator iter2 = array2.begin();\n\nintersection.clear();\n\nwhile (iter1 != array1.end() && iter2 != array2.end())\n{\nif (*iter1 == *iter2)\n{\nintersection.push_back(*iter1);\n++ iter1;\n++ iter2;\n}\nelse if (*iter1 < *iter2)\n++ iter1;\nelse\n++ iter2;\n}\n}\n\nSince it only requires to scan two arrays once, its time complexity is O( m + n ).\n\nSolution 2: With O( n log m ) Time\n\nAs we know, a binary search algorithm requires O(log m ) time to find a number in an array with length m . Therefore, if we search each number of an array with length n from an array with length m , its overall time complexity is O( n log m ). If m is much greater than n , O( n log m ) is actually less than O( m + n ). Therefore, we can implement a new and better solution based on binary search in such a situation.\n\nFor instance, the following same code is suitable when array1 is much longer than array2 .\n\n/* === Supposing array1 is much longer than array2 === */\nvoid GetIntersection_solution2( const vector< int >& array1,\nconst vector< int >& array2,\nvector< int >& intersection)\n{\nintersection.clear();\n\nvector< int >::const_iterator iter1 = array1.begin();\nwhile (iter1 != array1.end())\n{\nif (binary_search(array2.begin(), array2.end(), *iter1))\nintersection.push_back(*iter1);\n}\n}", "question": "\nProblem: Please implement a function which gets the intersection of two sorted arrays. Assuming numbers in each array are unique.\n\nFor example, if the two sorted arrays as input are {1, 4, 7, 10, 13} and {1, 3, 5, 7, 9}, it returns an intersection array with numbers {1, 7}.\n"},
{"answer": "\nAnalysis: An intuitive solution for this problem is to check whether every number in the first array (denoted as array1 ) is in the second array (denoted as array2 ). If the length of array1 is m , and the length of array2 is n , its overall time complexity is O( m * n ) based on linear search. We have two better solutions.\n\nSolution 1: With O( m + n ) Time\n\nIt is noticeable that the two input arrays are sorted. Supposing a number number1 in array1 equals to a number number2 in array2 , the numbers after number1 in array1 should be greater than the numbers before number2 in array2 . Therefore, it is not necessary to compare the numbers after number1 in array1 with numbers before number2 in array2 . It improves efficiency since many comparisons are eliminated.\n\nThe sample code for this solution is shown below:\n\nvoid GetIntersection_solution1( const vector< int >& array1,\nconst vector< int >& array2,\nvector< int >& intersection)\n{\nvector< int >::const_iterator iter1 = array1.begin();\nvector< int >::const_iterator iter2 = array2.begin();\n\nintersection.clear();\n\nwhile (iter1 != array1.end() && iter2 != array2.end())\n{\nif (*iter1 == *iter2)\n{\nintersection.push_back(*iter1);\n++ iter1;\n++ iter2;\n}\nelse if (*iter1 < *iter2)\n++ iter1;\nelse\n++ iter2;\n}\n}\n\nSince it only requires to scan two arrays once, its time complexity is O( m + n ).\n\nSolution 2: With O( n log m ) Time\n\nAs we know, a binary search algorithm requires O(log m ) time to find a number in an array with length m . Therefore, if we search each number of an array with length n from an array with length m , its overall time complexity is O( n log m ). If m is much greater than n , O( n log m ) is actually less than O( m + n ). Therefore, we can implement a new and better solution based on binary search in such a situation.\n\nFor instance, the following same code is suitable when array1 is much longer than array2 .\n\n/* === Supposing array1 is much longer than array2 === */\nvoid GetIntersection_solution2( const vector< int >& array1,\nconst vector< int >& array2,\nvector< int >& intersection)\n{\nintersection.clear();\n\nvector< int >::const_iterator iter1 = array1.begin();\nwhile (iter1 != array1.end())\n{\nif (binary_search(array2.begin(), array2.end(), *iter1))\nintersection.push_back(*iter1);\n}\n}", "question": "\nProblem: Please implement a function which gets the intersection of two sorted arrays. Assuming numbers in each array are unique.\n\nFor example, if the two sorted arrays as input are {1, 4, 7, 10, 13} and {1, 3, 5, 7, 9}, it returns an intersection array with numbers {1, 7}.\n"},
{"answer": "\nAnalysis: An intuitive solution for this problem is to check whether every number in the first array (denoted as array1 ) is in the second array (denoted as array2 ). If the length of array1 is m , and the length of array2 is n , its overall time complexity is O( m * n ) based on linear search. We have two better solutions.\n\nSolution 1: With O( m + n ) Time\n\nIt is noticeable that the two input arrays are sorted. Supposing a number number1 in array1 equals to a number number2 in array2 , the numbers after number1 in array1 should be greater than the numbers before number2 in array2 . Therefore, it is not necessary to compare the numbers after number1 in array1 with numbers before number2 in array2 . It improves efficiency since many comparisons are eliminated.\n\nThe sample code for this solution is shown below:\n\nvoid GetIntersection_solution1( const vector< int >& array1,\nconst vector< int >& array2,\nvector< int >& intersection)\n{\nvector< int >::const_iterator iter1 = array1.begin();\nvector< int >::const_iterator iter2 = array2.begin();\n\nintersection.clear();\n\nwhile (iter1 != array1.end() && iter2 != array2.end())\n{\nif (*iter1 == *iter2)\n{\nintersection.push_back(*iter1);\n++ iter1;\n++ iter2;\n}\nelse if (*iter1 < *iter2)\n++ iter1;\nelse\n++ iter2;\n}\n}\n\nSince it only requires to scan two arrays once, its time complexity is O( m + n ).\n\nSolution 2: With O( n log m ) Time\n\nAs we know, a binary search algorithm requires O(log m ) time to find a number in an array with length m . Therefore, if we search each number of an array with length n from an array with length m , its overall time complexity is O( n log m ). If m is much greater than n , O( n log m ) is actually less than O( m + n ). Therefore, we can implement a new and better solution based on binary search in such a situation.\n\nFor instance, the following same code is suitable when array1 is much longer than array2 .\n\n/* === Supposing array1 is much longer than array2 === */\nvoid GetIntersection_solution2( const vector< int >& array1,\nconst vector< int >& array2,\nvector< int >& intersection)\n{\nintersection.clear();\n\nvector< int >::const_iterator iter1 = array1.begin();\nwhile (iter1 != array1.end())\n{\nif (binary_search(array2.begin(), array2.end(), *iter1))\nintersection.push_back(*iter1);\n}\n}", "question": "\nProblem: Please implement a function which gets the intersection of two sorted arrays. Assuming numbers in each array are unique.\n\nFor example, if the two sorted arrays as input are {1, 4, 7, 10, 13} and {1, 3, 5, 7, 9}, it returns an intersection array with numbers {1, 7}.\n"},
{"answer": "\nAnalysis: An intuitive solution for this problem is to check whether every number in the first array (denoted as array1 ) is in the second array (denoted as array2 ). If the length of array1 is m , and the length of array2 is n , its overall time complexity is O( m * n ) based on linear search. We have two better solutions.\n\nSolution 1: With O( m + n ) Time\n\nIt is noticeable that the two input arrays are sorted. Supposing a number number1 in array1 equals to a number number2 in array2 , the numbers after number1 in array1 should be greater than the numbers before number2 in array2 . Therefore, it is not necessary to compare the numbers after number1 in array1 with numbers before number2 in array2 . It improves efficiency since many comparisons are eliminated.\n\nThe sample code for this solution is shown below:\n\nvoid GetIntersection_solution1( const vector< int >& array1,\nconst vector< int >& array2,\nvector< int >& intersection)\n{\nvector< int >::const_iterator iter1 = array1.begin();\nvector< int >::const_iterator iter2 = array2.begin();\n\nintersection.clear();\n\nwhile (iter1 != array1.end() && iter2 != array2.end())\n{\nif (*iter1 == *iter2)\n{\nintersection.push_back(*iter1);\n++ iter1;\n++ iter2;\n}\nelse if (*iter1 < *iter2)\n++ iter1;\nelse\n++ iter2;\n}\n}\n\nSince it only requires to scan two arrays once, its time complexity is O( m + n ).\n\nSolution 2: With O( n log m ) Time\n\nAs we know, a binary search algorithm requires O(log m ) time to find a number in an array with length m . Therefore, if we search each number of an array with length n from an array with length m , its overall time complexity is O( n log m ). If m is much greater than n , O( n log m ) is actually less than O( m + n ). Therefore, we can implement a new and better solution based on binary search in such a situation.\n\nFor instance, the following same code is suitable when array1 is much longer than array2 .\n\n/* === Supposing array1 is much longer than array2 === */\nvoid GetIntersection_solution2( const vector< int >& array1,\nconst vector< int >& array2,\nvector< int >& intersection)\n{\nintersection.clear();\n\nvector< int >::const_iterator iter1 = array1.begin();\nwhile (iter1 != array1.end())\n{\nif (binary_search(array2.begin(), array2.end(), *iter1))\nintersection.push_back(*iter1);\n}\n}", "question": "\nProblem: Please implement a function which gets the intersection of two sorted arrays. Assuming numbers in each array are unique.\n\nFor example, if the two sorted arrays as input are {1, 4, 7, 10, 13} and {1, 3, 5, 7, 9}, it returns an intersection array with numbers {1, 7}.\n"},
{"answer": "\nAnalysis: An intuitive solution for this problem is to check whether every number in the first array (denoted as array1 ) is in the second array (denoted as array2 ). If the length of array1 is m , and the length of array2 is n , its overall time complexity is O( m * n ) based on linear search. We have two better solutions.\n\nSolution 1: With O( m + n ) Time\n\nIt is noticeable that the two input arrays are sorted. Supposing a number number1 in array1 equals to a number number2 in array2 , the numbers after number1 in array1 should be greater than the numbers before number2 in array2 . Therefore, it is not necessary to compare the numbers after number1 in array1 with numbers before number2 in array2 . It improves efficiency since many comparisons are eliminated.\n\nThe sample code for this solution is shown below:\n\nvoid GetIntersection_solution1( const vector< int >& array1,\nconst vector< int >& array2,\nvector< int >& intersection)\n{\nvector< int >::const_iterator iter1 = array1.begin();\nvector< int >::const_iterator iter2 = array2.begin();\n\nintersection.clear();\n\nwhile (iter1 != array1.end() && iter2 != array2.end())\n{\nif (*iter1 == *iter2)\n{\nintersection.push_back(*iter1);\n++ iter1;\n++ iter2;\n}\nelse if (*iter1 < *iter2)\n++ iter1;\nelse\n++ iter2;\n}\n}\n\nSince it only requires to scan two arrays once, its time complexity is O( m + n ).\n\nSolution 2: With O( n log m ) Time\n\nAs we know, a binary search algorithm requires O(log m ) time to find a number in an array with length m . Therefore, if we search each number of an array with length n from an array with length m , its overall time complexity is O( n log m ). If m is much greater than n , O( n log m ) is actually less than O( m + n ). Therefore, we can implement a new and better solution based on binary search in such a situation.\n\nFor instance, the following same code is suitable when array1 is much longer than array2 .\n\n/* === Supposing array1 is much longer than array2 === */\nvoid GetIntersection_solution2( const vector< int >& array1,\nconst vector< int >& array2,\nvector< int >& intersection)\n{\nintersection.clear();\n\nvector< int >::const_iterator iter1 = array1.begin();\nwhile (iter1 != array1.end())\n{\nif (binary_search(array2.begin(), array2.end(), *iter1))\nintersection.push_back(*iter1);\n}\n}", "question": "\nProblem: Please implement a function which gets the intersection of two sorted arrays. Assuming numbers in each array are unique.\n\nFor example, if the two sorted arrays as input are {1, 4, 7, 10, 13} and {1, 3, 5, 7, 9}, it returns an intersection array with numbers {1, 7}.\n"},
{"answer": "\nAnalysis: An intuitive solution for this problem is to check whether every number in the first array (denoted as array1 ) is in the second array (denoted as array2 ). If the length of array1 is m , and the length of array2 is n , its overall time complexity is O( m * n ) based on linear search. We have two better solutions.\n\nSolution 1: With O( m + n ) Time\n\nIt is noticeable that the two input arrays are sorted. Supposing a number number1 in array1 equals to a number number2 in array2 , the numbers after number1 in array1 should be greater than the numbers before number2 in array2 . Therefore, it is not necessary to compare the numbers after number1 in array1 with numbers before number2 in array2 . It improves efficiency since many comparisons are eliminated.\n\nThe sample code for this solution is shown below:\n\nvoid GetIntersection_solution1( const vector< int >& array1,\nconst vector< int >& array2,\nvector< int >& intersection)\n{\nvector< int >::const_iterator iter1 = array1.begin();\nvector< int >::const_iterator iter2 = array2.begin();\n\nintersection.clear();\n\nwhile (iter1 != array1.end() && iter2 != array2.end())\n{\nif (*iter1 == *iter2)\n{\nintersection.push_back(*iter1);\n++ iter1;\n++ iter2;\n}\nelse if (*iter1 < *iter2)\n++ iter1;\nelse\n++ iter2;\n}\n}\n\nSince it only requires to scan two arrays once, its time complexity is O( m + n ).\n\nSolution 2: With O( n log m ) Time\n\nAs we know, a binary search algorithm requires O(log m ) time to find a number in an array with length m . Therefore, if we search each number of an array with length n from an array with length m , its overall time complexity is O( n log m ). If m is much greater than n , O( n log m ) is actually less than O( m + n ). Therefore, we can implement a new and better solution based on binary search in such a situation.\n\nFor instance, the following same code is suitable when array1 is much longer than array2 .\n\n/* === Supposing array1 is much longer than array2 === */\nvoid GetIntersection_solution2( const vector< int >& array1,\nconst vector< int >& array2,\nvector< int >& intersection)\n{\nintersection.clear();\n\nvector< int >::const_iterator iter1 = array1.begin();\nwhile (iter1 != array1.end())\n{\nif (binary_search(array2.begin(), array2.end(), *iter1))\nintersection.push_back(*iter1);\n}\n}", "question": "\nProblem: Please implement a function which gets the intersection of two sorted arrays. Assuming numbers in each array are unique.\n\nFor example, if the two sorted arrays as input are {1, 4, 7, 10, 13} and {1, 3, 5, 7, 9}, it returns an intersection array with numbers {1, 7}.\n"},
{"answer": "\nAnalysis: The merged shape of overlapping rectangles is no longer a rectangle, and there is no equation to calculate the merged area directly. Therefore, we should split it into a set of rectangles.\nA solution to split overlapping rectangles is based on x-values of all left and right edges. For example, there are three rectangles in Figure 1.\nFigure 1: Three rectangles\n\n\nWe should merge y-values of rectangles in ranges of x-value. For instance, both Rect1 and Rect2 fill into the x-value range between X2 and X3. Therefore, we should merge the y-value range of Rect1 and Rect2 to calculate the rectangle piece between X2 and X3.\nFigure 2: Split rectangles into pieces based on x-values\n\nstruct Range\n{\nint less;\nint greater;\n\nRange( int l, int g)\n{\nless = (l < g) ? l : g;\ngreater = (l + g) - less;\n}\n\nbool IsOverlapping( const Range& other)\n{\nreturn !(less > other.greater || other.less > greater);\n}\n\nvoid Merge( const Range& other)\n{\nif (IsOverlapping(other))\n{\nless = (less < other.less) ? less : other.less;\ngreater = (greater > other.greater) ? greater : other.greater;\n}\n}\n};\n\nThe overall algorithm to calculate the area of overlapping rectangles is: We firstly get all x-values of all rectangles, and then check whether every rectangle fills into each range formed by two neighboring x-values. If there are multiple rectangles fill into an x-value range, we merge their ranges of y-value before we calculate the area of a piece of merged rectangle.\n\nThe following function GetArea implements this algorithm. For optimization purpose, we sort all input rectangles according to their x-values of right edges, and sort a vector of all x-values.\n\nint GetArea(vector<Rect>& rects)\n{\n// sort rectangles according to x-value of right edges\nsort(rects.begin(), rects.end());\n\nvector< int > xes;\nGetAllX(rects, xes);\nsort(xes.begin(), xes.end());\n\nint area = 0;\nvector< int >::iterator iterX1 = xes.begin();\nvector<Rect>::const_iterator iterRect = rects.begin();\nfor (; iterX1 != xes.end() && iterX1 != xes.end() - 1; ++ iterX1)\n{\nvector< int >::iterator iterX2 = iterX1 + 1;\n\n// filter out duplicated X-es\nif (*iterX1 < *iterX2)\n{\nRange rangeX(*iterX1, *iterX2);\n\nwhile (iterRect->right < *iterX1)\n++ iterRect;\n\nlist<Range> rangesOfY;\nGetRangesOfY(rects, iterRect, rangeX, rangesOfY);\narea += GetRectArea(rangeX, rangesOfY);\n}\n}\n\nreturn area;\n}\n\nbool operator < ( const Rect& rect1, const Rect& rect2)\n{\nreturn (rect1.right < rect2.right);\n}\n\nThe following function GetAllX gets all x-values of all input rectangles.\n\nvoid GetAllX( const vector<Rect>& rects, vector< int >& xes)\n{\nvector<Rect>::const_iterator iter = rects.begin();\nfor (; iter != rects.end(); ++ iter)\n{\nxes.push_back(iter->left);\nxes.push_back(iter->right);\n}\n}\n\nThe function GetRangesOfY gets the ranges of y-values which fill into a range of x-value. It should be noticed that there might be multiple non-overlapping rectangles fill into an x-value range. For example, Rect1 and Rect2 in Figure do not overlap with each other. Therefore, we cannot merge their ranges of y-values. That is why it has a list of ranges of y-values for a range of x-value in the function GetRangesOfY .\n\n\nvoid GetRangesOfY( const vector<Rect>& rects, vector<Rect>::const_iterator iterRect, const Range& rangeX, list<Range>& rangesOfY)\n{\nfor (; iterRect != rects.end(); ++ iterRect)\n{\nif (rangeX.less < iterRect->right && rangeX.greater > iterRect->left)\nInsertRangeY(rangesOfY, Range(iterRect->top, iterRect->bottom));\n}\n}\nThe function InsertRangeY inserts a range of y-value into a list. When the range overlaps with another range existing in the list, we should remove the existing range and then insert a new merged range.\nvoid InsertRangeY(list<Range>& rangesOfY, Range& rangeY)\n{\nlist<Range>::iterator iter = rangesOfY.begin();\nwhile (iter != rangesOfY.end())\n{\nif (rangeY.IsOverlapping(*iter))\n{\nrangeY.Merge(*iter);\n\nlist<Range>::iterator iterCopy = iter;\n++ iter;\nrangesOfY.erase(iterCopy);\n}\nelse\n++ iter;\n}\n\nrangesOfY.push_back(rangeY);\n}\n\nThe function GetRectArea below gets the total area of all rectangle pieces in a range of x-value.\n\nint GetRectArea( const Range& rangeX, const list<Range>& rangesOfY)\n{\nint width = rangeX.greater - rangeX.less;\n\nlist<Range>::const_iterator iter = rangesOfY.begin();\nint area = 0;\nfor (; iter != rangesOfY.end(); ++ iter)\n{\nint height = iter->greater - iter->less;\narea += width * height;\n}\n\nreturn area;\n}\n", "question": ""},
{"answer": "\nAnalysis: The na\u00efve solution is sort the n input numbers increasingly, and the least k numbers should be the first k numbers. Since it needs to sort, its time complexity is O(n log n) . Interviewers will ask us explore more efficient solutions.\n\nSolution 1: O( n log k ) time efficiency, be suitable for data with huge size\n\nA data container with capacity k is firstly created to store the least k numbers, and then a number is read out of the n input numbers at each time. \u00a0\u00a0If the container has less than k numbers, the number read at current round (denoted as num ) is inserted into container directly. If it contains k numbers already, num cannot be inserted directly any more. However, it may replace an existing number in the container. \u00a0We get the maximum number of the k numbers in the container, and compare it with num . If num is less than the maximum number, we replace the maximum number with num . Otherwise we discard num , since we already have k numbers in the container which are all less than num and it cannot be one of the least k numbers.\n\nThree steps may be required when a number is read and the container is full: The first step is to find the maximum number, secondly we may delete the maximum number, and at last we may insert a new number. The second and third steps are optional, which depend on whether the number read at current round is greater than the maximum number in container or not. If we implement the data container as a binary tree, it costs O(log k ) time for these three steps. Therefore, the overall time complexity is O( n log k ) for n input numbers.\n\nWe have different choices for the data container. Since we need to get the maximum number out of k numbers, it intuitively might a maximum heap. In a maximum heap, its root is always greater than its children, so it costs O(1) time to get the maximum number. However, it takes O(log k ) time to insert and delete a number.\n\nWe have to write a lot of code for a maximum heap, and it is too difficult in the dozens-of-minute interview. We can also implement it as a red-black tree. A red-black tree classifies its nodes into red and black categories, and assure that it is somewhat balanced based on a set of rules. Therefore, it costs O(log k ) time to find, insert and delete a number. The classes set and multiset in STL are all based on red-black trees. We may use data containers in STL directly if our interviewers are not against it. The following sample code is based on the multiset in STL:\n\ntypedef multiset< int , greater< int > >\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 intSet;\ntypedef multiset< int , greater< int > >::iterator\u00a0 setIterator;\n\nvoid GetLeastNumbers( const vector< int >& data, intSet& leastNumbers, int k)\n{\nleastNumbers.clear();\n\nif (k < 1 || data.size() < k)\nreturn ;\n\nvector< int >::const_iterator iter = data.begin();\nfor (; iter != data.end(); ++ iter)\n{\nif ((leastNumbers.size()) < k)\nleastNumbers.insert(*iter);\n\nelse\n{\nsetIterator iterGreatest = leastNumbers.begin();\n\nif (*iter < *(leastNumbers.begin()))\n{\nleastNumbers.erase(iterGreatest);\nleastNumbers.insert(*iter);\n}\n}\n}\n}\n\nSolution 2: O( n ) time efficiency, be suitable only when we can reorder the input\n\nWe can also utilize the function Partition in quick sort to solve this problem with a hypothesis. It assumes that n input numbers are contained in an array. If it takes the k -th number as a pilot to partition the input array, all of numbers less than the k -th number should be at the left side and other greater ones should be at the right side. The k numbers at the left side are the least k numbers after the partition. We can develop the following code according to this solution:\n\nvoid GetLeastNumbers( int * input, int n, int * output, int k)\n{\nif (input == NULL || output == NULL || k > n || n <= 0 || k <= 0)\nreturn ;\n\nint start = 0;\nint end = n - 1;\nint index = Partition(input, n, start, end);\nwhile (index != k - 1)\n{\nif (index > k - 1)\n{\nend = index - 1;\nindex = Partition(input, n, start, end);\n}\nelse\n{\nstart = index + 1;\nindex = Partition(input, n, start, end);\n}\n}\n\nfor ( int i = 0; i < k; ++i)\noutput[i] = input[i];\n}\n\nComparison between two solutions\n\nThe second solution based on the function Partition costs only O( n ) time, so it is more efficient than the first one. However, it has two obvious limitations: One limitation is that it needs to load all input numbers into an array, and the other is that we have to reorder the input numbers.\nEven though the first takes more time, the second solution does have the two limitations as the first one. It is not required to reorder the input numbers ( data in the code above). We read a number from data at each round, and all write operations are taken in the container leastNumbers . It does not require loading all input number into memory at one time, so it is suitable for huge-size data. Supposing our interview asks us get the least k numbers from a huge-size input. Obviously we cannot load all data with huge size into limited memory at one time. We can read a number from auxiliary space (such as disk) at each round with the first solution, and determine whether we need to insert it into the container leastNumbers . It works once memory can accommodate leastNumbers , so it is especially works when n is huge and k is small.\n\nThe characters of these two solutions can be summarized in Table 1:\n\nFirst Solution Second Solution Time complexity O( n *log k ) O( n ) Reorder input   numbers? No Yes Suitable for   huge-size data? Yes No\n\nFirst Solution\nSecond Solution\nTime complexity\nO( n *log k )\nO( n )\nReorder input   numbers?\nNo\nYes\nSuitable for   huge-size data?\nYes\nNo\nTable 1: Pros and cons of two solutions\n", "question": "\nQuestion: Please find out the least k numbers out of n numbers. For example, if given the 8 numbers 4, 5, 1, 6, 2, 7, 3 and 8, please return the least 4 numbers 1, 2, 3 and 4.\n"},
{"answer": "\nAnalysis: The na\u00efve solution is sort the n input numbers increasingly, and the least k numbers should be the first k numbers. Since it needs to sort, its time complexity is O(n log n) . Interviewers will ask us explore more efficient solutions.\n\nSolution 1: O( n log k ) time efficiency, be suitable for data with huge size\n\nA data container with capacity k is firstly created to store the least k numbers, and then a number is read out of the n input numbers at each time. \u00a0\u00a0If the container has less than k numbers, the number read at current round (denoted as num ) is inserted into container directly. If it contains k numbers already, num cannot be inserted directly any more. However, it may replace an existing number in the container. \u00a0We get the maximum number of the k numbers in the container, and compare it with num . If num is less than the maximum number, we replace the maximum number with num . Otherwise we discard num , since we already have k numbers in the container which are all less than num and it cannot be one of the least k numbers.\n\nThree steps may be required when a number is read and the container is full: The first step is to find the maximum number, secondly we may delete the maximum number, and at last we may insert a new number. The second and third steps are optional, which depend on whether the number read at current round is greater than the maximum number in container or not. If we implement the data container as a binary tree, it costs O(log k ) time for these three steps. Therefore, the overall time complexity is O( n log k ) for n input numbers.\n\nWe have different choices for the data container. Since we need to get the maximum number out of k numbers, it intuitively might a maximum heap. In a maximum heap, its root is always greater than its children, so it costs O(1) time to get the maximum number. However, it takes O(log k ) time to insert and delete a number.\n\nWe have to write a lot of code for a maximum heap, and it is too difficult in the dozens-of-minute interview. We can also implement it as a red-black tree. A red-black tree classifies its nodes into red and black categories, and assure that it is somewhat balanced based on a set of rules. Therefore, it costs O(log k ) time to find, insert and delete a number. The classes set and multiset in STL are all based on red-black trees. We may use data containers in STL directly if our interviewers are not against it. The following sample code is based on the multiset in STL:\n\ntypedef multiset< int , greater< int > >\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 intSet;\ntypedef multiset< int , greater< int > >::iterator\u00a0 setIterator;\n\nvoid GetLeastNumbers( const vector< int >& data, intSet& leastNumbers, int k)\n{\nleastNumbers.clear();\n\nif (k < 1 || data.size() < k)\nreturn ;\n\nvector< int >::const_iterator iter = data.begin();\nfor (; iter != data.end(); ++ iter)\n{\nif ((leastNumbers.size()) < k)\nleastNumbers.insert(*iter);\n\nelse\n{\nsetIterator iterGreatest = leastNumbers.begin();\n\nif (*iter < *(leastNumbers.begin()))\n{\nleastNumbers.erase(iterGreatest);\nleastNumbers.insert(*iter);\n}\n}\n}\n}\n\nSolution 2: O( n ) time efficiency, be suitable only when we can reorder the input\n\nWe can also utilize the function Partition in quick sort to solve this problem with a hypothesis. It assumes that n input numbers are contained in an array. If it takes the k -th number as a pilot to partition the input array, all of numbers less than the k -th number should be at the left side and other greater ones should be at the right side. The k numbers at the left side are the least k numbers after the partition. We can develop the following code according to this solution:\n\nvoid GetLeastNumbers( int * input, int n, int * output, int k)\n{\nif (input == NULL || output == NULL || k > n || n <= 0 || k <= 0)\nreturn ;\n\nint start = 0;\nint end = n - 1;\nint index = Partition(input, n, start, end);\nwhile (index != k - 1)\n{\nif (index > k - 1)\n{\nend = index - 1;\nindex = Partition(input, n, start, end);\n}\nelse\n{\nstart = index + 1;\nindex = Partition(input, n, start, end);\n}\n}\n\nfor ( int i = 0; i < k; ++i)\noutput[i] = input[i];\n}\n\nComparison between two solutions\n\nThe second solution based on the function Partition costs only O( n ) time, so it is more efficient than the first one. However, it has two obvious limitations: One limitation is that it needs to load all input numbers into an array, and the other is that we have to reorder the input numbers.\nEven though the first takes more time, the second solution does have the two limitations as the first one. It is not required to reorder the input numbers ( data in the code above). We read a number from data at each round, and all write operations are taken in the container leastNumbers . It does not require loading all input number into memory at one time, so it is suitable for huge-size data. Supposing our interview asks us get the least k numbers from a huge-size input. Obviously we cannot load all data with huge size into limited memory at one time. We can read a number from auxiliary space (such as disk) at each round with the first solution, and determine whether we need to insert it into the container leastNumbers . It works once memory can accommodate leastNumbers , so it is especially works when n is huge and k is small.\n\nThe characters of these two solutions can be summarized in Table 1:\n\nFirst Solution Second Solution Time complexity O( n *log k ) O( n ) Reorder input   numbers? No Yes Suitable for   huge-size data? Yes No\n\nFirst Solution\nSecond Solution\nTime complexity\nO( n *log k )\nO( n )\nReorder input   numbers?\nNo\nYes\nSuitable for   huge-size data?\nYes\nNo\nTable 1: Pros and cons of two solutions\n", "question": "\nQuestion: Please find out the least k numbers out of n numbers. For example, if given the 8 numbers 4, 5, 1, 6, 2, 7, 3 and 8, please return the least 4 numbers 1, 2, 3 and 4.\n"},
{"answer": "\nAnalysis: An intuitive solution for this problem is to check whether every number in the first array (denoted as array1 ) is in the second array (denoted as array2 ). If the length of array1 is m , and the length of array2 is n , its overall time complexity is O( m * n ) based on linear search. We have two better solutions.\n\nSolution 1: With O( m + n ) Time\n\nIt is noticeable that the two input arrays are sorted. Supposing a number number1 in array1 equals to a number number2 in array2 , the numbers after number1 in array1 should be greater than the numbers before number2 in array2 . Therefore, it is not necessary to compare the numbers after number1 in array1 with numbers before number2 in array2 . It improves efficiency since many comparisons are eliminated.\n\nThe sample code for this solution is shown below:\n\nvoid GetIntersection_solution1( const vector< int >& array1,\nconst vector< int >& array2,\nvector< int >& intersection)\n{\nvector< int >::const_iterator iter1 = array1.begin();\nvector< int >::const_iterator iter2 = array2.begin();\n\nintersection.clear();\n\nwhile (iter1 != array1.end() && iter2 != array2.end())\n{\nif (*iter1 == *iter2)\n{\nintersection.push_back(*iter1);\n++ iter1;\n++ iter2;\n}\nelse if (*iter1 < *iter2)\n++ iter1;\nelse\n++ iter2;\n}\n}\n\nSince it only requires to scan two arrays once, its time complexity is O( m + n ).\n\nSolution 2: With O( n log m ) Time\n\nAs we know, a binary search algorithm requires O(log m ) time to find a number in an array with length m . Therefore, if we search each number of an array with length n from an array with length m , its overall time complexity is O( n log m ). If m is much greater than n , O( n log m ) is actually less than O( m + n ). Therefore, we can implement a new and better solution based on binary search in such a situation.\n\nFor instance, the following same code is suitable when array1 is much longer than array2 .\n\n/* === Supposing array1 is much longer than array2 === */\nvoid GetIntersection_solution2( const vector< int >& array1,\nconst vector< int >& array2,\nvector< int >& intersection)\n{\nintersection.clear();\n\nvector< int >::const_iterator iter1 = array1.begin();\nwhile (iter1 != array1.end())\n{\nif (binary_search(array2.begin(), array2.end(), *iter1))\nintersection.push_back(*iter1);\n}\n}", "question": "\nProblem: Please implement a function which gets the intersection of two sorted arrays. Assuming numbers in each array are unique.\n\nFor example, if the two sorted arrays as input are {1, 4, 7, 10, 13} and {1, 3, 5, 7, 9}, it returns an intersection array with numbers {1, 7}.\n"},
{"answer": "\nAnalysis: The na\u00efve solution is sort the n input numbers increasingly, and the least k numbers should be the first k numbers. Since it needs to sort, its time complexity is O(n log n) . Interviewers will ask us explore more efficient solutions.\n\nSolution 1: O( n log k ) time efficiency, be suitable for data with huge size\n\nA data container with capacity k is firstly created to store the least k numbers, and then a number is read out of the n input numbers at each time. \u00a0\u00a0If the container has less than k numbers, the number read at current round (denoted as num ) is inserted into container directly. If it contains k numbers already, num cannot be inserted directly any more. However, it may replace an existing number in the container. \u00a0We get the maximum number of the k numbers in the container, and compare it with num . If num is less than the maximum number, we replace the maximum number with num . Otherwise we discard num , since we already have k numbers in the container which are all less than num and it cannot be one of the least k numbers.\n\nThree steps may be required when a number is read and the container is full: The first step is to find the maximum number, secondly we may delete the maximum number, and at last we may insert a new number. The second and third steps are optional, which depend on whether the number read at current round is greater than the maximum number in container or not. If we implement the data container as a binary tree, it costs O(log k ) time for these three steps. Therefore, the overall time complexity is O( n log k ) for n input numbers.\n\nWe have different choices for the data container. Since we need to get the maximum number out of k numbers, it intuitively might a maximum heap. In a maximum heap, its root is always greater than its children, so it costs O(1) time to get the maximum number. However, it takes O(log k ) time to insert and delete a number.\n\nWe have to write a lot of code for a maximum heap, and it is too difficult in the dozens-of-minute interview. We can also implement it as a red-black tree. A red-black tree classifies its nodes into red and black categories, and assure that it is somewhat balanced based on a set of rules. Therefore, it costs O(log k ) time to find, insert and delete a number. The classes set and multiset in STL are all based on red-black trees. We may use data containers in STL directly if our interviewers are not against it. The following sample code is based on the multiset in STL:\n\ntypedef multiset< int , greater< int > >\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 intSet;\ntypedef multiset< int , greater< int > >::iterator\u00a0 setIterator;\n\nvoid GetLeastNumbers( const vector< int >& data, intSet& leastNumbers, int k)\n{\nleastNumbers.clear();\n\nif (k < 1 || data.size() < k)\nreturn ;\n\nvector< int >::const_iterator iter = data.begin();\nfor (; iter != data.end(); ++ iter)\n{\nif ((leastNumbers.size()) < k)\nleastNumbers.insert(*iter);\n\nelse\n{\nsetIterator iterGreatest = leastNumbers.begin();\n\nif (*iter < *(leastNumbers.begin()))\n{\nleastNumbers.erase(iterGreatest);\nleastNumbers.insert(*iter);\n}\n}\n}\n}\n\nSolution 2: O( n ) time efficiency, be suitable only when we can reorder the input\n\nWe can also utilize the function Partition in quick sort to solve this problem with a hypothesis. It assumes that n input numbers are contained in an array. If it takes the k -th number as a pilot to partition the input array, all of numbers less than the k -th number should be at the left side and other greater ones should be at the right side. The k numbers at the left side are the least k numbers after the partition. We can develop the following code according to this solution:\n\nvoid GetLeastNumbers( int * input, int n, int * output, int k)\n{\nif (input == NULL || output == NULL || k > n || n <= 0 || k <= 0)\nreturn ;\n\nint start = 0;\nint end = n - 1;\nint index = Partition(input, n, start, end);\nwhile (index != k - 1)\n{\nif (index > k - 1)\n{\nend = index - 1;\nindex = Partition(input, n, start, end);\n}\nelse\n{\nstart = index + 1;\nindex = Partition(input, n, start, end);\n}\n}\n\nfor ( int i = 0; i < k; ++i)\noutput[i] = input[i];\n}\n\nComparison between two solutions\n\nThe second solution based on the function Partition costs only O( n ) time, so it is more efficient than the first one. However, it has two obvious limitations: One limitation is that it needs to load all input numbers into an array, and the other is that we have to reorder the input numbers.\nEven though the first takes more time, the second solution does have the two limitations as the first one. It is not required to reorder the input numbers ( data in the code above). We read a number from data at each round, and all write operations are taken in the container leastNumbers . It does not require loading all input number into memory at one time, so it is suitable for huge-size data. Supposing our interview asks us get the least k numbers from a huge-size input. Obviously we cannot load all data with huge size into limited memory at one time. We can read a number from auxiliary space (such as disk) at each round with the first solution, and determine whether we need to insert it into the container leastNumbers . It works once memory can accommodate leastNumbers , so it is especially works when n is huge and k is small.\n\nThe characters of these two solutions can be summarized in Table 1:\n\nFirst Solution Second Solution Time complexity O( n *log k ) O( n ) Reorder input   numbers? No Yes Suitable for   huge-size data? Yes No\n\nFirst Solution\nSecond Solution\nTime complexity\nO( n *log k )\nO( n )\nReorder input   numbers?\nNo\nYes\nSuitable for   huge-size data?\nYes\nNo\nTable 1: Pros and cons of two solutions\n", "question": "\nQuestion: Please find out the least k numbers out of n numbers. For example, if given the 8 numbers 4, 5, 1, 6, 2, 7, 3 and 8, please return the least 4 numbers 1, 2, 3 and 4.\n"},
{"answer": "\nAnalysis: Every pair of two adjacent numbers in an arithmetic sequence has exactly same difference. For example, 1, 3, 5, and 7 is an arithmetic sequence, and the pairs (1, 3), (3, 5), and (5, 7) have the same difference 2.\n\nThere are n ( n -1)/2 pairs out of an array with n elements. These pairs can be categorized into a set of groups, of which each group of pairs have the same difference. For example, the pairs of numbers in the array {1, 6, 3, 5, 9, 7} can be categorized into groups:\n\nDifference -1: (6, 5) Difference 2: (1, 3), (3, 5), (5, 7) Difference 3: (6, 9) \u2026\n\nTherefore, a hash table can be defined for the groups. The key in the hash table is the difference of pairs, and the value in the hash table is a list of pairs with same difference. The code to build the hash table can be implemented in C# as the following:\n\n internal class Pair\n {\n     public int First { get ; set ; }\n     public int Second { get ; set ; }\n }\n\n private static Dictionary < int , List < Pair >> BuildHashTable( int [] numbers)\n {\n     var hashTable = new Dictionary < int , List < Pair >>();\n     for ( int i = 0; i < numbers.Length; ++i)\n     {\n         for ( int j = i + 1; j < numbers.Length; ++j)\n         {\n             Pair pair = new Pair\n             {\n                 First = i,\n                 Second = j\n             };\n\n             int diff = numbers[j] - numbers[i];\n             if (hashTable.Keys.Contains(diff))\n             {\n                 hashTable[diff].Add(pair);\n             }\n             else\n             {\n                 List < Pair > newValue = new List < Pair >();\n                 newValue.Add(pair);\n                 hashTable[diff] = newValue;\n             }\n         }\n     }\n\n     return hashTable;\n }\n\nIn the code above, the values of the hash table is pairs of indexes, rather than elements themselves of the array. The pairs are sorted according to their first elements.\n\nThe next step is to get the length of pairs with each difference. A list of pairs with difference k is got given a key k in the hash table. If an element A[ i ] is m th element is an arithmetic sequence with a common difference k , and there is a pair (A[ i ], A[ j ]) ( j > i ) in the list of pairs, the element A[ j ] should be the m + 1 th elemement in the arithmetic sequence.\n\nTherefore, the code to get the max length of all arithmetic sequences can be implemented as:\n\n private static int Analyze( Dictionary < int , List < Pair >> hashTable, int lengthOfNumbers)\n {\n     int maxLength = 0;\n     foreach ( var key in hashTable.Keys)\n     {\n         int [] lengths = new int [lengthOfNumbers];\n         for ( int i = 0; i < lengthOfNumbers; ++i)\n         {\n             lengths[i] = 1;\n         }\n\n         foreach ( Pair pair in hashTable[key])\n         {\n             lengths[pair.Second] =lengths[pair.First] + 1;\n         }\n\n         foreach ( var length in lengths)\n         {\n             if (length > maxLength)\n             {\n                 maxLength = length;\n             }\n         }\n     }\n\n     return maxLength;\n }\n\n public static int GetMaxLengthOfArithmeticSequence( int [] numbers)\n {\n     var hashTable = BuildHashTable(numbers);\n     return Analyze(hashTable, numbers.Length);\n }\n\n\nAs mentioned above, there are O( n 2 ) pairs in an array with n elements. Therefore, the time and space efficiencies of this solution is O( n 2 ) given an array with n elements.\n\n\nAnalysis: Different from the previous problem, there are no limitations on the order of arithmetic sequence. Consequently, we can sort the array before we try to get the maximal length of arithmetic sequences. The code is almost same as before, except for the revision that there is an additional line of code to sort the array, as listed below:\n\n public static int GetMaxLengthOfArithmeticSequence( int [] numbers)\n {\n     Array .Sort(numbers);\n     var hashTable = BuildHashTable(numbers);\n     return Analyze(hashTable, numbers.Length);\n }\n\n\n\nAnalysis: The solution to solve the above problems cost O( n 2 ) time and space. Therefore, we need a new solution to solve this problem.\n\nA consecutive can\u2019t have duplicated elements. A hash set, of which every element is unique, can be built from the input array. When a number is located in the set, we try to locate its consecutive neighbors. For instance, when the number 6 is found in the set, we try to find the number 5 and 7 in the set, and then we get a consecutive sequence 5, 6, and 7.\n\nThis solution can be implemented in C# code as listed below:\n\n public static int GetMaxLengthConsecutiveSequence( int [] numbers)\n {\n     HashSet < int > set = BuildHashSet(numbers);\n     return AnalyzeHashSet(set);\n }\n\n private static HashSet < int > BuildHashSet( int [] numbers)\n {\n     var set = new HashSet < int >();\n     foreach ( int number in numbers)\n     {\n         set.Add(number);\n     }\n\n     return set;\n }\n\n private static int AnalyzeHashSet( HashSet < int > set)\n {\n     int maxCount = 0;\n     while (set.Count > 0)\n     {\n         int number = set.First();\n         int count = 0;\n         int toDelete = number;\n\n         while (set.Remove(toDelete))\n         {\n             count++;\n             toDelete++;\n         }\n\n         toDelete = number - 1;\n         while (set.Remove(toDelete))\n         {\n             count++;\n             toDelete--;\n         }\n\n         if (count > maxCount)\n         {\n             maxCount = count;\n         }\n     }\n\n     return maxCount;\n }\n\nEvery number in the input array is added into and removed from the array only once, so the time and space efficiency is O( n ) if there are n numbers in the array.\n\n\n\n", "question": "\nQuestion 1: Given an array, please get the length of the longest arithmetic sequence. The element order in the arithmetic sequence should be same as the element order in the array. For example, in the array {1, 6, 3, 5, 9, 7}, the longest arithmetic sequence is 1, 3, 5, and 7, whose elements have same order as they are in the array, and the length is 4.\n\n\nQuestion 2: Given an array, please get the length of the longest arithmetic sequence. The element order in the arithmetic sequence is not necessarily same as the element order in the array. For example, in the array {1, 6, 3, 5, 9, 7}, the longest arithmetic sequence is 1, 3, 5, 7, and 9, and the length is 5.\n\n\nQuestion 3: Given an array, please get the length of the longest consecutive sequence. A consecutive sequence is an arithmetic sequence with common difference 1. The element order in the consecutive sequence is not necessarily same as the element order in the array. The solution should not cost more than O( n ) time and space if the length of the input array is n . For example, in the array {1, 6, 3, 5, 9, 7}, the longest consecutive sequence is 5, 6, and 7 whose length is 3.\n"},
{"answer": "\nAnalysis: Every pair of two adjacent numbers in an arithmetic sequence has exactly same difference. For example, 1, 3, 5, and 7 is an arithmetic sequence, and the pairs (1, 3), (3, 5), and (5, 7) have the same difference 2.\n\nThere are n ( n -1)/2 pairs out of an array with n elements. These pairs can be categorized into a set of groups, of which each group of pairs have the same difference. For example, the pairs of numbers in the array {1, 6, 3, 5, 9, 7} can be categorized into groups:\n\nDifference -1: (6, 5) Difference 2: (1, 3), (3, 5), (5, 7) Difference 3: (6, 9) \u2026\n\nTherefore, a hash table can be defined for the groups. The key in the hash table is the difference of pairs, and the value in the hash table is a list of pairs with same difference. The code to build the hash table can be implemented in C# as the following:\n\n internal class Pair\n {\n     public int First { get ; set ; }\n     public int Second { get ; set ; }\n }\n\n private static Dictionary < int , List < Pair >> BuildHashTable( int [] numbers)\n {\n     var hashTable = new Dictionary < int , List < Pair >>();\n     for ( int i = 0; i < numbers.Length; ++i)\n     {\n         for ( int j = i + 1; j < numbers.Length; ++j)\n         {\n             Pair pair = new Pair\n             {\n                 First = i,\n                 Second = j\n             };\n\n             int diff = numbers[j] - numbers[i];\n             if (hashTable.Keys.Contains(diff))\n             {\n                 hashTable[diff].Add(pair);\n             }\n             else\n             {\n                 List < Pair > newValue = new List < Pair >();\n                 newValue.Add(pair);\n                 hashTable[diff] = newValue;\n             }\n         }\n     }\n\n     return hashTable;\n }\n\nIn the code above, the values of the hash table is pairs of indexes, rather than elements themselves of the array. The pairs are sorted according to their first elements.\n\nThe next step is to get the length of pairs with each difference. A list of pairs with difference k is got given a key k in the hash table. If an element A[ i ] is m th element is an arithmetic sequence with a common difference k , and there is a pair (A[ i ], A[ j ]) ( j > i ) in the list of pairs, the element A[ j ] should be the m + 1 th elemement in the arithmetic sequence.\n\nTherefore, the code to get the max length of all arithmetic sequences can be implemented as:\n\n private static int Analyze( Dictionary < int , List < Pair >> hashTable, int lengthOfNumbers)\n {\n     int maxLength = 0;\n     foreach ( var key in hashTable.Keys)\n     {\n         int [] lengths = new int [lengthOfNumbers];\n         for ( int i = 0; i < lengthOfNumbers; ++i)\n         {\n             lengths[i] = 1;\n         }\n\n         foreach ( Pair pair in hashTable[key])\n         {\n             lengths[pair.Second] =lengths[pair.First] + 1;\n         }\n\n         foreach ( var length in lengths)\n         {\n             if (length > maxLength)\n             {\n                 maxLength = length;\n             }\n         }\n     }\n\n     return maxLength;\n }\n\n public static int GetMaxLengthOfArithmeticSequence( int [] numbers)\n {\n     var hashTable = BuildHashTable(numbers);\n     return Analyze(hashTable, numbers.Length);\n }\n\n\nAs mentioned above, there are O( n 2 ) pairs in an array with n elements. Therefore, the time and space efficiencies of this solution is O( n 2 ) given an array with n elements.\n\n\nAnalysis: Different from the previous problem, there are no limitations on the order of arithmetic sequence. Consequently, we can sort the array before we try to get the maximal length of arithmetic sequences. The code is almost same as before, except for the revision that there is an additional line of code to sort the array, as listed below:\n\n public static int GetMaxLengthOfArithmeticSequence( int [] numbers)\n {\n     Array .Sort(numbers);\n     var hashTable = BuildHashTable(numbers);\n     return Analyze(hashTable, numbers.Length);\n }\n\n\n\nAnalysis: The solution to solve the above problems cost O( n 2 ) time and space. Therefore, we need a new solution to solve this problem.\n\nA consecutive can\u2019t have duplicated elements. A hash set, of which every element is unique, can be built from the input array. When a number is located in the set, we try to locate its consecutive neighbors. For instance, when the number 6 is found in the set, we try to find the number 5 and 7 in the set, and then we get a consecutive sequence 5, 6, and 7.\n\nThis solution can be implemented in C# code as listed below:\n\n public static int GetMaxLengthConsecutiveSequence( int [] numbers)\n {\n     HashSet < int > set = BuildHashSet(numbers);\n     return AnalyzeHashSet(set);\n }\n\n private static HashSet < int > BuildHashSet( int [] numbers)\n {\n     var set = new HashSet < int >();\n     foreach ( int number in numbers)\n     {\n         set.Add(number);\n     }\n\n     return set;\n }\n\n private static int AnalyzeHashSet( HashSet < int > set)\n {\n     int maxCount = 0;\n     while (set.Count > 0)\n     {\n         int number = set.First();\n         int count = 0;\n         int toDelete = number;\n\n         while (set.Remove(toDelete))\n         {\n             count++;\n             toDelete++;\n         }\n\n         toDelete = number - 1;\n         while (set.Remove(toDelete))\n         {\n             count++;\n             toDelete--;\n         }\n\n         if (count > maxCount)\n         {\n             maxCount = count;\n         }\n     }\n\n     return maxCount;\n }\n\nEvery number in the input array is added into and removed from the array only once, so the time and space efficiency is O( n ) if there are n numbers in the array.\n\n\n\n", "question": "\nQuestion 1: Given an array, please get the length of the longest arithmetic sequence. The element order in the arithmetic sequence should be same as the element order in the array. For example, in the array {1, 6, 3, 5, 9, 7}, the longest arithmetic sequence is 1, 3, 5, and 7, whose elements have same order as they are in the array, and the length is 4.\n\n\nQuestion 2: Given an array, please get the length of the longest arithmetic sequence. The element order in the arithmetic sequence is not necessarily same as the element order in the array. For example, in the array {1, 6, 3, 5, 9, 7}, the longest arithmetic sequence is 1, 3, 5, 7, and 9, and the length is 5.\n\n\nQuestion 3: Given an array, please get the length of the longest consecutive sequence. A consecutive sequence is an arithmetic sequence with common difference 1. The element order in the consecutive sequence is not necessarily same as the element order in the array. The solution should not cost more than O( n ) time and space if the length of the input array is n . For example, in the array {1, 6, 3, 5, 9, 7}, the longest consecutive sequence is 5, 6, and 7 whose length is 3.\n"},
{"answer": "\nAnalysis: Every pair of two adjacent numbers in an arithmetic sequence has exactly same difference. For example, 1, 3, 5, and 7 is an arithmetic sequence, and the pairs (1, 3), (3, 5), and (5, 7) have the same difference 2.\n\nThere are n ( n -1)/2 pairs out of an array with n elements. These pairs can be categorized into a set of groups, of which each group of pairs have the same difference. For example, the pairs of numbers in the array {1, 6, 3, 5, 9, 7} can be categorized into groups:\n\nDifference -1: (6, 5) Difference 2: (1, 3), (3, 5), (5, 7) Difference 3: (6, 9) \u2026\n\nTherefore, a hash table can be defined for the groups. The key in the hash table is the difference of pairs, and the value in the hash table is a list of pairs with same difference. The code to build the hash table can be implemented in C# as the following:\n\n internal class Pair\n {\n     public int First { get ; set ; }\n     public int Second { get ; set ; }\n }\n\n private static Dictionary < int , List < Pair >> BuildHashTable( int [] numbers)\n {\n     var hashTable = new Dictionary < int , List < Pair >>();\n     for ( int i = 0; i < numbers.Length; ++i)\n     {\n         for ( int j = i + 1; j < numbers.Length; ++j)\n         {\n             Pair pair = new Pair\n             {\n                 First = i,\n                 Second = j\n             };\n\n             int diff = numbers[j] - numbers[i];\n             if (hashTable.Keys.Contains(diff))\n             {\n                 hashTable[diff].Add(pair);\n             }\n             else\n             {\n                 List < Pair > newValue = new List < Pair >();\n                 newValue.Add(pair);\n                 hashTable[diff] = newValue;\n             }\n         }\n     }\n\n     return hashTable;\n }\n\nIn the code above, the values of the hash table is pairs of indexes, rather than elements themselves of the array. The pairs are sorted according to their first elements.\n\nThe next step is to get the length of pairs with each difference. A list of pairs with difference k is got given a key k in the hash table. If an element A[ i ] is m th element is an arithmetic sequence with a common difference k , and there is a pair (A[ i ], A[ j ]) ( j > i ) in the list of pairs, the element A[ j ] should be the m + 1 th elemement in the arithmetic sequence.\n\nTherefore, the code to get the max length of all arithmetic sequences can be implemented as:\n\n private static int Analyze( Dictionary < int , List < Pair >> hashTable, int lengthOfNumbers)\n {\n     int maxLength = 0;\n     foreach ( var key in hashTable.Keys)\n     {\n         int [] lengths = new int [lengthOfNumbers];\n         for ( int i = 0; i < lengthOfNumbers; ++i)\n         {\n             lengths[i] = 1;\n         }\n\n         foreach ( Pair pair in hashTable[key])\n         {\n             lengths[pair.Second] =lengths[pair.First] + 1;\n         }\n\n         foreach ( var length in lengths)\n         {\n             if (length > maxLength)\n             {\n                 maxLength = length;\n             }\n         }\n     }\n\n     return maxLength;\n }\n\n public static int GetMaxLengthOfArithmeticSequence( int [] numbers)\n {\n     var hashTable = BuildHashTable(numbers);\n     return Analyze(hashTable, numbers.Length);\n }\n\n\nAs mentioned above, there are O( n 2 ) pairs in an array with n elements. Therefore, the time and space efficiencies of this solution is O( n 2 ) given an array with n elements.\n\n\nAnalysis: Different from the previous problem, there are no limitations on the order of arithmetic sequence. Consequently, we can sort the array before we try to get the maximal length of arithmetic sequences. The code is almost same as before, except for the revision that there is an additional line of code to sort the array, as listed below:\n\n public static int GetMaxLengthOfArithmeticSequence( int [] numbers)\n {\n     Array .Sort(numbers);\n     var hashTable = BuildHashTable(numbers);\n     return Analyze(hashTable, numbers.Length);\n }\n\n\n\nAnalysis: The solution to solve the above problems cost O( n 2 ) time and space. Therefore, we need a new solution to solve this problem.\n\nA consecutive can\u2019t have duplicated elements. A hash set, of which every element is unique, can be built from the input array. When a number is located in the set, we try to locate its consecutive neighbors. For instance, when the number 6 is found in the set, we try to find the number 5 and 7 in the set, and then we get a consecutive sequence 5, 6, and 7.\n\nThis solution can be implemented in C# code as listed below:\n\n public static int GetMaxLengthConsecutiveSequence( int [] numbers)\n {\n     HashSet < int > set = BuildHashSet(numbers);\n     return AnalyzeHashSet(set);\n }\n\n private static HashSet < int > BuildHashSet( int [] numbers)\n {\n     var set = new HashSet < int >();\n     foreach ( int number in numbers)\n     {\n         set.Add(number);\n     }\n\n     return set;\n }\n\n private static int AnalyzeHashSet( HashSet < int > set)\n {\n     int maxCount = 0;\n     while (set.Count > 0)\n     {\n         int number = set.First();\n         int count = 0;\n         int toDelete = number;\n\n         while (set.Remove(toDelete))\n         {\n             count++;\n             toDelete++;\n         }\n\n         toDelete = number - 1;\n         while (set.Remove(toDelete))\n         {\n             count++;\n             toDelete--;\n         }\n\n         if (count > maxCount)\n         {\n             maxCount = count;\n         }\n     }\n\n     return maxCount;\n }\n\nEvery number in the input array is added into and removed from the array only once, so the time and space efficiency is O( n ) if there are n numbers in the array.\n\n\n\n", "question": "\nQuestion 1: Given an array, please get the length of the longest arithmetic sequence. The element order in the arithmetic sequence should be same as the element order in the array. For example, in the array {1, 6, 3, 5, 9, 7}, the longest arithmetic sequence is 1, 3, 5, and 7, whose elements have same order as they are in the array, and the length is 4.\n\n\nQuestion 2: Given an array, please get the length of the longest arithmetic sequence. The element order in the arithmetic sequence is not necessarily same as the element order in the array. For example, in the array {1, 6, 3, 5, 9, 7}, the longest arithmetic sequence is 1, 3, 5, 7, and 9, and the length is 5.\n\n\nQuestion 3: Given an array, please get the length of the longest consecutive sequence. A consecutive sequence is an arithmetic sequence with common difference 1. The element order in the consecutive sequence is not necessarily same as the element order in the array. The solution should not cost more than O( n ) time and space if the length of the input array is n . For example, in the array {1, 6, 3, 5, 9, 7}, the longest consecutive sequence is 5, 6, and 7 whose length is 3.\n"},
{"answer": "\nAnalysis: Every pair of two adjacent numbers in an arithmetic sequence has exactly same difference. For example, 1, 3, 5, and 7 is an arithmetic sequence, and the pairs (1, 3), (3, 5), and (5, 7) have the same difference 2.\n\nThere are n ( n -1)/2 pairs out of an array with n elements. These pairs can be categorized into a set of groups, of which each group of pairs have the same difference. For example, the pairs of numbers in the array {1, 6, 3, 5, 9, 7} can be categorized into groups:\n\nDifference -1: (6, 5) Difference 2: (1, 3), (3, 5), (5, 7) Difference 3: (6, 9) \u2026\n\nTherefore, a hash table can be defined for the groups. The key in the hash table is the difference of pairs, and the value in the hash table is a list of pairs with same difference. The code to build the hash table can be implemented in C# as the following:\n\n internal class Pair\n {\n     public int First { get ; set ; }\n     public int Second { get ; set ; }\n }\n\n private static Dictionary < int , List < Pair >> BuildHashTable( int [] numbers)\n {\n     var hashTable = new Dictionary < int , List < Pair >>();\n     for ( int i = 0; i < numbers.Length; ++i)\n     {\n         for ( int j = i + 1; j < numbers.Length; ++j)\n         {\n             Pair pair = new Pair\n             {\n                 First = i,\n                 Second = j\n             };\n\n             int diff = numbers[j] - numbers[i];\n             if (hashTable.Keys.Contains(diff))\n             {\n                 hashTable[diff].Add(pair);\n             }\n             else\n             {\n                 List < Pair > newValue = new List < Pair >();\n                 newValue.Add(pair);\n                 hashTable[diff] = newValue;\n             }\n         }\n     }\n\n     return hashTable;\n }\n\nIn the code above, the values of the hash table is pairs of indexes, rather than elements themselves of the array. The pairs are sorted according to their first elements.\n\nThe next step is to get the length of pairs with each difference. A list of pairs with difference k is got given a key k in the hash table. If an element A[ i ] is m th element is an arithmetic sequence with a common difference k , and there is a pair (A[ i ], A[ j ]) ( j > i ) in the list of pairs, the element A[ j ] should be the m + 1 th elemement in the arithmetic sequence.\n\nTherefore, the code to get the max length of all arithmetic sequences can be implemented as:\n\n private static int Analyze( Dictionary < int , List < Pair >> hashTable, int lengthOfNumbers)\n {\n     int maxLength = 0;\n     foreach ( var key in hashTable.Keys)\n     {\n         int [] lengths = new int [lengthOfNumbers];\n         for ( int i = 0; i < lengthOfNumbers; ++i)\n         {\n             lengths[i] = 1;\n         }\n\n         foreach ( Pair pair in hashTable[key])\n         {\n             lengths[pair.Second] =lengths[pair.First] + 1;\n         }\n\n         foreach ( var length in lengths)\n         {\n             if (length > maxLength)\n             {\n                 maxLength = length;\n             }\n         }\n     }\n\n     return maxLength;\n }\n\n public static int GetMaxLengthOfArithmeticSequence( int [] numbers)\n {\n     var hashTable = BuildHashTable(numbers);\n     return Analyze(hashTable, numbers.Length);\n }\n\n\nAs mentioned above, there are O( n 2 ) pairs in an array with n elements. Therefore, the time and space efficiencies of this solution is O( n 2 ) given an array with n elements.\n\n\nAnalysis: Different from the previous problem, there are no limitations on the order of arithmetic sequence. Consequently, we can sort the array before we try to get the maximal length of arithmetic sequences. The code is almost same as before, except for the revision that there is an additional line of code to sort the array, as listed below:\n\n public static int GetMaxLengthOfArithmeticSequence( int [] numbers)\n {\n     Array .Sort(numbers);\n     var hashTable = BuildHashTable(numbers);\n     return Analyze(hashTable, numbers.Length);\n }\n\n\n\nAnalysis: The solution to solve the above problems cost O( n 2 ) time and space. Therefore, we need a new solution to solve this problem.\n\nA consecutive can\u2019t have duplicated elements. A hash set, of which every element is unique, can be built from the input array. When a number is located in the set, we try to locate its consecutive neighbors. For instance, when the number 6 is found in the set, we try to find the number 5 and 7 in the set, and then we get a consecutive sequence 5, 6, and 7.\n\nThis solution can be implemented in C# code as listed below:\n\n public static int GetMaxLengthConsecutiveSequence( int [] numbers)\n {\n     HashSet < int > set = BuildHashSet(numbers);\n     return AnalyzeHashSet(set);\n }\n\n private static HashSet < int > BuildHashSet( int [] numbers)\n {\n     var set = new HashSet < int >();\n     foreach ( int number in numbers)\n     {\n         set.Add(number);\n     }\n\n     return set;\n }\n\n private static int AnalyzeHashSet( HashSet < int > set)\n {\n     int maxCount = 0;\n     while (set.Count > 0)\n     {\n         int number = set.First();\n         int count = 0;\n         int toDelete = number;\n\n         while (set.Remove(toDelete))\n         {\n             count++;\n             toDelete++;\n         }\n\n         toDelete = number - 1;\n         while (set.Remove(toDelete))\n         {\n             count++;\n             toDelete--;\n         }\n\n         if (count > maxCount)\n         {\n             maxCount = count;\n         }\n     }\n\n     return maxCount;\n }\n\nEvery number in the input array is added into and removed from the array only once, so the time and space efficiency is O( n ) if there are n numbers in the array.\n\n\n\n", "question": "\nQuestion 1: Given an array, please get the length of the longest arithmetic sequence. The element order in the arithmetic sequence should be same as the element order in the array. For example, in the array {1, 6, 3, 5, 9, 7}, the longest arithmetic sequence is 1, 3, 5, and 7, whose elements have same order as they are in the array, and the length is 4.\n\n\nQuestion 2: Given an array, please get the length of the longest arithmetic sequence. The element order in the arithmetic sequence is not necessarily same as the element order in the array. For example, in the array {1, 6, 3, 5, 9, 7}, the longest arithmetic sequence is 1, 3, 5, 7, and 9, and the length is 5.\n\n\nQuestion 3: Given an array, please get the length of the longest consecutive sequence. A consecutive sequence is an arithmetic sequence with common difference 1. The element order in the consecutive sequence is not necessarily same as the element order in the array. The solution should not cost more than O( n ) time and space if the length of the input array is n . For example, in the array {1, 6, 3, 5, 9, 7}, the longest consecutive sequence is 5, 6, and 7 whose length is 3.\n"},
{"answer": "\nAnalysis: The na\u00efve solution is sort the n input numbers increasingly, and the least k numbers should be the first k numbers. Since it needs to sort, its time complexity is O(n log n) . Interviewers will ask us explore more efficient solutions.\n\nSolution 1: O( n log k ) time efficiency, be suitable for data with huge size\n\nA data container with capacity k is firstly created to store the least k numbers, and then a number is read out of the n input numbers at each time. \u00a0\u00a0If the container has less than k numbers, the number read at current round (denoted as num ) is inserted into container directly. If it contains k numbers already, num cannot be inserted directly any more. However, it may replace an existing number in the container. \u00a0We get the maximum number of the k numbers in the container, and compare it with num . If num is less than the maximum number, we replace the maximum number with num . Otherwise we discard num , since we already have k numbers in the container which are all less than num and it cannot be one of the least k numbers.\n\nThree steps may be required when a number is read and the container is full: The first step is to find the maximum number, secondly we may delete the maximum number, and at last we may insert a new number. The second and third steps are optional, which depend on whether the number read at current round is greater than the maximum number in container or not. If we implement the data container as a binary tree, it costs O(log k ) time for these three steps. Therefore, the overall time complexity is O( n log k ) for n input numbers.\n\nWe have different choices for the data container. Since we need to get the maximum number out of k numbers, it intuitively might a maximum heap. In a maximum heap, its root is always greater than its children, so it costs O(1) time to get the maximum number. However, it takes O(log k ) time to insert and delete a number.\n\nWe have to write a lot of code for a maximum heap, and it is too difficult in the dozens-of-minute interview. We can also implement it as a red-black tree. A red-black tree classifies its nodes into red and black categories, and assure that it is somewhat balanced based on a set of rules. Therefore, it costs O(log k ) time to find, insert and delete a number. The classes set and multiset in STL are all based on red-black trees. We may use data containers in STL directly if our interviewers are not against it. The following sample code is based on the multiset in STL:\n\ntypedef multiset< int , greater< int > >\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 intSet;\ntypedef multiset< int , greater< int > >::iterator\u00a0 setIterator;\n\nvoid GetLeastNumbers( const vector< int >& data, intSet& leastNumbers, int k)\n{\nleastNumbers.clear();\n\nif (k < 1 || data.size() < k)\nreturn ;\n\nvector< int >::const_iterator iter = data.begin();\nfor (; iter != data.end(); ++ iter)\n{\nif ((leastNumbers.size()) < k)\nleastNumbers.insert(*iter);\n\nelse\n{\nsetIterator iterGreatest = leastNumbers.begin();\n\nif (*iter < *(leastNumbers.begin()))\n{\nleastNumbers.erase(iterGreatest);\nleastNumbers.insert(*iter);\n}\n}\n}\n}\n\nSolution 2: O( n ) time efficiency, be suitable only when we can reorder the input\n\nWe can also utilize the function Partition in quick sort to solve this problem with a hypothesis. It assumes that n input numbers are contained in an array. If it takes the k -th number as a pilot to partition the input array, all of numbers less than the k -th number should be at the left side and other greater ones should be at the right side. The k numbers at the left side are the least k numbers after the partition. We can develop the following code according to this solution:\n\nvoid GetLeastNumbers( int * input, int n, int * output, int k)\n{\nif (input == NULL || output == NULL || k > n || n <= 0 || k <= 0)\nreturn ;\n\nint start = 0;\nint end = n - 1;\nint index = Partition(input, n, start, end);\nwhile (index != k - 1)\n{\nif (index > k - 1)\n{\nend = index - 1;\nindex = Partition(input, n, start, end);\n}\nelse\n{\nstart = index + 1;\nindex = Partition(input, n, start, end);\n}\n}\n\nfor ( int i = 0; i < k; ++i)\noutput[i] = input[i];\n}\n\nComparison between two solutions\n\nThe second solution based on the function Partition costs only O( n ) time, so it is more efficient than the first one. However, it has two obvious limitations: One limitation is that it needs to load all input numbers into an array, and the other is that we have to reorder the input numbers.\nEven though the first takes more time, the second solution does have the two limitations as the first one. It is not required to reorder the input numbers ( data in the code above). We read a number from data at each round, and all write operations are taken in the container leastNumbers . It does not require loading all input number into memory at one time, so it is suitable for huge-size data. Supposing our interview asks us get the least k numbers from a huge-size input. Obviously we cannot load all data with huge size into limited memory at one time. We can read a number from auxiliary space (such as disk) at each round with the first solution, and determine whether we need to insert it into the container leastNumbers . It works once memory can accommodate leastNumbers , so it is especially works when n is huge and k is small.\n\nThe characters of these two solutions can be summarized in Table 1:\n\nFirst Solution Second Solution Time complexity O( n *log k ) O( n ) Reorder input   numbers? No Yes Suitable for   huge-size data? Yes No\n\nFirst Solution\nSecond Solution\nTime complexity\nO( n *log k )\nO( n )\nReorder input   numbers?\nNo\nYes\nSuitable for   huge-size data?\nYes\nNo\nTable 1: Pros and cons of two solutions\n", "question": "\nQuestion: Please find out the least k numbers out of n numbers. For example, if given the 8 numbers 4, 5, 1, 6, 2, 7, 3 and 8, please return the least 4 numbers 1, 2, 3 and 4.\n"},
{"answer": "\nAnalysis: The na\u00efve solution is sort the n input numbers increasingly, and the least k numbers should be the first k numbers. Since it needs to sort, its time complexity is O(n log n) . Interviewers will ask us explore more efficient solutions.\n\nSolution 1: O( n log k ) time efficiency, be suitable for data with huge size\n\nA data container with capacity k is firstly created to store the least k numbers, and then a number is read out of the n input numbers at each time. \u00a0\u00a0If the container has less than k numbers, the number read at current round (denoted as num ) is inserted into container directly. If it contains k numbers already, num cannot be inserted directly any more. However, it may replace an existing number in the container. \u00a0We get the maximum number of the k numbers in the container, and compare it with num . If num is less than the maximum number, we replace the maximum number with num . Otherwise we discard num , since we already have k numbers in the container which are all less than num and it cannot be one of the least k numbers.\n\nThree steps may be required when a number is read and the container is full: The first step is to find the maximum number, secondly we may delete the maximum number, and at last we may insert a new number. The second and third steps are optional, which depend on whether the number read at current round is greater than the maximum number in container or not. If we implement the data container as a binary tree, it costs O(log k ) time for these three steps. Therefore, the overall time complexity is O( n log k ) for n input numbers.\n\nWe have different choices for the data container. Since we need to get the maximum number out of k numbers, it intuitively might a maximum heap. In a maximum heap, its root is always greater than its children, so it costs O(1) time to get the maximum number. However, it takes O(log k ) time to insert and delete a number.\n\nWe have to write a lot of code for a maximum heap, and it is too difficult in the dozens-of-minute interview. We can also implement it as a red-black tree. A red-black tree classifies its nodes into red and black categories, and assure that it is somewhat balanced based on a set of rules. Therefore, it costs O(log k ) time to find, insert and delete a number. The classes set and multiset in STL are all based on red-black trees. We may use data containers in STL directly if our interviewers are not against it. The following sample code is based on the multiset in STL:\n\ntypedef multiset< int , greater< int > >\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 intSet;\ntypedef multiset< int , greater< int > >::iterator\u00a0 setIterator;\n\nvoid GetLeastNumbers( const vector< int >& data, intSet& leastNumbers, int k)\n{\nleastNumbers.clear();\n\nif (k < 1 || data.size() < k)\nreturn ;\n\nvector< int >::const_iterator iter = data.begin();\nfor (; iter != data.end(); ++ iter)\n{\nif ((leastNumbers.size()) < k)\nleastNumbers.insert(*iter);\n\nelse\n{\nsetIterator iterGreatest = leastNumbers.begin();\n\nif (*iter < *(leastNumbers.begin()))\n{\nleastNumbers.erase(iterGreatest);\nleastNumbers.insert(*iter);\n}\n}\n}\n}\n\nSolution 2: O( n ) time efficiency, be suitable only when we can reorder the input\n\nWe can also utilize the function Partition in quick sort to solve this problem with a hypothesis. It assumes that n input numbers are contained in an array. If it takes the k -th number as a pilot to partition the input array, all of numbers less than the k -th number should be at the left side and other greater ones should be at the right side. The k numbers at the left side are the least k numbers after the partition. We can develop the following code according to this solution:\n\nvoid GetLeastNumbers( int * input, int n, int * output, int k)\n{\nif (input == NULL || output == NULL || k > n || n <= 0 || k <= 0)\nreturn ;\n\nint start = 0;\nint end = n - 1;\nint index = Partition(input, n, start, end);\nwhile (index != k - 1)\n{\nif (index > k - 1)\n{\nend = index - 1;\nindex = Partition(input, n, start, end);\n}\nelse\n{\nstart = index + 1;\nindex = Partition(input, n, start, end);\n}\n}\n\nfor ( int i = 0; i < k; ++i)\noutput[i] = input[i];\n}\n\nComparison between two solutions\n\nThe second solution based on the function Partition costs only O( n ) time, so it is more efficient than the first one. However, it has two obvious limitations: One limitation is that it needs to load all input numbers into an array, and the other is that we have to reorder the input numbers.\nEven though the first takes more time, the second solution does have the two limitations as the first one. It is not required to reorder the input numbers ( data in the code above). We read a number from data at each round, and all write operations are taken in the container leastNumbers . It does not require loading all input number into memory at one time, so it is suitable for huge-size data. Supposing our interview asks us get the least k numbers from a huge-size input. Obviously we cannot load all data with huge size into limited memory at one time. We can read a number from auxiliary space (such as disk) at each round with the first solution, and determine whether we need to insert it into the container leastNumbers . It works once memory can accommodate leastNumbers , so it is especially works when n is huge and k is small.\n\nThe characters of these two solutions can be summarized in Table 1:\n\nFirst Solution Second Solution Time complexity O( n *log k ) O( n ) Reorder input   numbers? No Yes Suitable for   huge-size data? Yes No\n\nFirst Solution\nSecond Solution\nTime complexity\nO( n *log k )\nO( n )\nReorder input   numbers?\nNo\nYes\nSuitable for   huge-size data?\nYes\nNo\nTable 1: Pros and cons of two solutions\n", "question": "\nQuestion: Please find out the least k numbers out of n numbers. For example, if given the 8 numbers 4, 5, 1, 6, 2, 7, 3 and 8, please return the least 4 numbers 1, 2, 3 and 4.\n"},
{"answer": "\nAnalysis: The na\u00efve solution is sort the n input numbers increasingly, and the least k numbers should be the first k numbers. Since it needs to sort, its time complexity is O(n log n) . Interviewers will ask us explore more efficient solutions.\n\nSolution 1: O( n log k ) time efficiency, be suitable for data with huge size\n\nA data container with capacity k is firstly created to store the least k numbers, and then a number is read out of the n input numbers at each time. \u00a0\u00a0If the container has less than k numbers, the number read at current round (denoted as num ) is inserted into container directly. If it contains k numbers already, num cannot be inserted directly any more. However, it may replace an existing number in the container. \u00a0We get the maximum number of the k numbers in the container, and compare it with num . If num is less than the maximum number, we replace the maximum number with num . Otherwise we discard num , since we already have k numbers in the container which are all less than num and it cannot be one of the least k numbers.\n\nThree steps may be required when a number is read and the container is full: The first step is to find the maximum number, secondly we may delete the maximum number, and at last we may insert a new number. The second and third steps are optional, which depend on whether the number read at current round is greater than the maximum number in container or not. If we implement the data container as a binary tree, it costs O(log k ) time for these three steps. Therefore, the overall time complexity is O( n log k ) for n input numbers.\n\nWe have different choices for the data container. Since we need to get the maximum number out of k numbers, it intuitively might a maximum heap. In a maximum heap, its root is always greater than its children, so it costs O(1) time to get the maximum number. However, it takes O(log k ) time to insert and delete a number.\n\nWe have to write a lot of code for a maximum heap, and it is too difficult in the dozens-of-minute interview. We can also implement it as a red-black tree. A red-black tree classifies its nodes into red and black categories, and assure that it is somewhat balanced based on a set of rules. Therefore, it costs O(log k ) time to find, insert and delete a number. The classes set and multiset in STL are all based on red-black trees. We may use data containers in STL directly if our interviewers are not against it. The following sample code is based on the multiset in STL:\n\ntypedef multiset< int , greater< int > >\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 intSet;\ntypedef multiset< int , greater< int > >::iterator\u00a0 setIterator;\n\nvoid GetLeastNumbers( const vector< int >& data, intSet& leastNumbers, int k)\n{\nleastNumbers.clear();\n\nif (k < 1 || data.size() < k)\nreturn ;\n\nvector< int >::const_iterator iter = data.begin();\nfor (; iter != data.end(); ++ iter)\n{\nif ((leastNumbers.size()) < k)\nleastNumbers.insert(*iter);\n\nelse\n{\nsetIterator iterGreatest = leastNumbers.begin();\n\nif (*iter < *(leastNumbers.begin()))\n{\nleastNumbers.erase(iterGreatest);\nleastNumbers.insert(*iter);\n}\n}\n}\n}\n\nSolution 2: O( n ) time efficiency, be suitable only when we can reorder the input\n\nWe can also utilize the function Partition in quick sort to solve this problem with a hypothesis. It assumes that n input numbers are contained in an array. If it takes the k -th number as a pilot to partition the input array, all of numbers less than the k -th number should be at the left side and other greater ones should be at the right side. The k numbers at the left side are the least k numbers after the partition. We can develop the following code according to this solution:\n\nvoid GetLeastNumbers( int * input, int n, int * output, int k)\n{\nif (input == NULL || output == NULL || k > n || n <= 0 || k <= 0)\nreturn ;\n\nint start = 0;\nint end = n - 1;\nint index = Partition(input, n, start, end);\nwhile (index != k - 1)\n{\nif (index > k - 1)\n{\nend = index - 1;\nindex = Partition(input, n, start, end);\n}\nelse\n{\nstart = index + 1;\nindex = Partition(input, n, start, end);\n}\n}\n\nfor ( int i = 0; i < k; ++i)\noutput[i] = input[i];\n}\n\nComparison between two solutions\n\nThe second solution based on the function Partition costs only O( n ) time, so it is more efficient than the first one. However, it has two obvious limitations: One limitation is that it needs to load all input numbers into an array, and the other is that we have to reorder the input numbers.\nEven though the first takes more time, the second solution does have the two limitations as the first one. It is not required to reorder the input numbers ( data in the code above). We read a number from data at each round, and all write operations are taken in the container leastNumbers . It does not require loading all input number into memory at one time, so it is suitable for huge-size data. Supposing our interview asks us get the least k numbers from a huge-size input. Obviously we cannot load all data with huge size into limited memory at one time. We can read a number from auxiliary space (such as disk) at each round with the first solution, and determine whether we need to insert it into the container leastNumbers . It works once memory can accommodate leastNumbers , so it is especially works when n is huge and k is small.\n\nThe characters of these two solutions can be summarized in Table 1:\n\nFirst Solution Second Solution Time complexity O( n *log k ) O( n ) Reorder input   numbers? No Yes Suitable for   huge-size data? Yes No\n\nFirst Solution\nSecond Solution\nTime complexity\nO( n *log k )\nO( n )\nReorder input   numbers?\nNo\nYes\nSuitable for   huge-size data?\nYes\nNo\nTable 1: Pros and cons of two solutions\n", "question": "\nQuestion: Please find out the least k numbers out of n numbers. For example, if given the 8 numbers 4, 5, 1, 6, 2, 7, 3 and 8, please return the least 4 numbers 1, 2, 3 and 4.\n"},
{"answer": "\nAnalysis: It\u2019s not difficult to get all substrings of a string, and to check whether a substring has duplicated characters. The only concern about this brute-force strategy is performance. A string with n characters has O( n 2 ) substrings, and it costs O( n ) time to check whether a substring has duplication. Therefore, the overall cost is O( n 3 ).\n\nWe may improve the efficiency with dynamic programming. Let\u2019s denote the length of longest substring ending with the i th character by L ( i ).\n\nWe scan the string one character after another. When the i th character is scanned, L ( i -1) is already know. If the i th character has not appeared before, L ( i ) should be L ( i -1)+1. It\u2019s more complex when the i th character is duplicated. Firstly we get the distance between the i th character and its previous occurrence. If the distance is greater than L ( i -1), the character is not in longest substring without duplication ending with the ( i -1) th character, so L ( i ) should also be L ( i -1)+1. If the distance is less than L ( i -1), L ( i ) is the distance, and it means between the two occurrence of the i th character there are no other duplicated characters.\n\nThis solution can be implemented in Java as the following code:\n\n public static int longestSubstringWithoutDuplication(String str) {\n     int curLength = 0;\n     int maxLength = 0;\n\n     int position[] = new int [26];\n     for ( int i = 0; i < 26; ++i) {\n         position[i] = -1;\n     }\n\n     for ( int i = 0; i < str.length(); ++i) {\n         int prevIndex = position[str.charAt(i) - 'a' ];\n         if (prevIndex < 0 || i - prevIndex > curLength) {\n             ++curLength;\n         }\n         else {\n             if (curLength > maxLength) {\n                 maxLength = curLength;\n             }\n\n             curLength = i - prevIndex;\n         }\n         position[str.charAt(i) - 'a' ] = i;\n     }\n\n     if (curLength > maxLength) {\n         maxLength = curLength;\n     }\n\n     return maxLength;\n }\n\n L ( i ) is implemented as curLength in the code above. Aninteger array is used to store the positions of each character.\n\n", "question": "\nProblem: Given a string, please get the length of the longest substring which does not have duplicated characters. Supposing all characters in the string are in the range from \u2018a\u2019 to \u2018z\u2019.\n"},
{"answer": "\nAnalysis: It\u2019s not difficult to get all substrings of a string, and to check whether a substring has duplicated characters. The only concern about this brute-force strategy is performance. A string with n characters has O( n 2 ) substrings, and it costs O( n ) time to check whether a substring has duplication. Therefore, the overall cost is O( n 3 ).\n\nWe may improve the efficiency with dynamic programming. Let\u2019s denote the length of longest substring ending with the i th character by L ( i ).\n\nWe scan the string one character after another. When the i th character is scanned, L ( i -1) is already know. If the i th character has not appeared before, L ( i ) should be L ( i -1)+1. It\u2019s more complex when the i th character is duplicated. Firstly we get the distance between the i th character and its previous occurrence. If the distance is greater than L ( i -1), the character is not in longest substring without duplication ending with the ( i -1) th character, so L ( i ) should also be L ( i -1)+1. If the distance is less than L ( i -1), L ( i ) is the distance, and it means between the two occurrence of the i th character there are no other duplicated characters.\n\nThis solution can be implemented in Java as the following code:\n\n public static int longestSubstringWithoutDuplication(String str) {\n     int curLength = 0;\n     int maxLength = 0;\n\n     int position[] = new int [26];\n     for ( int i = 0; i < 26; ++i) {\n         position[i] = -1;\n     }\n\n     for ( int i = 0; i < str.length(); ++i) {\n         int prevIndex = position[str.charAt(i) - 'a' ];\n         if (prevIndex < 0 || i - prevIndex > curLength) {\n             ++curLength;\n         }\n         else {\n             if (curLength > maxLength) {\n                 maxLength = curLength;\n             }\n\n             curLength = i - prevIndex;\n         }\n         position[str.charAt(i) - 'a' ] = i;\n     }\n\n     if (curLength > maxLength) {\n         maxLength = curLength;\n     }\n\n     return maxLength;\n }\n\n L ( i ) is implemented as curLength in the code above. Aninteger array is used to store the positions of each character.\n\n", "question": "\nProblem: Given a string, please get the length of the longest substring which does not have duplicated characters. Supposing all characters in the string are in the range from \u2018a\u2019 to \u2018z\u2019.\n"},
{"answer": "\nAnalysis: Let\u2019s delete a digit from the number at each step. What\u2019s the first digit to be deleted from the number 24635, in order to get the least number with the remaining digits? We may list all the remaining numbers after deleting a digit, in the following table:\nDeleted   Digit\nRemaining   Number\n2\n4635\n4\n2635\n6\n2435\n3\n2465\n5\n2463\nThe number 2435 is the least one in all remaining numbers, by deleting the digit 6. Notice that the digit 6 is the first digit in the number 24635 which is greater than the next digit.\nLet\u2019s delete another digit from the number 2435, the remaining least number after the first step. We may summarize the remaining numbers after delete every digit from it in the following table:\nDeleted   Digit\nRemaining   Number\n2\n435\n4\n235\n3\n245\n5\n243\nThe number 235 is the least one in all remaining numbers, by deleting the digit 4. Notice that the digit 4 is the first digit in the number 2435 which is greater than the next digit.\nThe remaining three digits in the number 235 are increasingly sorted. What is the next digit to be deleted to get the least remaining number? Again, we may list the remaining numbers after deleting each digit in a table:\nDeleted   Digit\nRemaining   Number\n2\n35\n3\n25\n5\n23\nThe number 23 is the least one in all remaining numbers, by deleting the last digit 5.\nIf we are going to deleting more digits from a number whose digits are increasingly sorted to get the least number, the last digit is deleted at each step.\nNow we get the rules to delete digits to get the least remaining number: If there are digits who are greater than the next one, delete the first digit. If all digits in the number are increasingly sorted, delete the last digit gets deleted. The process repeats until the required k digits are deleted.\nThe code can be implemented in Java as the following:\n public static String getLeastNumberDeletingDigits_1(String number, int k) {\n     String leastNumber = number;\n     while (k > 0 && leastNumber.length() > 0) {\n         int firstDecreasingDigit = getFirstDecreasing(leastNumber);\n         if (firstDecreasingDigit >= 0) {\n             leastNumber =removeDigit(leastNumber, firstDecreasingDigit);\n         }\n         else {\n             leastNumber =removeDigit(leastNumber, leastNumber.length() - 1);\n         }\n\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static int getFirstDecreasing(String number) {\n     for ( int i = 0; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             return i;\n         }\n     }\n\n     return -1;\n }\n\n private static String removeDigit(String number, int digitIndex) {\n     String result = \"\" ;\n     if (digitIndex > 0) {\n         result = number.substring(0,digitIndex);\n     }\n     if (digitIndex < number.length() - 1) {\n         result += number.substring(digitIndex +1);\n     }\n\n     return result;\n }\n\nOptimization: Save the start index for the next round of search for the first decreasing digit\n\n In the method getFirstDecreasing above to get the first digit which is greater than the next one, we always startfrom the first digit. Is it necessary to start over in every round of search?\n\nThe answer is no. If the i th digit is the first digit which is greater than the next one, all digits before the i th digit are increasingly sorted. The ( i-1) th digit might be less than the ( i+1) th digit, the next digit of the ( i-1) th digit after the i th digit is deleted. Therefore, it is safe to start from the ( i-1) th digit in the next round of search.\n\nWith this optimization strategy, the efficiency gets improved from O( n * k ) to O( n ), if the length of the input number has n digits and k digits are deleted.\n\nThe optimized solution can be implemented as:\n\n class DecreasingResult {\n     public int firstDecreasing;\n     public int nextStart;\n }\n\n public static String getLeastNumberDeletingDigits_2(String number, int k) {\n     String leastNumber = number;\n     int start = 0;\n     while (k > 0 && leastNumber.length() > 0) {\n        DecreasingResult result = getNextDecreasing(leastNumber, start);\n         if (result.firstDecreasing >= 0) {\n             leastNumber =removeDigit(leastNumber, result.firstDecreasing);\n         }\n         else {\n             leastNumber = removeDigit(leastNumber,leastNumber.length() - 1);\n         }\n\n         start = result.nextStart;\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static DecreasingResult getNextDecreasing(String number, int start) {\n     int firstDecreasing = -1;\n     int nextStart;\n\n     for ( int i = start; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             firstDecreasing = i;\n             break ;\n         }\n     }\n\n     if (firstDecreasing == 0) {\n         nextStart = 0;\n     }\n     else if (firstDecreasing > 0) {\n         nextStart = firstDecreasing - 1;\n     }\n     else {\n         nextStart = number.length();\n     }\n\n     DecreasingResult result = new DecreasingResult();\n     result.firstDecreasing = firstDecreasing;\n     result.nextStart = nextStart;\n\n     return result;\n }\n\n", "question": "\nProblem: Please get the least number after deleting k digits from the input number. For example, if the input number is 24635, the least number is 23 after deleting 3 digits."},
{"answer": "\nAnalysis: It\u2019s not difficult to get all substrings of a string, and to check whether a substring has duplicated characters. The only concern about this brute-force strategy is performance. A string with n characters has O( n 2 ) substrings, and it costs O( n ) time to check whether a substring has duplication. Therefore, the overall cost is O( n 3 ).\n\nWe may improve the efficiency with dynamic programming. Let\u2019s denote the length of longest substring ending with the i th character by L ( i ).\n\nWe scan the string one character after another. When the i th character is scanned, L ( i -1) is already know. If the i th character has not appeared before, L ( i ) should be L ( i -1)+1. It\u2019s more complex when the i th character is duplicated. Firstly we get the distance between the i th character and its previous occurrence. If the distance is greater than L ( i -1), the character is not in longest substring without duplication ending with the ( i -1) th character, so L ( i ) should also be L ( i -1)+1. If the distance is less than L ( i -1), L ( i ) is the distance, and it means between the two occurrence of the i th character there are no other duplicated characters.\n\nThis solution can be implemented in Java as the following code:\n\n public static int longestSubstringWithoutDuplication(String str) {\n     int curLength = 0;\n     int maxLength = 0;\n\n     int position[] = new int [26];\n     for ( int i = 0; i < 26; ++i) {\n         position[i] = -1;\n     }\n\n     for ( int i = 0; i < str.length(); ++i) {\n         int prevIndex = position[str.charAt(i) - 'a' ];\n         if (prevIndex < 0 || i - prevIndex > curLength) {\n             ++curLength;\n         }\n         else {\n             if (curLength > maxLength) {\n                 maxLength = curLength;\n             }\n\n             curLength = i - prevIndex;\n         }\n         position[str.charAt(i) - 'a' ] = i;\n     }\n\n     if (curLength > maxLength) {\n         maxLength = curLength;\n     }\n\n     return maxLength;\n }\n\n L ( i ) is implemented as curLength in the code above. Aninteger array is used to store the positions of each character.\n\n", "question": "\nProblem: Given a string, please get the length of the longest substring which does not have duplicated characters. Supposing all characters in the string are in the range from \u2018a\u2019 to \u2018z\u2019.\n"},
{"answer": "\nAnalysis: It\u2019s not difficult to get all substrings of a string, and to check whether a substring has duplicated characters. The only concern about this brute-force strategy is performance. A string with n characters has O( n 2 ) substrings, and it costs O( n ) time to check whether a substring has duplication. Therefore, the overall cost is O( n 3 ).\n\nWe may improve the efficiency with dynamic programming. Let\u2019s denote the length of longest substring ending with the i th character by L ( i ).\n\nWe scan the string one character after another. When the i th character is scanned, L ( i -1) is already know. If the i th character has not appeared before, L ( i ) should be L ( i -1)+1. It\u2019s more complex when the i th character is duplicated. Firstly we get the distance between the i th character and its previous occurrence. If the distance is greater than L ( i -1), the character is not in longest substring without duplication ending with the ( i -1) th character, so L ( i ) should also be L ( i -1)+1. If the distance is less than L ( i -1), L ( i ) is the distance, and it means between the two occurrence of the i th character there are no other duplicated characters.\n\nThis solution can be implemented in Java as the following code:\n\n public static int longestSubstringWithoutDuplication(String str) {\n     int curLength = 0;\n     int maxLength = 0;\n\n     int position[] = new int [26];\n     for ( int i = 0; i < 26; ++i) {\n         position[i] = -1;\n     }\n\n     for ( int i = 0; i < str.length(); ++i) {\n         int prevIndex = position[str.charAt(i) - 'a' ];\n         if (prevIndex < 0 || i - prevIndex > curLength) {\n             ++curLength;\n         }\n         else {\n             if (curLength > maxLength) {\n                 maxLength = curLength;\n             }\n\n             curLength = i - prevIndex;\n         }\n         position[str.charAt(i) - 'a' ] = i;\n     }\n\n     if (curLength > maxLength) {\n         maxLength = curLength;\n     }\n\n     return maxLength;\n }\n\n L ( i ) is implemented as curLength in the code above. Aninteger array is used to store the positions of each character.\n\n", "question": "\nProblem: Given a string, please get the length of the longest substring which does not have duplicated characters. Supposing all characters in the string are in the range from \u2018a\u2019 to \u2018z\u2019.\n"},
{"answer": "\nAnalysis: It looks difficult to get rules of left rotation on a string. Fortunately, the 7 th problem in this series \u201c Reverse Words in a Sentence \u201d can give us some hints.\n\nIf we input a sentence with two words \u201chello world\u201d for the problem \u201cReverse Words in a Sentence\u201d, the reversed result should be \u201cworld hello\u201d. It is noticeable that the result \u201cworld hello\u201d can be viewed as a rotated result of \u201chello world\u201d. It becomes \u201cworld hello\u201d when we move some leading characters of string \u201chello world\u201d to its ending. Therefore, this problem is quite similar to problem \u201cReverse Words in a Sentence\u201d.\n\nLet us take a string \u201cabcdefg\u201d as an example. We divide it into two parts: the first part contains the two leading characters \u201cab\u201d, and the second part contains all other characters \u201ccdefg\u201d. We firstly reverse these two parts separately, and the whole string becomes \u201cbagfedc\u201d. It becomes \u201ccdefgab\u201d if we reverse the whole string, which is the expected result of left rotation with 2.\n\nAccording to the analysis above, we can see that left rotation of a string can be implemented calling a Reverse function three times to reverse a segment or whole string. The sample code is shown below:\n\nchar * LeftRotateString( char * pStr, int n)\n{\nif (pStr != NULL)\n{\nint nLength = static_cast < int >(strlen(pStr));\nif (nLength > 0 && n > 0 && n < nLength)\n{\nchar * pFirstStart = pStr;\nchar * pFirstEnd = pStr + n - 1;\nchar * pSecondStart = pStr + n;\nchar * pSecondEnd = pStr + nLength - 1;\n\n// Reverse the n leading characters\nReverse(pFirstStart, pFirstEnd);\n// Reverse other characters\nReverse(pSecondStart, pSecondEnd);\n// Reverse the whole string\nReverse(pFirstStart, pSecondEnd);\n}\n}\n\nreturn pStr;\n}\n\nThe function Reverse is shown in \u201c Reverse Words in a Sentence \u201d, so we are not going to repeat it here.", "question": "\nProblem: Left rotation of a string is to move some leading characters to its tail. Please implement a function to rotate a string.\n\nFor example, if the input string is \u201cabcdefg\u201d and a number 2, the rotated result is \u201ccdefgab\u201d.\n"},
{"answer": "\nAnalysis: It looks difficult to get rules of left rotation on a string. Fortunately, the 7 th problem in this series \u201c Reverse Words in a Sentence \u201d can give us some hints.\n\nIf we input a sentence with two words \u201chello world\u201d for the problem \u201cReverse Words in a Sentence\u201d, the reversed result should be \u201cworld hello\u201d. It is noticeable that the result \u201cworld hello\u201d can be viewed as a rotated result of \u201chello world\u201d. It becomes \u201cworld hello\u201d when we move some leading characters of string \u201chello world\u201d to its ending. Therefore, this problem is quite similar to problem \u201cReverse Words in a Sentence\u201d.\n\nLet us take a string \u201cabcdefg\u201d as an example. We divide it into two parts: the first part contains the two leading characters \u201cab\u201d, and the second part contains all other characters \u201ccdefg\u201d. We firstly reverse these two parts separately, and the whole string becomes \u201cbagfedc\u201d. It becomes \u201ccdefgab\u201d if we reverse the whole string, which is the expected result of left rotation with 2.\n\nAccording to the analysis above, we can see that left rotation of a string can be implemented calling a Reverse function three times to reverse a segment or whole string. The sample code is shown below:\n\nchar * LeftRotateString( char * pStr, int n)\n{\nif (pStr != NULL)\n{\nint nLength = static_cast < int >(strlen(pStr));\nif (nLength > 0 && n > 0 && n < nLength)\n{\nchar * pFirstStart = pStr;\nchar * pFirstEnd = pStr + n - 1;\nchar * pSecondStart = pStr + n;\nchar * pSecondEnd = pStr + nLength - 1;\n\n// Reverse the n leading characters\nReverse(pFirstStart, pFirstEnd);\n// Reverse other characters\nReverse(pSecondStart, pSecondEnd);\n// Reverse the whole string\nReverse(pFirstStart, pSecondEnd);\n}\n}\n\nreturn pStr;\n}\n\nThe function Reverse is shown in \u201c Reverse Words in a Sentence \u201d, so we are not going to repeat it here.", "question": "\nProblem: Left rotation of a string is to move some leading characters to its tail. Please implement a function to rotate a string.\n\nFor example, if the input string is \u201cabcdefg\u201d and a number 2, the rotated result is \u201ccdefgab\u201d.\n"},
{"answer": "\nAnalysis: It looks difficult to get rules of left rotation on a string. Fortunately, the 7 th problem in this series \u201c Reverse Words in a Sentence \u201d can give us some hints.\n\nIf we input a sentence with two words \u201chello world\u201d for the problem \u201cReverse Words in a Sentence\u201d, the reversed result should be \u201cworld hello\u201d. It is noticeable that the result \u201cworld hello\u201d can be viewed as a rotated result of \u201chello world\u201d. It becomes \u201cworld hello\u201d when we move some leading characters of string \u201chello world\u201d to its ending. Therefore, this problem is quite similar to problem \u201cReverse Words in a Sentence\u201d.\n\nLet us take a string \u201cabcdefg\u201d as an example. We divide it into two parts: the first part contains the two leading characters \u201cab\u201d, and the second part contains all other characters \u201ccdefg\u201d. We firstly reverse these two parts separately, and the whole string becomes \u201cbagfedc\u201d. It becomes \u201ccdefgab\u201d if we reverse the whole string, which is the expected result of left rotation with 2.\n\nAccording to the analysis above, we can see that left rotation of a string can be implemented calling a Reverse function three times to reverse a segment or whole string. The sample code is shown below:\n\nchar * LeftRotateString( char * pStr, int n)\n{\nif (pStr != NULL)\n{\nint nLength = static_cast < int >(strlen(pStr));\nif (nLength > 0 && n > 0 && n < nLength)\n{\nchar * pFirstStart = pStr;\nchar * pFirstEnd = pStr + n - 1;\nchar * pSecondStart = pStr + n;\nchar * pSecondEnd = pStr + nLength - 1;\n\n// Reverse the n leading characters\nReverse(pFirstStart, pFirstEnd);\n// Reverse other characters\nReverse(pSecondStart, pSecondEnd);\n// Reverse the whole string\nReverse(pFirstStart, pSecondEnd);\n}\n}\n\nreturn pStr;\n}\n\nThe function Reverse is shown in \u201c Reverse Words in a Sentence \u201d, so we are not going to repeat it here.", "question": "\nProblem: Left rotation of a string is to move some leading characters to its tail. Please implement a function to rotate a string.\n\nFor example, if the input string is \u201cabcdefg\u201d and a number 2, the rotated result is \u201ccdefgab\u201d.\n"},
{"answer": "\nAnalysis: It looks difficult to get rules of left rotation on a string. Fortunately, the 7 th problem in this series \u201c Reverse Words in a Sentence \u201d can give us some hints.\n\nIf we input a sentence with two words \u201chello world\u201d for the problem \u201cReverse Words in a Sentence\u201d, the reversed result should be \u201cworld hello\u201d. It is noticeable that the result \u201cworld hello\u201d can be viewed as a rotated result of \u201chello world\u201d. It becomes \u201cworld hello\u201d when we move some leading characters of string \u201chello world\u201d to its ending. Therefore, this problem is quite similar to problem \u201cReverse Words in a Sentence\u201d.\n\nLet us take a string \u201cabcdefg\u201d as an example. We divide it into two parts: the first part contains the two leading characters \u201cab\u201d, and the second part contains all other characters \u201ccdefg\u201d. We firstly reverse these two parts separately, and the whole string becomes \u201cbagfedc\u201d. It becomes \u201ccdefgab\u201d if we reverse the whole string, which is the expected result of left rotation with 2.\n\nAccording to the analysis above, we can see that left rotation of a string can be implemented calling a Reverse function three times to reverse a segment or whole string. The sample code is shown below:\n\nchar * LeftRotateString( char * pStr, int n)\n{\nif (pStr != NULL)\n{\nint nLength = static_cast < int >(strlen(pStr));\nif (nLength > 0 && n > 0 && n < nLength)\n{\nchar * pFirstStart = pStr;\nchar * pFirstEnd = pStr + n - 1;\nchar * pSecondStart = pStr + n;\nchar * pSecondEnd = pStr + nLength - 1;\n\n// Reverse the n leading characters\nReverse(pFirstStart, pFirstEnd);\n// Reverse other characters\nReverse(pSecondStart, pSecondEnd);\n// Reverse the whole string\nReverse(pFirstStart, pSecondEnd);\n}\n}\n\nreturn pStr;\n}\n\nThe function Reverse is shown in \u201c Reverse Words in a Sentence \u201d, so we are not going to repeat it here.", "question": "\nProblem: Left rotation of a string is to move some leading characters to its tail. Please implement a function to rotate a string.\n\nFor example, if the input string is \u201cabcdefg\u201d and a number 2, the rotated result is \u201ccdefgab\u201d.\n"},
{"answer": "\nAnalysis: Many candidates can get a straight solution which converts the input number into a string first. However, it is not what interviewers expect usually.\n\nSolution 1: Convert a Number into a String\n\nIt is easy to check whether a number is palindrome or not: We can check whether the first character and the last one are identical, and then check the second character and the second one from end, and so on. Therefore, we can firstly convert the input number into a string via the function sprintf , and then check whether the string is a palindrome.\n\nThis solution can be implemented as the following code:\n\nbool IsPalindrome_solution1( unsigned int number)\n{\nconst int NUMBER_LENGTH = 20;\nchar string[NUMBER_LENGTH];\nsprintf(string, \"%d\" , number);\n\nreturn IsPalindrome(string);\n}\n\nbool IsPalindrome( const char * const string)\n{\nbool palindrome = true ;\nif (string != NULL)\n{\nint length = strlen(string);\nint half = length >> 1;\n\nfor ( int i = 0; i < half; ++ i)\n{\nif (string[i] != string[length - 1 - i])\n{\npalindrome = false ;\nbreak ;\n}\n}\n}\n\nreturn palindrome;\n}\n\nUsually the solution above is not the one expected by interviewers. One reason is that it is intuitive while interviewers expect something innovative, and the other is that it requires auxiliary memory to store the converted string.\n\nSolution 2: Compose a Reversed Number\n\nAs we know, it is easy to get digits from right to left via / and % operators. For example, digits in the number 123 are 3, 2 and 1. We can construct a reversed number 321 with these three digits. And then we check whether the reverse number is identical to the original one. If it is, the original number is a palindrome.\n\nIts corresponding code is shown below:\n\nbool IsPalindrome_solution2( unsigned int number)\n{\nint reversed = 0;\nint copy = number;\n\nwhile (number != 0)\n{\nreversed = reversed * 10 + number % 10;\nnumber /= 10;\n}\n\nreturn (reversed == copy);\n}", "question": "\nProblem: Please implement a function which checks whether a number is a palindrome or not. For example, 121 is a palindrome, while 123 is not.\n"},
{"answer": "\nAnalysis: As we know, the binary search algorithm is suitable to search a number in a sorted array. Since the input array for this problem is partially sorted, we may also have a try with binary search.\n\nLet us try to get the middle number in an array. The middle number of array {1, 2, 3, 4, 5, 10, 9, 8, 7, 6} is 5 (the fourth number). It is greater than its previous number 4, and less than its next number 10, so it is in the increasing sub-array. Therefore, numbers before 5 can be discarded in the next round of search.\n\nThe remaining numbers for the next round of search are {5, 10, 9, 8, 7, 6}, and the number 9 is in the middle of them. Since 9 is less than is previous number 10 and greater than its next number 8, it is in the decreasing sub-array. Therefore, numbers after 9 can be discarded in the next round of search.\n\nThe remaining numbers for the next round of search are {5, 10, 9}, and the number 10 is in the middle. It is noticeable that number 10 is greater than its previous number 5 and greater than its next number 9, so it is the maximum number. That is to say, the number 10 is the turning number in the input array.\n\nWe can see the process above is actually a classic binary search. Therefore, we can implement the required function based on binary search algorithm, as listed below:\n\nint TurningNumberIndex( int * numbers, int length)\n{\nif (numbers == NULL || length <= 2)\nreturn -1;\n\nint left = 0;\nint right = length - 1;\nwhile (right > left + 1)\n{\nint middle = (left + right) / 2;\nif (middle == 0 || middle == length - 1)\nreturn -1;\n\nif (numbers[middle] > numbers[middle - 1] &&\nnumbers[middle] > numbers[middle + 1])\nreturn middle;\nelse if (numbers[middle] > numbers[middle - 1] &&\nnumbers[middle] < numbers[middle + 1])\nleft = middle;\nelse\nright = middle;\n}\n\nreturn -1;\n}", "question": "\nProblem: Turning number is the maximum number in an array which increases and then decreases. This kind of array is also named unimodal array. Please write a function which gets the index of the turning number in such an array.\n\nFor example, the turning number in array {1, 2, 3, 4, 5, 10, 9, 8, 7, 6} is 10, so its index 5 is the expected output.\n"},
{"answer": "\nAnalysis: This problem is not meaningful during software development since usually we do not have such rigorous limitations. However, many interviewers believe that it is useful to test candidates\u2019 ability of divergent thinking. Ability of divergent thinking reflects the depth and width of programming understanding.\n\nBesides equation n(n+1)/2 to get 1+2+\u2026+n, we only have two approaches: Iteration and recursion. Since key words for and while are forbidden, we cannot utilize iteration directly any more. In a recursive function, we need to use key word if or conditional operators to check whether we should continue or stop recursion. Unfortunately, both of them are also forbidden.\n\nSolution 1: Based on Constructors\n\nLet us firstly focus on iterations. An iteration is actually only to repeat n times, and we can achieve it without key words for and while . We can define a class, and then create n instances of it. Therefore, its constructor and destructor will be definitely called n times. If we implement calculation operations inside the constructor, it will iterate for n times. The following code is based on this solution:\n\nclass Temp\n{\npublic :\nTemp() { ++ N; Sum += N; }\n\nstatic void Reset() { N = 0; Sum = 0; }\nstatic unsigned int GetSum() { return Sum; }\n\nprivate :\nstatic unsigned int N;\nstatic unsigned int Sum;\n};\n\nunsigned int Temp::N = 0;\nunsigned int Temp::Sum = 0;\n\nunsigned int Sum_Solution1( unsigned int n)\n{\nTemp::Reset();\n\nTemp *a = new Temp[n];\ndelete []a;\na = NULL;\n\nreturn Temp::GetSum();\n}\n\nSolution 2: Based on Virtual Functions\n\nWe secondly focus on recursion. We cannot determine to continue or stop recursion inside a single function. How about to define two functions, one for normal operations and the other as a terminator? We may use Boolean variables since we are going to select a function out of two. When the Boolean variable is true (1), the operational function will be selected. When it is false (0), the terminal function will be selected.\n\nWe have to convert integer variables into Boolean variables. It is an easy task since it can be achieved with two not operations (!!n). Non-zero numbers will be true with two not operations and zero will be false .\n\nclass A;\nA* Array[2];\n\nclass A\n{\npublic :\nvirtual unsigned int Sum ( unsigned int n)\n{\nreturn 0;\n}\n};\n\nclass B: public A\n{\npublic :\nvirtual unsigned int Sum ( unsigned int n)\n{\nreturn Array[!!n]->Sum(n-1) + n;\n}\n};\n\nint Sum_Solution2( int n)\n{\nA a;\nB b;\nArray[0] = &a;\nArray[1] = &b;\n\nint value = Array[1]->Sum(n);\n\nreturn value;\n}\n\nThis solution is based on virtual functions. The function B::Sum is called when variable n is not zero, while the function A::Sum , which acts as a terminator, is called when n equals to zero.\n\nSolution 3: Based on Function Pointers\n\nThere are no virtual functions in native C programming environment, so we have to simulate them with function pointers. The code below may be more straightforward:\ntypedef unsigned int (*fun)( unsigned int );\n\nunsigned int Solution3_Teminator( unsigned int n)\n{\nreturn 0;\n}\n\nunsigned int Sum_Solution3( unsigned int n)\n{\nstatic fun f[2] = {Solution3_Teminator, Sum_Solution3};\nreturn n + f[!!n](n - 1);\n}\n\nSolution 4: Based on Template Classes\n\nWe can also utilize compiler to simulate recursive calculate. Let us have a look at the following code:\ntemplate < unsigned int n> struct Sum_Solution4\n{\nenum Value { N = Sum_Solution4<n - 1>::N + n};\n};\n\ntemplate <> struct Sum_Solution4<1>\n{\nenum Value { N = 1};\n};\n\nThe value of Sum_Solution4<100>::N is the result of 1+2+\u2026+100. When compilers see Sum_Solution4<100> , it will generate code for the template class Sum_Solution4 with parameter 100. A class Sum _S olution4 <99> is needed to generate the class Sum_Solution4<100> since Sum _Solution4<100>::N= Sum _Solution4 <99>::N+100 . The recursive process stops when it reaches the Sum_Solution4<1> because it has been defined explicitly.\n", "question": "\nProblem: Calculate 1+2+\u2026+n without multiplication, division, key words for , while , if , else , switch , case , as well as conditional operator (A ? B : C).\n"},
{"answer": "\nAnalysis: In a list with n nodes, its k th node from end should be the (n-k+1) th node from its head. Therefore, if we know the number of nodes n in a list, we can get the required node with n-k+1 steps from its head. How to get the number n? It is easy if we scan the whole list from beginning to end.\n\nThe solution above needs to scan a list twice: We get the total number of nodes with the first scan, and reach the k th node from end with the second scan. Unfortunately, interviewers usually expect a solution which only scans a list once.\n\nWe have a better solution to get the k th node from end with two pointers. Firstly we move a pointer (denoted as P1) k-1 steps beginning from the head of a list. And then we move another pointer (denoted as P2) beginning from the head, and continue moving the P1 forward at same speed. Since the distance of these two pointers is always k-1, P2 reaches the k th node from end when P1 reaches the tail of a list. It scans a list only once, and it is more efficient than the previous solution.\n\n\n\nFigure 1: Get the 3 rd node from end of a list with 6 nodes\n\nIt simulates the process to get the 3 rd node from end of a list with 6 nodes in Figure 1. We firstly move P1 2 steps (2=3-1) to reach the 3 rd node (Figure 1-a). Then P2 points to the head of a list (Figure 1-b). We move two pointers at the same speed, when the P1 reaches the tail, what P2 points is the 3 rd node from end (Figure 1-c).\n\nThe sample code of the solutions with two pointers is shown below:\n\nListNode* FindKthToTail(ListNode* pListHead, unsigned int k)\n{\nif (pListHead == NULL || k == 0)\nreturn NULL;\n\nListNode *pAhead = pListHead;\nListNode *pBehind = NULL;\n\nfor ( unsigned int i = 0; i < k - 1; ++ i)\n{\nif (pAhead->m_pNext != NULL)\npAhead = pAhead->m_pNext;\nelse\n{\nreturn NULL;\n}\n}\n\npBehind = pListHead;\nwhile (pAhead->m_pNext != NULL)\n{\npAhead = pAhead->m_pNext;\npBehind = pBehind->m_pNext;\n}\n\nreturn pBehind;", "question": "\nProblem: Get the K th node from end of a linked list. It counts from 1 here, so the 1 st node from end is the tail of list.\n\nFor instance, given a linked list with 6 nodes, whose value are 1, 2, 3, 4, 5, 6, its 3 rd node from end is the node with value 4.\n\nA node in the list is defined as:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: In a list with n nodes, its k th node from end should be the (n-k+1) th node from its head. Therefore, if we know the number of nodes n in a list, we can get the required node with n-k+1 steps from its head. How to get the number n? It is easy if we scan the whole list from beginning to end.\n\nThe solution above needs to scan a list twice: We get the total number of nodes with the first scan, and reach the k th node from end with the second scan. Unfortunately, interviewers usually expect a solution which only scans a list once.\n\nWe have a better solution to get the k th node from end with two pointers. Firstly we move a pointer (denoted as P1) k-1 steps beginning from the head of a list. And then we move another pointer (denoted as P2) beginning from the head, and continue moving the P1 forward at same speed. Since the distance of these two pointers is always k-1, P2 reaches the k th node from end when P1 reaches the tail of a list. It scans a list only once, and it is more efficient than the previous solution.\n\n\n\nFigure 1: Get the 3 rd node from end of a list with 6 nodes\n\nIt simulates the process to get the 3 rd node from end of a list with 6 nodes in Figure 1. We firstly move P1 2 steps (2=3-1) to reach the 3 rd node (Figure 1-a). Then P2 points to the head of a list (Figure 1-b). We move two pointers at the same speed, when the P1 reaches the tail, what P2 points is the 3 rd node from end (Figure 1-c).\n\nThe sample code of the solutions with two pointers is shown below:\n\nListNode* FindKthToTail(ListNode* pListHead, unsigned int k)\n{\nif (pListHead == NULL || k == 0)\nreturn NULL;\n\nListNode *pAhead = pListHead;\nListNode *pBehind = NULL;\n\nfor ( unsigned int i = 0; i < k - 1; ++ i)\n{\nif (pAhead->m_pNext != NULL)\npAhead = pAhead->m_pNext;\nelse\n{\nreturn NULL;\n}\n}\n\npBehind = pListHead;\nwhile (pAhead->m_pNext != NULL)\n{\npAhead = pAhead->m_pNext;\npBehind = pBehind->m_pNext;\n}\n\nreturn pBehind;", "question": "\nProblem: Get the K th node from end of a linked list. It counts from 1 here, so the 1 st node from end is the tail of list.\n\nFor instance, given a linked list with 6 nodes, whose value are 1, 2, 3, 4, 5, 6, its 3 rd node from end is the node with value 4.\n\nA node in the list is defined as:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: This is a typical problem which can be solved by dynamic programming. We have two strategies to analyze and solve this problem\n\nSolution 1: Split at any space between two characters\n\nGiven a substring of str , starting from the index i and ending at the index j (denoted as str [ i : j ]), we define a function f ( i , j ) to denote the minimal number of splits to partition the substring str [ i : j ] into a set of palindromes. If the substring is a palindrome itself, we don\u2019t have to split so f ( i , j ) is 0. If the substring is not a palindrome, the substring is split between two characters k and k +1. f ( i , j )= f ( i , k )+ f ( k +1, j )+1 under such conditions. Therefore, f ( i , j ) can be defined with the following equation:\n\n\nThe value of f (0, n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nIf the equation is calculated recursively, its complexity grows exponentially with the length n . A better choice is to calculate in bottom-up order with a 2D matrix with size n \u00d7 n . The following C++ code implements this solution:\n\n int minSplit_1( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length * length];\n    \n     for ( int i = 0; i <length; ++i)\n        split[i * length + i] = 0;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         for ( int j = length -i; j > 0; --j)\n         {\n             int row = length - i - j;\n             int col = row + i;\n             if (isPalindrome(str, row, col))\n             {\n                split[row * length + col] = 0;\n             }\n             else\n             {\n                 int min = 0x7FFFFFFF;\n                 for ( int k = row; k < col; ++k)\n                {\n                     int temp1 = split[row * length + k];\n                     int temp2 = split[(k + 1) * length +col];\n                     if (min> temp1 + temp2 + 1)\n                         min = temp1 + temp2 +1;\n                }\n                split[row * length + col] = min;\n             }\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nSolution 2: Split only before a palindrome\n\nWe split the string str with another strategy. Given a substring ending at the index i , str [0, i], we do not have to split if the substring is a palindrome itself. Otherwise it is split between two characters at index j and j +1 only if the substring str [ j +1, i ] is a palindrome. Therefore, an equation f ( i ) can be defined as the following:\n\n\nThe value of f ( n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nWe could utilize a 1D array to solve this equation in bottom-up order, as listed in the following code:\n\n int minSplit_2( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length];\n     for ( int i = 0; i <length; ++i)\n        split[i] = i;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         if (isPalindrome(str, 0, i))\n         {\n            split[i] = 0;\n             continue ;\n         }\n\n         for ( int j = 0; j <i; ++j)\n         {\n             if (isPalindrome(str, j + 1, i) && split[i]> split[j] + 1)\n                split[i] = split[j] + 1;\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nOptimization to verify palindromes:\n\nUsually it costs O( n ) time to check whether a string with length n is a palindrome, and the typical implementation looks like the following code:\n\n bool isPalindrome( const string& str, int begin, int end)\n {\n     for ( int i = begin; i< end - (i - begin); ++i)\n     {\n         if (str[i] != str[end - (i - begin)])\n             return false ;\n     }\n\n     return true ;\n }\n\nBoth solutions above cost O( n 3 ) time. The first solution contains three nesting for-loops. The function isPalindrome is inside two nesting for-loops.\n\nIf we could reduce the cost of isPalindrome to O(1), the time complexity of the second solution would be O( n 2 ).\n\nNotice that the substring str [ i , j ] is a palindrome only if the characters at index i and j , and str [ i +1, j -1] is also a palindrome. We could build a 2D table accordingly to store whether every substring of str is a palindrome or not during the preprocessing. With such a table, the function isPalindrome can verify the substring str [ i , j ] in O(1) time.\n\n", "question": "\nProblem: A string can be partitioned into some substrings, such that each substring is a palindrome. For example, there are a few strategies to split the string \u201cabbab\u201d into palindrome substrings, such as: \u201cabba\u201d|\u201db\u201d, \u201ca\u201d|\u201db\u201d|\u201dbab\u201d and \u201ca\u201d|\u201dbb\u201d|\u201da\u201d|\u201db\u201d.\n\nGiven a string str , please get the minimal numbers of splits to partition it into palindromes. The minimal number of splits to partition the string \u201cabbab\u201d into a set of palindromes is 1.\n"},
{"answer": "\nAnalysis: In a list with n nodes, its k th node from end should be the (n-k+1) th node from its head. Therefore, if we know the number of nodes n in a list, we can get the required node with n-k+1 steps from its head. How to get the number n? It is easy if we scan the whole list from beginning to end.\n\nThe solution above needs to scan a list twice: We get the total number of nodes with the first scan, and reach the k th node from end with the second scan. Unfortunately, interviewers usually expect a solution which only scans a list once.\n\nWe have a better solution to get the k th node from end with two pointers. Firstly we move a pointer (denoted as P1) k-1 steps beginning from the head of a list. And then we move another pointer (denoted as P2) beginning from the head, and continue moving the P1 forward at same speed. Since the distance of these two pointers is always k-1, P2 reaches the k th node from end when P1 reaches the tail of a list. It scans a list only once, and it is more efficient than the previous solution.\n\n\n\nFigure 1: Get the 3 rd node from end of a list with 6 nodes\n\nIt simulates the process to get the 3 rd node from end of a list with 6 nodes in Figure 1. We firstly move P1 2 steps (2=3-1) to reach the 3 rd node (Figure 1-a). Then P2 points to the head of a list (Figure 1-b). We move two pointers at the same speed, when the P1 reaches the tail, what P2 points is the 3 rd node from end (Figure 1-c).\n\nThe sample code of the solutions with two pointers is shown below:\n\nListNode* FindKthToTail(ListNode* pListHead, unsigned int k)\n{\nif (pListHead == NULL || k == 0)\nreturn NULL;\n\nListNode *pAhead = pListHead;\nListNode *pBehind = NULL;\n\nfor ( unsigned int i = 0; i < k - 1; ++ i)\n{\nif (pAhead->m_pNext != NULL)\npAhead = pAhead->m_pNext;\nelse\n{\nreturn NULL;\n}\n}\n\npBehind = pListHead;\nwhile (pAhead->m_pNext != NULL)\n{\npAhead = pAhead->m_pNext;\npBehind = pBehind->m_pNext;\n}\n\nreturn pBehind;", "question": "\nProblem: Get the K th node from end of a linked list. It counts from 1 here, so the 1 st node from end is the tail of list.\n\nFor instance, given a linked list with 6 nodes, whose value are 1, 2, 3, 4, 5, 6, its 3 rd node from end is the node with value 4.\n\nA node in the list is defined as:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: In a list with n nodes, its k th node from end should be the (n-k+1) th node from its head. Therefore, if we know the number of nodes n in a list, we can get the required node with n-k+1 steps from its head. How to get the number n? It is easy if we scan the whole list from beginning to end.\n\nThe solution above needs to scan a list twice: We get the total number of nodes with the first scan, and reach the k th node from end with the second scan. Unfortunately, interviewers usually expect a solution which only scans a list once.\n\nWe have a better solution to get the k th node from end with two pointers. Firstly we move a pointer (denoted as P1) k-1 steps beginning from the head of a list. And then we move another pointer (denoted as P2) beginning from the head, and continue moving the P1 forward at same speed. Since the distance of these two pointers is always k-1, P2 reaches the k th node from end when P1 reaches the tail of a list. It scans a list only once, and it is more efficient than the previous solution.\n\n\n\nFigure 1: Get the 3 rd node from end of a list with 6 nodes\n\nIt simulates the process to get the 3 rd node from end of a list with 6 nodes in Figure 1. We firstly move P1 2 steps (2=3-1) to reach the 3 rd node (Figure 1-a). Then P2 points to the head of a list (Figure 1-b). We move two pointers at the same speed, when the P1 reaches the tail, what P2 points is the 3 rd node from end (Figure 1-c).\n\nThe sample code of the solutions with two pointers is shown below:\n\nListNode* FindKthToTail(ListNode* pListHead, unsigned int k)\n{\nif (pListHead == NULL || k == 0)\nreturn NULL;\n\nListNode *pAhead = pListHead;\nListNode *pBehind = NULL;\n\nfor ( unsigned int i = 0; i < k - 1; ++ i)\n{\nif (pAhead->m_pNext != NULL)\npAhead = pAhead->m_pNext;\nelse\n{\nreturn NULL;\n}\n}\n\npBehind = pListHead;\nwhile (pAhead->m_pNext != NULL)\n{\npAhead = pAhead->m_pNext;\npBehind = pBehind->m_pNext;\n}\n\nreturn pBehind;", "question": "\nProblem: Get the K th node from end of a linked list. It counts from 1 here, so the 1 st node from end is the tail of list.\n\nFor instance, given a linked list with 6 nodes, whose value are 1, 2, 3, 4, 5, 6, its 3 rd node from end is the node with value 4.\n\nA node in the list is defined as:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: In a list with n nodes, its k th node from end should be the (n-k+1) th node from its head. Therefore, if we know the number of nodes n in a list, we can get the required node with n-k+1 steps from its head. How to get the number n? It is easy if we scan the whole list from beginning to end.\n\nThe solution above needs to scan a list twice: We get the total number of nodes with the first scan, and reach the k th node from end with the second scan. Unfortunately, interviewers usually expect a solution which only scans a list once.\n\nWe have a better solution to get the k th node from end with two pointers. Firstly we move a pointer (denoted as P1) k-1 steps beginning from the head of a list. And then we move another pointer (denoted as P2) beginning from the head, and continue moving the P1 forward at same speed. Since the distance of these two pointers is always k-1, P2 reaches the k th node from end when P1 reaches the tail of a list. It scans a list only once, and it is more efficient than the previous solution.\n\n\n\nFigure 1: Get the 3 rd node from end of a list with 6 nodes\n\nIt simulates the process to get the 3 rd node from end of a list with 6 nodes in Figure 1. We firstly move P1 2 steps (2=3-1) to reach the 3 rd node (Figure 1-a). Then P2 points to the head of a list (Figure 1-b). We move two pointers at the same speed, when the P1 reaches the tail, what P2 points is the 3 rd node from end (Figure 1-c).\n\nThe sample code of the solutions with two pointers is shown below:\n\nListNode* FindKthToTail(ListNode* pListHead, unsigned int k)\n{\nif (pListHead == NULL || k == 0)\nreturn NULL;\n\nListNode *pAhead = pListHead;\nListNode *pBehind = NULL;\n\nfor ( unsigned int i = 0; i < k - 1; ++ i)\n{\nif (pAhead->m_pNext != NULL)\npAhead = pAhead->m_pNext;\nelse\n{\nreturn NULL;\n}\n}\n\npBehind = pListHead;\nwhile (pAhead->m_pNext != NULL)\n{\npAhead = pAhead->m_pNext;\npBehind = pBehind->m_pNext;\n}\n\nreturn pBehind;", "question": "\nProblem: Get the K th node from end of a linked list. It counts from 1 here, so the 1 st node from end is the tail of list.\n\nFor instance, given a linked list with 6 nodes, whose value are 1, 2, 3, 4, 5, 6, its 3 rd node from end is the node with value 4.\n\nA node in the list is defined as:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: In a list with n nodes, its k th node from end should be the (n-k+1) th node from its head. Therefore, if we know the number of nodes n in a list, we can get the required node with n-k+1 steps from its head. How to get the number n? It is easy if we scan the whole list from beginning to end.\n\nThe solution above needs to scan a list twice: We get the total number of nodes with the first scan, and reach the k th node from end with the second scan. Unfortunately, interviewers usually expect a solution which only scans a list once.\n\nWe have a better solution to get the k th node from end with two pointers. Firstly we move a pointer (denoted as P1) k-1 steps beginning from the head of a list. And then we move another pointer (denoted as P2) beginning from the head, and continue moving the P1 forward at same speed. Since the distance of these two pointers is always k-1, P2 reaches the k th node from end when P1 reaches the tail of a list. It scans a list only once, and it is more efficient than the previous solution.\n\n\n\nFigure 1: Get the 3 rd node from end of a list with 6 nodes\n\nIt simulates the process to get the 3 rd node from end of a list with 6 nodes in Figure 1. We firstly move P1 2 steps (2=3-1) to reach the 3 rd node (Figure 1-a). Then P2 points to the head of a list (Figure 1-b). We move two pointers at the same speed, when the P1 reaches the tail, what P2 points is the 3 rd node from end (Figure 1-c).\n\nThe sample code of the solutions with two pointers is shown below:\n\nListNode* FindKthToTail(ListNode* pListHead, unsigned int k)\n{\nif (pListHead == NULL || k == 0)\nreturn NULL;\n\nListNode *pAhead = pListHead;\nListNode *pBehind = NULL;\n\nfor ( unsigned int i = 0; i < k - 1; ++ i)\n{\nif (pAhead->m_pNext != NULL)\npAhead = pAhead->m_pNext;\nelse\n{\nreturn NULL;\n}\n}\n\npBehind = pListHead;\nwhile (pAhead->m_pNext != NULL)\n{\npAhead = pAhead->m_pNext;\npBehind = pBehind->m_pNext;\n}\n\nreturn pBehind;", "question": "\nProblem: Get the K th node from end of a linked list. It counts from 1 here, so the 1 st node from end is the tail of list.\n\nFor instance, given a linked list with 6 nodes, whose value are 1, 2, 3, 4, 5, 6, its 3 rd node from end is the node with value 4.\n\nA node in the list is defined as:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: This is a typical problem which can be solved by dynamic programming. We have two strategies to analyze and solve this problem\n\nSolution 1: Split at any space between two characters\n\nGiven a substring of str , starting from the index i and ending at the index j (denoted as str [ i : j ]), we define a function f ( i , j ) to denote the minimal number of splits to partition the substring str [ i : j ] into a set of palindromes. If the substring is a palindrome itself, we don\u2019t have to split so f ( i , j ) is 0. If the substring is not a palindrome, the substring is split between two characters k and k +1. f ( i , j )= f ( i , k )+ f ( k +1, j )+1 under such conditions. Therefore, f ( i , j ) can be defined with the following equation:\n\n\nThe value of f (0, n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nIf the equation is calculated recursively, its complexity grows exponentially with the length n . A better choice is to calculate in bottom-up order with a 2D matrix with size n \u00d7 n . The following C++ code implements this solution:\n\n int minSplit_1( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length * length];\n    \n     for ( int i = 0; i <length; ++i)\n        split[i * length + i] = 0;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         for ( int j = length -i; j > 0; --j)\n         {\n             int row = length - i - j;\n             int col = row + i;\n             if (isPalindrome(str, row, col))\n             {\n                split[row * length + col] = 0;\n             }\n             else\n             {\n                 int min = 0x7FFFFFFF;\n                 for ( int k = row; k < col; ++k)\n                {\n                     int temp1 = split[row * length + k];\n                     int temp2 = split[(k + 1) * length +col];\n                     if (min> temp1 + temp2 + 1)\n                         min = temp1 + temp2 +1;\n                }\n                split[row * length + col] = min;\n             }\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nSolution 2: Split only before a palindrome\n\nWe split the string str with another strategy. Given a substring ending at the index i , str [0, i], we do not have to split if the substring is a palindrome itself. Otherwise it is split between two characters at index j and j +1 only if the substring str [ j +1, i ] is a palindrome. Therefore, an equation f ( i ) can be defined as the following:\n\n\nThe value of f ( n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nWe could utilize a 1D array to solve this equation in bottom-up order, as listed in the following code:\n\n int minSplit_2( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length];\n     for ( int i = 0; i <length; ++i)\n        split[i] = i;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         if (isPalindrome(str, 0, i))\n         {\n            split[i] = 0;\n             continue ;\n         }\n\n         for ( int j = 0; j <i; ++j)\n         {\n             if (isPalindrome(str, j + 1, i) && split[i]> split[j] + 1)\n                split[i] = split[j] + 1;\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nOptimization to verify palindromes:\n\nUsually it costs O( n ) time to check whether a string with length n is a palindrome, and the typical implementation looks like the following code:\n\n bool isPalindrome( const string& str, int begin, int end)\n {\n     for ( int i = begin; i< end - (i - begin); ++i)\n     {\n         if (str[i] != str[end - (i - begin)])\n             return false ;\n     }\n\n     return true ;\n }\n\nBoth solutions above cost O( n 3 ) time. The first solution contains three nesting for-loops. The function isPalindrome is inside two nesting for-loops.\n\nIf we could reduce the cost of isPalindrome to O(1), the time complexity of the second solution would be O( n 2 ).\n\nNotice that the substring str [ i , j ] is a palindrome only if the characters at index i and j , and str [ i +1, j -1] is also a palindrome. We could build a 2D table accordingly to store whether every substring of str is a palindrome or not during the preprocessing. With such a table, the function isPalindrome can verify the substring str [ i , j ] in O(1) time.\n\n", "question": "\nProblem: A string can be partitioned into some substrings, such that each substring is a palindrome. For example, there are a few strategies to split the string \u201cabbab\u201d into palindrome substrings, such as: \u201cabba\u201d|\u201db\u201d, \u201ca\u201d|\u201db\u201d|\u201dbab\u201d and \u201ca\u201d|\u201dbb\u201d|\u201da\u201d|\u201db\u201d.\n\nGiven a string str , please get the minimal numbers of splits to partition it into palindromes. The minimal number of splits to partition the string \u201cabbab\u201d into a set of palindromes is 1.\n"},
{"answer": "\nAnalysis: In a list with n nodes, its k th node from end should be the (n-k+1) th node from its head. Therefore, if we know the number of nodes n in a list, we can get the required node with n-k+1 steps from its head. How to get the number n? It is easy if we scan the whole list from beginning to end.\n\nThe solution above needs to scan a list twice: We get the total number of nodes with the first scan, and reach the k th node from end with the second scan. Unfortunately, interviewers usually expect a solution which only scans a list once.\n\nWe have a better solution to get the k th node from end with two pointers. Firstly we move a pointer (denoted as P1) k-1 steps beginning from the head of a list. And then we move another pointer (denoted as P2) beginning from the head, and continue moving the P1 forward at same speed. Since the distance of these two pointers is always k-1, P2 reaches the k th node from end when P1 reaches the tail of a list. It scans a list only once, and it is more efficient than the previous solution.\n\n\n\nFigure 1: Get the 3 rd node from end of a list with 6 nodes\n\nIt simulates the process to get the 3 rd node from end of a list with 6 nodes in Figure 1. We firstly move P1 2 steps (2=3-1) to reach the 3 rd node (Figure 1-a). Then P2 points to the head of a list (Figure 1-b). We move two pointers at the same speed, when the P1 reaches the tail, what P2 points is the 3 rd node from end (Figure 1-c).\n\nThe sample code of the solutions with two pointers is shown below:\n\nListNode* FindKthToTail(ListNode* pListHead, unsigned int k)\n{\nif (pListHead == NULL || k == 0)\nreturn NULL;\n\nListNode *pAhead = pListHead;\nListNode *pBehind = NULL;\n\nfor ( unsigned int i = 0; i < k - 1; ++ i)\n{\nif (pAhead->m_pNext != NULL)\npAhead = pAhead->m_pNext;\nelse\n{\nreturn NULL;\n}\n}\n\npBehind = pListHead;\nwhile (pAhead->m_pNext != NULL)\n{\npAhead = pAhead->m_pNext;\npBehind = pBehind->m_pNext;\n}\n\nreturn pBehind;", "question": "\nProblem: Get the K th node from end of a linked list. It counts from 1 here, so the 1 st node from end is the tail of list.\n\nFor instance, given a linked list with 6 nodes, whose value are 1, 2, 3, 4, 5, 6, its 3 rd node from end is the node with value 4.\n\nA node in the list is defined as:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: Let\u2019s delete a digit from the number at each step. What\u2019s the first digit to be deleted from the number 24635, in order to get the least number with the remaining digits? We may list all the remaining numbers after deleting a digit, in the following table:\nDeleted   Digit\nRemaining   Number\n2\n4635\n4\n2635\n6\n2435\n3\n2465\n5\n2463\nThe number 2435 is the least one in all remaining numbers, by deleting the digit 6. Notice that the digit 6 is the first digit in the number 24635 which is greater than the next digit.\nLet\u2019s delete another digit from the number 2435, the remaining least number after the first step. We may summarize the remaining numbers after delete every digit from it in the following table:\nDeleted   Digit\nRemaining   Number\n2\n435\n4\n235\n3\n245\n5\n243\nThe number 235 is the least one in all remaining numbers, by deleting the digit 4. Notice that the digit 4 is the first digit in the number 2435 which is greater than the next digit.\nThe remaining three digits in the number 235 are increasingly sorted. What is the next digit to be deleted to get the least remaining number? Again, we may list the remaining numbers after deleting each digit in a table:\nDeleted   Digit\nRemaining   Number\n2\n35\n3\n25\n5\n23\nThe number 23 is the least one in all remaining numbers, by deleting the last digit 5.\nIf we are going to deleting more digits from a number whose digits are increasingly sorted to get the least number, the last digit is deleted at each step.\nNow we get the rules to delete digits to get the least remaining number: If there are digits who are greater than the next one, delete the first digit. If all digits in the number are increasingly sorted, delete the last digit gets deleted. The process repeats until the required k digits are deleted.\nThe code can be implemented in Java as the following:\n public static String getLeastNumberDeletingDigits_1(String number, int k) {\n     String leastNumber = number;\n     while (k > 0 && leastNumber.length() > 0) {\n         int firstDecreasingDigit = getFirstDecreasing(leastNumber);\n         if (firstDecreasingDigit >= 0) {\n             leastNumber =removeDigit(leastNumber, firstDecreasingDigit);\n         }\n         else {\n             leastNumber =removeDigit(leastNumber, leastNumber.length() - 1);\n         }\n\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static int getFirstDecreasing(String number) {\n     for ( int i = 0; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             return i;\n         }\n     }\n\n     return -1;\n }\n\n private static String removeDigit(String number, int digitIndex) {\n     String result = \"\" ;\n     if (digitIndex > 0) {\n         result = number.substring(0,digitIndex);\n     }\n     if (digitIndex < number.length() - 1) {\n         result += number.substring(digitIndex +1);\n     }\n\n     return result;\n }\n\nOptimization: Save the start index for the next round of search for the first decreasing digit\n\n In the method getFirstDecreasing above to get the first digit which is greater than the next one, we always startfrom the first digit. Is it necessary to start over in every round of search?\n\nThe answer is no. If the i th digit is the first digit which is greater than the next one, all digits before the i th digit are increasingly sorted. The ( i-1) th digit might be less than the ( i+1) th digit, the next digit of the ( i-1) th digit after the i th digit is deleted. Therefore, it is safe to start from the ( i-1) th digit in the next round of search.\n\nWith this optimization strategy, the efficiency gets improved from O( n * k ) to O( n ), if the length of the input number has n digits and k digits are deleted.\n\nThe optimized solution can be implemented as:\n\n class DecreasingResult {\n     public int firstDecreasing;\n     public int nextStart;\n }\n\n public static String getLeastNumberDeletingDigits_2(String number, int k) {\n     String leastNumber = number;\n     int start = 0;\n     while (k > 0 && leastNumber.length() > 0) {\n        DecreasingResult result = getNextDecreasing(leastNumber, start);\n         if (result.firstDecreasing >= 0) {\n             leastNumber =removeDigit(leastNumber, result.firstDecreasing);\n         }\n         else {\n             leastNumber = removeDigit(leastNumber,leastNumber.length() - 1);\n         }\n\n         start = result.nextStart;\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static DecreasingResult getNextDecreasing(String number, int start) {\n     int firstDecreasing = -1;\n     int nextStart;\n\n     for ( int i = start; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             firstDecreasing = i;\n             break ;\n         }\n     }\n\n     if (firstDecreasing == 0) {\n         nextStart = 0;\n     }\n     else if (firstDecreasing > 0) {\n         nextStart = firstDecreasing - 1;\n     }\n     else {\n         nextStart = number.length();\n     }\n\n     DecreasingResult result = new DecreasingResult();\n     result.firstDecreasing = firstDecreasing;\n     result.nextStart = nextStart;\n\n     return result;\n }\n\n", "question": "\nProblem: Please get the least number after deleting k digits from the input number. For example, if the input number is 24635, the least number is 23 after deleting 3 digits."},
{"answer": "\nAnalysis: Let\u2019s delete a digit from the number at each step. What\u2019s the first digit to be deleted from the number 24635, in order to get the least number with the remaining digits? We may list all the remaining numbers after deleting a digit, in the following table:\nDeleted   Digit\nRemaining   Number\n2\n4635\n4\n2635\n6\n2435\n3\n2465\n5\n2463\nThe number 2435 is the least one in all remaining numbers, by deleting the digit 6. Notice that the digit 6 is the first digit in the number 24635 which is greater than the next digit.\nLet\u2019s delete another digit from the number 2435, the remaining least number after the first step. We may summarize the remaining numbers after delete every digit from it in the following table:\nDeleted   Digit\nRemaining   Number\n2\n435\n4\n235\n3\n245\n5\n243\nThe number 235 is the least one in all remaining numbers, by deleting the digit 4. Notice that the digit 4 is the first digit in the number 2435 which is greater than the next digit.\nThe remaining three digits in the number 235 are increasingly sorted. What is the next digit to be deleted to get the least remaining number? Again, we may list the remaining numbers after deleting each digit in a table:\nDeleted   Digit\nRemaining   Number\n2\n35\n3\n25\n5\n23\nThe number 23 is the least one in all remaining numbers, by deleting the last digit 5.\nIf we are going to deleting more digits from a number whose digits are increasingly sorted to get the least number, the last digit is deleted at each step.\nNow we get the rules to delete digits to get the least remaining number: If there are digits who are greater than the next one, delete the first digit. If all digits in the number are increasingly sorted, delete the last digit gets deleted. The process repeats until the required k digits are deleted.\nThe code can be implemented in Java as the following:\n public static String getLeastNumberDeletingDigits_1(String number, int k) {\n     String leastNumber = number;\n     while (k > 0 && leastNumber.length() > 0) {\n         int firstDecreasingDigit = getFirstDecreasing(leastNumber);\n         if (firstDecreasingDigit >= 0) {\n             leastNumber =removeDigit(leastNumber, firstDecreasingDigit);\n         }\n         else {\n             leastNumber =removeDigit(leastNumber, leastNumber.length() - 1);\n         }\n\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static int getFirstDecreasing(String number) {\n     for ( int i = 0; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             return i;\n         }\n     }\n\n     return -1;\n }\n\n private static String removeDigit(String number, int digitIndex) {\n     String result = \"\" ;\n     if (digitIndex > 0) {\n         result = number.substring(0,digitIndex);\n     }\n     if (digitIndex < number.length() - 1) {\n         result += number.substring(digitIndex +1);\n     }\n\n     return result;\n }\n\nOptimization: Save the start index for the next round of search for the first decreasing digit\n\n In the method getFirstDecreasing above to get the first digit which is greater than the next one, we always startfrom the first digit. Is it necessary to start over in every round of search?\n\nThe answer is no. If the i th digit is the first digit which is greater than the next one, all digits before the i th digit are increasingly sorted. The ( i-1) th digit might be less than the ( i+1) th digit, the next digit of the ( i-1) th digit after the i th digit is deleted. Therefore, it is safe to start from the ( i-1) th digit in the next round of search.\n\nWith this optimization strategy, the efficiency gets improved from O( n * k ) to O( n ), if the length of the input number has n digits and k digits are deleted.\n\nThe optimized solution can be implemented as:\n\n class DecreasingResult {\n     public int firstDecreasing;\n     public int nextStart;\n }\n\n public static String getLeastNumberDeletingDigits_2(String number, int k) {\n     String leastNumber = number;\n     int start = 0;\n     while (k > 0 && leastNumber.length() > 0) {\n        DecreasingResult result = getNextDecreasing(leastNumber, start);\n         if (result.firstDecreasing >= 0) {\n             leastNumber =removeDigit(leastNumber, result.firstDecreasing);\n         }\n         else {\n             leastNumber = removeDigit(leastNumber,leastNumber.length() - 1);\n         }\n\n         start = result.nextStart;\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static DecreasingResult getNextDecreasing(String number, int start) {\n     int firstDecreasing = -1;\n     int nextStart;\n\n     for ( int i = start; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             firstDecreasing = i;\n             break ;\n         }\n     }\n\n     if (firstDecreasing == 0) {\n         nextStart = 0;\n     }\n     else if (firstDecreasing > 0) {\n         nextStart = firstDecreasing - 1;\n     }\n     else {\n         nextStart = number.length();\n     }\n\n     DecreasingResult result = new DecreasingResult();\n     result.firstDecreasing = firstDecreasing;\n     result.nextStart = nextStart;\n\n     return result;\n }\n\n", "question": "\nProblem: Please get the least number after deleting k digits from the input number. For example, if the input number is 24635, the least number is 23 after deleting 3 digits."},
{"answer": "\nAnalysis: Let\u2019s delete a digit from the number at each step. What\u2019s the first digit to be deleted from the number 24635, in order to get the least number with the remaining digits? We may list all the remaining numbers after deleting a digit, in the following table:\nDeleted   Digit\nRemaining   Number\n2\n4635\n4\n2635\n6\n2435\n3\n2465\n5\n2463\nThe number 2435 is the least one in all remaining numbers, by deleting the digit 6. Notice that the digit 6 is the first digit in the number 24635 which is greater than the next digit.\nLet\u2019s delete another digit from the number 2435, the remaining least number after the first step. We may summarize the remaining numbers after delete every digit from it in the following table:\nDeleted   Digit\nRemaining   Number\n2\n435\n4\n235\n3\n245\n5\n243\nThe number 235 is the least one in all remaining numbers, by deleting the digit 4. Notice that the digit 4 is the first digit in the number 2435 which is greater than the next digit.\nThe remaining three digits in the number 235 are increasingly sorted. What is the next digit to be deleted to get the least remaining number? Again, we may list the remaining numbers after deleting each digit in a table:\nDeleted   Digit\nRemaining   Number\n2\n35\n3\n25\n5\n23\nThe number 23 is the least one in all remaining numbers, by deleting the last digit 5.\nIf we are going to deleting more digits from a number whose digits are increasingly sorted to get the least number, the last digit is deleted at each step.\nNow we get the rules to delete digits to get the least remaining number: If there are digits who are greater than the next one, delete the first digit. If all digits in the number are increasingly sorted, delete the last digit gets deleted. The process repeats until the required k digits are deleted.\nThe code can be implemented in Java as the following:\n public static String getLeastNumberDeletingDigits_1(String number, int k) {\n     String leastNumber = number;\n     while (k > 0 && leastNumber.length() > 0) {\n         int firstDecreasingDigit = getFirstDecreasing(leastNumber);\n         if (firstDecreasingDigit >= 0) {\n             leastNumber =removeDigit(leastNumber, firstDecreasingDigit);\n         }\n         else {\n             leastNumber =removeDigit(leastNumber, leastNumber.length() - 1);\n         }\n\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static int getFirstDecreasing(String number) {\n     for ( int i = 0; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             return i;\n         }\n     }\n\n     return -1;\n }\n\n private static String removeDigit(String number, int digitIndex) {\n     String result = \"\" ;\n     if (digitIndex > 0) {\n         result = number.substring(0,digitIndex);\n     }\n     if (digitIndex < number.length() - 1) {\n         result += number.substring(digitIndex +1);\n     }\n\n     return result;\n }\n\nOptimization: Save the start index for the next round of search for the first decreasing digit\n\n In the method getFirstDecreasing above to get the first digit which is greater than the next one, we always startfrom the first digit. Is it necessary to start over in every round of search?\n\nThe answer is no. If the i th digit is the first digit which is greater than the next one, all digits before the i th digit are increasingly sorted. The ( i-1) th digit might be less than the ( i+1) th digit, the next digit of the ( i-1) th digit after the i th digit is deleted. Therefore, it is safe to start from the ( i-1) th digit in the next round of search.\n\nWith this optimization strategy, the efficiency gets improved from O( n * k ) to O( n ), if the length of the input number has n digits and k digits are deleted.\n\nThe optimized solution can be implemented as:\n\n class DecreasingResult {\n     public int firstDecreasing;\n     public int nextStart;\n }\n\n public static String getLeastNumberDeletingDigits_2(String number, int k) {\n     String leastNumber = number;\n     int start = 0;\n     while (k > 0 && leastNumber.length() > 0) {\n        DecreasingResult result = getNextDecreasing(leastNumber, start);\n         if (result.firstDecreasing >= 0) {\n             leastNumber =removeDigit(leastNumber, result.firstDecreasing);\n         }\n         else {\n             leastNumber = removeDigit(leastNumber,leastNumber.length() - 1);\n         }\n\n         start = result.nextStart;\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static DecreasingResult getNextDecreasing(String number, int start) {\n     int firstDecreasing = -1;\n     int nextStart;\n\n     for ( int i = start; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             firstDecreasing = i;\n             break ;\n         }\n     }\n\n     if (firstDecreasing == 0) {\n         nextStart = 0;\n     }\n     else if (firstDecreasing > 0) {\n         nextStart = firstDecreasing - 1;\n     }\n     else {\n         nextStart = number.length();\n     }\n\n     DecreasingResult result = new DecreasingResult();\n     result.firstDecreasing = firstDecreasing;\n     result.nextStart = nextStart;\n\n     return result;\n }\n\n", "question": "\nProblem: Please get the least number after deleting k digits from the input number. For example, if the input number is 24635, the least number is 23 after deleting 3 digits."},
{"answer": "\nAnalysis: Let\u2019s delete a digit from the number at each step. What\u2019s the first digit to be deleted from the number 24635, in order to get the least number with the remaining digits? We may list all the remaining numbers after deleting a digit, in the following table:\nDeleted   Digit\nRemaining   Number\n2\n4635\n4\n2635\n6\n2435\n3\n2465\n5\n2463\nThe number 2435 is the least one in all remaining numbers, by deleting the digit 6. Notice that the digit 6 is the first digit in the number 24635 which is greater than the next digit.\nLet\u2019s delete another digit from the number 2435, the remaining least number after the first step. We may summarize the remaining numbers after delete every digit from it in the following table:\nDeleted   Digit\nRemaining   Number\n2\n435\n4\n235\n3\n245\n5\n243\nThe number 235 is the least one in all remaining numbers, by deleting the digit 4. Notice that the digit 4 is the first digit in the number 2435 which is greater than the next digit.\nThe remaining three digits in the number 235 are increasingly sorted. What is the next digit to be deleted to get the least remaining number? Again, we may list the remaining numbers after deleting each digit in a table:\nDeleted   Digit\nRemaining   Number\n2\n35\n3\n25\n5\n23\nThe number 23 is the least one in all remaining numbers, by deleting the last digit 5.\nIf we are going to deleting more digits from a number whose digits are increasingly sorted to get the least number, the last digit is deleted at each step.\nNow we get the rules to delete digits to get the least remaining number: If there are digits who are greater than the next one, delete the first digit. If all digits in the number are increasingly sorted, delete the last digit gets deleted. The process repeats until the required k digits are deleted.\nThe code can be implemented in Java as the following:\n public static String getLeastNumberDeletingDigits_1(String number, int k) {\n     String leastNumber = number;\n     while (k > 0 && leastNumber.length() > 0) {\n         int firstDecreasingDigit = getFirstDecreasing(leastNumber);\n         if (firstDecreasingDigit >= 0) {\n             leastNumber =removeDigit(leastNumber, firstDecreasingDigit);\n         }\n         else {\n             leastNumber =removeDigit(leastNumber, leastNumber.length() - 1);\n         }\n\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static int getFirstDecreasing(String number) {\n     for ( int i = 0; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             return i;\n         }\n     }\n\n     return -1;\n }\n\n private static String removeDigit(String number, int digitIndex) {\n     String result = \"\" ;\n     if (digitIndex > 0) {\n         result = number.substring(0,digitIndex);\n     }\n     if (digitIndex < number.length() - 1) {\n         result += number.substring(digitIndex +1);\n     }\n\n     return result;\n }\n\nOptimization: Save the start index for the next round of search for the first decreasing digit\n\n In the method getFirstDecreasing above to get the first digit which is greater than the next one, we always startfrom the first digit. Is it necessary to start over in every round of search?\n\nThe answer is no. If the i th digit is the first digit which is greater than the next one, all digits before the i th digit are increasingly sorted. The ( i-1) th digit might be less than the ( i+1) th digit, the next digit of the ( i-1) th digit after the i th digit is deleted. Therefore, it is safe to start from the ( i-1) th digit in the next round of search.\n\nWith this optimization strategy, the efficiency gets improved from O( n * k ) to O( n ), if the length of the input number has n digits and k digits are deleted.\n\nThe optimized solution can be implemented as:\n\n class DecreasingResult {\n     public int firstDecreasing;\n     public int nextStart;\n }\n\n public static String getLeastNumberDeletingDigits_2(String number, int k) {\n     String leastNumber = number;\n     int start = 0;\n     while (k > 0 && leastNumber.length() > 0) {\n        DecreasingResult result = getNextDecreasing(leastNumber, start);\n         if (result.firstDecreasing >= 0) {\n             leastNumber =removeDigit(leastNumber, result.firstDecreasing);\n         }\n         else {\n             leastNumber = removeDigit(leastNumber,leastNumber.length() - 1);\n         }\n\n         start = result.nextStart;\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static DecreasingResult getNextDecreasing(String number, int start) {\n     int firstDecreasing = -1;\n     int nextStart;\n\n     for ( int i = start; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             firstDecreasing = i;\n             break ;\n         }\n     }\n\n     if (firstDecreasing == 0) {\n         nextStart = 0;\n     }\n     else if (firstDecreasing > 0) {\n         nextStart = firstDecreasing - 1;\n     }\n     else {\n         nextStart = number.length();\n     }\n\n     DecreasingResult result = new DecreasingResult();\n     result.firstDecreasing = firstDecreasing;\n     result.nextStart = nextStart;\n\n     return result;\n }\n\n", "question": "\nProblem: Please get the least number after deleting k digits from the input number. For example, if the input number is 24635, the least number is 23 after deleting 3 digits."},
{"answer": "\nAnalysis: Let\u2019s delete a digit from the number at each step. What\u2019s the first digit to be deleted from the number 24635, in order to get the least number with the remaining digits? We may list all the remaining numbers after deleting a digit, in the following table:\nDeleted   Digit\nRemaining   Number\n2\n4635\n4\n2635\n6\n2435\n3\n2465\n5\n2463\nThe number 2435 is the least one in all remaining numbers, by deleting the digit 6. Notice that the digit 6 is the first digit in the number 24635 which is greater than the next digit.\nLet\u2019s delete another digit from the number 2435, the remaining least number after the first step. We may summarize the remaining numbers after delete every digit from it in the following table:\nDeleted   Digit\nRemaining   Number\n2\n435\n4\n235\n3\n245\n5\n243\nThe number 235 is the least one in all remaining numbers, by deleting the digit 4. Notice that the digit 4 is the first digit in the number 2435 which is greater than the next digit.\nThe remaining three digits in the number 235 are increasingly sorted. What is the next digit to be deleted to get the least remaining number? Again, we may list the remaining numbers after deleting each digit in a table:\nDeleted   Digit\nRemaining   Number\n2\n35\n3\n25\n5\n23\nThe number 23 is the least one in all remaining numbers, by deleting the last digit 5.\nIf we are going to deleting more digits from a number whose digits are increasingly sorted to get the least number, the last digit is deleted at each step.\nNow we get the rules to delete digits to get the least remaining number: If there are digits who are greater than the next one, delete the first digit. If all digits in the number are increasingly sorted, delete the last digit gets deleted. The process repeats until the required k digits are deleted.\nThe code can be implemented in Java as the following:\n public static String getLeastNumberDeletingDigits_1(String number, int k) {\n     String leastNumber = number;\n     while (k > 0 && leastNumber.length() > 0) {\n         int firstDecreasingDigit = getFirstDecreasing(leastNumber);\n         if (firstDecreasingDigit >= 0) {\n             leastNumber =removeDigit(leastNumber, firstDecreasingDigit);\n         }\n         else {\n             leastNumber =removeDigit(leastNumber, leastNumber.length() - 1);\n         }\n\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static int getFirstDecreasing(String number) {\n     for ( int i = 0; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             return i;\n         }\n     }\n\n     return -1;\n }\n\n private static String removeDigit(String number, int digitIndex) {\n     String result = \"\" ;\n     if (digitIndex > 0) {\n         result = number.substring(0,digitIndex);\n     }\n     if (digitIndex < number.length() - 1) {\n         result += number.substring(digitIndex +1);\n     }\n\n     return result;\n }\n\nOptimization: Save the start index for the next round of search for the first decreasing digit\n\n In the method getFirstDecreasing above to get the first digit which is greater than the next one, we always startfrom the first digit. Is it necessary to start over in every round of search?\n\nThe answer is no. If the i th digit is the first digit which is greater than the next one, all digits before the i th digit are increasingly sorted. The ( i-1) th digit might be less than the ( i+1) th digit, the next digit of the ( i-1) th digit after the i th digit is deleted. Therefore, it is safe to start from the ( i-1) th digit in the next round of search.\n\nWith this optimization strategy, the efficiency gets improved from O( n * k ) to O( n ), if the length of the input number has n digits and k digits are deleted.\n\nThe optimized solution can be implemented as:\n\n class DecreasingResult {\n     public int firstDecreasing;\n     public int nextStart;\n }\n\n public static String getLeastNumberDeletingDigits_2(String number, int k) {\n     String leastNumber = number;\n     int start = 0;\n     while (k > 0 && leastNumber.length() > 0) {\n        DecreasingResult result = getNextDecreasing(leastNumber, start);\n         if (result.firstDecreasing >= 0) {\n             leastNumber =removeDigit(leastNumber, result.firstDecreasing);\n         }\n         else {\n             leastNumber = removeDigit(leastNumber,leastNumber.length() - 1);\n         }\n\n         start = result.nextStart;\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static DecreasingResult getNextDecreasing(String number, int start) {\n     int firstDecreasing = -1;\n     int nextStart;\n\n     for ( int i = start; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             firstDecreasing = i;\n             break ;\n         }\n     }\n\n     if (firstDecreasing == 0) {\n         nextStart = 0;\n     }\n     else if (firstDecreasing > 0) {\n         nextStart = firstDecreasing - 1;\n     }\n     else {\n         nextStart = number.length();\n     }\n\n     DecreasingResult result = new DecreasingResult();\n     result.firstDecreasing = firstDecreasing;\n     result.nextStart = nextStart;\n\n     return result;\n }\n\n", "question": "\nProblem: Please get the least number after deleting k digits from the input number. For example, if the input number is 24635, the least number is 23 after deleting 3 digits."},
{"answer": "\nAnalysis: Let\u2019s delete a digit from the number at each step. What\u2019s the first digit to be deleted from the number 24635, in order to get the least number with the remaining digits? We may list all the remaining numbers after deleting a digit, in the following table:\nDeleted   Digit\nRemaining   Number\n2\n4635\n4\n2635\n6\n2435\n3\n2465\n5\n2463\nThe number 2435 is the least one in all remaining numbers, by deleting the digit 6. Notice that the digit 6 is the first digit in the number 24635 which is greater than the next digit.\nLet\u2019s delete another digit from the number 2435, the remaining least number after the first step. We may summarize the remaining numbers after delete every digit from it in the following table:\nDeleted   Digit\nRemaining   Number\n2\n435\n4\n235\n3\n245\n5\n243\nThe number 235 is the least one in all remaining numbers, by deleting the digit 4. Notice that the digit 4 is the first digit in the number 2435 which is greater than the next digit.\nThe remaining three digits in the number 235 are increasingly sorted. What is the next digit to be deleted to get the least remaining number? Again, we may list the remaining numbers after deleting each digit in a table:\nDeleted   Digit\nRemaining   Number\n2\n35\n3\n25\n5\n23\nThe number 23 is the least one in all remaining numbers, by deleting the last digit 5.\nIf we are going to deleting more digits from a number whose digits are increasingly sorted to get the least number, the last digit is deleted at each step.\nNow we get the rules to delete digits to get the least remaining number: If there are digits who are greater than the next one, delete the first digit. If all digits in the number are increasingly sorted, delete the last digit gets deleted. The process repeats until the required k digits are deleted.\nThe code can be implemented in Java as the following:\n public static String getLeastNumberDeletingDigits_1(String number, int k) {\n     String leastNumber = number;\n     while (k > 0 && leastNumber.length() > 0) {\n         int firstDecreasingDigit = getFirstDecreasing(leastNumber);\n         if (firstDecreasingDigit >= 0) {\n             leastNumber =removeDigit(leastNumber, firstDecreasingDigit);\n         }\n         else {\n             leastNumber =removeDigit(leastNumber, leastNumber.length() - 1);\n         }\n\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static int getFirstDecreasing(String number) {\n     for ( int i = 0; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             return i;\n         }\n     }\n\n     return -1;\n }\n\n private static String removeDigit(String number, int digitIndex) {\n     String result = \"\" ;\n     if (digitIndex > 0) {\n         result = number.substring(0,digitIndex);\n     }\n     if (digitIndex < number.length() - 1) {\n         result += number.substring(digitIndex +1);\n     }\n\n     return result;\n }\n\nOptimization: Save the start index for the next round of search for the first decreasing digit\n\n In the method getFirstDecreasing above to get the first digit which is greater than the next one, we always startfrom the first digit. Is it necessary to start over in every round of search?\n\nThe answer is no. If the i th digit is the first digit which is greater than the next one, all digits before the i th digit are increasingly sorted. The ( i-1) th digit might be less than the ( i+1) th digit, the next digit of the ( i-1) th digit after the i th digit is deleted. Therefore, it is safe to start from the ( i-1) th digit in the next round of search.\n\nWith this optimization strategy, the efficiency gets improved from O( n * k ) to O( n ), if the length of the input number has n digits and k digits are deleted.\n\nThe optimized solution can be implemented as:\n\n class DecreasingResult {\n     public int firstDecreasing;\n     public int nextStart;\n }\n\n public static String getLeastNumberDeletingDigits_2(String number, int k) {\n     String leastNumber = number;\n     int start = 0;\n     while (k > 0 && leastNumber.length() > 0) {\n        DecreasingResult result = getNextDecreasing(leastNumber, start);\n         if (result.firstDecreasing >= 0) {\n             leastNumber =removeDigit(leastNumber, result.firstDecreasing);\n         }\n         else {\n             leastNumber = removeDigit(leastNumber,leastNumber.length() - 1);\n         }\n\n         start = result.nextStart;\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static DecreasingResult getNextDecreasing(String number, int start) {\n     int firstDecreasing = -1;\n     int nextStart;\n\n     for ( int i = start; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             firstDecreasing = i;\n             break ;\n         }\n     }\n\n     if (firstDecreasing == 0) {\n         nextStart = 0;\n     }\n     else if (firstDecreasing > 0) {\n         nextStart = firstDecreasing - 1;\n     }\n     else {\n         nextStart = number.length();\n     }\n\n     DecreasingResult result = new DecreasingResult();\n     result.firstDecreasing = firstDecreasing;\n     result.nextStart = nextStart;\n\n     return result;\n }\n\n", "question": "\nProblem: Please get the least number after deleting k digits from the input number. For example, if the input number is 24635, the least number is 23 after deleting 3 digits."},
{"answer": "\nAnalysis: Let\u2019s delete a digit from the number at each step. What\u2019s the first digit to be deleted from the number 24635, in order to get the least number with the remaining digits? We may list all the remaining numbers after deleting a digit, in the following table:\nDeleted   Digit\nRemaining   Number\n2\n4635\n4\n2635\n6\n2435\n3\n2465\n5\n2463\nThe number 2435 is the least one in all remaining numbers, by deleting the digit 6. Notice that the digit 6 is the first digit in the number 24635 which is greater than the next digit.\nLet\u2019s delete another digit from the number 2435, the remaining least number after the first step. We may summarize the remaining numbers after delete every digit from it in the following table:\nDeleted   Digit\nRemaining   Number\n2\n435\n4\n235\n3\n245\n5\n243\nThe number 235 is the least one in all remaining numbers, by deleting the digit 4. Notice that the digit 4 is the first digit in the number 2435 which is greater than the next digit.\nThe remaining three digits in the number 235 are increasingly sorted. What is the next digit to be deleted to get the least remaining number? Again, we may list the remaining numbers after deleting each digit in a table:\nDeleted   Digit\nRemaining   Number\n2\n35\n3\n25\n5\n23\nThe number 23 is the least one in all remaining numbers, by deleting the last digit 5.\nIf we are going to deleting more digits from a number whose digits are increasingly sorted to get the least number, the last digit is deleted at each step.\nNow we get the rules to delete digits to get the least remaining number: If there are digits who are greater than the next one, delete the first digit. If all digits in the number are increasingly sorted, delete the last digit gets deleted. The process repeats until the required k digits are deleted.\nThe code can be implemented in Java as the following:\n public static String getLeastNumberDeletingDigits_1(String number, int k) {\n     String leastNumber = number;\n     while (k > 0 && leastNumber.length() > 0) {\n         int firstDecreasingDigit = getFirstDecreasing(leastNumber);\n         if (firstDecreasingDigit >= 0) {\n             leastNumber =removeDigit(leastNumber, firstDecreasingDigit);\n         }\n         else {\n             leastNumber =removeDigit(leastNumber, leastNumber.length() - 1);\n         }\n\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static int getFirstDecreasing(String number) {\n     for ( int i = 0; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             return i;\n         }\n     }\n\n     return -1;\n }\n\n private static String removeDigit(String number, int digitIndex) {\n     String result = \"\" ;\n     if (digitIndex > 0) {\n         result = number.substring(0,digitIndex);\n     }\n     if (digitIndex < number.length() - 1) {\n         result += number.substring(digitIndex +1);\n     }\n\n     return result;\n }\n\nOptimization: Save the start index for the next round of search for the first decreasing digit\n\n In the method getFirstDecreasing above to get the first digit which is greater than the next one, we always startfrom the first digit. Is it necessary to start over in every round of search?\n\nThe answer is no. If the i th digit is the first digit which is greater than the next one, all digits before the i th digit are increasingly sorted. The ( i-1) th digit might be less than the ( i+1) th digit, the next digit of the ( i-1) th digit after the i th digit is deleted. Therefore, it is safe to start from the ( i-1) th digit in the next round of search.\n\nWith this optimization strategy, the efficiency gets improved from O( n * k ) to O( n ), if the length of the input number has n digits and k digits are deleted.\n\nThe optimized solution can be implemented as:\n\n class DecreasingResult {\n     public int firstDecreasing;\n     public int nextStart;\n }\n\n public static String getLeastNumberDeletingDigits_2(String number, int k) {\n     String leastNumber = number;\n     int start = 0;\n     while (k > 0 && leastNumber.length() > 0) {\n        DecreasingResult result = getNextDecreasing(leastNumber, start);\n         if (result.firstDecreasing >= 0) {\n             leastNumber =removeDigit(leastNumber, result.firstDecreasing);\n         }\n         else {\n             leastNumber = removeDigit(leastNumber,leastNumber.length() - 1);\n         }\n\n         start = result.nextStart;\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static DecreasingResult getNextDecreasing(String number, int start) {\n     int firstDecreasing = -1;\n     int nextStart;\n\n     for ( int i = start; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             firstDecreasing = i;\n             break ;\n         }\n     }\n\n     if (firstDecreasing == 0) {\n         nextStart = 0;\n     }\n     else if (firstDecreasing > 0) {\n         nextStart = firstDecreasing - 1;\n     }\n     else {\n         nextStart = number.length();\n     }\n\n     DecreasingResult result = new DecreasingResult();\n     result.firstDecreasing = firstDecreasing;\n     result.nextStart = nextStart;\n\n     return result;\n }\n\n", "question": "\nProblem: Please get the least number after deleting k digits from the input number. For example, if the input number is 24635, the least number is 23 after deleting 3 digits."},
{"answer": "\nAnalysis: Let\u2019s delete a digit from the number at each step. What\u2019s the first digit to be deleted from the number 24635, in order to get the least number with the remaining digits? We may list all the remaining numbers after deleting a digit, in the following table:\nDeleted   Digit\nRemaining   Number\n2\n4635\n4\n2635\n6\n2435\n3\n2465\n5\n2463\nThe number 2435 is the least one in all remaining numbers, by deleting the digit 6. Notice that the digit 6 is the first digit in the number 24635 which is greater than the next digit.\nLet\u2019s delete another digit from the number 2435, the remaining least number after the first step. We may summarize the remaining numbers after delete every digit from it in the following table:\nDeleted   Digit\nRemaining   Number\n2\n435\n4\n235\n3\n245\n5\n243\nThe number 235 is the least one in all remaining numbers, by deleting the digit 4. Notice that the digit 4 is the first digit in the number 2435 which is greater than the next digit.\nThe remaining three digits in the number 235 are increasingly sorted. What is the next digit to be deleted to get the least remaining number? Again, we may list the remaining numbers after deleting each digit in a table:\nDeleted   Digit\nRemaining   Number\n2\n35\n3\n25\n5\n23\nThe number 23 is the least one in all remaining numbers, by deleting the last digit 5.\nIf we are going to deleting more digits from a number whose digits are increasingly sorted to get the least number, the last digit is deleted at each step.\nNow we get the rules to delete digits to get the least remaining number: If there are digits who are greater than the next one, delete the first digit. If all digits in the number are increasingly sorted, delete the last digit gets deleted. The process repeats until the required k digits are deleted.\nThe code can be implemented in Java as the following:\n public static String getLeastNumberDeletingDigits_1(String number, int k) {\n     String leastNumber = number;\n     while (k > 0 && leastNumber.length() > 0) {\n         int firstDecreasingDigit = getFirstDecreasing(leastNumber);\n         if (firstDecreasingDigit >= 0) {\n             leastNumber =removeDigit(leastNumber, firstDecreasingDigit);\n         }\n         else {\n             leastNumber =removeDigit(leastNumber, leastNumber.length() - 1);\n         }\n\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static int getFirstDecreasing(String number) {\n     for ( int i = 0; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             return i;\n         }\n     }\n\n     return -1;\n }\n\n private static String removeDigit(String number, int digitIndex) {\n     String result = \"\" ;\n     if (digitIndex > 0) {\n         result = number.substring(0,digitIndex);\n     }\n     if (digitIndex < number.length() - 1) {\n         result += number.substring(digitIndex +1);\n     }\n\n     return result;\n }\n\nOptimization: Save the start index for the next round of search for the first decreasing digit\n\n In the method getFirstDecreasing above to get the first digit which is greater than the next one, we always startfrom the first digit. Is it necessary to start over in every round of search?\n\nThe answer is no. If the i th digit is the first digit which is greater than the next one, all digits before the i th digit are increasingly sorted. The ( i-1) th digit might be less than the ( i+1) th digit, the next digit of the ( i-1) th digit after the i th digit is deleted. Therefore, it is safe to start from the ( i-1) th digit in the next round of search.\n\nWith this optimization strategy, the efficiency gets improved from O( n * k ) to O( n ), if the length of the input number has n digits and k digits are deleted.\n\nThe optimized solution can be implemented as:\n\n class DecreasingResult {\n     public int firstDecreasing;\n     public int nextStart;\n }\n\n public static String getLeastNumberDeletingDigits_2(String number, int k) {\n     String leastNumber = number;\n     int start = 0;\n     while (k > 0 && leastNumber.length() > 0) {\n        DecreasingResult result = getNextDecreasing(leastNumber, start);\n         if (result.firstDecreasing >= 0) {\n             leastNumber =removeDigit(leastNumber, result.firstDecreasing);\n         }\n         else {\n             leastNumber = removeDigit(leastNumber,leastNumber.length() - 1);\n         }\n\n         start = result.nextStart;\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static DecreasingResult getNextDecreasing(String number, int start) {\n     int firstDecreasing = -1;\n     int nextStart;\n\n     for ( int i = start; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             firstDecreasing = i;\n             break ;\n         }\n     }\n\n     if (firstDecreasing == 0) {\n         nextStart = 0;\n     }\n     else if (firstDecreasing > 0) {\n         nextStart = firstDecreasing - 1;\n     }\n     else {\n         nextStart = number.length();\n     }\n\n     DecreasingResult result = new DecreasingResult();\n     result.firstDecreasing = firstDecreasing;\n     result.nextStart = nextStart;\n\n     return result;\n }\n\n", "question": "\nProblem: Please get the least number after deleting k digits from the input number. For example, if the input number is 24635, the least number is 23 after deleting 3 digits."},
{"answer": "\nAnalysis: This is a typical problem which can be solved by dynamic programming. We have two strategies to analyze and solve this problem\n\nSolution 1: Split at any space between two characters\n\nGiven a substring of str , starting from the index i and ending at the index j (denoted as str [ i : j ]), we define a function f ( i , j ) to denote the minimal number of splits to partition the substring str [ i : j ] into a set of palindromes. If the substring is a palindrome itself, we don\u2019t have to split so f ( i , j ) is 0. If the substring is not a palindrome, the substring is split between two characters k and k +1. f ( i , j )= f ( i , k )+ f ( k +1, j )+1 under such conditions. Therefore, f ( i , j ) can be defined with the following equation:\n\n\nThe value of f (0, n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nIf the equation is calculated recursively, its complexity grows exponentially with the length n . A better choice is to calculate in bottom-up order with a 2D matrix with size n \u00d7 n . The following C++ code implements this solution:\n\n int minSplit_1( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length * length];\n    \n     for ( int i = 0; i <length; ++i)\n        split[i * length + i] = 0;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         for ( int j = length -i; j > 0; --j)\n         {\n             int row = length - i - j;\n             int col = row + i;\n             if (isPalindrome(str, row, col))\n             {\n                split[row * length + col] = 0;\n             }\n             else\n             {\n                 int min = 0x7FFFFFFF;\n                 for ( int k = row; k < col; ++k)\n                {\n                     int temp1 = split[row * length + k];\n                     int temp2 = split[(k + 1) * length +col];\n                     if (min> temp1 + temp2 + 1)\n                         min = temp1 + temp2 +1;\n                }\n                split[row * length + col] = min;\n             }\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nSolution 2: Split only before a palindrome\n\nWe split the string str with another strategy. Given a substring ending at the index i , str [0, i], we do not have to split if the substring is a palindrome itself. Otherwise it is split between two characters at index j and j +1 only if the substring str [ j +1, i ] is a palindrome. Therefore, an equation f ( i ) can be defined as the following:\n\n\nThe value of f ( n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nWe could utilize a 1D array to solve this equation in bottom-up order, as listed in the following code:\n\n int minSplit_2( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length];\n     for ( int i = 0; i <length; ++i)\n        split[i] = i;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         if (isPalindrome(str, 0, i))\n         {\n            split[i] = 0;\n             continue ;\n         }\n\n         for ( int j = 0; j <i; ++j)\n         {\n             if (isPalindrome(str, j + 1, i) && split[i]> split[j] + 1)\n                split[i] = split[j] + 1;\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nOptimization to verify palindromes:\n\nUsually it costs O( n ) time to check whether a string with length n is a palindrome, and the typical implementation looks like the following code:\n\n bool isPalindrome( const string& str, int begin, int end)\n {\n     for ( int i = begin; i< end - (i - begin); ++i)\n     {\n         if (str[i] != str[end - (i - begin)])\n             return false ;\n     }\n\n     return true ;\n }\n\nBoth solutions above cost O( n 3 ) time. The first solution contains three nesting for-loops. The function isPalindrome is inside two nesting for-loops.\n\nIf we could reduce the cost of isPalindrome to O(1), the time complexity of the second solution would be O( n 2 ).\n\nNotice that the substring str [ i , j ] is a palindrome only if the characters at index i and j , and str [ i +1, j -1] is also a palindrome. We could build a 2D table accordingly to store whether every substring of str is a palindrome or not during the preprocessing. With such a table, the function isPalindrome can verify the substring str [ i , j ] in O(1) time.\n\n", "question": "\nProblem: A string can be partitioned into some substrings, such that each substring is a palindrome. For example, there are a few strategies to split the string \u201cabbab\u201d into palindrome substrings, such as: \u201cabba\u201d|\u201db\u201d, \u201ca\u201d|\u201db\u201d|\u201dbab\u201d and \u201ca\u201d|\u201dbb\u201d|\u201da\u201d|\u201db\u201d.\n\nGiven a string str , please get the minimal numbers of splits to partition it into palindromes. The minimal number of splits to partition the string \u201cabbab\u201d into a set of palindromes is 1.\n"},
{"answer": "\nAnalysis: Let\u2019s delete a digit from the number at each step. What\u2019s the first digit to be deleted from the number 24635, in order to get the least number with the remaining digits? We may list all the remaining numbers after deleting a digit, in the following table:\nDeleted   Digit\nRemaining   Number\n2\n4635\n4\n2635\n6\n2435\n3\n2465\n5\n2463\nThe number 2435 is the least one in all remaining numbers, by deleting the digit 6. Notice that the digit 6 is the first digit in the number 24635 which is greater than the next digit.\nLet\u2019s delete another digit from the number 2435, the remaining least number after the first step. We may summarize the remaining numbers after delete every digit from it in the following table:\nDeleted   Digit\nRemaining   Number\n2\n435\n4\n235\n3\n245\n5\n243\nThe number 235 is the least one in all remaining numbers, by deleting the digit 4. Notice that the digit 4 is the first digit in the number 2435 which is greater than the next digit.\nThe remaining three digits in the number 235 are increasingly sorted. What is the next digit to be deleted to get the least remaining number? Again, we may list the remaining numbers after deleting each digit in a table:\nDeleted   Digit\nRemaining   Number\n2\n35\n3\n25\n5\n23\nThe number 23 is the least one in all remaining numbers, by deleting the last digit 5.\nIf we are going to deleting more digits from a number whose digits are increasingly sorted to get the least number, the last digit is deleted at each step.\nNow we get the rules to delete digits to get the least remaining number: If there are digits who are greater than the next one, delete the first digit. If all digits in the number are increasingly sorted, delete the last digit gets deleted. The process repeats until the required k digits are deleted.\nThe code can be implemented in Java as the following:\n public static String getLeastNumberDeletingDigits_1(String number, int k) {\n     String leastNumber = number;\n     while (k > 0 && leastNumber.length() > 0) {\n         int firstDecreasingDigit = getFirstDecreasing(leastNumber);\n         if (firstDecreasingDigit >= 0) {\n             leastNumber =removeDigit(leastNumber, firstDecreasingDigit);\n         }\n         else {\n             leastNumber =removeDigit(leastNumber, leastNumber.length() - 1);\n         }\n\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static int getFirstDecreasing(String number) {\n     for ( int i = 0; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             return i;\n         }\n     }\n\n     return -1;\n }\n\n private static String removeDigit(String number, int digitIndex) {\n     String result = \"\" ;\n     if (digitIndex > 0) {\n         result = number.substring(0,digitIndex);\n     }\n     if (digitIndex < number.length() - 1) {\n         result += number.substring(digitIndex +1);\n     }\n\n     return result;\n }\n\nOptimization: Save the start index for the next round of search for the first decreasing digit\n\n In the method getFirstDecreasing above to get the first digit which is greater than the next one, we always startfrom the first digit. Is it necessary to start over in every round of search?\n\nThe answer is no. If the i th digit is the first digit which is greater than the next one, all digits before the i th digit are increasingly sorted. The ( i-1) th digit might be less than the ( i+1) th digit, the next digit of the ( i-1) th digit after the i th digit is deleted. Therefore, it is safe to start from the ( i-1) th digit in the next round of search.\n\nWith this optimization strategy, the efficiency gets improved from O( n * k ) to O( n ), if the length of the input number has n digits and k digits are deleted.\n\nThe optimized solution can be implemented as:\n\n class DecreasingResult {\n     public int firstDecreasing;\n     public int nextStart;\n }\n\n public static String getLeastNumberDeletingDigits_2(String number, int k) {\n     String leastNumber = number;\n     int start = 0;\n     while (k > 0 && leastNumber.length() > 0) {\n        DecreasingResult result = getNextDecreasing(leastNumber, start);\n         if (result.firstDecreasing >= 0) {\n             leastNumber =removeDigit(leastNumber, result.firstDecreasing);\n         }\n         else {\n             leastNumber = removeDigit(leastNumber,leastNumber.length() - 1);\n         }\n\n         start = result.nextStart;\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static DecreasingResult getNextDecreasing(String number, int start) {\n     int firstDecreasing = -1;\n     int nextStart;\n\n     for ( int i = start; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             firstDecreasing = i;\n             break ;\n         }\n     }\n\n     if (firstDecreasing == 0) {\n         nextStart = 0;\n     }\n     else if (firstDecreasing > 0) {\n         nextStart = firstDecreasing - 1;\n     }\n     else {\n         nextStart = number.length();\n     }\n\n     DecreasingResult result = new DecreasingResult();\n     result.firstDecreasing = firstDecreasing;\n     result.nextStart = nextStart;\n\n     return result;\n }\n\n", "question": "\nProblem: Please get the least number after deleting k digits from the input number. For example, if the input number is 24635, the least number is 23 after deleting 3 digits."},
{"answer": "\nAnalysis: Let\u2019s delete a digit from the number at each step. What\u2019s the first digit to be deleted from the number 24635, in order to get the least number with the remaining digits? We may list all the remaining numbers after deleting a digit, in the following table:\nDeleted   Digit\nRemaining   Number\n2\n4635\n4\n2635\n6\n2435\n3\n2465\n5\n2463\nThe number 2435 is the least one in all remaining numbers, by deleting the digit 6. Notice that the digit 6 is the first digit in the number 24635 which is greater than the next digit.\nLet\u2019s delete another digit from the number 2435, the remaining least number after the first step. We may summarize the remaining numbers after delete every digit from it in the following table:\nDeleted   Digit\nRemaining   Number\n2\n435\n4\n235\n3\n245\n5\n243\nThe number 235 is the least one in all remaining numbers, by deleting the digit 4. Notice that the digit 4 is the first digit in the number 2435 which is greater than the next digit.\nThe remaining three digits in the number 235 are increasingly sorted. What is the next digit to be deleted to get the least remaining number? Again, we may list the remaining numbers after deleting each digit in a table:\nDeleted   Digit\nRemaining   Number\n2\n35\n3\n25\n5\n23\nThe number 23 is the least one in all remaining numbers, by deleting the last digit 5.\nIf we are going to deleting more digits from a number whose digits are increasingly sorted to get the least number, the last digit is deleted at each step.\nNow we get the rules to delete digits to get the least remaining number: If there are digits who are greater than the next one, delete the first digit. If all digits in the number are increasingly sorted, delete the last digit gets deleted. The process repeats until the required k digits are deleted.\nThe code can be implemented in Java as the following:\n public static String getLeastNumberDeletingDigits_1(String number, int k) {\n     String leastNumber = number;\n     while (k > 0 && leastNumber.length() > 0) {\n         int firstDecreasingDigit = getFirstDecreasing(leastNumber);\n         if (firstDecreasingDigit >= 0) {\n             leastNumber =removeDigit(leastNumber, firstDecreasingDigit);\n         }\n         else {\n             leastNumber =removeDigit(leastNumber, leastNumber.length() - 1);\n         }\n\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static int getFirstDecreasing(String number) {\n     for ( int i = 0; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             return i;\n         }\n     }\n\n     return -1;\n }\n\n private static String removeDigit(String number, int digitIndex) {\n     String result = \"\" ;\n     if (digitIndex > 0) {\n         result = number.substring(0,digitIndex);\n     }\n     if (digitIndex < number.length() - 1) {\n         result += number.substring(digitIndex +1);\n     }\n\n     return result;\n }\n\nOptimization: Save the start index for the next round of search for the first decreasing digit\n\n In the method getFirstDecreasing above to get the first digit which is greater than the next one, we always startfrom the first digit. Is it necessary to start over in every round of search?\n\nThe answer is no. If the i th digit is the first digit which is greater than the next one, all digits before the i th digit are increasingly sorted. The ( i-1) th digit might be less than the ( i+1) th digit, the next digit of the ( i-1) th digit after the i th digit is deleted. Therefore, it is safe to start from the ( i-1) th digit in the next round of search.\n\nWith this optimization strategy, the efficiency gets improved from O( n * k ) to O( n ), if the length of the input number has n digits and k digits are deleted.\n\nThe optimized solution can be implemented as:\n\n class DecreasingResult {\n     public int firstDecreasing;\n     public int nextStart;\n }\n\n public static String getLeastNumberDeletingDigits_2(String number, int k) {\n     String leastNumber = number;\n     int start = 0;\n     while (k > 0 && leastNumber.length() > 0) {\n        DecreasingResult result = getNextDecreasing(leastNumber, start);\n         if (result.firstDecreasing >= 0) {\n             leastNumber =removeDigit(leastNumber, result.firstDecreasing);\n         }\n         else {\n             leastNumber = removeDigit(leastNumber,leastNumber.length() - 1);\n         }\n\n         start = result.nextStart;\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static DecreasingResult getNextDecreasing(String number, int start) {\n     int firstDecreasing = -1;\n     int nextStart;\n\n     for ( int i = start; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             firstDecreasing = i;\n             break ;\n         }\n     }\n\n     if (firstDecreasing == 0) {\n         nextStart = 0;\n     }\n     else if (firstDecreasing > 0) {\n         nextStart = firstDecreasing - 1;\n     }\n     else {\n         nextStart = number.length();\n     }\n\n     DecreasingResult result = new DecreasingResult();\n     result.firstDecreasing = firstDecreasing;\n     result.nextStart = nextStart;\n\n     return result;\n }\n\n", "question": "\nProblem: Please get the least number after deleting k digits from the input number. For example, if the input number is 24635, the least number is 23 after deleting 3 digits."},
{"answer": "\nAnalysis: Let\u2019s delete a digit from the number at each step. What\u2019s the first digit to be deleted from the number 24635, in order to get the least number with the remaining digits? We may list all the remaining numbers after deleting a digit, in the following table:\nDeleted   Digit\nRemaining   Number\n2\n4635\n4\n2635\n6\n2435\n3\n2465\n5\n2463\nThe number 2435 is the least one in all remaining numbers, by deleting the digit 6. Notice that the digit 6 is the first digit in the number 24635 which is greater than the next digit.\nLet\u2019s delete another digit from the number 2435, the remaining least number after the first step. We may summarize the remaining numbers after delete every digit from it in the following table:\nDeleted   Digit\nRemaining   Number\n2\n435\n4\n235\n3\n245\n5\n243\nThe number 235 is the least one in all remaining numbers, by deleting the digit 4. Notice that the digit 4 is the first digit in the number 2435 which is greater than the next digit.\nThe remaining three digits in the number 235 are increasingly sorted. What is the next digit to be deleted to get the least remaining number? Again, we may list the remaining numbers after deleting each digit in a table:\nDeleted   Digit\nRemaining   Number\n2\n35\n3\n25\n5\n23\nThe number 23 is the least one in all remaining numbers, by deleting the last digit 5.\nIf we are going to deleting more digits from a number whose digits are increasingly sorted to get the least number, the last digit is deleted at each step.\nNow we get the rules to delete digits to get the least remaining number: If there are digits who are greater than the next one, delete the first digit. If all digits in the number are increasingly sorted, delete the last digit gets deleted. The process repeats until the required k digits are deleted.\nThe code can be implemented in Java as the following:\n public static String getLeastNumberDeletingDigits_1(String number, int k) {\n     String leastNumber = number;\n     while (k > 0 && leastNumber.length() > 0) {\n         int firstDecreasingDigit = getFirstDecreasing(leastNumber);\n         if (firstDecreasingDigit >= 0) {\n             leastNumber =removeDigit(leastNumber, firstDecreasingDigit);\n         }\n         else {\n             leastNumber =removeDigit(leastNumber, leastNumber.length() - 1);\n         }\n\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static int getFirstDecreasing(String number) {\n     for ( int i = 0; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             return i;\n         }\n     }\n\n     return -1;\n }\n\n private static String removeDigit(String number, int digitIndex) {\n     String result = \"\" ;\n     if (digitIndex > 0) {\n         result = number.substring(0,digitIndex);\n     }\n     if (digitIndex < number.length() - 1) {\n         result += number.substring(digitIndex +1);\n     }\n\n     return result;\n }\n\nOptimization: Save the start index for the next round of search for the first decreasing digit\n\n In the method getFirstDecreasing above to get the first digit which is greater than the next one, we always startfrom the first digit. Is it necessary to start over in every round of search?\n\nThe answer is no. If the i th digit is the first digit which is greater than the next one, all digits before the i th digit are increasingly sorted. The ( i-1) th digit might be less than the ( i+1) th digit, the next digit of the ( i-1) th digit after the i th digit is deleted. Therefore, it is safe to start from the ( i-1) th digit in the next round of search.\n\nWith this optimization strategy, the efficiency gets improved from O( n * k ) to O( n ), if the length of the input number has n digits and k digits are deleted.\n\nThe optimized solution can be implemented as:\n\n class DecreasingResult {\n     public int firstDecreasing;\n     public int nextStart;\n }\n\n public static String getLeastNumberDeletingDigits_2(String number, int k) {\n     String leastNumber = number;\n     int start = 0;\n     while (k > 0 && leastNumber.length() > 0) {\n        DecreasingResult result = getNextDecreasing(leastNumber, start);\n         if (result.firstDecreasing >= 0) {\n             leastNumber =removeDigit(leastNumber, result.firstDecreasing);\n         }\n         else {\n             leastNumber = removeDigit(leastNumber,leastNumber.length() - 1);\n         }\n\n         start = result.nextStart;\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static DecreasingResult getNextDecreasing(String number, int start) {\n     int firstDecreasing = -1;\n     int nextStart;\n\n     for ( int i = start; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             firstDecreasing = i;\n             break ;\n         }\n     }\n\n     if (firstDecreasing == 0) {\n         nextStart = 0;\n     }\n     else if (firstDecreasing > 0) {\n         nextStart = firstDecreasing - 1;\n     }\n     else {\n         nextStart = number.length();\n     }\n\n     DecreasingResult result = new DecreasingResult();\n     result.firstDecreasing = firstDecreasing;\n     result.nextStart = nextStart;\n\n     return result;\n }\n\n", "question": "\nProblem: Please get the least number after deleting k digits from the input number. For example, if the input number is 24635, the least number is 23 after deleting 3 digits."},
{"answer": "\nAnalysis: Let\u2019s delete a digit from the number at each step. What\u2019s the first digit to be deleted from the number 24635, in order to get the least number with the remaining digits? We may list all the remaining numbers after deleting a digit, in the following table:\nDeleted   Digit\nRemaining   Number\n2\n4635\n4\n2635\n6\n2435\n3\n2465\n5\n2463\nThe number 2435 is the least one in all remaining numbers, by deleting the digit 6. Notice that the digit 6 is the first digit in the number 24635 which is greater than the next digit.\nLet\u2019s delete another digit from the number 2435, the remaining least number after the first step. We may summarize the remaining numbers after delete every digit from it in the following table:\nDeleted   Digit\nRemaining   Number\n2\n435\n4\n235\n3\n245\n5\n243\nThe number 235 is the least one in all remaining numbers, by deleting the digit 4. Notice that the digit 4 is the first digit in the number 2435 which is greater than the next digit.\nThe remaining three digits in the number 235 are increasingly sorted. What is the next digit to be deleted to get the least remaining number? Again, we may list the remaining numbers after deleting each digit in a table:\nDeleted   Digit\nRemaining   Number\n2\n35\n3\n25\n5\n23\nThe number 23 is the least one in all remaining numbers, by deleting the last digit 5.\nIf we are going to deleting more digits from a number whose digits are increasingly sorted to get the least number, the last digit is deleted at each step.\nNow we get the rules to delete digits to get the least remaining number: If there are digits who are greater than the next one, delete the first digit. If all digits in the number are increasingly sorted, delete the last digit gets deleted. The process repeats until the required k digits are deleted.\nThe code can be implemented in Java as the following:\n public static String getLeastNumberDeletingDigits_1(String number, int k) {\n     String leastNumber = number;\n     while (k > 0 && leastNumber.length() > 0) {\n         int firstDecreasingDigit = getFirstDecreasing(leastNumber);\n         if (firstDecreasingDigit >= 0) {\n             leastNumber =removeDigit(leastNumber, firstDecreasingDigit);\n         }\n         else {\n             leastNumber =removeDigit(leastNumber, leastNumber.length() - 1);\n         }\n\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static int getFirstDecreasing(String number) {\n     for ( int i = 0; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             return i;\n         }\n     }\n\n     return -1;\n }\n\n private static String removeDigit(String number, int digitIndex) {\n     String result = \"\" ;\n     if (digitIndex > 0) {\n         result = number.substring(0,digitIndex);\n     }\n     if (digitIndex < number.length() - 1) {\n         result += number.substring(digitIndex +1);\n     }\n\n     return result;\n }\n\nOptimization: Save the start index for the next round of search for the first decreasing digit\n\n In the method getFirstDecreasing above to get the first digit which is greater than the next one, we always startfrom the first digit. Is it necessary to start over in every round of search?\n\nThe answer is no. If the i th digit is the first digit which is greater than the next one, all digits before the i th digit are increasingly sorted. The ( i-1) th digit might be less than the ( i+1) th digit, the next digit of the ( i-1) th digit after the i th digit is deleted. Therefore, it is safe to start from the ( i-1) th digit in the next round of search.\n\nWith this optimization strategy, the efficiency gets improved from O( n * k ) to O( n ), if the length of the input number has n digits and k digits are deleted.\n\nThe optimized solution can be implemented as:\n\n class DecreasingResult {\n     public int firstDecreasing;\n     public int nextStart;\n }\n\n public static String getLeastNumberDeletingDigits_2(String number, int k) {\n     String leastNumber = number;\n     int start = 0;\n     while (k > 0 && leastNumber.length() > 0) {\n        DecreasingResult result = getNextDecreasing(leastNumber, start);\n         if (result.firstDecreasing >= 0) {\n             leastNumber =removeDigit(leastNumber, result.firstDecreasing);\n         }\n         else {\n             leastNumber = removeDigit(leastNumber,leastNumber.length() - 1);\n         }\n\n         start = result.nextStart;\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static DecreasingResult getNextDecreasing(String number, int start) {\n     int firstDecreasing = -1;\n     int nextStart;\n\n     for ( int i = start; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             firstDecreasing = i;\n             break ;\n         }\n     }\n\n     if (firstDecreasing == 0) {\n         nextStart = 0;\n     }\n     else if (firstDecreasing > 0) {\n         nextStart = firstDecreasing - 1;\n     }\n     else {\n         nextStart = number.length();\n     }\n\n     DecreasingResult result = new DecreasingResult();\n     result.firstDecreasing = firstDecreasing;\n     result.nextStart = nextStart;\n\n     return result;\n }\n\n", "question": "\nProblem: Please get the least number after deleting k digits from the input number. For example, if the input number is 24635, the least number is 23 after deleting 3 digits."},
{"answer": "\nAnalysis: Let\u2019s delete a digit from the number at each step. What\u2019s the first digit to be deleted from the number 24635, in order to get the least number with the remaining digits? We may list all the remaining numbers after deleting a digit, in the following table:\nDeleted   Digit\nRemaining   Number\n2\n4635\n4\n2635\n6\n2435\n3\n2465\n5\n2463\nThe number 2435 is the least one in all remaining numbers, by deleting the digit 6. Notice that the digit 6 is the first digit in the number 24635 which is greater than the next digit.\nLet\u2019s delete another digit from the number 2435, the remaining least number after the first step. We may summarize the remaining numbers after delete every digit from it in the following table:\nDeleted   Digit\nRemaining   Number\n2\n435\n4\n235\n3\n245\n5\n243\nThe number 235 is the least one in all remaining numbers, by deleting the digit 4. Notice that the digit 4 is the first digit in the number 2435 which is greater than the next digit.\nThe remaining three digits in the number 235 are increasingly sorted. What is the next digit to be deleted to get the least remaining number? Again, we may list the remaining numbers after deleting each digit in a table:\nDeleted   Digit\nRemaining   Number\n2\n35\n3\n25\n5\n23\nThe number 23 is the least one in all remaining numbers, by deleting the last digit 5.\nIf we are going to deleting more digits from a number whose digits are increasingly sorted to get the least number, the last digit is deleted at each step.\nNow we get the rules to delete digits to get the least remaining number: If there are digits who are greater than the next one, delete the first digit. If all digits in the number are increasingly sorted, delete the last digit gets deleted. The process repeats until the required k digits are deleted.\nThe code can be implemented in Java as the following:\n public static String getLeastNumberDeletingDigits_1(String number, int k) {\n     String leastNumber = number;\n     while (k > 0 && leastNumber.length() > 0) {\n         int firstDecreasingDigit = getFirstDecreasing(leastNumber);\n         if (firstDecreasingDigit >= 0) {\n             leastNumber =removeDigit(leastNumber, firstDecreasingDigit);\n         }\n         else {\n             leastNumber =removeDigit(leastNumber, leastNumber.length() - 1);\n         }\n\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static int getFirstDecreasing(String number) {\n     for ( int i = 0; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             return i;\n         }\n     }\n\n     return -1;\n }\n\n private static String removeDigit(String number, int digitIndex) {\n     String result = \"\" ;\n     if (digitIndex > 0) {\n         result = number.substring(0,digitIndex);\n     }\n     if (digitIndex < number.length() - 1) {\n         result += number.substring(digitIndex +1);\n     }\n\n     return result;\n }\n\nOptimization: Save the start index for the next round of search for the first decreasing digit\n\n In the method getFirstDecreasing above to get the first digit which is greater than the next one, we always startfrom the first digit. Is it necessary to start over in every round of search?\n\nThe answer is no. If the i th digit is the first digit which is greater than the next one, all digits before the i th digit are increasingly sorted. The ( i-1) th digit might be less than the ( i+1) th digit, the next digit of the ( i-1) th digit after the i th digit is deleted. Therefore, it is safe to start from the ( i-1) th digit in the next round of search.\n\nWith this optimization strategy, the efficiency gets improved from O( n * k ) to O( n ), if the length of the input number has n digits and k digits are deleted.\n\nThe optimized solution can be implemented as:\n\n class DecreasingResult {\n     public int firstDecreasing;\n     public int nextStart;\n }\n\n public static String getLeastNumberDeletingDigits_2(String number, int k) {\n     String leastNumber = number;\n     int start = 0;\n     while (k > 0 && leastNumber.length() > 0) {\n        DecreasingResult result = getNextDecreasing(leastNumber, start);\n         if (result.firstDecreasing >= 0) {\n             leastNumber =removeDigit(leastNumber, result.firstDecreasing);\n         }\n         else {\n             leastNumber = removeDigit(leastNumber,leastNumber.length() - 1);\n         }\n\n         start = result.nextStart;\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static DecreasingResult getNextDecreasing(String number, int start) {\n     int firstDecreasing = -1;\n     int nextStart;\n\n     for ( int i = start; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             firstDecreasing = i;\n             break ;\n         }\n     }\n\n     if (firstDecreasing == 0) {\n         nextStart = 0;\n     }\n     else if (firstDecreasing > 0) {\n         nextStart = firstDecreasing - 1;\n     }\n     else {\n         nextStart = number.length();\n     }\n\n     DecreasingResult result = new DecreasingResult();\n     result.firstDecreasing = firstDecreasing;\n     result.nextStart = nextStart;\n\n     return result;\n }\n\n", "question": "\nProblem: Please get the least number after deleting k digits from the input number. For example, if the input number is 24635, the least number is 23 after deleting 3 digits."},
{"answer": "\nAnalysis: Let\u2019s delete a digit from the number at each step. What\u2019s the first digit to be deleted from the number 24635, in order to get the least number with the remaining digits? We may list all the remaining numbers after deleting a digit, in the following table:\nDeleted   Digit\nRemaining   Number\n2\n4635\n4\n2635\n6\n2435\n3\n2465\n5\n2463\nThe number 2435 is the least one in all remaining numbers, by deleting the digit 6. Notice that the digit 6 is the first digit in the number 24635 which is greater than the next digit.\nLet\u2019s delete another digit from the number 2435, the remaining least number after the first step. We may summarize the remaining numbers after delete every digit from it in the following table:\nDeleted   Digit\nRemaining   Number\n2\n435\n4\n235\n3\n245\n5\n243\nThe number 235 is the least one in all remaining numbers, by deleting the digit 4. Notice that the digit 4 is the first digit in the number 2435 which is greater than the next digit.\nThe remaining three digits in the number 235 are increasingly sorted. What is the next digit to be deleted to get the least remaining number? Again, we may list the remaining numbers after deleting each digit in a table:\nDeleted   Digit\nRemaining   Number\n2\n35\n3\n25\n5\n23\nThe number 23 is the least one in all remaining numbers, by deleting the last digit 5.\nIf we are going to deleting more digits from a number whose digits are increasingly sorted to get the least number, the last digit is deleted at each step.\nNow we get the rules to delete digits to get the least remaining number: If there are digits who are greater than the next one, delete the first digit. If all digits in the number are increasingly sorted, delete the last digit gets deleted. The process repeats until the required k digits are deleted.\nThe code can be implemented in Java as the following:\n public static String getLeastNumberDeletingDigits_1(String number, int k) {\n     String leastNumber = number;\n     while (k > 0 && leastNumber.length() > 0) {\n         int firstDecreasingDigit = getFirstDecreasing(leastNumber);\n         if (firstDecreasingDigit >= 0) {\n             leastNumber =removeDigit(leastNumber, firstDecreasingDigit);\n         }\n         else {\n             leastNumber =removeDigit(leastNumber, leastNumber.length() - 1);\n         }\n\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static int getFirstDecreasing(String number) {\n     for ( int i = 0; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             return i;\n         }\n     }\n\n     return -1;\n }\n\n private static String removeDigit(String number, int digitIndex) {\n     String result = \"\" ;\n     if (digitIndex > 0) {\n         result = number.substring(0,digitIndex);\n     }\n     if (digitIndex < number.length() - 1) {\n         result += number.substring(digitIndex +1);\n     }\n\n     return result;\n }\n\nOptimization: Save the start index for the next round of search for the first decreasing digit\n\n In the method getFirstDecreasing above to get the first digit which is greater than the next one, we always startfrom the first digit. Is it necessary to start over in every round of search?\n\nThe answer is no. If the i th digit is the first digit which is greater than the next one, all digits before the i th digit are increasingly sorted. The ( i-1) th digit might be less than the ( i+1) th digit, the next digit of the ( i-1) th digit after the i th digit is deleted. Therefore, it is safe to start from the ( i-1) th digit in the next round of search.\n\nWith this optimization strategy, the efficiency gets improved from O( n * k ) to O( n ), if the length of the input number has n digits and k digits are deleted.\n\nThe optimized solution can be implemented as:\n\n class DecreasingResult {\n     public int firstDecreasing;\n     public int nextStart;\n }\n\n public static String getLeastNumberDeletingDigits_2(String number, int k) {\n     String leastNumber = number;\n     int start = 0;\n     while (k > 0 && leastNumber.length() > 0) {\n        DecreasingResult result = getNextDecreasing(leastNumber, start);\n         if (result.firstDecreasing >= 0) {\n             leastNumber =removeDigit(leastNumber, result.firstDecreasing);\n         }\n         else {\n             leastNumber = removeDigit(leastNumber,leastNumber.length() - 1);\n         }\n\n         start = result.nextStart;\n         --k;\n     }\n\n     return leastNumber;\n }\n\n private static DecreasingResult getNextDecreasing(String number, int start) {\n     int firstDecreasing = -1;\n     int nextStart;\n\n     for ( int i = start; i < number.length() - 1; ++i) {\n         int curDigit = number.charAt(i) - '0' ;\n         int nextDigit = number.charAt(i + 1) - '0' ;\n         if (curDigit > nextDigit) {\n             firstDecreasing = i;\n             break ;\n         }\n     }\n\n     if (firstDecreasing == 0) {\n         nextStart = 0;\n     }\n     else if (firstDecreasing > 0) {\n         nextStart = firstDecreasing - 1;\n     }\n     else {\n         nextStart = number.length();\n     }\n\n     DecreasingResult result = new DecreasingResult();\n     result.firstDecreasing = firstDecreasing;\n     result.nextStart = nextStart;\n\n     return result;\n }\n\n", "question": "\nProblem: Please get the least number after deleting k digits from the input number. For example, if the input number is 24635, the least number is 23 after deleting 3 digits."},
{"answer": "\nAnalysis: This is a typical problem which can be solved by dynamic programming. We have two strategies to analyze and solve this problem\n\nSolution 1: Split at any space between two characters\n\nGiven a substring of str , starting from the index i and ending at the index j (denoted as str [ i : j ]), we define a function f ( i , j ) to denote the minimal number of splits to partition the substring str [ i : j ] into a set of palindromes. If the substring is a palindrome itself, we don\u2019t have to split so f ( i , j ) is 0. If the substring is not a palindrome, the substring is split between two characters k and k +1. f ( i , j )= f ( i , k )+ f ( k +1, j )+1 under such conditions. Therefore, f ( i , j ) can be defined with the following equation:\n\n\nThe value of f (0, n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nIf the equation is calculated recursively, its complexity grows exponentially with the length n . A better choice is to calculate in bottom-up order with a 2D matrix with size n \u00d7 n . The following C++ code implements this solution:\n\n int minSplit_1( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length * length];\n    \n     for ( int i = 0; i <length; ++i)\n        split[i * length + i] = 0;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         for ( int j = length -i; j > 0; --j)\n         {\n             int row = length - i - j;\n             int col = row + i;\n             if (isPalindrome(str, row, col))\n             {\n                split[row * length + col] = 0;\n             }\n             else\n             {\n                 int min = 0x7FFFFFFF;\n                 for ( int k = row; k < col; ++k)\n                {\n                     int temp1 = split[row * length + k];\n                     int temp2 = split[(k + 1) * length +col];\n                     if (min> temp1 + temp2 + 1)\n                         min = temp1 + temp2 +1;\n                }\n                split[row * length + col] = min;\n             }\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nSolution 2: Split only before a palindrome\n\nWe split the string str with another strategy. Given a substring ending at the index i , str [0, i], we do not have to split if the substring is a palindrome itself. Otherwise it is split between two characters at index j and j +1 only if the substring str [ j +1, i ] is a palindrome. Therefore, an equation f ( i ) can be defined as the following:\n\n\nThe value of f ( n -1) is the value of the minimal number of splits to partition str into palindromes, if n is the length of str .\n\nWe could utilize a 1D array to solve this equation in bottom-up order, as listed in the following code:\n\n int minSplit_2( const string& str)\n {\n     int length = str.size();\n     int * split = new int [length];\n     for ( int i = 0; i <length; ++i)\n        split[i] = i;\n\n     for ( int i = 1; i <length; ++i)\n     {\n         if (isPalindrome(str, 0, i))\n         {\n            split[i] = 0;\n             continue ;\n         }\n\n         for ( int j = 0; j <i; ++j)\n         {\n             if (isPalindrome(str, j + 1, i) && split[i]> split[j] + 1)\n                split[i] = split[j] + 1;\n         }\n     }\n\n     int minSplit = split[length - 1];\n     delete [] split;\n     return minSplit;\n }\n\nOptimization to verify palindromes:\n\nUsually it costs O( n ) time to check whether a string with length n is a palindrome, and the typical implementation looks like the following code:\n\n bool isPalindrome( const string& str, int begin, int end)\n {\n     for ( int i = begin; i< end - (i - begin); ++i)\n     {\n         if (str[i] != str[end - (i - begin)])\n             return false ;\n     }\n\n     return true ;\n }\n\nBoth solutions above cost O( n 3 ) time. The first solution contains three nesting for-loops. The function isPalindrome is inside two nesting for-loops.\n\nIf we could reduce the cost of isPalindrome to O(1), the time complexity of the second solution would be O( n 2 ).\n\nNotice that the substring str [ i , j ] is a palindrome only if the characters at index i and j , and str [ i +1, j -1] is also a palindrome. We could build a 2D table accordingly to store whether every substring of str is a palindrome or not during the preprocessing. With such a table, the function isPalindrome can verify the substring str [ i , j ] in O(1) time.\n\n", "question": "\nProblem: A string can be partitioned into some substrings, such that each substring is a palindrome. For example, there are a few strategies to split the string \u201cabbab\u201d into palindrome substrings, such as: \u201cabba\u201d|\u201db\u201d, \u201ca\u201d|\u201db\u201d|\u201dbab\u201d and \u201ca\u201d|\u201dbb\u201d|\u201da\u201d|\u201db\u201d.\n\nGiven a string str , please get the minimal numbers of splits to partition it into palindromes. The minimal number of splits to partition the string \u201cabbab\u201d into a set of palindromes is 1.\n"},
{"answer": "\nAnalysis: Firstly let\u2019s analyze this problem with the brute-force solution: All elements in the array are scanned one by one. When an element is scanned, we take is as A[ j ], and check whether there is a smaller element on its left side (A[ i ]), and a greater element on its right side (A[ k ]).\nSince it takes O( n ) time to scan numbers on two sides of each A[ j ], the overall time of this solution is O( n 2 ) on an array with n elements.\n\nSolution 1: O(n) time efficiency with O(n) space consumption\nAs our analysis above, for each element A[ j ], we need to know whether there is a smaller element on its left side. If there is not a smaller element on the left side, A[ j ] itself is the smallest of all elements from the leftmost element to A[ j ]. If there is a smaller element on the left side, the smallest of all elements from the leftmost element to A[ j ] is on the left side of A[ j ].\nTherefore, we could construct an auxiliary array B. The element B[ j ] stores the index of the smallest element of elements from the leftmost element to A[ j ]. The array B can be constructed based on elements in A from left to right.\nSimilarly, we could also construct another auxiliary array C. The element C[ j ] stores the index of the greatest element of elements from the rightmost element to A[ j ]. The array C can be constructed based on elements in A from right to left.\nWhen an element A[ j ] is scanned, the index j is compared with B[ j ] and C[ j ]. if B[ j ]< j (there is a smaller element on the left side) and j <C[ j ] (there is a greater element on the right side), three increasing elements have been found.\nThis solution can be implemented with the following C/C++ code:\n void increasingIndex_1( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     int * minIndex = new int [length];\n     int index = 0;\n    minIndex[0] = 0;\n     int t;\n     for (t = 1; t < length; ++t)\n     {\n         if (nums[t] < nums[index])\n            index = t;\n        minIndex[t] = index;\n     }\n\n     int * maxIndex = new int [length];\n     index =length - 1;\n     for (t = length - 1; t >= 0; --t)\n     {\n         if (nums[t] > nums[index])\n            index = t;\n        maxIndex[t] = index;\n     }\n\n     for (t = 1; t < length - 1; ++t)\n     {\n         if (minIndex[t] < t && maxIndex[t] > t)\n             break ;\n     }\n     if (t < length - 1)\n     {\n         *i =minIndex[t];\n         *j =t;\n         *k =maxIndex[t];\n     }\n     else\n     {\n         *i =*j = *k = -1;\n     }\n\n     delete [] minIndex;\n     delete [] maxIndex;\n }\n\nSolution 2: O(n) time efficiency with O(1) space consumption\nIn order to find an even more efficient solution, let\u2019s scan all elements in an array and try to find three increasing elements. The array {3, 2, 5, 1, 4, 7, 9, 6, 8} is taken as an example to simulate the process.\nAt first, all elements A[ i ], A[ j ], and A[ k ] have not been found, so three indexes i , j , and k are initialized as -1.\nThe number 3 is the first number to be scanned, and A[ i ] is updated as 3.\nThe next number to be scanned is the number 2. Notice that 2 is less than 3, and it is a better candidate of A[ i ]. The less A[ i ] is, the larger range A[ j ] and A[ k ] will have. Therefore, A[ i ] is updated as 2.\nLet\u2019s continue to scan the next number 5. Since 5 is greater the current A[ i ], it is a candidate of A[ j ]. A[ j ] is updated as 5.\nThe number 1 is scanned in the next round. Because 1 is less than the current A[ j ], it cannot be A[ k ]. Additionally, the number 1 is a candidate to be A[ i ] or A[ j ] in the future since it is less than the current A[ i ] and A[ j ]. However, neither A[ i ] nor A[ j ] can be updated as 1 at this time. If A[ i ] is updated as 1, A[ i ]<A[ j ] but i > j . If A[ j ] is updated as 1, A[ i ]>A[ j ]. Therefore, we store the number 1 into another variable named t .\nWe move on to scan the next number 4. Notice that the number 4 is less than A[ j ] again. At this time we have two numbers 1 (the stored variable t ) and 4, so we have a new pair of numbers to be A[ i ] and A[ j ]. A[ i ] and A[ j ] are updated as 1 and 4 respectively.\nThe next number, 7, is greater than the current A[ j ], so A[ k ] is updated as 7. The process terminates.\nThe following table summarizes the step-by-step analysis above:\nStep\nScanned Number\nA[ i ]\nA[ j ]\nA[ k ]\nt\nOperation\n1\n3\n3\n-1\n-1\n-1\nUpdate A[ i ]\n2\n2\n2\n-1\n-1\n-1\nUpdate A[ i ]\n3\n5\n2\n5\n-1\n-1\nUpdate A[ j ]\n4\n1\n2\n5\n-1\n1\nUpdate t\n5\n4\n1\n4\n-1\n-1\nUpdate A[ i ], A[ j ] and t\n6\n7\n1\n4\n7\n-1\nUpdate A[ k ]. Terminate.\nThe strategy of this solution is to store as less value to A[ i ] and A[ j ] as possible, in order to enlarge the value range for steps in the future.\nWith our step-by-step analysis, we could implement this solution with the following C++ code:\n void increasingIndex_2( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     *i = *j =*k = -1;\n     int backup = -1;\n\n     int index;\n     for (index = 0; index < length; ++index)\n     {\n         if (*i == -1)\n         {\n            *i = index;\n         }\n         else if (*j == -1)\n         {\n             if (nums[index] > nums[*i])\n                *j = index;\n             else\n                *i = index;\n         }\n         else if (nums[index]> nums[*j])\n         {\n            *k = index;\n             break ;\n         }\n         else if (nums[index]< nums[*j])\n         {\n             if (backup != -1)\n             {\n                 if (nums[index] > nums[backup])\n                {\n                    *i = backup;\n                    *j = index;\n                    backup = -1;\n                }\n                 else if (nums[index] < nums[backup])\n                {\n                    backup = index;\n                }\n             }\n             else if (nums[index]< nums[*j])\n                backup = index;\n         }\n     }\n     if (index == length)\n         *i =*j = *k = -1;\n }\n", "question": "\nProblem: Given an array of integers A, please find three indexes i , j , k , such that i < j < k and A[ i ]<A[ j ]<A[ k ].\n"},
{"answer": "", "question": ""},
{"answer": "", "question": ""},
{"answer": "\nAnalysis: Many candidates can get a straight solution which converts the input number into a string first. However, it is not what interviewers expect usually.\n\nSolution 1: Convert a Number into a String\n\nIt is easy to check whether a number is palindrome or not: We can check whether the first character and the last one are identical, and then check the second character and the second one from end, and so on. Therefore, we can firstly convert the input number into a string via the function sprintf , and then check whether the string is a palindrome.\n\nThis solution can be implemented as the following code:\n\nbool IsPalindrome_solution1( unsigned int number)\n{\nconst int NUMBER_LENGTH = 20;\nchar string[NUMBER_LENGTH];\nsprintf(string, \"%d\" , number);\n\nreturn IsPalindrome(string);\n}\n\nbool IsPalindrome( const char * const string)\n{\nbool palindrome = true ;\nif (string != NULL)\n{\nint length = strlen(string);\nint half = length >> 1;\n\nfor ( int i = 0; i < half; ++ i)\n{\nif (string[i] != string[length - 1 - i])\n{\npalindrome = false ;\nbreak ;\n}\n}\n}\n\nreturn palindrome;\n}\n\nUsually the solution above is not the one expected by interviewers. One reason is that it is intuitive while interviewers expect something innovative, and the other is that it requires auxiliary memory to store the converted string.\n\nSolution 2: Compose a Reversed Number\n\nAs we know, it is easy to get digits from right to left via / and % operators. For example, digits in the number 123 are 3, 2 and 1. We can construct a reversed number 321 with these three digits. And then we check whether the reverse number is identical to the original one. If it is, the original number is a palindrome.\n\nIts corresponding code is shown below:\n\nbool IsPalindrome_solution2( unsigned int number)\n{\nint reversed = 0;\nint copy = number;\n\nwhile (number != 0)\n{\nreversed = reversed * 10 + number % 10;\nnumber /= 10;\n}\n\nreturn (reversed == copy);\n}", "question": "\nProblem: Please implement a function which checks whether a number is a palindrome or not. For example, 121 is a palindrome, while 123 is not.\n"},
{"answer": "\nAnalysis: Firstly let\u2019s analyze this problem with the brute-force solution: All elements in the array are scanned one by one. When an element is scanned, we take is as A[ j ], and check whether there is a smaller element on its left side (A[ i ]), and a greater element on its right side (A[ k ]).\nSince it takes O( n ) time to scan numbers on two sides of each A[ j ], the overall time of this solution is O( n 2 ) on an array with n elements.\n\nSolution 1: O(n) time efficiency with O(n) space consumption\nAs our analysis above, for each element A[ j ], we need to know whether there is a smaller element on its left side. If there is not a smaller element on the left side, A[ j ] itself is the smallest of all elements from the leftmost element to A[ j ]. If there is a smaller element on the left side, the smallest of all elements from the leftmost element to A[ j ] is on the left side of A[ j ].\nTherefore, we could construct an auxiliary array B. The element B[ j ] stores the index of the smallest element of elements from the leftmost element to A[ j ]. The array B can be constructed based on elements in A from left to right.\nSimilarly, we could also construct another auxiliary array C. The element C[ j ] stores the index of the greatest element of elements from the rightmost element to A[ j ]. The array C can be constructed based on elements in A from right to left.\nWhen an element A[ j ] is scanned, the index j is compared with B[ j ] and C[ j ]. if B[ j ]< j (there is a smaller element on the left side) and j <C[ j ] (there is a greater element on the right side), three increasing elements have been found.\nThis solution can be implemented with the following C/C++ code:\n void increasingIndex_1( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     int * minIndex = new int [length];\n     int index = 0;\n    minIndex[0] = 0;\n     int t;\n     for (t = 1; t < length; ++t)\n     {\n         if (nums[t] < nums[index])\n            index = t;\n        minIndex[t] = index;\n     }\n\n     int * maxIndex = new int [length];\n     index =length - 1;\n     for (t = length - 1; t >= 0; --t)\n     {\n         if (nums[t] > nums[index])\n            index = t;\n        maxIndex[t] = index;\n     }\n\n     for (t = 1; t < length - 1; ++t)\n     {\n         if (minIndex[t] < t && maxIndex[t] > t)\n             break ;\n     }\n     if (t < length - 1)\n     {\n         *i =minIndex[t];\n         *j =t;\n         *k =maxIndex[t];\n     }\n     else\n     {\n         *i =*j = *k = -1;\n     }\n\n     delete [] minIndex;\n     delete [] maxIndex;\n }\n\nSolution 2: O(n) time efficiency with O(1) space consumption\nIn order to find an even more efficient solution, let\u2019s scan all elements in an array and try to find three increasing elements. The array {3, 2, 5, 1, 4, 7, 9, 6, 8} is taken as an example to simulate the process.\nAt first, all elements A[ i ], A[ j ], and A[ k ] have not been found, so three indexes i , j , and k are initialized as -1.\nThe number 3 is the first number to be scanned, and A[ i ] is updated as 3.\nThe next number to be scanned is the number 2. Notice that 2 is less than 3, and it is a better candidate of A[ i ]. The less A[ i ] is, the larger range A[ j ] and A[ k ] will have. Therefore, A[ i ] is updated as 2.\nLet\u2019s continue to scan the next number 5. Since 5 is greater the current A[ i ], it is a candidate of A[ j ]. A[ j ] is updated as 5.\nThe number 1 is scanned in the next round. Because 1 is less than the current A[ j ], it cannot be A[ k ]. Additionally, the number 1 is a candidate to be A[ i ] or A[ j ] in the future since it is less than the current A[ i ] and A[ j ]. However, neither A[ i ] nor A[ j ] can be updated as 1 at this time. If A[ i ] is updated as 1, A[ i ]<A[ j ] but i > j . If A[ j ] is updated as 1, A[ i ]>A[ j ]. Therefore, we store the number 1 into another variable named t .\nWe move on to scan the next number 4. Notice that the number 4 is less than A[ j ] again. At this time we have two numbers 1 (the stored variable t ) and 4, so we have a new pair of numbers to be A[ i ] and A[ j ]. A[ i ] and A[ j ] are updated as 1 and 4 respectively.\nThe next number, 7, is greater than the current A[ j ], so A[ k ] is updated as 7. The process terminates.\nThe following table summarizes the step-by-step analysis above:\nStep\nScanned Number\nA[ i ]\nA[ j ]\nA[ k ]\nt\nOperation\n1\n3\n3\n-1\n-1\n-1\nUpdate A[ i ]\n2\n2\n2\n-1\n-1\n-1\nUpdate A[ i ]\n3\n5\n2\n5\n-1\n-1\nUpdate A[ j ]\n4\n1\n2\n5\n-1\n1\nUpdate t\n5\n4\n1\n4\n-1\n-1\nUpdate A[ i ], A[ j ] and t\n6\n7\n1\n4\n7\n-1\nUpdate A[ k ]. Terminate.\nThe strategy of this solution is to store as less value to A[ i ] and A[ j ] as possible, in order to enlarge the value range for steps in the future.\nWith our step-by-step analysis, we could implement this solution with the following C++ code:\n void increasingIndex_2( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     *i = *j =*k = -1;\n     int backup = -1;\n\n     int index;\n     for (index = 0; index < length; ++index)\n     {\n         if (*i == -1)\n         {\n            *i = index;\n         }\n         else if (*j == -1)\n         {\n             if (nums[index] > nums[*i])\n                *j = index;\n             else\n                *i = index;\n         }\n         else if (nums[index]> nums[*j])\n         {\n            *k = index;\n             break ;\n         }\n         else if (nums[index]< nums[*j])\n         {\n             if (backup != -1)\n             {\n                 if (nums[index] > nums[backup])\n                {\n                    *i = backup;\n                    *j = index;\n                    backup = -1;\n                }\n                 else if (nums[index] < nums[backup])\n                {\n                    backup = index;\n                }\n             }\n             else if (nums[index]< nums[*j])\n                backup = index;\n         }\n     }\n     if (index == length)\n         *i =*j = *k = -1;\n }\n", "question": "\nProblem: Given an array of integers A, please find three indexes i , j , k , such that i < j < k and A[ i ]<A[ j ]<A[ k ].\n"},
{"answer": "\nAnalysis: Firstly let\u2019s analyze this problem with the brute-force solution: All elements in the array are scanned one by one. When an element is scanned, we take is as A[ j ], and check whether there is a smaller element on its left side (A[ i ]), and a greater element on its right side (A[ k ]).\nSince it takes O( n ) time to scan numbers on two sides of each A[ j ], the overall time of this solution is O( n 2 ) on an array with n elements.\n\nSolution 1: O(n) time efficiency with O(n) space consumption\nAs our analysis above, for each element A[ j ], we need to know whether there is a smaller element on its left side. If there is not a smaller element on the left side, A[ j ] itself is the smallest of all elements from the leftmost element to A[ j ]. If there is a smaller element on the left side, the smallest of all elements from the leftmost element to A[ j ] is on the left side of A[ j ].\nTherefore, we could construct an auxiliary array B. The element B[ j ] stores the index of the smallest element of elements from the leftmost element to A[ j ]. The array B can be constructed based on elements in A from left to right.\nSimilarly, we could also construct another auxiliary array C. The element C[ j ] stores the index of the greatest element of elements from the rightmost element to A[ j ]. The array C can be constructed based on elements in A from right to left.\nWhen an element A[ j ] is scanned, the index j is compared with B[ j ] and C[ j ]. if B[ j ]< j (there is a smaller element on the left side) and j <C[ j ] (there is a greater element on the right side), three increasing elements have been found.\nThis solution can be implemented with the following C/C++ code:\n void increasingIndex_1( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     int * minIndex = new int [length];\n     int index = 0;\n    minIndex[0] = 0;\n     int t;\n     for (t = 1; t < length; ++t)\n     {\n         if (nums[t] < nums[index])\n            index = t;\n        minIndex[t] = index;\n     }\n\n     int * maxIndex = new int [length];\n     index =length - 1;\n     for (t = length - 1; t >= 0; --t)\n     {\n         if (nums[t] > nums[index])\n            index = t;\n        maxIndex[t] = index;\n     }\n\n     for (t = 1; t < length - 1; ++t)\n     {\n         if (minIndex[t] < t && maxIndex[t] > t)\n             break ;\n     }\n     if (t < length - 1)\n     {\n         *i =minIndex[t];\n         *j =t;\n         *k =maxIndex[t];\n     }\n     else\n     {\n         *i =*j = *k = -1;\n     }\n\n     delete [] minIndex;\n     delete [] maxIndex;\n }\n\nSolution 2: O(n) time efficiency with O(1) space consumption\nIn order to find an even more efficient solution, let\u2019s scan all elements in an array and try to find three increasing elements. The array {3, 2, 5, 1, 4, 7, 9, 6, 8} is taken as an example to simulate the process.\nAt first, all elements A[ i ], A[ j ], and A[ k ] have not been found, so three indexes i , j , and k are initialized as -1.\nThe number 3 is the first number to be scanned, and A[ i ] is updated as 3.\nThe next number to be scanned is the number 2. Notice that 2 is less than 3, and it is a better candidate of A[ i ]. The less A[ i ] is, the larger range A[ j ] and A[ k ] will have. Therefore, A[ i ] is updated as 2.\nLet\u2019s continue to scan the next number 5. Since 5 is greater the current A[ i ], it is a candidate of A[ j ]. A[ j ] is updated as 5.\nThe number 1 is scanned in the next round. Because 1 is less than the current A[ j ], it cannot be A[ k ]. Additionally, the number 1 is a candidate to be A[ i ] or A[ j ] in the future since it is less than the current A[ i ] and A[ j ]. However, neither A[ i ] nor A[ j ] can be updated as 1 at this time. If A[ i ] is updated as 1, A[ i ]<A[ j ] but i > j . If A[ j ] is updated as 1, A[ i ]>A[ j ]. Therefore, we store the number 1 into another variable named t .\nWe move on to scan the next number 4. Notice that the number 4 is less than A[ j ] again. At this time we have two numbers 1 (the stored variable t ) and 4, so we have a new pair of numbers to be A[ i ] and A[ j ]. A[ i ] and A[ j ] are updated as 1 and 4 respectively.\nThe next number, 7, is greater than the current A[ j ], so A[ k ] is updated as 7. The process terminates.\nThe following table summarizes the step-by-step analysis above:\nStep\nScanned Number\nA[ i ]\nA[ j ]\nA[ k ]\nt\nOperation\n1\n3\n3\n-1\n-1\n-1\nUpdate A[ i ]\n2\n2\n2\n-1\n-1\n-1\nUpdate A[ i ]\n3\n5\n2\n5\n-1\n-1\nUpdate A[ j ]\n4\n1\n2\n5\n-1\n1\nUpdate t\n5\n4\n1\n4\n-1\n-1\nUpdate A[ i ], A[ j ] and t\n6\n7\n1\n4\n7\n-1\nUpdate A[ k ]. Terminate.\nThe strategy of this solution is to store as less value to A[ i ] and A[ j ] as possible, in order to enlarge the value range for steps in the future.\nWith our step-by-step analysis, we could implement this solution with the following C++ code:\n void increasingIndex_2( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     *i = *j =*k = -1;\n     int backup = -1;\n\n     int index;\n     for (index = 0; index < length; ++index)\n     {\n         if (*i == -1)\n         {\n            *i = index;\n         }\n         else if (*j == -1)\n         {\n             if (nums[index] > nums[*i])\n                *j = index;\n             else\n                *i = index;\n         }\n         else if (nums[index]> nums[*j])\n         {\n            *k = index;\n             break ;\n         }\n         else if (nums[index]< nums[*j])\n         {\n             if (backup != -1)\n             {\n                 if (nums[index] > nums[backup])\n                {\n                    *i = backup;\n                    *j = index;\n                    backup = -1;\n                }\n                 else if (nums[index] < nums[backup])\n                {\n                    backup = index;\n                }\n             }\n             else if (nums[index]< nums[*j])\n                backup = index;\n         }\n     }\n     if (index == length)\n         *i =*j = *k = -1;\n }\n", "question": "\nProblem: Given an array of integers A, please find three indexes i , j , k , such that i < j < k and A[ i ]<A[ j ]<A[ k ].\n"},
{"answer": "\nAnalysis: Firstly let\u2019s analyze this problem with the brute-force solution: All elements in the array are scanned one by one. When an element is scanned, we take is as A[ j ], and check whether there is a smaller element on its left side (A[ i ]), and a greater element on its right side (A[ k ]).\nSince it takes O( n ) time to scan numbers on two sides of each A[ j ], the overall time of this solution is O( n 2 ) on an array with n elements.\n\nSolution 1: O(n) time efficiency with O(n) space consumption\nAs our analysis above, for each element A[ j ], we need to know whether there is a smaller element on its left side. If there is not a smaller element on the left side, A[ j ] itself is the smallest of all elements from the leftmost element to A[ j ]. If there is a smaller element on the left side, the smallest of all elements from the leftmost element to A[ j ] is on the left side of A[ j ].\nTherefore, we could construct an auxiliary array B. The element B[ j ] stores the index of the smallest element of elements from the leftmost element to A[ j ]. The array B can be constructed based on elements in A from left to right.\nSimilarly, we could also construct another auxiliary array C. The element C[ j ] stores the index of the greatest element of elements from the rightmost element to A[ j ]. The array C can be constructed based on elements in A from right to left.\nWhen an element A[ j ] is scanned, the index j is compared with B[ j ] and C[ j ]. if B[ j ]< j (there is a smaller element on the left side) and j <C[ j ] (there is a greater element on the right side), three increasing elements have been found.\nThis solution can be implemented with the following C/C++ code:\n void increasingIndex_1( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     int * minIndex = new int [length];\n     int index = 0;\n    minIndex[0] = 0;\n     int t;\n     for (t = 1; t < length; ++t)\n     {\n         if (nums[t] < nums[index])\n            index = t;\n        minIndex[t] = index;\n     }\n\n     int * maxIndex = new int [length];\n     index =length - 1;\n     for (t = length - 1; t >= 0; --t)\n     {\n         if (nums[t] > nums[index])\n            index = t;\n        maxIndex[t] = index;\n     }\n\n     for (t = 1; t < length - 1; ++t)\n     {\n         if (minIndex[t] < t && maxIndex[t] > t)\n             break ;\n     }\n     if (t < length - 1)\n     {\n         *i =minIndex[t];\n         *j =t;\n         *k =maxIndex[t];\n     }\n     else\n     {\n         *i =*j = *k = -1;\n     }\n\n     delete [] minIndex;\n     delete [] maxIndex;\n }\n\nSolution 2: O(n) time efficiency with O(1) space consumption\nIn order to find an even more efficient solution, let\u2019s scan all elements in an array and try to find three increasing elements. The array {3, 2, 5, 1, 4, 7, 9, 6, 8} is taken as an example to simulate the process.\nAt first, all elements A[ i ], A[ j ], and A[ k ] have not been found, so three indexes i , j , and k are initialized as -1.\nThe number 3 is the first number to be scanned, and A[ i ] is updated as 3.\nThe next number to be scanned is the number 2. Notice that 2 is less than 3, and it is a better candidate of A[ i ]. The less A[ i ] is, the larger range A[ j ] and A[ k ] will have. Therefore, A[ i ] is updated as 2.\nLet\u2019s continue to scan the next number 5. Since 5 is greater the current A[ i ], it is a candidate of A[ j ]. A[ j ] is updated as 5.\nThe number 1 is scanned in the next round. Because 1 is less than the current A[ j ], it cannot be A[ k ]. Additionally, the number 1 is a candidate to be A[ i ] or A[ j ] in the future since it is less than the current A[ i ] and A[ j ]. However, neither A[ i ] nor A[ j ] can be updated as 1 at this time. If A[ i ] is updated as 1, A[ i ]<A[ j ] but i > j . If A[ j ] is updated as 1, A[ i ]>A[ j ]. Therefore, we store the number 1 into another variable named t .\nWe move on to scan the next number 4. Notice that the number 4 is less than A[ j ] again. At this time we have two numbers 1 (the stored variable t ) and 4, so we have a new pair of numbers to be A[ i ] and A[ j ]. A[ i ] and A[ j ] are updated as 1 and 4 respectively.\nThe next number, 7, is greater than the current A[ j ], so A[ k ] is updated as 7. The process terminates.\nThe following table summarizes the step-by-step analysis above:\nStep\nScanned Number\nA[ i ]\nA[ j ]\nA[ k ]\nt\nOperation\n1\n3\n3\n-1\n-1\n-1\nUpdate A[ i ]\n2\n2\n2\n-1\n-1\n-1\nUpdate A[ i ]\n3\n5\n2\n5\n-1\n-1\nUpdate A[ j ]\n4\n1\n2\n5\n-1\n1\nUpdate t\n5\n4\n1\n4\n-1\n-1\nUpdate A[ i ], A[ j ] and t\n6\n7\n1\n4\n7\n-1\nUpdate A[ k ]. Terminate.\nThe strategy of this solution is to store as less value to A[ i ] and A[ j ] as possible, in order to enlarge the value range for steps in the future.\nWith our step-by-step analysis, we could implement this solution with the following C++ code:\n void increasingIndex_2( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     *i = *j =*k = -1;\n     int backup = -1;\n\n     int index;\n     for (index = 0; index < length; ++index)\n     {\n         if (*i == -1)\n         {\n            *i = index;\n         }\n         else if (*j == -1)\n         {\n             if (nums[index] > nums[*i])\n                *j = index;\n             else\n                *i = index;\n         }\n         else if (nums[index]> nums[*j])\n         {\n            *k = index;\n             break ;\n         }\n         else if (nums[index]< nums[*j])\n         {\n             if (backup != -1)\n             {\n                 if (nums[index] > nums[backup])\n                {\n                    *i = backup;\n                    *j = index;\n                    backup = -1;\n                }\n                 else if (nums[index] < nums[backup])\n                {\n                    backup = index;\n                }\n             }\n             else if (nums[index]< nums[*j])\n                backup = index;\n         }\n     }\n     if (index == length)\n         *i =*j = *k = -1;\n }\n", "question": "\nProblem: Given an array of integers A, please find three indexes i , j , k , such that i < j < k and A[ i ]<A[ j ]<A[ k ].\n"},
{"answer": "\nAnalysis: Firstly let\u2019s analyze this problem with the brute-force solution: All elements in the array are scanned one by one. When an element is scanned, we take is as A[ j ], and check whether there is a smaller element on its left side (A[ i ]), and a greater element on its right side (A[ k ]).\nSince it takes O( n ) time to scan numbers on two sides of each A[ j ], the overall time of this solution is O( n 2 ) on an array with n elements.\n\nSolution 1: O(n) time efficiency with O(n) space consumption\nAs our analysis above, for each element A[ j ], we need to know whether there is a smaller element on its left side. If there is not a smaller element on the left side, A[ j ] itself is the smallest of all elements from the leftmost element to A[ j ]. If there is a smaller element on the left side, the smallest of all elements from the leftmost element to A[ j ] is on the left side of A[ j ].\nTherefore, we could construct an auxiliary array B. The element B[ j ] stores the index of the smallest element of elements from the leftmost element to A[ j ]. The array B can be constructed based on elements in A from left to right.\nSimilarly, we could also construct another auxiliary array C. The element C[ j ] stores the index of the greatest element of elements from the rightmost element to A[ j ]. The array C can be constructed based on elements in A from right to left.\nWhen an element A[ j ] is scanned, the index j is compared with B[ j ] and C[ j ]. if B[ j ]< j (there is a smaller element on the left side) and j <C[ j ] (there is a greater element on the right side), three increasing elements have been found.\nThis solution can be implemented with the following C/C++ code:\n void increasingIndex_1( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     int * minIndex = new int [length];\n     int index = 0;\n    minIndex[0] = 0;\n     int t;\n     for (t = 1; t < length; ++t)\n     {\n         if (nums[t] < nums[index])\n            index = t;\n        minIndex[t] = index;\n     }\n\n     int * maxIndex = new int [length];\n     index =length - 1;\n     for (t = length - 1; t >= 0; --t)\n     {\n         if (nums[t] > nums[index])\n            index = t;\n        maxIndex[t] = index;\n     }\n\n     for (t = 1; t < length - 1; ++t)\n     {\n         if (minIndex[t] < t && maxIndex[t] > t)\n             break ;\n     }\n     if (t < length - 1)\n     {\n         *i =minIndex[t];\n         *j =t;\n         *k =maxIndex[t];\n     }\n     else\n     {\n         *i =*j = *k = -1;\n     }\n\n     delete [] minIndex;\n     delete [] maxIndex;\n }\n\nSolution 2: O(n) time efficiency with O(1) space consumption\nIn order to find an even more efficient solution, let\u2019s scan all elements in an array and try to find three increasing elements. The array {3, 2, 5, 1, 4, 7, 9, 6, 8} is taken as an example to simulate the process.\nAt first, all elements A[ i ], A[ j ], and A[ k ] have not been found, so three indexes i , j , and k are initialized as -1.\nThe number 3 is the first number to be scanned, and A[ i ] is updated as 3.\nThe next number to be scanned is the number 2. Notice that 2 is less than 3, and it is a better candidate of A[ i ]. The less A[ i ] is, the larger range A[ j ] and A[ k ] will have. Therefore, A[ i ] is updated as 2.\nLet\u2019s continue to scan the next number 5. Since 5 is greater the current A[ i ], it is a candidate of A[ j ]. A[ j ] is updated as 5.\nThe number 1 is scanned in the next round. Because 1 is less than the current A[ j ], it cannot be A[ k ]. Additionally, the number 1 is a candidate to be A[ i ] or A[ j ] in the future since it is less than the current A[ i ] and A[ j ]. However, neither A[ i ] nor A[ j ] can be updated as 1 at this time. If A[ i ] is updated as 1, A[ i ]<A[ j ] but i > j . If A[ j ] is updated as 1, A[ i ]>A[ j ]. Therefore, we store the number 1 into another variable named t .\nWe move on to scan the next number 4. Notice that the number 4 is less than A[ j ] again. At this time we have two numbers 1 (the stored variable t ) and 4, so we have a new pair of numbers to be A[ i ] and A[ j ]. A[ i ] and A[ j ] are updated as 1 and 4 respectively.\nThe next number, 7, is greater than the current A[ j ], so A[ k ] is updated as 7. The process terminates.\nThe following table summarizes the step-by-step analysis above:\nStep\nScanned Number\nA[ i ]\nA[ j ]\nA[ k ]\nt\nOperation\n1\n3\n3\n-1\n-1\n-1\nUpdate A[ i ]\n2\n2\n2\n-1\n-1\n-1\nUpdate A[ i ]\n3\n5\n2\n5\n-1\n-1\nUpdate A[ j ]\n4\n1\n2\n5\n-1\n1\nUpdate t\n5\n4\n1\n4\n-1\n-1\nUpdate A[ i ], A[ j ] and t\n6\n7\n1\n4\n7\n-1\nUpdate A[ k ]. Terminate.\nThe strategy of this solution is to store as less value to A[ i ] and A[ j ] as possible, in order to enlarge the value range for steps in the future.\nWith our step-by-step analysis, we could implement this solution with the following C++ code:\n void increasingIndex_2( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     *i = *j =*k = -1;\n     int backup = -1;\n\n     int index;\n     for (index = 0; index < length; ++index)\n     {\n         if (*i == -1)\n         {\n            *i = index;\n         }\n         else if (*j == -1)\n         {\n             if (nums[index] > nums[*i])\n                *j = index;\n             else\n                *i = index;\n         }\n         else if (nums[index]> nums[*j])\n         {\n            *k = index;\n             break ;\n         }\n         else if (nums[index]< nums[*j])\n         {\n             if (backup != -1)\n             {\n                 if (nums[index] > nums[backup])\n                {\n                    *i = backup;\n                    *j = index;\n                    backup = -1;\n                }\n                 else if (nums[index] < nums[backup])\n                {\n                    backup = index;\n                }\n             }\n             else if (nums[index]< nums[*j])\n                backup = index;\n         }\n     }\n     if (index == length)\n         *i =*j = *k = -1;\n }\n", "question": "\nProblem: Given an array of integers A, please find three indexes i , j , k , such that i < j < k and A[ i ]<A[ j ]<A[ k ].\n"},
{"answer": "\nAnalysis: Firstly let\u2019s analyze this problem with the brute-force solution: All elements in the array are scanned one by one. When an element is scanned, we take is as A[ j ], and check whether there is a smaller element on its left side (A[ i ]), and a greater element on its right side (A[ k ]).\nSince it takes O( n ) time to scan numbers on two sides of each A[ j ], the overall time of this solution is O( n 2 ) on an array with n elements.\n\nSolution 1: O(n) time efficiency with O(n) space consumption\nAs our analysis above, for each element A[ j ], we need to know whether there is a smaller element on its left side. If there is not a smaller element on the left side, A[ j ] itself is the smallest of all elements from the leftmost element to A[ j ]. If there is a smaller element on the left side, the smallest of all elements from the leftmost element to A[ j ] is on the left side of A[ j ].\nTherefore, we could construct an auxiliary array B. The element B[ j ] stores the index of the smallest element of elements from the leftmost element to A[ j ]. The array B can be constructed based on elements in A from left to right.\nSimilarly, we could also construct another auxiliary array C. The element C[ j ] stores the index of the greatest element of elements from the rightmost element to A[ j ]. The array C can be constructed based on elements in A from right to left.\nWhen an element A[ j ] is scanned, the index j is compared with B[ j ] and C[ j ]. if B[ j ]< j (there is a smaller element on the left side) and j <C[ j ] (there is a greater element on the right side), three increasing elements have been found.\nThis solution can be implemented with the following C/C++ code:\n void increasingIndex_1( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     int * minIndex = new int [length];\n     int index = 0;\n    minIndex[0] = 0;\n     int t;\n     for (t = 1; t < length; ++t)\n     {\n         if (nums[t] < nums[index])\n            index = t;\n        minIndex[t] = index;\n     }\n\n     int * maxIndex = new int [length];\n     index =length - 1;\n     for (t = length - 1; t >= 0; --t)\n     {\n         if (nums[t] > nums[index])\n            index = t;\n        maxIndex[t] = index;\n     }\n\n     for (t = 1; t < length - 1; ++t)\n     {\n         if (minIndex[t] < t && maxIndex[t] > t)\n             break ;\n     }\n     if (t < length - 1)\n     {\n         *i =minIndex[t];\n         *j =t;\n         *k =maxIndex[t];\n     }\n     else\n     {\n         *i =*j = *k = -1;\n     }\n\n     delete [] minIndex;\n     delete [] maxIndex;\n }\n\nSolution 2: O(n) time efficiency with O(1) space consumption\nIn order to find an even more efficient solution, let\u2019s scan all elements in an array and try to find three increasing elements. The array {3, 2, 5, 1, 4, 7, 9, 6, 8} is taken as an example to simulate the process.\nAt first, all elements A[ i ], A[ j ], and A[ k ] have not been found, so three indexes i , j , and k are initialized as -1.\nThe number 3 is the first number to be scanned, and A[ i ] is updated as 3.\nThe next number to be scanned is the number 2. Notice that 2 is less than 3, and it is a better candidate of A[ i ]. The less A[ i ] is, the larger range A[ j ] and A[ k ] will have. Therefore, A[ i ] is updated as 2.\nLet\u2019s continue to scan the next number 5. Since 5 is greater the current A[ i ], it is a candidate of A[ j ]. A[ j ] is updated as 5.\nThe number 1 is scanned in the next round. Because 1 is less than the current A[ j ], it cannot be A[ k ]. Additionally, the number 1 is a candidate to be A[ i ] or A[ j ] in the future since it is less than the current A[ i ] and A[ j ]. However, neither A[ i ] nor A[ j ] can be updated as 1 at this time. If A[ i ] is updated as 1, A[ i ]<A[ j ] but i > j . If A[ j ] is updated as 1, A[ i ]>A[ j ]. Therefore, we store the number 1 into another variable named t .\nWe move on to scan the next number 4. Notice that the number 4 is less than A[ j ] again. At this time we have two numbers 1 (the stored variable t ) and 4, so we have a new pair of numbers to be A[ i ] and A[ j ]. A[ i ] and A[ j ] are updated as 1 and 4 respectively.\nThe next number, 7, is greater than the current A[ j ], so A[ k ] is updated as 7. The process terminates.\nThe following table summarizes the step-by-step analysis above:\nStep\nScanned Number\nA[ i ]\nA[ j ]\nA[ k ]\nt\nOperation\n1\n3\n3\n-1\n-1\n-1\nUpdate A[ i ]\n2\n2\n2\n-1\n-1\n-1\nUpdate A[ i ]\n3\n5\n2\n5\n-1\n-1\nUpdate A[ j ]\n4\n1\n2\n5\n-1\n1\nUpdate t\n5\n4\n1\n4\n-1\n-1\nUpdate A[ i ], A[ j ] and t\n6\n7\n1\n4\n7\n-1\nUpdate A[ k ]. Terminate.\nThe strategy of this solution is to store as less value to A[ i ] and A[ j ] as possible, in order to enlarge the value range for steps in the future.\nWith our step-by-step analysis, we could implement this solution with the following C++ code:\n void increasingIndex_2( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     *i = *j =*k = -1;\n     int backup = -1;\n\n     int index;\n     for (index = 0; index < length; ++index)\n     {\n         if (*i == -1)\n         {\n            *i = index;\n         }\n         else if (*j == -1)\n         {\n             if (nums[index] > nums[*i])\n                *j = index;\n             else\n                *i = index;\n         }\n         else if (nums[index]> nums[*j])\n         {\n            *k = index;\n             break ;\n         }\n         else if (nums[index]< nums[*j])\n         {\n             if (backup != -1)\n             {\n                 if (nums[index] > nums[backup])\n                {\n                    *i = backup;\n                    *j = index;\n                    backup = -1;\n                }\n                 else if (nums[index] < nums[backup])\n                {\n                    backup = index;\n                }\n             }\n             else if (nums[index]< nums[*j])\n                backup = index;\n         }\n     }\n     if (index == length)\n         *i =*j = *k = -1;\n }\n", "question": "\nProblem: Given an array of integers A, please find three indexes i , j , k , such that i < j < k and A[ i ]<A[ j ]<A[ k ].\n"},
{"answer": "\nAnalysis: Firstly let\u2019s analyze this problem with the brute-force solution: All elements in the array are scanned one by one. When an element is scanned, we take is as A[ j ], and check whether there is a smaller element on its left side (A[ i ]), and a greater element on its right side (A[ k ]).\nSince it takes O( n ) time to scan numbers on two sides of each A[ j ], the overall time of this solution is O( n 2 ) on an array with n elements.\n\nSolution 1: O(n) time efficiency with O(n) space consumption\nAs our analysis above, for each element A[ j ], we need to know whether there is a smaller element on its left side. If there is not a smaller element on the left side, A[ j ] itself is the smallest of all elements from the leftmost element to A[ j ]. If there is a smaller element on the left side, the smallest of all elements from the leftmost element to A[ j ] is on the left side of A[ j ].\nTherefore, we could construct an auxiliary array B. The element B[ j ] stores the index of the smallest element of elements from the leftmost element to A[ j ]. The array B can be constructed based on elements in A from left to right.\nSimilarly, we could also construct another auxiliary array C. The element C[ j ] stores the index of the greatest element of elements from the rightmost element to A[ j ]. The array C can be constructed based on elements in A from right to left.\nWhen an element A[ j ] is scanned, the index j is compared with B[ j ] and C[ j ]. if B[ j ]< j (there is a smaller element on the left side) and j <C[ j ] (there is a greater element on the right side), three increasing elements have been found.\nThis solution can be implemented with the following C/C++ code:\n void increasingIndex_1( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     int * minIndex = new int [length];\n     int index = 0;\n    minIndex[0] = 0;\n     int t;\n     for (t = 1; t < length; ++t)\n     {\n         if (nums[t] < nums[index])\n            index = t;\n        minIndex[t] = index;\n     }\n\n     int * maxIndex = new int [length];\n     index =length - 1;\n     for (t = length - 1; t >= 0; --t)\n     {\n         if (nums[t] > nums[index])\n            index = t;\n        maxIndex[t] = index;\n     }\n\n     for (t = 1; t < length - 1; ++t)\n     {\n         if (minIndex[t] < t && maxIndex[t] > t)\n             break ;\n     }\n     if (t < length - 1)\n     {\n         *i =minIndex[t];\n         *j =t;\n         *k =maxIndex[t];\n     }\n     else\n     {\n         *i =*j = *k = -1;\n     }\n\n     delete [] minIndex;\n     delete [] maxIndex;\n }\n\nSolution 2: O(n) time efficiency with O(1) space consumption\nIn order to find an even more efficient solution, let\u2019s scan all elements in an array and try to find three increasing elements. The array {3, 2, 5, 1, 4, 7, 9, 6, 8} is taken as an example to simulate the process.\nAt first, all elements A[ i ], A[ j ], and A[ k ] have not been found, so three indexes i , j , and k are initialized as -1.\nThe number 3 is the first number to be scanned, and A[ i ] is updated as 3.\nThe next number to be scanned is the number 2. Notice that 2 is less than 3, and it is a better candidate of A[ i ]. The less A[ i ] is, the larger range A[ j ] and A[ k ] will have. Therefore, A[ i ] is updated as 2.\nLet\u2019s continue to scan the next number 5. Since 5 is greater the current A[ i ], it is a candidate of A[ j ]. A[ j ] is updated as 5.\nThe number 1 is scanned in the next round. Because 1 is less than the current A[ j ], it cannot be A[ k ]. Additionally, the number 1 is a candidate to be A[ i ] or A[ j ] in the future since it is less than the current A[ i ] and A[ j ]. However, neither A[ i ] nor A[ j ] can be updated as 1 at this time. If A[ i ] is updated as 1, A[ i ]<A[ j ] but i > j . If A[ j ] is updated as 1, A[ i ]>A[ j ]. Therefore, we store the number 1 into another variable named t .\nWe move on to scan the next number 4. Notice that the number 4 is less than A[ j ] again. At this time we have two numbers 1 (the stored variable t ) and 4, so we have a new pair of numbers to be A[ i ] and A[ j ]. A[ i ] and A[ j ] are updated as 1 and 4 respectively.\nThe next number, 7, is greater than the current A[ j ], so A[ k ] is updated as 7. The process terminates.\nThe following table summarizes the step-by-step analysis above:\nStep\nScanned Number\nA[ i ]\nA[ j ]\nA[ k ]\nt\nOperation\n1\n3\n3\n-1\n-1\n-1\nUpdate A[ i ]\n2\n2\n2\n-1\n-1\n-1\nUpdate A[ i ]\n3\n5\n2\n5\n-1\n-1\nUpdate A[ j ]\n4\n1\n2\n5\n-1\n1\nUpdate t\n5\n4\n1\n4\n-1\n-1\nUpdate A[ i ], A[ j ] and t\n6\n7\n1\n4\n7\n-1\nUpdate A[ k ]. Terminate.\nThe strategy of this solution is to store as less value to A[ i ] and A[ j ] as possible, in order to enlarge the value range for steps in the future.\nWith our step-by-step analysis, we could implement this solution with the following C++ code:\n void increasingIndex_2( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     *i = *j =*k = -1;\n     int backup = -1;\n\n     int index;\n     for (index = 0; index < length; ++index)\n     {\n         if (*i == -1)\n         {\n            *i = index;\n         }\n         else if (*j == -1)\n         {\n             if (nums[index] > nums[*i])\n                *j = index;\n             else\n                *i = index;\n         }\n         else if (nums[index]> nums[*j])\n         {\n            *k = index;\n             break ;\n         }\n         else if (nums[index]< nums[*j])\n         {\n             if (backup != -1)\n             {\n                 if (nums[index] > nums[backup])\n                {\n                    *i = backup;\n                    *j = index;\n                    backup = -1;\n                }\n                 else if (nums[index] < nums[backup])\n                {\n                    backup = index;\n                }\n             }\n             else if (nums[index]< nums[*j])\n                backup = index;\n         }\n     }\n     if (index == length)\n         *i =*j = *k = -1;\n }\n", "question": "\nProblem: Given an array of integers A, please find three indexes i , j , k , such that i < j < k and A[ i ]<A[ j ]<A[ k ].\n"},
{"answer": "\nAnalysis: Firstly let\u2019s analyze this problem with the brute-force solution: All elements in the array are scanned one by one. When an element is scanned, we take is as A[ j ], and check whether there is a smaller element on its left side (A[ i ]), and a greater element on its right side (A[ k ]).\nSince it takes O( n ) time to scan numbers on two sides of each A[ j ], the overall time of this solution is O( n 2 ) on an array with n elements.\n\nSolution 1: O(n) time efficiency with O(n) space consumption\nAs our analysis above, for each element A[ j ], we need to know whether there is a smaller element on its left side. If there is not a smaller element on the left side, A[ j ] itself is the smallest of all elements from the leftmost element to A[ j ]. If there is a smaller element on the left side, the smallest of all elements from the leftmost element to A[ j ] is on the left side of A[ j ].\nTherefore, we could construct an auxiliary array B. The element B[ j ] stores the index of the smallest element of elements from the leftmost element to A[ j ]. The array B can be constructed based on elements in A from left to right.\nSimilarly, we could also construct another auxiliary array C. The element C[ j ] stores the index of the greatest element of elements from the rightmost element to A[ j ]. The array C can be constructed based on elements in A from right to left.\nWhen an element A[ j ] is scanned, the index j is compared with B[ j ] and C[ j ]. if B[ j ]< j (there is a smaller element on the left side) and j <C[ j ] (there is a greater element on the right side), three increasing elements have been found.\nThis solution can be implemented with the following C/C++ code:\n void increasingIndex_1( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     int * minIndex = new int [length];\n     int index = 0;\n    minIndex[0] = 0;\n     int t;\n     for (t = 1; t < length; ++t)\n     {\n         if (nums[t] < nums[index])\n            index = t;\n        minIndex[t] = index;\n     }\n\n     int * maxIndex = new int [length];\n     index =length - 1;\n     for (t = length - 1; t >= 0; --t)\n     {\n         if (nums[t] > nums[index])\n            index = t;\n        maxIndex[t] = index;\n     }\n\n     for (t = 1; t < length - 1; ++t)\n     {\n         if (minIndex[t] < t && maxIndex[t] > t)\n             break ;\n     }\n     if (t < length - 1)\n     {\n         *i =minIndex[t];\n         *j =t;\n         *k =maxIndex[t];\n     }\n     else\n     {\n         *i =*j = *k = -1;\n     }\n\n     delete [] minIndex;\n     delete [] maxIndex;\n }\n\nSolution 2: O(n) time efficiency with O(1) space consumption\nIn order to find an even more efficient solution, let\u2019s scan all elements in an array and try to find three increasing elements. The array {3, 2, 5, 1, 4, 7, 9, 6, 8} is taken as an example to simulate the process.\nAt first, all elements A[ i ], A[ j ], and A[ k ] have not been found, so three indexes i , j , and k are initialized as -1.\nThe number 3 is the first number to be scanned, and A[ i ] is updated as 3.\nThe next number to be scanned is the number 2. Notice that 2 is less than 3, and it is a better candidate of A[ i ]. The less A[ i ] is, the larger range A[ j ] and A[ k ] will have. Therefore, A[ i ] is updated as 2.\nLet\u2019s continue to scan the next number 5. Since 5 is greater the current A[ i ], it is a candidate of A[ j ]. A[ j ] is updated as 5.\nThe number 1 is scanned in the next round. Because 1 is less than the current A[ j ], it cannot be A[ k ]. Additionally, the number 1 is a candidate to be A[ i ] or A[ j ] in the future since it is less than the current A[ i ] and A[ j ]. However, neither A[ i ] nor A[ j ] can be updated as 1 at this time. If A[ i ] is updated as 1, A[ i ]<A[ j ] but i > j . If A[ j ] is updated as 1, A[ i ]>A[ j ]. Therefore, we store the number 1 into another variable named t .\nWe move on to scan the next number 4. Notice that the number 4 is less than A[ j ] again. At this time we have two numbers 1 (the stored variable t ) and 4, so we have a new pair of numbers to be A[ i ] and A[ j ]. A[ i ] and A[ j ] are updated as 1 and 4 respectively.\nThe next number, 7, is greater than the current A[ j ], so A[ k ] is updated as 7. The process terminates.\nThe following table summarizes the step-by-step analysis above:\nStep\nScanned Number\nA[ i ]\nA[ j ]\nA[ k ]\nt\nOperation\n1\n3\n3\n-1\n-1\n-1\nUpdate A[ i ]\n2\n2\n2\n-1\n-1\n-1\nUpdate A[ i ]\n3\n5\n2\n5\n-1\n-1\nUpdate A[ j ]\n4\n1\n2\n5\n-1\n1\nUpdate t\n5\n4\n1\n4\n-1\n-1\nUpdate A[ i ], A[ j ] and t\n6\n7\n1\n4\n7\n-1\nUpdate A[ k ]. Terminate.\nThe strategy of this solution is to store as less value to A[ i ] and A[ j ] as possible, in order to enlarge the value range for steps in the future.\nWith our step-by-step analysis, we could implement this solution with the following C++ code:\n void increasingIndex_2( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     *i = *j =*k = -1;\n     int backup = -1;\n\n     int index;\n     for (index = 0; index < length; ++index)\n     {\n         if (*i == -1)\n         {\n            *i = index;\n         }\n         else if (*j == -1)\n         {\n             if (nums[index] > nums[*i])\n                *j = index;\n             else\n                *i = index;\n         }\n         else if (nums[index]> nums[*j])\n         {\n            *k = index;\n             break ;\n         }\n         else if (nums[index]< nums[*j])\n         {\n             if (backup != -1)\n             {\n                 if (nums[index] > nums[backup])\n                {\n                    *i = backup;\n                    *j = index;\n                    backup = -1;\n                }\n                 else if (nums[index] < nums[backup])\n                {\n                    backup = index;\n                }\n             }\n             else if (nums[index]< nums[*j])\n                backup = index;\n         }\n     }\n     if (index == length)\n         *i =*j = *k = -1;\n }\n", "question": "\nProblem: Given an array of integers A, please find three indexes i , j , k , such that i < j < k and A[ i ]<A[ j ]<A[ k ].\n"},
{"answer": "\nAnalysis: Firstly let\u2019s analyze this problem with the brute-force solution: All elements in the array are scanned one by one. When an element is scanned, we take is as A[ j ], and check whether there is a smaller element on its left side (A[ i ]), and a greater element on its right side (A[ k ]).\nSince it takes O( n ) time to scan numbers on two sides of each A[ j ], the overall time of this solution is O( n 2 ) on an array with n elements.\n\nSolution 1: O(n) time efficiency with O(n) space consumption\nAs our analysis above, for each element A[ j ], we need to know whether there is a smaller element on its left side. If there is not a smaller element on the left side, A[ j ] itself is the smallest of all elements from the leftmost element to A[ j ]. If there is a smaller element on the left side, the smallest of all elements from the leftmost element to A[ j ] is on the left side of A[ j ].\nTherefore, we could construct an auxiliary array B. The element B[ j ] stores the index of the smallest element of elements from the leftmost element to A[ j ]. The array B can be constructed based on elements in A from left to right.\nSimilarly, we could also construct another auxiliary array C. The element C[ j ] stores the index of the greatest element of elements from the rightmost element to A[ j ]. The array C can be constructed based on elements in A from right to left.\nWhen an element A[ j ] is scanned, the index j is compared with B[ j ] and C[ j ]. if B[ j ]< j (there is a smaller element on the left side) and j <C[ j ] (there is a greater element on the right side), three increasing elements have been found.\nThis solution can be implemented with the following C/C++ code:\n void increasingIndex_1( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     int * minIndex = new int [length];\n     int index = 0;\n    minIndex[0] = 0;\n     int t;\n     for (t = 1; t < length; ++t)\n     {\n         if (nums[t] < nums[index])\n            index = t;\n        minIndex[t] = index;\n     }\n\n     int * maxIndex = new int [length];\n     index =length - 1;\n     for (t = length - 1; t >= 0; --t)\n     {\n         if (nums[t] > nums[index])\n            index = t;\n        maxIndex[t] = index;\n     }\n\n     for (t = 1; t < length - 1; ++t)\n     {\n         if (minIndex[t] < t && maxIndex[t] > t)\n             break ;\n     }\n     if (t < length - 1)\n     {\n         *i =minIndex[t];\n         *j =t;\n         *k =maxIndex[t];\n     }\n     else\n     {\n         *i =*j = *k = -1;\n     }\n\n     delete [] minIndex;\n     delete [] maxIndex;\n }\n\nSolution 2: O(n) time efficiency with O(1) space consumption\nIn order to find an even more efficient solution, let\u2019s scan all elements in an array and try to find three increasing elements. The array {3, 2, 5, 1, 4, 7, 9, 6, 8} is taken as an example to simulate the process.\nAt first, all elements A[ i ], A[ j ], and A[ k ] have not been found, so three indexes i , j , and k are initialized as -1.\nThe number 3 is the first number to be scanned, and A[ i ] is updated as 3.\nThe next number to be scanned is the number 2. Notice that 2 is less than 3, and it is a better candidate of A[ i ]. The less A[ i ] is, the larger range A[ j ] and A[ k ] will have. Therefore, A[ i ] is updated as 2.\nLet\u2019s continue to scan the next number 5. Since 5 is greater the current A[ i ], it is a candidate of A[ j ]. A[ j ] is updated as 5.\nThe number 1 is scanned in the next round. Because 1 is less than the current A[ j ], it cannot be A[ k ]. Additionally, the number 1 is a candidate to be A[ i ] or A[ j ] in the future since it is less than the current A[ i ] and A[ j ]. However, neither A[ i ] nor A[ j ] can be updated as 1 at this time. If A[ i ] is updated as 1, A[ i ]<A[ j ] but i > j . If A[ j ] is updated as 1, A[ i ]>A[ j ]. Therefore, we store the number 1 into another variable named t .\nWe move on to scan the next number 4. Notice that the number 4 is less than A[ j ] again. At this time we have two numbers 1 (the stored variable t ) and 4, so we have a new pair of numbers to be A[ i ] and A[ j ]. A[ i ] and A[ j ] are updated as 1 and 4 respectively.\nThe next number, 7, is greater than the current A[ j ], so A[ k ] is updated as 7. The process terminates.\nThe following table summarizes the step-by-step analysis above:\nStep\nScanned Number\nA[ i ]\nA[ j ]\nA[ k ]\nt\nOperation\n1\n3\n3\n-1\n-1\n-1\nUpdate A[ i ]\n2\n2\n2\n-1\n-1\n-1\nUpdate A[ i ]\n3\n5\n2\n5\n-1\n-1\nUpdate A[ j ]\n4\n1\n2\n5\n-1\n1\nUpdate t\n5\n4\n1\n4\n-1\n-1\nUpdate A[ i ], A[ j ] and t\n6\n7\n1\n4\n7\n-1\nUpdate A[ k ]. Terminate.\nThe strategy of this solution is to store as less value to A[ i ] and A[ j ] as possible, in order to enlarge the value range for steps in the future.\nWith our step-by-step analysis, we could implement this solution with the following C++ code:\n void increasingIndex_2( int *nums, int length, int *i, int * j, int *k)\n {\n     if (nums == NULL || length <= 0 || i == NULL || j== NULL || k == NULL)\n         return ;\n\n     *i = *j =*k = -1;\n     int backup = -1;\n\n     int index;\n     for (index = 0; index < length; ++index)\n     {\n         if (*i == -1)\n         {\n            *i = index;\n         }\n         else if (*j == -1)\n         {\n             if (nums[index] > nums[*i])\n                *j = index;\n             else\n                *i = index;\n         }\n         else if (nums[index]> nums[*j])\n         {\n            *k = index;\n             break ;\n         }\n         else if (nums[index]< nums[*j])\n         {\n             if (backup != -1)\n             {\n                 if (nums[index] > nums[backup])\n                {\n                    *i = backup;\n                    *j = index;\n                    backup = -1;\n                }\n                 else if (nums[index] < nums[backup])\n                {\n                    backup = index;\n                }\n             }\n             else if (nums[index]< nums[*j])\n                backup = index;\n         }\n     }\n     if (index == length)\n         *i =*j = *k = -1;\n }\n", "question": "\nProblem: Given an array of integers A, please find three indexes i , j , k , such that i < j < k and A[ i ]<A[ j ]<A[ k ].\n"},
{"answer": "\nAnalysis : An array has two ends, so each of the two stacks may grow from an end in the array. Figure 1 below shows the initial status of the array and two stacks (assuming the capacity of the array is 10).\nFigure 2: The status after three items are pushed into the first stack and two items are pushed into the second stack\n\ufeffNo more items can be pushed into stacks when two top items are adjacent to each other, because all space in the array has been occupied.\nOur solution can be implemented with the following C++ class: template < typename T, int capacity> class TwoStacks { public : TwoStacks() { topFirst = -1; topSecond = capacity; } T top( int stackIndex) { validateIndex(stackIndex); if (empty(stackIndex)) throw new exception( \"The stack is empty.\" ); if (stackIndex == 0) return items[topFirst]; return items[topSecond]; } void push( int stackIndex, T item) { validateIndex(stackIndex); if (full()) throw new exception( \"All space has been occupied.\" ); if (stackIndex == 0) items[++topFirst] = item; else items[--topSecond] = item; } void pop( int stackIndex) { validateIndex(stackIndex); if (empty(stackIndex)) throw new exception( \"The stack is empty.\" ); if (stackIndex == 0) --topFirst; else ++topSecond; } bool empty( int stackIndex) { if (stackIndex == 0 && topFirst == -1) return true ; if (stackIndex == 1 && topSecond == capacity) return true ; return false ; } private : bool full() { return (topFirst >= topSecond - 1); } void validateIndex( int stackIndex) { if (stackIndex < 0 || stackIndex > 1) throw new exception( \"Invalid Stack Index.\" ); } private : T items[capacity]; int topFirst; int topSecond; };\ntemplate < typename T, int capacity> class TwoStacks\n{\npublic :\nTwoStacks()\n{\ntopFirst = -1;\ntopSecond = capacity;\n}\n\nT top( int stackIndex)\n{\nvalidateIndex(stackIndex);\nif (empty(stackIndex))\nthrow new exception( \"The stack is empty.\" );\n\nif (stackIndex == 0)\nreturn items[topFirst];\nreturn items[topSecond];\n}\n\nvoid push( int stackIndex, T item)\n{\nvalidateIndex(stackIndex);\nif (full())\nthrow new exception( \"All space has been occupied.\" );\n\nif (stackIndex == 0)\nitems[++topFirst] = item;\nelse\nitems[--topSecond] = item;\n}\n\nvoid pop( int stackIndex)\n{\nvalidateIndex(stackIndex);\nif (empty(stackIndex))\nthrow new exception( \"The stack is empty.\" );\n\nif (stackIndex == 0)\n--topFirst;\nelse\n++topSecond;\n}\n\nbool empty( int stackIndex)\n{\nif (stackIndex == 0 && topFirst == -1)\nreturn true ;\nif (stackIndex == 1 && topSecond == capacity)\nreturn true ;\nreturn false ;\n}\n\nprivate :\nbool full()\n{\nreturn (topFirst >= topSecond - 1);\n}\n\nvoid validateIndex( int stackIndex)\n{\nif (stackIndex < 0 || stackIndex > 1)\nthrow new exception( \"Invalid Stack Index.\" );\n}\n\nprivate :\nT items[capacity];\nint topFirst;\nint topSecond;\n};\n\nAnalysis : An array only has two ends, so we need new strategies to implement more than two stacks in a single array.\nWe may implement the array like a list, where each item in the array has a link to another item. When an item has not been occupied by any stacks and it is available, it is linked to the next available item. When an item is pushed into a stack, it is linked to the previous item in the stack. That\u2019s to say, there are n + 1 list in total in the system if there are n stacks sharing an array, a list for the available space left in the array, and a list for each stack.\nLet\u2019s take three stacks sharing an array with capacity 10 as an example. Figure 3 shows the initial status for the array and stacks. Each item in the array has two blocks, one for item data and the other for the index of another block.\n\n\nAs shown in Figure 3, each item is linked to the next item (the link block of the i th item is i +1). The head of list for available items in the array points to the item at position 0, which is the Ava pointer in the figure. Since three stacks are empty, their top (Top1, Top2 and Top3 in the figure) are initialized as -1.\n\nLet\u2019s try to push an item a into the first stack. Currently the first available item is at the position 0, so we set its data block as a . The link block of the item is 1, which means the next available item is at the position 1, so we update the Ava pointer to the position 1. Additionally, the link block of the item at the position 1 should be updated to -1, the previous top index of the first stack. Lastly, we update to top index of the first stack to 0. The status of the array and stacks are shown in Figure 4.\nLet\u2019s push two more items b and c into the first stack. The operations are similar as before, and the status is shown in Figure 5.\nIn the next step we are going to push another d into the second stack. Most operations are similar as before. The link block in the item at the position 3 is updated to -1, since the second stack is empty before and its top index is -1 previously. And then the top index of the second stack is updated to 3. The status after adding d into the second stack is shown in Figure 6.\n\nIf we continue to push three more item e , f , and g into the second stack, the status is shown in Figure 7.\n\nAt this time we are going to pop an item from the first stack. Since the top index of the first stack is 2, the item to be popped off is at the position 2. The link value in that item is 1, which means the previous top in the first stack is at the position 1 in the array, so we update the top index of the first stack as 1. Now the item at the position 2 becomes available, it should be linked to the list for available items. We move the Ava pointer to 2, and then update the link value of the item at the position 2 as 7, which is the previous head position of the list for available items. The status is shown in Figure 8.\nIf we pop an item off the second stack, the item at the position 6 will be linked to the list for available items too. Figure 9 depicts the status after the related operations.\nIf we push h into the third stack, it will be placed into the item at the position 6 because Ava points to that item. The next available item is at the position 2 (the link value in the item at the position 6). Therefore, the head of the list for available items points to location 2, as shown in Figure 10.\nLet\u2019s continue to push four more items into the third stack, i , j , k , and l . The status after these four items are pushed is shown in Figure 11. At this time, there are two items in the first stack ( a and b ), three items in the second stack ( d , e and f ), and five items in the third stack ( h , i , j , k , and l ). Please note that items inside a stack are not necessarily adjacent.\nAfter l is pushed into the item at the position 9, the Ava pointer is update to -1 (the previous link value in the item at the position 9), which means all items in the array have been occupied by stacks. We can\u2019t push more items until some items are popped off.\nThe source code in C++ to implement stacks sharing an array is listed below:\n template < typename T, int capacity, int count> class Stacks\n {\n\npublic :\n\nStacks()\n\n{\n\nint i;\n         for (i = 0; i < capacity - 1; ++i)\n            items[i].link = i + 1;\n        items[i].link = -1;\n        emptyHead = 0;\n\n         for (i = 0; i < count; ++i)\n            stackHead[i] = -1;\n     }\n\n     T top( int stackIndex)\n     {\n         validateIndex(stackIndex);\n         if (empty(stackIndex))\n             throw new exception( \"The stack is empty.\" );\n\n         return items[stackHead[stackIndex]].data;\n     }\n\n     void push( int stackIndex, const T& item)\n     {\n        validateIndex(stackIndex);\n         if (full())\n             throw new exception( \"All space has been occupied.\" );\n\n        Item<T>& block = items[emptyHead];\n         int nextEmpty = block.link;\n\n        block.data = item;\n        block.link = stackHead[stackIndex];\n        stackHead[stackIndex] = emptyHead;\n\n        emptyHead = nextEmpty;\n     }\n\n     void pop( int stackIndex)\n     {\n        validateIndex(stackIndex);\n         if (empty(stackIndex))\n             throw new exception( \"The stack is empty.\" );\n\n         Item<T>& block =items[stackHead[stackIndex]];\n         int nextItem = block.link;\n\n        block.link = emptyHead;         emptyHead = stackHead[stackIndex];         stackHead[stackIndex] = nextItem;\n        block.link = emptyHead;         emptyHead = stackHead[stackIndex];\n     }\n\n     bool empty( int stackIndex)\n     {\n         return (stackHead[stackIndex] < 0);\n     }\n\n private :\n     void validateIndex( int stackIndex)\n     {\n         if (stackIndex < 0 || stackIndex >= count)\n             throw new exception( \"Invalid index of stack.\" );\n     }\n\n     bool full()\n     {\n         return (emptyHead < 0);\n     }\n\n private :\n     template < typename T> struct Item\n     {\n         Tdata;\n         int link;\n     };\n\n private :\n    Item<T> items[capacity];\n     int emptyHead;\n     int stackHead[count];\n };\n\n", "question": "\nProblem 2 : How can you implement n ( n > 2) stacks in a single array, where no stack overflows until no space left in the entire array space? Analysis : An array only has two ends, so we need new strategies to implement more than two stacks in a single array. We may implement the array like a list, where each item in the array has a link to another item. When an item has not been occupied by any stacks and it is available, it is linked to the next available item. When an item is pushed into a stack, it is linked to the previous item in the stack. That\u2019s to say, there are n + 1 list in total in the system if there are n stacks sharing an array, a list for the available space left in the array, and a list for each stack. Let\u2019s take three stacks sharing an array with capacity 10 as an example. Figure 3 shows the initial status for the array and stacks. Each item in the array has two blocks, one for item data and the other for the index of another block.\nProblem 2 : How can you implement n ( n > 2) stacks in a single array, where no stack overflows until no space left in the entire array space?"},
{"answer": "\nAnalysis : An array has two ends, so each of the two stacks may grow from an end in the array. Figure 1 below shows the initial status of the array and two stacks (assuming the capacity of the array is 10).\nFigure 2: The status after three items are pushed into the first stack and two items are pushed into the second stack\n\ufeffNo more items can be pushed into stacks when two top items are adjacent to each other, because all space in the array has been occupied.\nOur solution can be implemented with the following C++ class: template < typename T, int capacity> class TwoStacks { public : TwoStacks() { topFirst = -1; topSecond = capacity; } T top( int stackIndex) { validateIndex(stackIndex); if (empty(stackIndex)) throw new exception( \"The stack is empty.\" ); if (stackIndex == 0) return items[topFirst]; return items[topSecond]; } void push( int stackIndex, T item) { validateIndex(stackIndex); if (full()) throw new exception( \"All space has been occupied.\" ); if (stackIndex == 0) items[++topFirst] = item; else items[--topSecond] = item; } void pop( int stackIndex) { validateIndex(stackIndex); if (empty(stackIndex)) throw new exception( \"The stack is empty.\" ); if (stackIndex == 0) --topFirst; else ++topSecond; } bool empty( int stackIndex) { if (stackIndex == 0 && topFirst == -1) return true ; if (stackIndex == 1 && topSecond == capacity) return true ; return false ; } private : bool full() { return (topFirst >= topSecond - 1); } void validateIndex( int stackIndex) { if (stackIndex < 0 || stackIndex > 1) throw new exception( \"Invalid Stack Index.\" ); } private : T items[capacity]; int topFirst; int topSecond; };\ntemplate < typename T, int capacity> class TwoStacks\n{\npublic :\nTwoStacks()\n{\ntopFirst = -1;\ntopSecond = capacity;\n}\n\nT top( int stackIndex)\n{\nvalidateIndex(stackIndex);\nif (empty(stackIndex))\nthrow new exception( \"The stack is empty.\" );\n\nif (stackIndex == 0)\nreturn items[topFirst];\nreturn items[topSecond];\n}\n\nvoid push( int stackIndex, T item)\n{\nvalidateIndex(stackIndex);\nif (full())\nthrow new exception( \"All space has been occupied.\" );\n\nif (stackIndex == 0)\nitems[++topFirst] = item;\nelse\nitems[--topSecond] = item;\n}\n\nvoid pop( int stackIndex)\n{\nvalidateIndex(stackIndex);\nif (empty(stackIndex))\nthrow new exception( \"The stack is empty.\" );\n\nif (stackIndex == 0)\n--topFirst;\nelse\n++topSecond;\n}\n\nbool empty( int stackIndex)\n{\nif (stackIndex == 0 && topFirst == -1)\nreturn true ;\nif (stackIndex == 1 && topSecond == capacity)\nreturn true ;\nreturn false ;\n}\n\nprivate :\nbool full()\n{\nreturn (topFirst >= topSecond - 1);\n}\n\nvoid validateIndex( int stackIndex)\n{\nif (stackIndex < 0 || stackIndex > 1)\nthrow new exception( \"Invalid Stack Index.\" );\n}\n\nprivate :\nT items[capacity];\nint topFirst;\nint topSecond;\n};\n\nAnalysis : An array only has two ends, so we need new strategies to implement more than two stacks in a single array.\nWe may implement the array like a list, where each item in the array has a link to another item. When an item has not been occupied by any stacks and it is available, it is linked to the next available item. When an item is pushed into a stack, it is linked to the previous item in the stack. That\u2019s to say, there are n + 1 list in total in the system if there are n stacks sharing an array, a list for the available space left in the array, and a list for each stack.\nLet\u2019s take three stacks sharing an array with capacity 10 as an example. Figure 3 shows the initial status for the array and stacks. Each item in the array has two blocks, one for item data and the other for the index of another block.\n\n\nAs shown in Figure 3, each item is linked to the next item (the link block of the i th item is i +1). The head of list for available items in the array points to the item at position 0, which is the Ava pointer in the figure. Since three stacks are empty, their top (Top1, Top2 and Top3 in the figure) are initialized as -1.\n\nLet\u2019s try to push an item a into the first stack. Currently the first available item is at the position 0, so we set its data block as a . The link block of the item is 1, which means the next available item is at the position 1, so we update the Ava pointer to the position 1. Additionally, the link block of the item at the position 1 should be updated to -1, the previous top index of the first stack. Lastly, we update to top index of the first stack to 0. The status of the array and stacks are shown in Figure 4.\nLet\u2019s push two more items b and c into the first stack. The operations are similar as before, and the status is shown in Figure 5.\nIn the next step we are going to push another d into the second stack. Most operations are similar as before. The link block in the item at the position 3 is updated to -1, since the second stack is empty before and its top index is -1 previously. And then the top index of the second stack is updated to 3. The status after adding d into the second stack is shown in Figure 6.\n\nIf we continue to push three more item e , f , and g into the second stack, the status is shown in Figure 7.\n\nAt this time we are going to pop an item from the first stack. Since the top index of the first stack is 2, the item to be popped off is at the position 2. The link value in that item is 1, which means the previous top in the first stack is at the position 1 in the array, so we update the top index of the first stack as 1. Now the item at the position 2 becomes available, it should be linked to the list for available items. We move the Ava pointer to 2, and then update the link value of the item at the position 2 as 7, which is the previous head position of the list for available items. The status is shown in Figure 8.\nIf we pop an item off the second stack, the item at the position 6 will be linked to the list for available items too. Figure 9 depicts the status after the related operations.\nIf we push h into the third stack, it will be placed into the item at the position 6 because Ava points to that item. The next available item is at the position 2 (the link value in the item at the position 6). Therefore, the head of the list for available items points to location 2, as shown in Figure 10.\nLet\u2019s continue to push four more items into the third stack, i , j , k , and l . The status after these four items are pushed is shown in Figure 11. At this time, there are two items in the first stack ( a and b ), three items in the second stack ( d , e and f ), and five items in the third stack ( h , i , j , k , and l ). Please note that items inside a stack are not necessarily adjacent.\nAfter l is pushed into the item at the position 9, the Ava pointer is update to -1 (the previous link value in the item at the position 9), which means all items in the array have been occupied by stacks. We can\u2019t push more items until some items are popped off.\nThe source code in C++ to implement stacks sharing an array is listed below:\n template < typename T, int capacity, int count> class Stacks\n {\n\npublic :\n\nStacks()\n\n{\n\nint i;\n         for (i = 0; i < capacity - 1; ++i)\n            items[i].link = i + 1;\n        items[i].link = -1;\n        emptyHead = 0;\n\n         for (i = 0; i < count; ++i)\n            stackHead[i] = -1;\n     }\n\n     T top( int stackIndex)\n     {\n         validateIndex(stackIndex);\n         if (empty(stackIndex))\n             throw new exception( \"The stack is empty.\" );\n\n         return items[stackHead[stackIndex]].data;\n     }\n\n     void push( int stackIndex, const T& item)\n     {\n        validateIndex(stackIndex);\n         if (full())\n             throw new exception( \"All space has been occupied.\" );\n\n        Item<T>& block = items[emptyHead];\n         int nextEmpty = block.link;\n\n        block.data = item;\n        block.link = stackHead[stackIndex];\n        stackHead[stackIndex] = emptyHead;\n\n        emptyHead = nextEmpty;\n     }\n\n     void pop( int stackIndex)\n     {\n        validateIndex(stackIndex);\n         if (empty(stackIndex))\n             throw new exception( \"The stack is empty.\" );\n\n         Item<T>& block =items[stackHead[stackIndex]];\n         int nextItem = block.link;\n\n        block.link = emptyHead;         emptyHead = stackHead[stackIndex];         stackHead[stackIndex] = nextItem;\n        block.link = emptyHead;         emptyHead = stackHead[stackIndex];\n     }\n\n     bool empty( int stackIndex)\n     {\n         return (stackHead[stackIndex] < 0);\n     }\n\n private :\n     void validateIndex( int stackIndex)\n     {\n         if (stackIndex < 0 || stackIndex >= count)\n             throw new exception( \"Invalid index of stack.\" );\n     }\n\n     bool full()\n     {\n         return (emptyHead < 0);\n     }\n\n private :\n     template < typename T> struct Item\n     {\n         Tdata;\n         int link;\n     };\n\n private :\n    Item<T> items[capacity];\n     int emptyHead;\n     int stackHead[count];\n };\n\n", "question": "\nProblem 2 : How can you implement n ( n > 2) stacks in a single array, where no stack overflows until no space left in the entire array space? Analysis : An array only has two ends, so we need new strategies to implement more than two stacks in a single array. We may implement the array like a list, where each item in the array has a link to another item. When an item has not been occupied by any stacks and it is available, it is linked to the next available item. When an item is pushed into a stack, it is linked to the previous item in the stack. That\u2019s to say, there are n + 1 list in total in the system if there are n stacks sharing an array, a list for the available space left in the array, and a list for each stack. Let\u2019s take three stacks sharing an array with capacity 10 as an example. Figure 3 shows the initial status for the array and stacks. Each item in the array has two blocks, one for item data and the other for the index of another block.\nProblem 2 : How can you implement n ( n > 2) stacks in a single array, where no stack overflows until no space left in the entire array space?"},
{"answer": "\nAnalysis: Path in a binary tree is a new concept for many candidates, so it is not a simple question for them. We may try to find the hidden rules with concrete examples. Let us take the binary tree in Figure 1 as an example.\n\nSince paths always start from a root node, we traverse from a root node in a binary tree. We have three traversal orders, pre-order, in-order and post-order, and we firstly visit a root node with pre-order traversal.\n\nAccording to the pre-order traversal process on the binary tree in Figure 1, we visit the node 5 after visiting the root node 10. Since a binary tree node does not have a pointer to its parent node, we do not know what nodes have been visited when we reach the node 5 if we do not save the visited node on the path. Therefore, we could insert the current node into a path when we reach it during traversal. The path contains two nodes with value 10 and 5 when we are visiting the node 5. Then we insert the node 4 into the path too when we reach it. We have reached a leaf node, and the sum of three nodes in the path is 19. Since it is not same as the input number 22, current path is not a qualified one.\nWe should continue to traverse other nodes. Before visiting other nodes, we should return back to the node 5, and then reach the node 7. It can be noticed that node 4 is no longer in the path from node 10 to node 7, so we should remove it from the path. When we are visiting node 7, we insert it into the path, which contains three nodes now. Since the sum of value of these three nodes is 22, the path is qualified.\n\nLastly we are going to visit the node 12. We should return back to node 5 then back to node 10 before we visit node 12. When we return back from a child node to its parent node, we remove the child node from the path. When we reach the node 12 eventually, the path contains two nodes, one is node 10 and the other is node 12. Since the sum of value of these two nodes is 22, the path is qualified too.\n\nWe can summarize the whole process above with the Table 1:\n\nStep Operation Is it a leaf? Path Sum of nodes value 1 Visit node 10 No node 10 10 2 Visit node 5 No node 10, node 5 15 3 Visit node 4 Yes node 10, node 5, node 4 19 4 Return to node 5 node 10, node 5 15 5 Visit node 7 Yes node 10, node 5, node 7 22 6 Return to node 5 node 10, node 5 15 7 Return to node 10 node 10 10 8 Visit node 12 Yes node 10, node 12 22\nStep\nOperation\nIs it a leaf?\nPath\nSum of nodes value\n1\nVisit node 10\nNo\nnode 10\n10\n2\nVisit node 5\nNo\nnode 10, node 5\n15\n3\nVisit node 4\nYes\nnode 10, node 5, node 4\n19\n4\nReturn to node 5\n\nnode 10, node 5\n15\n5\nVisit node 7\nYes\nnode 10, node 5, node 7\n22\n6\nReturn to node 5\n\nnode 10, node 5\n15\n7\nReturn to node 10\n\nnode 10\n10\n8\nVisit node 12\nYes\nnode 10, node 12\n22\nTable 1: The process to traverse the binary tree in Figure 1\n\nIt is time to summarize some rules with the example above. When we visit a node with pre-order traversal order, we insert it into the path, and accumulate its value to sum .\u00a0 When the node is a leaf and sum is same as the input number, the path is qualified and we need to print it. We continue to visit its children if the current node is not a leaf. After we finish visiting the current node, a recursive function will return back to its parent node automatically, so we should remove the current node from the path before a function returns to make sure the nodes in the path is same as the path from root node to its parent node. The data structure to save paths should be a stack, because paths should be consistent to the recursion status and recursion is essentially pushing and popping in a call stack.\nHere is some sample code for this problem:\n\nvoid FindPath(BinaryTreeNode* pRoot, int expectedSum)\n{\nif (pRoot == NULL)\nreturn ;\n\nstd::vector< int > path;\nint currentSum = 0;\nFindPath(pRoot, expectedSum, path, currentSum);\n}\n\nvoid FindPath\n(\nBinaryTreeNode*\u00a0\u00a0 pRoot,\nint expectedSum,\nstd::vector< int >&\u00a0path,\nint currentSum\n)\n{\ncurrentSum += pRoot->m_nValue;\npath.push_back(pRoot->m_nValue);\n\n// Print the path is the current node is a leaf\n// and the sum of all nodes value is same as expectedSum\nbool isLeaf = pRoot->m_pLeft == NULL && pRoot->m_pRight == NULL;\nif (currentSum == expectedSum && isLeaf)\n{\nprintf( \"A path is found: \" );\nstd::vector< int >::iterator iter = path.begin();\nfor (; iter != path.end(); ++ iter)\nprintf( \"%d\\t\" , *iter);\n\nprintf( \"\\n\" );\n}\n\n// If it is not a leaf, continue visition its children\nif (pRoot->m_pLeft != NULL)\nFindPath(pRoot->m_pLeft, expectedSum, path, currentSum);\nif (pRoot->m_pRight != NULL)\nFindPath(pRoot->m_pRight, expectedSum, path, currentSum);\n\n// Before returning back to its parent, remove it from path,\npath.pop_back();\n}\n\nIn the code above, we save path with a vector in STL actually. We use function push_back to insert a node and pop_back to remove a node to assure it is \u201cFirst in Last out\u201d in a path. The reason we don\u2019t utilize a stack in STL is that we can only get an element at the top of a stack, but we need to get all nodes when we print a path. Therefore, std::stack is not the best choice for us.", "question": "\nQuestion: All nodes along children pointers from root to leaf nodes form a path in a binary tree. Given a binary tree and a number, please print out all of paths where the sum of all nodes value is same as the given number. The node of binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n\nFor instance, if inputs are the binary tree in Figure 1 and a number 22, two paths with be printed: One is the path contains node 10 and 12, and the other contains 10, 5 and 7."},
{"answer": "\nAnalysis: Path in a binary tree is a new concept for many candidates, so it is not a simple question for them. We may try to find the hidden rules with concrete examples. Let us take the binary tree in Figure 1 as an example.\n\nSince paths always start from a root node, we traverse from a root node in a binary tree. We have three traversal orders, pre-order, in-order and post-order, and we firstly visit a root node with pre-order traversal.\n\nAccording to the pre-order traversal process on the binary tree in Figure 1, we visit the node 5 after visiting the root node 10. Since a binary tree node does not have a pointer to its parent node, we do not know what nodes have been visited when we reach the node 5 if we do not save the visited node on the path. Therefore, we could insert the current node into a path when we reach it during traversal. The path contains two nodes with value 10 and 5 when we are visiting the node 5. Then we insert the node 4 into the path too when we reach it. We have reached a leaf node, and the sum of three nodes in the path is 19. Since it is not same as the input number 22, current path is not a qualified one.\nWe should continue to traverse other nodes. Before visiting other nodes, we should return back to the node 5, and then reach the node 7. It can be noticed that node 4 is no longer in the path from node 10 to node 7, so we should remove it from the path. When we are visiting node 7, we insert it into the path, which contains three nodes now. Since the sum of value of these three nodes is 22, the path is qualified.\n\nLastly we are going to visit the node 12. We should return back to node 5 then back to node 10 before we visit node 12. When we return back from a child node to its parent node, we remove the child node from the path. When we reach the node 12 eventually, the path contains two nodes, one is node 10 and the other is node 12. Since the sum of value of these two nodes is 22, the path is qualified too.\n\nWe can summarize the whole process above with the Table 1:\n\nStep Operation Is it a leaf? Path Sum of nodes value 1 Visit node 10 No node 10 10 2 Visit node 5 No node 10, node 5 15 3 Visit node 4 Yes node 10, node 5, node 4 19 4 Return to node 5 node 10, node 5 15 5 Visit node 7 Yes node 10, node 5, node 7 22 6 Return to node 5 node 10, node 5 15 7 Return to node 10 node 10 10 8 Visit node 12 Yes node 10, node 12 22\nStep\nOperation\nIs it a leaf?\nPath\nSum of nodes value\n1\nVisit node 10\nNo\nnode 10\n10\n2\nVisit node 5\nNo\nnode 10, node 5\n15\n3\nVisit node 4\nYes\nnode 10, node 5, node 4\n19\n4\nReturn to node 5\n\nnode 10, node 5\n15\n5\nVisit node 7\nYes\nnode 10, node 5, node 7\n22\n6\nReturn to node 5\n\nnode 10, node 5\n15\n7\nReturn to node 10\n\nnode 10\n10\n8\nVisit node 12\nYes\nnode 10, node 12\n22\nTable 1: The process to traverse the binary tree in Figure 1\n\nIt is time to summarize some rules with the example above. When we visit a node with pre-order traversal order, we insert it into the path, and accumulate its value to sum .\u00a0 When the node is a leaf and sum is same as the input number, the path is qualified and we need to print it. We continue to visit its children if the current node is not a leaf. After we finish visiting the current node, a recursive function will return back to its parent node automatically, so we should remove the current node from the path before a function returns to make sure the nodes in the path is same as the path from root node to its parent node. The data structure to save paths should be a stack, because paths should be consistent to the recursion status and recursion is essentially pushing and popping in a call stack.\nHere is some sample code for this problem:\n\nvoid FindPath(BinaryTreeNode* pRoot, int expectedSum)\n{\nif (pRoot == NULL)\nreturn ;\n\nstd::vector< int > path;\nint currentSum = 0;\nFindPath(pRoot, expectedSum, path, currentSum);\n}\n\nvoid FindPath\n(\nBinaryTreeNode*\u00a0\u00a0 pRoot,\nint expectedSum,\nstd::vector< int >&\u00a0path,\nint currentSum\n)\n{\ncurrentSum += pRoot->m_nValue;\npath.push_back(pRoot->m_nValue);\n\n// Print the path is the current node is a leaf\n// and the sum of all nodes value is same as expectedSum\nbool isLeaf = pRoot->m_pLeft == NULL && pRoot->m_pRight == NULL;\nif (currentSum == expectedSum && isLeaf)\n{\nprintf( \"A path is found: \" );\nstd::vector< int >::iterator iter = path.begin();\nfor (; iter != path.end(); ++ iter)\nprintf( \"%d\\t\" , *iter);\n\nprintf( \"\\n\" );\n}\n\n// If it is not a leaf, continue visition its children\nif (pRoot->m_pLeft != NULL)\nFindPath(pRoot->m_pLeft, expectedSum, path, currentSum);\nif (pRoot->m_pRight != NULL)\nFindPath(pRoot->m_pRight, expectedSum, path, currentSum);\n\n// Before returning back to its parent, remove it from path,\npath.pop_back();\n}\n\nIn the code above, we save path with a vector in STL actually. We use function push_back to insert a node and pop_back to remove a node to assure it is \u201cFirst in Last out\u201d in a path. The reason we don\u2019t utilize a stack in STL is that we can only get an element at the top of a stack, but we need to get all nodes when we print a path. Therefore, std::stack is not the best choice for us.", "question": "\nQuestion: All nodes along children pointers from root to leaf nodes form a path in a binary tree. Given a binary tree and a number, please print out all of paths where the sum of all nodes value is same as the given number. The node of binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n\nFor instance, if inputs are the binary tree in Figure 1 and a number 22, two paths with be printed: One is the path contains node 10 and 12, and the other contains 10, 5 and 7."},
{"answer": "\nAnalysis : An array has two ends, so each of the two stacks may grow from an end in the array. Figure 1 below shows the initial status of the array and two stacks (assuming the capacity of the array is 10).\nFigure 2: The status after three items are pushed into the first stack and two items are pushed into the second stack\n\ufeffNo more items can be pushed into stacks when two top items are adjacent to each other, because all space in the array has been occupied.\nOur solution can be implemented with the following C++ class: template < typename T, int capacity> class TwoStacks { public : TwoStacks() { topFirst = -1; topSecond = capacity; } T top( int stackIndex) { validateIndex(stackIndex); if (empty(stackIndex)) throw new exception( \"The stack is empty.\" ); if (stackIndex == 0) return items[topFirst]; return items[topSecond]; } void push( int stackIndex, T item) { validateIndex(stackIndex); if (full()) throw new exception( \"All space has been occupied.\" ); if (stackIndex == 0) items[++topFirst] = item; else items[--topSecond] = item; } void pop( int stackIndex) { validateIndex(stackIndex); if (empty(stackIndex)) throw new exception( \"The stack is empty.\" ); if (stackIndex == 0) --topFirst; else ++topSecond; } bool empty( int stackIndex) { if (stackIndex == 0 && topFirst == -1) return true ; if (stackIndex == 1 && topSecond == capacity) return true ; return false ; } private : bool full() { return (topFirst >= topSecond - 1); } void validateIndex( int stackIndex) { if (stackIndex < 0 || stackIndex > 1) throw new exception( \"Invalid Stack Index.\" ); } private : T items[capacity]; int topFirst; int topSecond; };\ntemplate < typename T, int capacity> class TwoStacks\n{\npublic :\nTwoStacks()\n{\ntopFirst = -1;\ntopSecond = capacity;\n}\n\nT top( int stackIndex)\n{\nvalidateIndex(stackIndex);\nif (empty(stackIndex))\nthrow new exception( \"The stack is empty.\" );\n\nif (stackIndex == 0)\nreturn items[topFirst];\nreturn items[topSecond];\n}\n\nvoid push( int stackIndex, T item)\n{\nvalidateIndex(stackIndex);\nif (full())\nthrow new exception( \"All space has been occupied.\" );\n\nif (stackIndex == 0)\nitems[++topFirst] = item;\nelse\nitems[--topSecond] = item;\n}\n\nvoid pop( int stackIndex)\n{\nvalidateIndex(stackIndex);\nif (empty(stackIndex))\nthrow new exception( \"The stack is empty.\" );\n\nif (stackIndex == 0)\n--topFirst;\nelse\n++topSecond;\n}\n\nbool empty( int stackIndex)\n{\nif (stackIndex == 0 && topFirst == -1)\nreturn true ;\nif (stackIndex == 1 && topSecond == capacity)\nreturn true ;\nreturn false ;\n}\n\nprivate :\nbool full()\n{\nreturn (topFirst >= topSecond - 1);\n}\n\nvoid validateIndex( int stackIndex)\n{\nif (stackIndex < 0 || stackIndex > 1)\nthrow new exception( \"Invalid Stack Index.\" );\n}\n\nprivate :\nT items[capacity];\nint topFirst;\nint topSecond;\n};\n\nAnalysis : An array only has two ends, so we need new strategies to implement more than two stacks in a single array.\nWe may implement the array like a list, where each item in the array has a link to another item. When an item has not been occupied by any stacks and it is available, it is linked to the next available item. When an item is pushed into a stack, it is linked to the previous item in the stack. That\u2019s to say, there are n + 1 list in total in the system if there are n stacks sharing an array, a list for the available space left in the array, and a list for each stack.\nLet\u2019s take three stacks sharing an array with capacity 10 as an example. Figure 3 shows the initial status for the array and stacks. Each item in the array has two blocks, one for item data and the other for the index of another block.\n\n\nAs shown in Figure 3, each item is linked to the next item (the link block of the i th item is i +1). The head of list for available items in the array points to the item at position 0, which is the Ava pointer in the figure. Since three stacks are empty, their top (Top1, Top2 and Top3 in the figure) are initialized as -1.\n\nLet\u2019s try to push an item a into the first stack. Currently the first available item is at the position 0, so we set its data block as a . The link block of the item is 1, which means the next available item is at the position 1, so we update the Ava pointer to the position 1. Additionally, the link block of the item at the position 1 should be updated to -1, the previous top index of the first stack. Lastly, we update to top index of the first stack to 0. The status of the array and stacks are shown in Figure 4.\nLet\u2019s push two more items b and c into the first stack. The operations are similar as before, and the status is shown in Figure 5.\nIn the next step we are going to push another d into the second stack. Most operations are similar as before. The link block in the item at the position 3 is updated to -1, since the second stack is empty before and its top index is -1 previously. And then the top index of the second stack is updated to 3. The status after adding d into the second stack is shown in Figure 6.\n\nIf we continue to push three more item e , f , and g into the second stack, the status is shown in Figure 7.\n\nAt this time we are going to pop an item from the first stack. Since the top index of the first stack is 2, the item to be popped off is at the position 2. The link value in that item is 1, which means the previous top in the first stack is at the position 1 in the array, so we update the top index of the first stack as 1. Now the item at the position 2 becomes available, it should be linked to the list for available items. We move the Ava pointer to 2, and then update the link value of the item at the position 2 as 7, which is the previous head position of the list for available items. The status is shown in Figure 8.\nIf we pop an item off the second stack, the item at the position 6 will be linked to the list for available items too. Figure 9 depicts the status after the related operations.\nIf we push h into the third stack, it will be placed into the item at the position 6 because Ava points to that item. The next available item is at the position 2 (the link value in the item at the position 6). Therefore, the head of the list for available items points to location 2, as shown in Figure 10.\nLet\u2019s continue to push four more items into the third stack, i , j , k , and l . The status after these four items are pushed is shown in Figure 11. At this time, there are two items in the first stack ( a and b ), three items in the second stack ( d , e and f ), and five items in the third stack ( h , i , j , k , and l ). Please note that items inside a stack are not necessarily adjacent.\nAfter l is pushed into the item at the position 9, the Ava pointer is update to -1 (the previous link value in the item at the position 9), which means all items in the array have been occupied by stacks. We can\u2019t push more items until some items are popped off.\nThe source code in C++ to implement stacks sharing an array is listed below:\n template < typename T, int capacity, int count> class Stacks\n {\n\npublic :\n\nStacks()\n\n{\n\nint i;\n         for (i = 0; i < capacity - 1; ++i)\n            items[i].link = i + 1;\n        items[i].link = -1;\n        emptyHead = 0;\n\n         for (i = 0; i < count; ++i)\n            stackHead[i] = -1;\n     }\n\n     T top( int stackIndex)\n     {\n         validateIndex(stackIndex);\n         if (empty(stackIndex))\n             throw new exception( \"The stack is empty.\" );\n\n         return items[stackHead[stackIndex]].data;\n     }\n\n     void push( int stackIndex, const T& item)\n     {\n        validateIndex(stackIndex);\n         if (full())\n             throw new exception( \"All space has been occupied.\" );\n\n        Item<T>& block = items[emptyHead];\n         int nextEmpty = block.link;\n\n        block.data = item;\n        block.link = stackHead[stackIndex];\n        stackHead[stackIndex] = emptyHead;\n\n        emptyHead = nextEmpty;\n     }\n\n     void pop( int stackIndex)\n     {\n        validateIndex(stackIndex);\n         if (empty(stackIndex))\n             throw new exception( \"The stack is empty.\" );\n\n         Item<T>& block =items[stackHead[stackIndex]];\n         int nextItem = block.link;\n\n        block.link = emptyHead;         emptyHead = stackHead[stackIndex];         stackHead[stackIndex] = nextItem;\n        block.link = emptyHead;         emptyHead = stackHead[stackIndex];\n     }\n\n     bool empty( int stackIndex)\n     {\n         return (stackHead[stackIndex] < 0);\n     }\n\n private :\n     void validateIndex( int stackIndex)\n     {\n         if (stackIndex < 0 || stackIndex >= count)\n             throw new exception( \"Invalid index of stack.\" );\n     }\n\n     bool full()\n     {\n         return (emptyHead < 0);\n     }\n\n private :\n     template < typename T> struct Item\n     {\n         Tdata;\n         int link;\n     };\n\n private :\n    Item<T> items[capacity];\n     int emptyHead;\n     int stackHead[count];\n };\n\n", "question": "\nProblem 2 : How can you implement n ( n > 2) stacks in a single array, where no stack overflows until no space left in the entire array space? Analysis : An array only has two ends, so we need new strategies to implement more than two stacks in a single array. We may implement the array like a list, where each item in the array has a link to another item. When an item has not been occupied by any stacks and it is available, it is linked to the next available item. When an item is pushed into a stack, it is linked to the previous item in the stack. That\u2019s to say, there are n + 1 list in total in the system if there are n stacks sharing an array, a list for the available space left in the array, and a list for each stack. Let\u2019s take three stacks sharing an array with capacity 10 as an example. Figure 3 shows the initial status for the array and stacks. Each item in the array has two blocks, one for item data and the other for the index of another block.\nProblem 2 : How can you implement n ( n > 2) stacks in a single array, where no stack overflows until no space left in the entire array space?"},
{"answer": "\nAnalysis : An array has two ends, so each of the two stacks may grow from an end in the array. Figure 1 below shows the initial status of the array and two stacks (assuming the capacity of the array is 10).\nFigure 2: The status after three items are pushed into the first stack and two items are pushed into the second stack\n\ufeffNo more items can be pushed into stacks when two top items are adjacent to each other, because all space in the array has been occupied.\nOur solution can be implemented with the following C++ class: template < typename T, int capacity> class TwoStacks { public : TwoStacks() { topFirst = -1; topSecond = capacity; } T top( int stackIndex) { validateIndex(stackIndex); if (empty(stackIndex)) throw new exception( \"The stack is empty.\" ); if (stackIndex == 0) return items[topFirst]; return items[topSecond]; } void push( int stackIndex, T item) { validateIndex(stackIndex); if (full()) throw new exception( \"All space has been occupied.\" ); if (stackIndex == 0) items[++topFirst] = item; else items[--topSecond] = item; } void pop( int stackIndex) { validateIndex(stackIndex); if (empty(stackIndex)) throw new exception( \"The stack is empty.\" ); if (stackIndex == 0) --topFirst; else ++topSecond; } bool empty( int stackIndex) { if (stackIndex == 0 && topFirst == -1) return true ; if (stackIndex == 1 && topSecond == capacity) return true ; return false ; } private : bool full() { return (topFirst >= topSecond - 1); } void validateIndex( int stackIndex) { if (stackIndex < 0 || stackIndex > 1) throw new exception( \"Invalid Stack Index.\" ); } private : T items[capacity]; int topFirst; int topSecond; };\ntemplate < typename T, int capacity> class TwoStacks\n{\npublic :\nTwoStacks()\n{\ntopFirst = -1;\ntopSecond = capacity;\n}\n\nT top( int stackIndex)\n{\nvalidateIndex(stackIndex);\nif (empty(stackIndex))\nthrow new exception( \"The stack is empty.\" );\n\nif (stackIndex == 0)\nreturn items[topFirst];\nreturn items[topSecond];\n}\n\nvoid push( int stackIndex, T item)\n{\nvalidateIndex(stackIndex);\nif (full())\nthrow new exception( \"All space has been occupied.\" );\n\nif (stackIndex == 0)\nitems[++topFirst] = item;\nelse\nitems[--topSecond] = item;\n}\n\nvoid pop( int stackIndex)\n{\nvalidateIndex(stackIndex);\nif (empty(stackIndex))\nthrow new exception( \"The stack is empty.\" );\n\nif (stackIndex == 0)\n--topFirst;\nelse\n++topSecond;\n}\n\nbool empty( int stackIndex)\n{\nif (stackIndex == 0 && topFirst == -1)\nreturn true ;\nif (stackIndex == 1 && topSecond == capacity)\nreturn true ;\nreturn false ;\n}\n\nprivate :\nbool full()\n{\nreturn (topFirst >= topSecond - 1);\n}\n\nvoid validateIndex( int stackIndex)\n{\nif (stackIndex < 0 || stackIndex > 1)\nthrow new exception( \"Invalid Stack Index.\" );\n}\n\nprivate :\nT items[capacity];\nint topFirst;\nint topSecond;\n};\n\nAnalysis : An array only has two ends, so we need new strategies to implement more than two stacks in a single array.\nWe may implement the array like a list, where each item in the array has a link to another item. When an item has not been occupied by any stacks and it is available, it is linked to the next available item. When an item is pushed into a stack, it is linked to the previous item in the stack. That\u2019s to say, there are n + 1 list in total in the system if there are n stacks sharing an array, a list for the available space left in the array, and a list for each stack.\nLet\u2019s take three stacks sharing an array with capacity 10 as an example. Figure 3 shows the initial status for the array and stacks. Each item in the array has two blocks, one for item data and the other for the index of another block.\n\n\nAs shown in Figure 3, each item is linked to the next item (the link block of the i th item is i +1). The head of list for available items in the array points to the item at position 0, which is the Ava pointer in the figure. Since three stacks are empty, their top (Top1, Top2 and Top3 in the figure) are initialized as -1.\n\nLet\u2019s try to push an item a into the first stack. Currently the first available item is at the position 0, so we set its data block as a . The link block of the item is 1, which means the next available item is at the position 1, so we update the Ava pointer to the position 1. Additionally, the link block of the item at the position 1 should be updated to -1, the previous top index of the first stack. Lastly, we update to top index of the first stack to 0. The status of the array and stacks are shown in Figure 4.\nLet\u2019s push two more items b and c into the first stack. The operations are similar as before, and the status is shown in Figure 5.\nIn the next step we are going to push another d into the second stack. Most operations are similar as before. The link block in the item at the position 3 is updated to -1, since the second stack is empty before and its top index is -1 previously. And then the top index of the second stack is updated to 3. The status after adding d into the second stack is shown in Figure 6.\n\nIf we continue to push three more item e , f , and g into the second stack, the status is shown in Figure 7.\n\nAt this time we are going to pop an item from the first stack. Since the top index of the first stack is 2, the item to be popped off is at the position 2. The link value in that item is 1, which means the previous top in the first stack is at the position 1 in the array, so we update the top index of the first stack as 1. Now the item at the position 2 becomes available, it should be linked to the list for available items. We move the Ava pointer to 2, and then update the link value of the item at the position 2 as 7, which is the previous head position of the list for available items. The status is shown in Figure 8.\nIf we pop an item off the second stack, the item at the position 6 will be linked to the list for available items too. Figure 9 depicts the status after the related operations.\nIf we push h into the third stack, it will be placed into the item at the position 6 because Ava points to that item. The next available item is at the position 2 (the link value in the item at the position 6). Therefore, the head of the list for available items points to location 2, as shown in Figure 10.\nLet\u2019s continue to push four more items into the third stack, i , j , k , and l . The status after these four items are pushed is shown in Figure 11. At this time, there are two items in the first stack ( a and b ), three items in the second stack ( d , e and f ), and five items in the third stack ( h , i , j , k , and l ). Please note that items inside a stack are not necessarily adjacent.\nAfter l is pushed into the item at the position 9, the Ava pointer is update to -1 (the previous link value in the item at the position 9), which means all items in the array have been occupied by stacks. We can\u2019t push more items until some items are popped off.\nThe source code in C++ to implement stacks sharing an array is listed below:\n template < typename T, int capacity, int count> class Stacks\n {\n\npublic :\n\nStacks()\n\n{\n\nint i;\n         for (i = 0; i < capacity - 1; ++i)\n            items[i].link = i + 1;\n        items[i].link = -1;\n        emptyHead = 0;\n\n         for (i = 0; i < count; ++i)\n            stackHead[i] = -1;\n     }\n\n     T top( int stackIndex)\n     {\n         validateIndex(stackIndex);\n         if (empty(stackIndex))\n             throw new exception( \"The stack is empty.\" );\n\n         return items[stackHead[stackIndex]].data;\n     }\n\n     void push( int stackIndex, const T& item)\n     {\n        validateIndex(stackIndex);\n         if (full())\n             throw new exception( \"All space has been occupied.\" );\n\n        Item<T>& block = items[emptyHead];\n         int nextEmpty = block.link;\n\n        block.data = item;\n        block.link = stackHead[stackIndex];\n        stackHead[stackIndex] = emptyHead;\n\n        emptyHead = nextEmpty;\n     }\n\n     void pop( int stackIndex)\n     {\n        validateIndex(stackIndex);\n         if (empty(stackIndex))\n             throw new exception( \"The stack is empty.\" );\n\n         Item<T>& block =items[stackHead[stackIndex]];\n         int nextItem = block.link;\n\n        block.link = emptyHead;         emptyHead = stackHead[stackIndex];         stackHead[stackIndex] = nextItem;\n        block.link = emptyHead;         emptyHead = stackHead[stackIndex];\n     }\n\n     bool empty( int stackIndex)\n     {\n         return (stackHead[stackIndex] < 0);\n     }\n\n private :\n     void validateIndex( int stackIndex)\n     {\n         if (stackIndex < 0 || stackIndex >= count)\n             throw new exception( \"Invalid index of stack.\" );\n     }\n\n     bool full()\n     {\n         return (emptyHead < 0);\n     }\n\n private :\n     template < typename T> struct Item\n     {\n         Tdata;\n         int link;\n     };\n\n private :\n    Item<T> items[capacity];\n     int emptyHead;\n     int stackHead[count];\n };\n\n", "question": "\nProblem 2 : How can you implement n ( n > 2) stacks in a single array, where no stack overflows until no space left in the entire array space? Analysis : An array only has two ends, so we need new strategies to implement more than two stacks in a single array. We may implement the array like a list, where each item in the array has a link to another item. When an item has not been occupied by any stacks and it is available, it is linked to the next available item. When an item is pushed into a stack, it is linked to the previous item in the stack. That\u2019s to say, there are n + 1 list in total in the system if there are n stacks sharing an array, a list for the available space left in the array, and a list for each stack. Let\u2019s take three stacks sharing an array with capacity 10 as an example. Figure 3 shows the initial status for the array and stacks. Each item in the array has two blocks, one for item data and the other for the index of another block.\nProblem 2 : How can you implement n ( n > 2) stacks in a single array, where no stack overflows until no space left in the entire array space?"},
{"answer": "\nAnalysis: Path in a binary tree is a new concept for many candidates, so it is not a simple question for them. We may try to find the hidden rules with concrete examples. Let us take the binary tree in Figure 1 as an example.\n\nSince paths always start from a root node, we traverse from a root node in a binary tree. We have three traversal orders, pre-order, in-order and post-order, and we firstly visit a root node with pre-order traversal.\n\nAccording to the pre-order traversal process on the binary tree in Figure 1, we visit the node 5 after visiting the root node 10. Since a binary tree node does not have a pointer to its parent node, we do not know what nodes have been visited when we reach the node 5 if we do not save the visited node on the path. Therefore, we could insert the current node into a path when we reach it during traversal. The path contains two nodes with value 10 and 5 when we are visiting the node 5. Then we insert the node 4 into the path too when we reach it. We have reached a leaf node, and the sum of three nodes in the path is 19. Since it is not same as the input number 22, current path is not a qualified one.\nWe should continue to traverse other nodes. Before visiting other nodes, we should return back to the node 5, and then reach the node 7. It can be noticed that node 4 is no longer in the path from node 10 to node 7, so we should remove it from the path. When we are visiting node 7, we insert it into the path, which contains three nodes now. Since the sum of value of these three nodes is 22, the path is qualified.\n\nLastly we are going to visit the node 12. We should return back to node 5 then back to node 10 before we visit node 12. When we return back from a child node to its parent node, we remove the child node from the path. When we reach the node 12 eventually, the path contains two nodes, one is node 10 and the other is node 12. Since the sum of value of these two nodes is 22, the path is qualified too.\n\nWe can summarize the whole process above with the Table 1:\n\nStep Operation Is it a leaf? Path Sum of nodes value 1 Visit node 10 No node 10 10 2 Visit node 5 No node 10, node 5 15 3 Visit node 4 Yes node 10, node 5, node 4 19 4 Return to node 5 node 10, node 5 15 5 Visit node 7 Yes node 10, node 5, node 7 22 6 Return to node 5 node 10, node 5 15 7 Return to node 10 node 10 10 8 Visit node 12 Yes node 10, node 12 22\nStep\nOperation\nIs it a leaf?\nPath\nSum of nodes value\n1\nVisit node 10\nNo\nnode 10\n10\n2\nVisit node 5\nNo\nnode 10, node 5\n15\n3\nVisit node 4\nYes\nnode 10, node 5, node 4\n19\n4\nReturn to node 5\n\nnode 10, node 5\n15\n5\nVisit node 7\nYes\nnode 10, node 5, node 7\n22\n6\nReturn to node 5\n\nnode 10, node 5\n15\n7\nReturn to node 10\n\nnode 10\n10\n8\nVisit node 12\nYes\nnode 10, node 12\n22\nTable 1: The process to traverse the binary tree in Figure 1\n\nIt is time to summarize some rules with the example above. When we visit a node with pre-order traversal order, we insert it into the path, and accumulate its value to sum .\u00a0 When the node is a leaf and sum is same as the input number, the path is qualified and we need to print it. We continue to visit its children if the current node is not a leaf. After we finish visiting the current node, a recursive function will return back to its parent node automatically, so we should remove the current node from the path before a function returns to make sure the nodes in the path is same as the path from root node to its parent node. The data structure to save paths should be a stack, because paths should be consistent to the recursion status and recursion is essentially pushing and popping in a call stack.\nHere is some sample code for this problem:\n\nvoid FindPath(BinaryTreeNode* pRoot, int expectedSum)\n{\nif (pRoot == NULL)\nreturn ;\n\nstd::vector< int > path;\nint currentSum = 0;\nFindPath(pRoot, expectedSum, path, currentSum);\n}\n\nvoid FindPath\n(\nBinaryTreeNode*\u00a0\u00a0 pRoot,\nint expectedSum,\nstd::vector< int >&\u00a0path,\nint currentSum\n)\n{\ncurrentSum += pRoot->m_nValue;\npath.push_back(pRoot->m_nValue);\n\n// Print the path is the current node is a leaf\n// and the sum of all nodes value is same as expectedSum\nbool isLeaf = pRoot->m_pLeft == NULL && pRoot->m_pRight == NULL;\nif (currentSum == expectedSum && isLeaf)\n{\nprintf( \"A path is found: \" );\nstd::vector< int >::iterator iter = path.begin();\nfor (; iter != path.end(); ++ iter)\nprintf( \"%d\\t\" , *iter);\n\nprintf( \"\\n\" );\n}\n\n// If it is not a leaf, continue visition its children\nif (pRoot->m_pLeft != NULL)\nFindPath(pRoot->m_pLeft, expectedSum, path, currentSum);\nif (pRoot->m_pRight != NULL)\nFindPath(pRoot->m_pRight, expectedSum, path, currentSum);\n\n// Before returning back to its parent, remove it from path,\npath.pop_back();\n}\n\nIn the code above, we save path with a vector in STL actually. We use function push_back to insert a node and pop_back to remove a node to assure it is \u201cFirst in Last out\u201d in a path. The reason we don\u2019t utilize a stack in STL is that we can only get an element at the top of a stack, but we need to get all nodes when we print a path. Therefore, std::stack is not the best choice for us.", "question": "\nQuestion: All nodes along children pointers from root to leaf nodes form a path in a binary tree. Given a binary tree and a number, please print out all of paths where the sum of all nodes value is same as the given number. The node of binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n\nFor instance, if inputs are the binary tree in Figure 1 and a number 22, two paths with be printed: One is the path contains node 10 and 12, and the other contains 10, 5 and 7."},
{"answer": "\nAnalysis: Path in a binary tree is a new concept for many candidates, so it is not a simple question for them. We may try to find the hidden rules with concrete examples. Let us take the binary tree in Figure 1 as an example.\n\nSince paths always start from a root node, we traverse from a root node in a binary tree. We have three traversal orders, pre-order, in-order and post-order, and we firstly visit a root node with pre-order traversal.\n\nAccording to the pre-order traversal process on the binary tree in Figure 1, we visit the node 5 after visiting the root node 10. Since a binary tree node does not have a pointer to its parent node, we do not know what nodes have been visited when we reach the node 5 if we do not save the visited node on the path. Therefore, we could insert the current node into a path when we reach it during traversal. The path contains two nodes with value 10 and 5 when we are visiting the node 5. Then we insert the node 4 into the path too when we reach it. We have reached a leaf node, and the sum of three nodes in the path is 19. Since it is not same as the input number 22, current path is not a qualified one.\nWe should continue to traverse other nodes. Before visiting other nodes, we should return back to the node 5, and then reach the node 7. It can be noticed that node 4 is no longer in the path from node 10 to node 7, so we should remove it from the path. When we are visiting node 7, we insert it into the path, which contains three nodes now. Since the sum of value of these three nodes is 22, the path is qualified.\n\nLastly we are going to visit the node 12. We should return back to node 5 then back to node 10 before we visit node 12. When we return back from a child node to its parent node, we remove the child node from the path. When we reach the node 12 eventually, the path contains two nodes, one is node 10 and the other is node 12. Since the sum of value of these two nodes is 22, the path is qualified too.\n\nWe can summarize the whole process above with the Table 1:\n\nStep Operation Is it a leaf? Path Sum of nodes value 1 Visit node 10 No node 10 10 2 Visit node 5 No node 10, node 5 15 3 Visit node 4 Yes node 10, node 5, node 4 19 4 Return to node 5 node 10, node 5 15 5 Visit node 7 Yes node 10, node 5, node 7 22 6 Return to node 5 node 10, node 5 15 7 Return to node 10 node 10 10 8 Visit node 12 Yes node 10, node 12 22\nStep\nOperation\nIs it a leaf?\nPath\nSum of nodes value\n1\nVisit node 10\nNo\nnode 10\n10\n2\nVisit node 5\nNo\nnode 10, node 5\n15\n3\nVisit node 4\nYes\nnode 10, node 5, node 4\n19\n4\nReturn to node 5\n\nnode 10, node 5\n15\n5\nVisit node 7\nYes\nnode 10, node 5, node 7\n22\n6\nReturn to node 5\n\nnode 10, node 5\n15\n7\nReturn to node 10\n\nnode 10\n10\n8\nVisit node 12\nYes\nnode 10, node 12\n22\nTable 1: The process to traverse the binary tree in Figure 1\n\nIt is time to summarize some rules with the example above. When we visit a node with pre-order traversal order, we insert it into the path, and accumulate its value to sum .\u00a0 When the node is a leaf and sum is same as the input number, the path is qualified and we need to print it. We continue to visit its children if the current node is not a leaf. After we finish visiting the current node, a recursive function will return back to its parent node automatically, so we should remove the current node from the path before a function returns to make sure the nodes in the path is same as the path from root node to its parent node. The data structure to save paths should be a stack, because paths should be consistent to the recursion status and recursion is essentially pushing and popping in a call stack.\nHere is some sample code for this problem:\n\nvoid FindPath(BinaryTreeNode* pRoot, int expectedSum)\n{\nif (pRoot == NULL)\nreturn ;\n\nstd::vector< int > path;\nint currentSum = 0;\nFindPath(pRoot, expectedSum, path, currentSum);\n}\n\nvoid FindPath\n(\nBinaryTreeNode*\u00a0\u00a0 pRoot,\nint expectedSum,\nstd::vector< int >&\u00a0path,\nint currentSum\n)\n{\ncurrentSum += pRoot->m_nValue;\npath.push_back(pRoot->m_nValue);\n\n// Print the path is the current node is a leaf\n// and the sum of all nodes value is same as expectedSum\nbool isLeaf = pRoot->m_pLeft == NULL && pRoot->m_pRight == NULL;\nif (currentSum == expectedSum && isLeaf)\n{\nprintf( \"A path is found: \" );\nstd::vector< int >::iterator iter = path.begin();\nfor (; iter != path.end(); ++ iter)\nprintf( \"%d\\t\" , *iter);\n\nprintf( \"\\n\" );\n}\n\n// If it is not a leaf, continue visition its children\nif (pRoot->m_pLeft != NULL)\nFindPath(pRoot->m_pLeft, expectedSum, path, currentSum);\nif (pRoot->m_pRight != NULL)\nFindPath(pRoot->m_pRight, expectedSum, path, currentSum);\n\n// Before returning back to its parent, remove it from path,\npath.pop_back();\n}\n\nIn the code above, we save path with a vector in STL actually. We use function push_back to insert a node and pop_back to remove a node to assure it is \u201cFirst in Last out\u201d in a path. The reason we don\u2019t utilize a stack in STL is that we can only get an element at the top of a stack, but we need to get all nodes when we print a path. Therefore, std::stack is not the best choice for us.", "question": "\nQuestion: All nodes along children pointers from root to leaf nodes form a path in a binary tree. Given a binary tree and a number, please print out all of paths where the sum of all nodes value is same as the given number. The node of binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n\nFor instance, if inputs are the binary tree in Figure 1 and a number 22, two paths with be printed: One is the path contains node 10 and 12, and the other contains 10, 5 and 7."},
{"answer": "\nAnalysis: Lots of pointer operations are necessary to solve problems related to linked lists. Interviewers know that many candidates are prone to make mistakes on pointer operations, so they like problems of linked list to qualify candidates\u2019 programming abilities. During interviews, we had better analyze and design carefully rather than begin to code hastily. It is much better to write robust code with comprehensive analysis than write code quickly with many errors.\n\nDirection of pointers should be adjusted in order to reverse a linked list. We may utilize figures to analyze visually the complex steps to adjust pointers. As shown in the list in Figure 1-a, node h, i and j are three adjacent nodes. Let us assume pointers of all nodes prior to h have been reversed after some operations and all m_pNext point to their previous nodes. We are going to reverse the m_pNext pointer in node i. The status of list is shown in Figure 1-b.\n\n\nIt is noticeable that m_pNext in node i points to its previous node h, the list is broken and we cannot visit the node j anymore. We should save the node j before the m_pNext pointer of node i is adjusted to prevent the list becoming broken.\n\nWhen we adjust the pointer in node i, we need to access to node h since m_pNext of node i is adjusted to point to node h. Meanwhile, we also need to access to node j because it is necessary to save it otherwise the list will be broken. Therefore, three pointers should be declared in our code, which point to the current visited node, its previous node and its next node.\n\nLastly we should get the head node of the reversed list. Obviously head in the reversed list should be tail of the original list. Which pointer is tail? It should be a node whose m_pNext is NULL .\nWith comprehensive analysis above, we are ready to write code, which is shown below:\n\nListNode* ReverseList(ListNode* pHead)\n{\nListNode* pReversedHead = NULL;\nListNode* pNode = pHead;\nListNode* pPrev = NULL;\nwhile (pNode != NULL)\n{\nListNode* pNext = pNode->m_pNext;\n\nif (pNext == NULL)\npReversedHead = pNode;\n\npNode->m_pNext = pPrev;\n\npPrev = pNode;\npNode = pNext;\n}\n\nreturn pReversedHead;", "question": "\nProblem: Implement a function to reverse a linked list, and return the head of the reversed list. A list node is defined as below:\nstruct ListNode\n{\nint m_nKey;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: Lots of pointer operations are necessary to solve problems related to linked lists. Interviewers know that many candidates are prone to make mistakes on pointer operations, so they like problems of linked list to qualify candidates\u2019 programming abilities. During interviews, we had better analyze and design carefully rather than begin to code hastily. It is much better to write robust code with comprehensive analysis than write code quickly with many errors.\n\nDirection of pointers should be adjusted in order to reverse a linked list. We may utilize figures to analyze visually the complex steps to adjust pointers. As shown in the list in Figure 1-a, node h, i and j are three adjacent nodes. Let us assume pointers of all nodes prior to h have been reversed after some operations and all m_pNext point to their previous nodes. We are going to reverse the m_pNext pointer in node i. The status of list is shown in Figure 1-b.\n\n\nIt is noticeable that m_pNext in node i points to its previous node h, the list is broken and we cannot visit the node j anymore. We should save the node j before the m_pNext pointer of node i is adjusted to prevent the list becoming broken.\n\nWhen we adjust the pointer in node i, we need to access to node h since m_pNext of node i is adjusted to point to node h. Meanwhile, we also need to access to node j because it is necessary to save it otherwise the list will be broken. Therefore, three pointers should be declared in our code, which point to the current visited node, its previous node and its next node.\n\nLastly we should get the head node of the reversed list. Obviously head in the reversed list should be tail of the original list. Which pointer is tail? It should be a node whose m_pNext is NULL .\nWith comprehensive analysis above, we are ready to write code, which is shown below:\n\nListNode* ReverseList(ListNode* pHead)\n{\nListNode* pReversedHead = NULL;\nListNode* pNode = pHead;\nListNode* pPrev = NULL;\nwhile (pNode != NULL)\n{\nListNode* pNext = pNode->m_pNext;\n\nif (pNext == NULL)\npReversedHead = pNode;\n\npNode->m_pNext = pPrev;\n\npPrev = pNode;\npNode = pNext;\n}\n\nreturn pReversedHead;", "question": "\nProblem: Implement a function to reverse a linked list, and return the head of the reversed list. A list node is defined as below:\nstruct ListNode\n{\nint m_nKey;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: Lots of pointer operations are necessary to solve problems related to linked lists. Interviewers know that many candidates are prone to make mistakes on pointer operations, so they like problems of linked list to qualify candidates\u2019 programming abilities. During interviews, we had better analyze and design carefully rather than begin to code hastily. It is much better to write robust code with comprehensive analysis than write code quickly with many errors.\n\nDirection of pointers should be adjusted in order to reverse a linked list. We may utilize figures to analyze visually the complex steps to adjust pointers. As shown in the list in Figure 1-a, node h, i and j are three adjacent nodes. Let us assume pointers of all nodes prior to h have been reversed after some operations and all m_pNext point to their previous nodes. We are going to reverse the m_pNext pointer in node i. The status of list is shown in Figure 1-b.\n\n\nIt is noticeable that m_pNext in node i points to its previous node h, the list is broken and we cannot visit the node j anymore. We should save the node j before the m_pNext pointer of node i is adjusted to prevent the list becoming broken.\n\nWhen we adjust the pointer in node i, we need to access to node h since m_pNext of node i is adjusted to point to node h. Meanwhile, we also need to access to node j because it is necessary to save it otherwise the list will be broken. Therefore, three pointers should be declared in our code, which point to the current visited node, its previous node and its next node.\n\nLastly we should get the head node of the reversed list. Obviously head in the reversed list should be tail of the original list. Which pointer is tail? It should be a node whose m_pNext is NULL .\nWith comprehensive analysis above, we are ready to write code, which is shown below:\n\nListNode* ReverseList(ListNode* pHead)\n{\nListNode* pReversedHead = NULL;\nListNode* pNode = pHead;\nListNode* pPrev = NULL;\nwhile (pNode != NULL)\n{\nListNode* pNext = pNode->m_pNext;\n\nif (pNext == NULL)\npReversedHead = pNode;\n\npNode->m_pNext = pPrev;\n\npPrev = pNode;\npNode = pNext;\n}\n\nreturn pReversedHead;", "question": "\nProblem: Implement a function to reverse a linked list, and return the head of the reversed list. A list node is defined as below:\nstruct ListNode\n{\nint m_nKey;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: Lots of pointer operations are necessary to solve problems related to linked lists. Interviewers know that many candidates are prone to make mistakes on pointer operations, so they like problems of linked list to qualify candidates\u2019 programming abilities. During interviews, we had better analyze and design carefully rather than begin to code hastily. It is much better to write robust code with comprehensive analysis than write code quickly with many errors.\n\nDirection of pointers should be adjusted in order to reverse a linked list. We may utilize figures to analyze visually the complex steps to adjust pointers. As shown in the list in Figure 1-a, node h, i and j are three adjacent nodes. Let us assume pointers of all nodes prior to h have been reversed after some operations and all m_pNext point to their previous nodes. We are going to reverse the m_pNext pointer in node i. The status of list is shown in Figure 1-b.\n\n\nIt is noticeable that m_pNext in node i points to its previous node h, the list is broken and we cannot visit the node j anymore. We should save the node j before the m_pNext pointer of node i is adjusted to prevent the list becoming broken.\n\nWhen we adjust the pointer in node i, we need to access to node h since m_pNext of node i is adjusted to point to node h. Meanwhile, we also need to access to node j because it is necessary to save it otherwise the list will be broken. Therefore, three pointers should be declared in our code, which point to the current visited node, its previous node and its next node.\n\nLastly we should get the head node of the reversed list. Obviously head in the reversed list should be tail of the original list. Which pointer is tail? It should be a node whose m_pNext is NULL .\nWith comprehensive analysis above, we are ready to write code, which is shown below:\n\nListNode* ReverseList(ListNode* pHead)\n{\nListNode* pReversedHead = NULL;\nListNode* pNode = pHead;\nListNode* pPrev = NULL;\nwhile (pNode != NULL)\n{\nListNode* pNext = pNode->m_pNext;\n\nif (pNext == NULL)\npReversedHead = pNode;\n\npNode->m_pNext = pPrev;\n\npPrev = pNode;\npNode = pNext;\n}\n\nreturn pReversedHead;", "question": "\nProblem: Implement a function to reverse a linked list, and return the head of the reversed list. A list node is defined as below:\nstruct ListNode\n{\nint m_nKey;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: Lots of pointer operations are necessary to solve problems related to linked lists. Interviewers know that many candidates are prone to make mistakes on pointer operations, so they like problems of linked list to qualify candidates\u2019 programming abilities. During interviews, we had better analyze and design carefully rather than begin to code hastily. It is much better to write robust code with comprehensive analysis than write code quickly with many errors.\n\nDirection of pointers should be adjusted in order to reverse a linked list. We may utilize figures to analyze visually the complex steps to adjust pointers. As shown in the list in Figure 1-a, node h, i and j are three adjacent nodes. Let us assume pointers of all nodes prior to h have been reversed after some operations and all m_pNext point to their previous nodes. We are going to reverse the m_pNext pointer in node i. The status of list is shown in Figure 1-b.\n\n\nIt is noticeable that m_pNext in node i points to its previous node h, the list is broken and we cannot visit the node j anymore. We should save the node j before the m_pNext pointer of node i is adjusted to prevent the list becoming broken.\n\nWhen we adjust the pointer in node i, we need to access to node h since m_pNext of node i is adjusted to point to node h. Meanwhile, we also need to access to node j because it is necessary to save it otherwise the list will be broken. Therefore, three pointers should be declared in our code, which point to the current visited node, its previous node and its next node.\n\nLastly we should get the head node of the reversed list. Obviously head in the reversed list should be tail of the original list. Which pointer is tail? It should be a node whose m_pNext is NULL .\nWith comprehensive analysis above, we are ready to write code, which is shown below:\n\nListNode* ReverseList(ListNode* pHead)\n{\nListNode* pReversedHead = NULL;\nListNode* pNode = pHead;\nListNode* pPrev = NULL;\nwhile (pNode != NULL)\n{\nListNode* pNext = pNode->m_pNext;\n\nif (pNext == NULL)\npReversedHead = pNode;\n\npNode->m_pNext = pPrev;\n\npPrev = pNode;\npNode = pNext;\n}\n\nreturn pReversedHead;", "question": "\nProblem: Implement a function to reverse a linked list, and return the head of the reversed list. A list node is defined as below:\nstruct ListNode\n{\nint m_nKey;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: Path in a binary tree is a new concept for many candidates, so it is not a simple question for them. We may try to find the hidden rules with concrete examples. Let us take the binary tree in Figure 1 as an example.\n\nSince paths always start from a root node, we traverse from a root node in a binary tree. We have three traversal orders, pre-order, in-order and post-order, and we firstly visit a root node with pre-order traversal.\n\nAccording to the pre-order traversal process on the binary tree in Figure 1, we visit the node 5 after visiting the root node 10. Since a binary tree node does not have a pointer to its parent node, we do not know what nodes have been visited when we reach the node 5 if we do not save the visited node on the path. Therefore, we could insert the current node into a path when we reach it during traversal. The path contains two nodes with value 10 and 5 when we are visiting the node 5. Then we insert the node 4 into the path too when we reach it. We have reached a leaf node, and the sum of three nodes in the path is 19. Since it is not same as the input number 22, current path is not a qualified one.\nWe should continue to traverse other nodes. Before visiting other nodes, we should return back to the node 5, and then reach the node 7. It can be noticed that node 4 is no longer in the path from node 10 to node 7, so we should remove it from the path. When we are visiting node 7, we insert it into the path, which contains three nodes now. Since the sum of value of these three nodes is 22, the path is qualified.\n\nLastly we are going to visit the node 12. We should return back to node 5 then back to node 10 before we visit node 12. When we return back from a child node to its parent node, we remove the child node from the path. When we reach the node 12 eventually, the path contains two nodes, one is node 10 and the other is node 12. Since the sum of value of these two nodes is 22, the path is qualified too.\n\nWe can summarize the whole process above with the Table 1:\n\nStep Operation Is it a leaf? Path Sum of nodes value 1 Visit node 10 No node 10 10 2 Visit node 5 No node 10, node 5 15 3 Visit node 4 Yes node 10, node 5, node 4 19 4 Return to node 5 node 10, node 5 15 5 Visit node 7 Yes node 10, node 5, node 7 22 6 Return to node 5 node 10, node 5 15 7 Return to node 10 node 10 10 8 Visit node 12 Yes node 10, node 12 22\nStep\nOperation\nIs it a leaf?\nPath\nSum of nodes value\n1\nVisit node 10\nNo\nnode 10\n10\n2\nVisit node 5\nNo\nnode 10, node 5\n15\n3\nVisit node 4\nYes\nnode 10, node 5, node 4\n19\n4\nReturn to node 5\n\nnode 10, node 5\n15\n5\nVisit node 7\nYes\nnode 10, node 5, node 7\n22\n6\nReturn to node 5\n\nnode 10, node 5\n15\n7\nReturn to node 10\n\nnode 10\n10\n8\nVisit node 12\nYes\nnode 10, node 12\n22\nTable 1: The process to traverse the binary tree in Figure 1\n\nIt is time to summarize some rules with the example above. When we visit a node with pre-order traversal order, we insert it into the path, and accumulate its value to sum .\u00a0 When the node is a leaf and sum is same as the input number, the path is qualified and we need to print it. We continue to visit its children if the current node is not a leaf. After we finish visiting the current node, a recursive function will return back to its parent node automatically, so we should remove the current node from the path before a function returns to make sure the nodes in the path is same as the path from root node to its parent node. The data structure to save paths should be a stack, because paths should be consistent to the recursion status and recursion is essentially pushing and popping in a call stack.\nHere is some sample code for this problem:\n\nvoid FindPath(BinaryTreeNode* pRoot, int expectedSum)\n{\nif (pRoot == NULL)\nreturn ;\n\nstd::vector< int > path;\nint currentSum = 0;\nFindPath(pRoot, expectedSum, path, currentSum);\n}\n\nvoid FindPath\n(\nBinaryTreeNode*\u00a0\u00a0 pRoot,\nint expectedSum,\nstd::vector< int >&\u00a0path,\nint currentSum\n)\n{\ncurrentSum += pRoot->m_nValue;\npath.push_back(pRoot->m_nValue);\n\n// Print the path is the current node is a leaf\n// and the sum of all nodes value is same as expectedSum\nbool isLeaf = pRoot->m_pLeft == NULL && pRoot->m_pRight == NULL;\nif (currentSum == expectedSum && isLeaf)\n{\nprintf( \"A path is found: \" );\nstd::vector< int >::iterator iter = path.begin();\nfor (; iter != path.end(); ++ iter)\nprintf( \"%d\\t\" , *iter);\n\nprintf( \"\\n\" );\n}\n\n// If it is not a leaf, continue visition its children\nif (pRoot->m_pLeft != NULL)\nFindPath(pRoot->m_pLeft, expectedSum, path, currentSum);\nif (pRoot->m_pRight != NULL)\nFindPath(pRoot->m_pRight, expectedSum, path, currentSum);\n\n// Before returning back to its parent, remove it from path,\npath.pop_back();\n}\n\nIn the code above, we save path with a vector in STL actually. We use function push_back to insert a node and pop_back to remove a node to assure it is \u201cFirst in Last out\u201d in a path. The reason we don\u2019t utilize a stack in STL is that we can only get an element at the top of a stack, but we need to get all nodes when we print a path. Therefore, std::stack is not the best choice for us.", "question": "\nQuestion: All nodes along children pointers from root to leaf nodes form a path in a binary tree. Given a binary tree and a number, please print out all of paths where the sum of all nodes value is same as the given number. The node of binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n\nFor instance, if inputs are the binary tree in Figure 1 and a number 22, two paths with be printed: One is the path contains node 10 and 12, and the other contains 10, 5 and 7."},
{"answer": "\nAnalysis: Path in a binary tree is a new concept for many candidates, so it is not a simple question for them. We may try to find the hidden rules with concrete examples. Let us take the binary tree in Figure 1 as an example.\n\nSince paths always start from a root node, we traverse from a root node in a binary tree. We have three traversal orders, pre-order, in-order and post-order, and we firstly visit a root node with pre-order traversal.\n\nAccording to the pre-order traversal process on the binary tree in Figure 1, we visit the node 5 after visiting the root node 10. Since a binary tree node does not have a pointer to its parent node, we do not know what nodes have been visited when we reach the node 5 if we do not save the visited node on the path. Therefore, we could insert the current node into a path when we reach it during traversal. The path contains two nodes with value 10 and 5 when we are visiting the node 5. Then we insert the node 4 into the path too when we reach it. We have reached a leaf node, and the sum of three nodes in the path is 19. Since it is not same as the input number 22, current path is not a qualified one.\nWe should continue to traverse other nodes. Before visiting other nodes, we should return back to the node 5, and then reach the node 7. It can be noticed that node 4 is no longer in the path from node 10 to node 7, so we should remove it from the path. When we are visiting node 7, we insert it into the path, which contains three nodes now. Since the sum of value of these three nodes is 22, the path is qualified.\n\nLastly we are going to visit the node 12. We should return back to node 5 then back to node 10 before we visit node 12. When we return back from a child node to its parent node, we remove the child node from the path. When we reach the node 12 eventually, the path contains two nodes, one is node 10 and the other is node 12. Since the sum of value of these two nodes is 22, the path is qualified too.\n\nWe can summarize the whole process above with the Table 1:\n\nStep Operation Is it a leaf? Path Sum of nodes value 1 Visit node 10 No node 10 10 2 Visit node 5 No node 10, node 5 15 3 Visit node 4 Yes node 10, node 5, node 4 19 4 Return to node 5 node 10, node 5 15 5 Visit node 7 Yes node 10, node 5, node 7 22 6 Return to node 5 node 10, node 5 15 7 Return to node 10 node 10 10 8 Visit node 12 Yes node 10, node 12 22\nStep\nOperation\nIs it a leaf?\nPath\nSum of nodes value\n1\nVisit node 10\nNo\nnode 10\n10\n2\nVisit node 5\nNo\nnode 10, node 5\n15\n3\nVisit node 4\nYes\nnode 10, node 5, node 4\n19\n4\nReturn to node 5\n\nnode 10, node 5\n15\n5\nVisit node 7\nYes\nnode 10, node 5, node 7\n22\n6\nReturn to node 5\n\nnode 10, node 5\n15\n7\nReturn to node 10\n\nnode 10\n10\n8\nVisit node 12\nYes\nnode 10, node 12\n22\nTable 1: The process to traverse the binary tree in Figure 1\n\nIt is time to summarize some rules with the example above. When we visit a node with pre-order traversal order, we insert it into the path, and accumulate its value to sum .\u00a0 When the node is a leaf and sum is same as the input number, the path is qualified and we need to print it. We continue to visit its children if the current node is not a leaf. After we finish visiting the current node, a recursive function will return back to its parent node automatically, so we should remove the current node from the path before a function returns to make sure the nodes in the path is same as the path from root node to its parent node. The data structure to save paths should be a stack, because paths should be consistent to the recursion status and recursion is essentially pushing and popping in a call stack.\nHere is some sample code for this problem:\n\nvoid FindPath(BinaryTreeNode* pRoot, int expectedSum)\n{\nif (pRoot == NULL)\nreturn ;\n\nstd::vector< int > path;\nint currentSum = 0;\nFindPath(pRoot, expectedSum, path, currentSum);\n}\n\nvoid FindPath\n(\nBinaryTreeNode*\u00a0\u00a0 pRoot,\nint expectedSum,\nstd::vector< int >&\u00a0path,\nint currentSum\n)\n{\ncurrentSum += pRoot->m_nValue;\npath.push_back(pRoot->m_nValue);\n\n// Print the path is the current node is a leaf\n// and the sum of all nodes value is same as expectedSum\nbool isLeaf = pRoot->m_pLeft == NULL && pRoot->m_pRight == NULL;\nif (currentSum == expectedSum && isLeaf)\n{\nprintf( \"A path is found: \" );\nstd::vector< int >::iterator iter = path.begin();\nfor (; iter != path.end(); ++ iter)\nprintf( \"%d\\t\" , *iter);\n\nprintf( \"\\n\" );\n}\n\n// If it is not a leaf, continue visition its children\nif (pRoot->m_pLeft != NULL)\nFindPath(pRoot->m_pLeft, expectedSum, path, currentSum);\nif (pRoot->m_pRight != NULL)\nFindPath(pRoot->m_pRight, expectedSum, path, currentSum);\n\n// Before returning back to its parent, remove it from path,\npath.pop_back();\n}\n\nIn the code above, we save path with a vector in STL actually. We use function push_back to insert a node and pop_back to remove a node to assure it is \u201cFirst in Last out\u201d in a path. The reason we don\u2019t utilize a stack in STL is that we can only get an element at the top of a stack, but we need to get all nodes when we print a path. Therefore, std::stack is not the best choice for us.", "question": "\nQuestion: All nodes along children pointers from root to leaf nodes form a path in a binary tree. Given a binary tree and a number, please print out all of paths where the sum of all nodes value is same as the given number. The node of binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n\nFor instance, if inputs are the binary tree in Figure 1 and a number 22, two paths with be printed: One is the path contains node 10 and 12, and the other contains 10, 5 and 7."},
{"answer": "\nAnalysis: Path in a binary tree is a new concept for many candidates, so it is not a simple question for them. We may try to find the hidden rules with concrete examples. Let us take the binary tree in Figure 1 as an example.\n\nSince paths always start from a root node, we traverse from a root node in a binary tree. We have three traversal orders, pre-order, in-order and post-order, and we firstly visit a root node with pre-order traversal.\n\nAccording to the pre-order traversal process on the binary tree in Figure 1, we visit the node 5 after visiting the root node 10. Since a binary tree node does not have a pointer to its parent node, we do not know what nodes have been visited when we reach the node 5 if we do not save the visited node on the path. Therefore, we could insert the current node into a path when we reach it during traversal. The path contains two nodes with value 10 and 5 when we are visiting the node 5. Then we insert the node 4 into the path too when we reach it. We have reached a leaf node, and the sum of three nodes in the path is 19. Since it is not same as the input number 22, current path is not a qualified one.\nWe should continue to traverse other nodes. Before visiting other nodes, we should return back to the node 5, and then reach the node 7. It can be noticed that node 4 is no longer in the path from node 10 to node 7, so we should remove it from the path. When we are visiting node 7, we insert it into the path, which contains three nodes now. Since the sum of value of these three nodes is 22, the path is qualified.\n\nLastly we are going to visit the node 12. We should return back to node 5 then back to node 10 before we visit node 12. When we return back from a child node to its parent node, we remove the child node from the path. When we reach the node 12 eventually, the path contains two nodes, one is node 10 and the other is node 12. Since the sum of value of these two nodes is 22, the path is qualified too.\n\nWe can summarize the whole process above with the Table 1:\n\nStep Operation Is it a leaf? Path Sum of nodes value 1 Visit node 10 No node 10 10 2 Visit node 5 No node 10, node 5 15 3 Visit node 4 Yes node 10, node 5, node 4 19 4 Return to node 5 node 10, node 5 15 5 Visit node 7 Yes node 10, node 5, node 7 22 6 Return to node 5 node 10, node 5 15 7 Return to node 10 node 10 10 8 Visit node 12 Yes node 10, node 12 22\nStep\nOperation\nIs it a leaf?\nPath\nSum of nodes value\n1\nVisit node 10\nNo\nnode 10\n10\n2\nVisit node 5\nNo\nnode 10, node 5\n15\n3\nVisit node 4\nYes\nnode 10, node 5, node 4\n19\n4\nReturn to node 5\n\nnode 10, node 5\n15\n5\nVisit node 7\nYes\nnode 10, node 5, node 7\n22\n6\nReturn to node 5\n\nnode 10, node 5\n15\n7\nReturn to node 10\n\nnode 10\n10\n8\nVisit node 12\nYes\nnode 10, node 12\n22\nTable 1: The process to traverse the binary tree in Figure 1\n\nIt is time to summarize some rules with the example above. When we visit a node with pre-order traversal order, we insert it into the path, and accumulate its value to sum .\u00a0 When the node is a leaf and sum is same as the input number, the path is qualified and we need to print it. We continue to visit its children if the current node is not a leaf. After we finish visiting the current node, a recursive function will return back to its parent node automatically, so we should remove the current node from the path before a function returns to make sure the nodes in the path is same as the path from root node to its parent node. The data structure to save paths should be a stack, because paths should be consistent to the recursion status and recursion is essentially pushing and popping in a call stack.\nHere is some sample code for this problem:\n\nvoid FindPath(BinaryTreeNode* pRoot, int expectedSum)\n{\nif (pRoot == NULL)\nreturn ;\n\nstd::vector< int > path;\nint currentSum = 0;\nFindPath(pRoot, expectedSum, path, currentSum);\n}\n\nvoid FindPath\n(\nBinaryTreeNode*\u00a0\u00a0 pRoot,\nint expectedSum,\nstd::vector< int >&\u00a0path,\nint currentSum\n)\n{\ncurrentSum += pRoot->m_nValue;\npath.push_back(pRoot->m_nValue);\n\n// Print the path is the current node is a leaf\n// and the sum of all nodes value is same as expectedSum\nbool isLeaf = pRoot->m_pLeft == NULL && pRoot->m_pRight == NULL;\nif (currentSum == expectedSum && isLeaf)\n{\nprintf( \"A path is found: \" );\nstd::vector< int >::iterator iter = path.begin();\nfor (; iter != path.end(); ++ iter)\nprintf( \"%d\\t\" , *iter);\n\nprintf( \"\\n\" );\n}\n\n// If it is not a leaf, continue visition its children\nif (pRoot->m_pLeft != NULL)\nFindPath(pRoot->m_pLeft, expectedSum, path, currentSum);\nif (pRoot->m_pRight != NULL)\nFindPath(pRoot->m_pRight, expectedSum, path, currentSum);\n\n// Before returning back to its parent, remove it from path,\npath.pop_back();\n}\n\nIn the code above, we save path with a vector in STL actually. We use function push_back to insert a node and pop_back to remove a node to assure it is \u201cFirst in Last out\u201d in a path. The reason we don\u2019t utilize a stack in STL is that we can only get an element at the top of a stack, but we need to get all nodes when we print a path. Therefore, std::stack is not the best choice for us.", "question": "\nQuestion: All nodes along children pointers from root to leaf nodes form a path in a binary tree. Given a binary tree and a number, please print out all of paths where the sum of all nodes value is same as the given number. The node of binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n\nFor instance, if inputs are the binary tree in Figure 1 and a number 22, two paths with be printed: One is the path contains node 10 and 12, and the other contains 10, 5 and 7."},
{"answer": "\nAnalysis: If a function f(i, j) is defined to indicate the edit difference between the substring of the \u00a0first string ending with the j th character and the substring of the second string ending with the i th character. It is obvious that f(i, 0) = i, because when we delete i characters from the substring of the first string ending with the i th character, we get an empty string (it is also the substring of the second string ending with the 0-th string). Similarly, f(0, j) = j.\n\nLet discuss the cases when both i and j are greater than 1. If the i th character of the second string is same as the j th character of the first string, no edit operations are necessary. Therefore, f(i, j) = f(i-1, j-1).\n\nWhen the j th character of the first string is different from the i th character of the second string, there are three options available: (1) Insert the i th character of second string into the first string. In this case, f(i, j) = f(i-1, j) + 1. (2) Delete the j th character of the first string. In this case, f(i, j) = f(i, j-1) + 1. (3) Replace the j th character of the first string with the i th character of the second string. In this case, f(i, j) = f(i-1, j-1) + 1. What is the final value for f(i, j)? It should be the minimal value of the three cases.\nIf we draw a table to show the edit distance values f(i, j) between \u201cSaturday\u201d and \u201cSunday\u201d, it looks like the Table 1.\n\nS a t u r d a y 0 1 2 3 4 5 6 7 8 S 1 0 1 2 3 4 5 6 7 u 2 1 1 2 2 3 4 5 6 n 3 2 2 2 3 3 4 5 6 d 4 3 3 3 3 4 3 4 5 a 5 4 3 4 4 4 4 3 4 y 6 5 4 4 5 5 5 4 3\n\n\nS\na\nt\nu\nr\nd\na\ny\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\nS\n1\n0\n1\n2\n3\n4\n5\n6\n7\nu\n2\n1\n1\n2\n2\n3\n4\n5\n6\nn\n3\n2\n2\n2\n3\n3\n4\n5\n6\nd\n4\n3\n3\n3\n3\n4\n3\n4\n5\na\n5\n4\n3\n4\n4\n4\n4\n3\n4\ny\n6\n5\n4\n4\n5\n5\n5\n4\n3\nTable 1: Edit distance value f(i, j) between \u201cSaturday\u201d and \u201cSunday\u201d.\n\nThe edit distance of two strings is at the right-bottom corner of the table for edit distance values.\nA formal equation can be defined for this problem:\n\n\n\n\nIt is not difficult to develop code based on the equation above. An edit distance value table can be implemented as a 2-D array. Some sample code is shown as below:\n\nint getEditDistance( char * str1, char * str2)\n{\nif (str1 == NULL || str2 == NULL)\nreturn -1;\n\nint len1 = strlen(str1);\nint len2 = strlen(str2);\n\nint ** distances = ( int **) new int [len2 + 1];\nfor ( int i = 0; i < len2 + 1; ++ i)\ndistances[i] = new int [len1 + 1];\n\nint editDistance = getEditDistance(str1, str2, distances, len1, len2);\n\nfor ( int i = 0; i < len2 + 1; ++ i)\ndelete [] distances[i];\ndelete [] distances;\n\nreturn editDistance;\n}\n\nint getEditDistance( char * str1, char * str2, int ** distances, int len1, int len2)\n{\nfor ( int i = 0; i < len2 + 1; ++ i)\ndistances[i][0] = i;\nfor ( int j = 0; j < len1 + 1; ++ j)\ndistances[0][j] = j;\n\nfor ( int i = 1; i < len2 + 1; ++ i)\n{\nfor ( int j = 1; j < len1 + 1; ++ j)\n{\nif (str1[j - 1] == str2[i - 1])\ndistances[i][j] = distances[i - 1][j - 1];\nelse\n{\nint deletion = distances[i][j - 1] + 1;\nint insertion = distances[i - 1][j] + 1;\nint substitution = distances[i - 1][j - 1] + 1;\ndistances[i][j] = min(deletion, insertion, substitution);\n}\n}\n}\n\nreturn distances[len2][len1];\n}\n\nint min( int num1, int num2, int num3)\n{\nint less = (num1 < num2) ? num1 : num2;\nreturn (less < num3) ? less : num3;\n}\n", "question": "\nProblem: Implement a function which gets the edit distance of two input strings. There are three types of edit operations: insertion, deletion and substitution. Edit distance is the minimal number of edit operations to modify a string from one to the other.\n\nFor example, the edit distance between \u201cSaturday\u201d and \u201cSunday\u201d is 3, since the following three edit operations are required to modify one into the other:\n1. S a turday \u2192 Sturday (deletion of \u2018a\u2019)\n2. S t urday\u2192 Surday (deletion of \u2018t\u2019)\n3. Su r day \u2192 Su n day (substitution of \u2018n\u2019 for \u2018r\u2019)\n\nThere is no way to achieve it with fewer than three operations.\n"},
{"answer": "\nAnalysis: Firstly let us define a function f(t) which is the minimal number of coins to make change for total value t. If there are n different coins, we have n choices to make change for value t: we can add a coin with value v 1 into a set of coins whose total value is t-v 1 . The minimal number of coins to get value t-v 1 is f(t-v 1 ). Similarly, we can add a coin with value v 2 into a set of coins whose total value is t-v 2 . The minimal number of coins to get value t-v 2 is f(t-v 2 )\u2026\n\nTherefore, we divide a problem to calculate f(t) into n sub-problems: f(t-v 1 ), f(t-v 2 ), \u2026, f(t-v n ). We can get a formal equation for f(t) as the following accordingly:\n\n\n\nThis equation can be implemented with recursion easily. However, the recursive solution will cause serious performance issues since there are overlaps when we divide this problem into n sub-problems. A better solution is to utilize iteration, and store the result of sub-problems into a table (as the Table 1).\n\nIn the Table 1, each column except the first one is to denote the number of coins to make change for a specific value. We can calculate the numbers in the Table 1 from left to right, to simulate the iterative process to get the result of f(15).\n\nFor instance, there are two numbers 4 and 2 under the column title \u201c6\u201d. We have two alternatives to make change for 6: the first one is to add a coin with value 1 to a set of coins whose total value is 5. Since the minimal number of coins to get value 5 is 3 (highlighted number under the column tile \u201c5\u201d), the number in the first cell under column title \u201c6\u201d is 4 (4=3+1). The second choice is to add a coin with value 3 to a set of coins whose total value is 3. Since the minimal number of coins to get value 3 is 1 (highlighted number under the column tile \u201c3\u201d), the number in the second cell under column title \u201c6\u201d is 2 (2=1+1). We highlight the number 2 in the column under tile 6 because 2 is less than 4.\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n1\n0\n1\n2\n3\n2\n3\n4\n3\n4\n5\n2\n2\n3\n3\n4\n5\n3\n0\n-\n-\n1\n2\n3\n2\n3\n4\n3\n4\n5\n2\n2\n3\n3\n9\n0\n-\n-\n-\n-\n-\n-\n-\n-\n1\n2\n3\n2\n3\n4\n3\n10\n0\n-\n-\n-\n-\n-\n-\n-\n-\n-\n1\n2\n3\n2\n3\n4\nTable 1: The iterative process to calculate the minimal number of coins to make changes for 15.\n\nEven though we have a 2-D matrix to show the iterative process, it only requires a 1-D array for coding, because it is only necessary to store the minimal number of coins to make change for each total value. The sample code is shown below:\n\nint GetMinCount( int total, int * coins, int length)\n{\nint * counts = new int [total + 1];\ncounts[0] = 0;\n\nconst int MAX = 0x7FFFFFFF;\n\nfor ( int i = 1; i <= total; ++ i)\n{\nint count = MAX;\nfor ( int j = 0; j < length; ++ j)\n{\nif (i - coins[j] >= 0 && count > counts[i - coins[j]])\ncount = counts[i - coins[j]];\n}\n\nif (count < MAX)\ncounts[i] = count + 1;\nelse\ncounts[i] = MAX;\n}\n\nint minCount = counts[total];\ndelete [] counts;\n\nreturn minCount;", "question": "\nProblem: Please implement a function which gets the minimal number of coins, whose value is v 1 , v 2 , \u2026, v n , to make change for an amount of money with value t. Any coin with value v i may duplicate for any times to make change.\n\nFor example, the minimal number of coins to make change for 15 out of a set of coins with value 1, 3, 9, 10 is 3. We can choose two coins with value 3 and a coin with value 9. The number of coins for other choices should be greater than 3.\n"},
{"answer": "\nAnalysis: An intuitive thought on this problem is to create an auxiliary stack. We push the numbers in the first sequence one by one, and try to pop them out according to the order in the second sequence.\n\nTake the sequence 4, 5, 3, 2, 1 as an example to analyze the process to push and pop. The first number to be popped is 4, so we need to push it into a stack. The pushing order is defined in the first sequence, where there are numbers 1, 2 and 3 prior to 4. Therefore, numbers 1, 2, and 3 are pushed into a stack before 4 is pushed. At this time, there are 4 numbers in a stack, which are 1, 2, 3 and 4, with 4 on top. When 4 is popped, numbers 1, 2 and 3 are left. The next number to be popped is 5, which is not on top of stack, so we have to push numbers in the first sequence into stack until 5 is pushed. When number 5 is on top of a stack, we can pop it. The next three numbers to be popped are 3, 2 and 1. Since these numbers are on top of a stack before pop operations, they can be popped directly. The whole process to push and pop is summarized in Table 1.\n\nStep Operation Stack Status Popped Step Operation Stack Status Popped 1 Push 1 1 6 Push 5 1, 2, 3, 5 2 Push 2 1, 2 7 Pop 1, 2, 3 5 3 Push 3 1, 2, 3 8 Pop 1, 2 3 4 Push 4 1, 2, 3, 4 9 Pop 1 2 5 Pop 1, 2, 3 4 10 Pop 1\nStep\nOperation\nStack Status\nPopped\nStep\nOperation\nStack Status\nPopped\n1\nPush 1\n1\n\n6\nPush 5\n1, 2, 3, 5\n\n2\nPush 2\n1, 2\n\n7\nPop\n1, 2, 3\n5\n3\nPush 3\n1, 2, 3\n\n8\nPop\n1, 2\n3\n4\nPush 4\n1, 2, 3, 4\n\n9\nPop\n1\n2\n5\nPop\n1, 2, 3\n4\n10\nPop\n\n1\nTable 1: The process to push and pop with a push sequence 1, 2, 3, 4, 5 and pop sequence 4, 5, 3, 2, 1\n\nLet us continue to analyze another pop sequence 4, 3, 5, 1, 2. The process to pop the first number 4 is similar to the process above. After the number 4 is popped, 3 is on the top of stack and it can be popped. The next number to be popped is 5. Since it is not on top, we have to push numbers in the first sequence until the number 5 is pushed. The number 5 can be popped when it is pushed onto the top of a stack. After 5 is popped out, there are only two numbers 1 and 2 left in stack. The next number to be popped is 1, but it is not on the top of stack. We have to push numbers in the first sequence until 1 is pushed. However, all numbers in the first sequence have been pushed. Therefore, the sequence 4, 3, 5, 1, 2 is not a pop sequence of the stack with push sequence 1, 2, 3, 4, 5. The whole process to push and pop is summarized in Table 2.\n\nStep Operation Stack Status Popped Step Operation Stack Status Popped 1 Push 1 1 6 Pop 1, 2 3 2 Push 2 1, 2 7 Push 5 1, 2, 5 3 Push 3 1, 2, 3 8 Pop 1, 2 5 4 Push 4 1, 2, 3, 4 The next number to be popped is 1, which is neither on the top of stack,   nor in the remaining numbers of push sequence. 5 Pop 1, 2, 3 4\nStep\nOperation\nStack Status\nPopped\nStep\nOperation\nStack Status\nPopped\n1\nPush 1\n1\n\n6\nPop\n1, 2\n3\n2\nPush 2\n1, 2\n\n7\nPush 5\n1, 2, 5\n\n3\nPush 3\n1, 2, 3\n\n8\nPop\n1, 2\n5\n4\nPush 4\n1, 2, 3, 4\n\nThe next number to be popped is 1, which is neither on the top of stack,   nor in the remaining numbers of push sequence.\n5\nPop\n1, 2, 3\n4\nTable 1: The process to push and pop with a push sequence 1, 2, 3, 4, 5 and pop sequence 4, 3, 5, 1, 2\n\nAccording to the analysis above, we get a solution to check whether a sequence is a pop sequence of a stack or not. If the number to be popped is currently on top of stack, just pop it. If it is not on the top of stack, we have to push remaining numbers into the auxiliary stack until we meet the number to be popped. If the next number to be popped is not remaining in the push sequence, it is not a pop sequence of a stack. The following is some sample code based on this solution:\n\nbool IsPopOrder( const int * pPush, const int * pPop, int nLength)\n{\nbool bPossible = false ;\n\nif (pPush != NULL && pPop != NULL && nLength > 0)\n{\nconst int * pNextPush = pPush;\nconst int * pNextPop = pPop;\n\nstd::stack< int > stackData;\n\nwhile (pNextPop - pPop < nLength)\n{\n// When the number to be popped is not on top of stack,\n// push some numbers in the push sequence into stack\nwhile (stackData.empty() || stackData.top() != *pNextPop)\n{\n// If all numbers have been pushed, break\nif (pNextPush - pPush == nLength)\nbreak ;\n\nstackData.push(*pNextPush);\n\npNextPush ++;\n}\n\nif (stackData.top() != *pNextPop)\nbreak ;\n\nstackData.pop();\npNextPop ++;\n}\n\nif (stackData.empty() && pNextPop - pPop == nLength)\nbPossible = true ;\n}\n\nreturn bPossible;\n}", "question": "\nProblem: Given two integer sequences, one of which is the push sequence of a stack, please check whether the other sequence is a corresponding pop sequence or not.\n\nFor example, if 1, 2, 3, 4, 5 is a push sequence, 4, 5, 3, 2, 1 is a corresponding pop sequence, but the sequence 4, 3, 5, 1, 2 is not.\n"},
{"answer": "\nAnalysis: Lots of pointer operations are necessary to solve problems related to linked lists. Interviewers know that many candidates are prone to make mistakes on pointer operations, so they like problems of linked list to qualify candidates\u2019 programming abilities. During interviews, we had better analyze and design carefully rather than begin to code hastily. It is much better to write robust code with comprehensive analysis than write code quickly with many errors.\n\nDirection of pointers should be adjusted in order to reverse a linked list. We may utilize figures to analyze visually the complex steps to adjust pointers. As shown in the list in Figure 1-a, node h, i and j are three adjacent nodes. Let us assume pointers of all nodes prior to h have been reversed after some operations and all m_pNext point to their previous nodes. We are going to reverse the m_pNext pointer in node i. The status of list is shown in Figure 1-b.\n\n\nIt is noticeable that m_pNext in node i points to its previous node h, the list is broken and we cannot visit the node j anymore. We should save the node j before the m_pNext pointer of node i is adjusted to prevent the list becoming broken.\n\nWhen we adjust the pointer in node i, we need to access to node h since m_pNext of node i is adjusted to point to node h. Meanwhile, we also need to access to node j because it is necessary to save it otherwise the list will be broken. Therefore, three pointers should be declared in our code, which point to the current visited node, its previous node and its next node.\n\nLastly we should get the head node of the reversed list. Obviously head in the reversed list should be tail of the original list. Which pointer is tail? It should be a node whose m_pNext is NULL .\nWith comprehensive analysis above, we are ready to write code, which is shown below:\n\nListNode* ReverseList(ListNode* pHead)\n{\nListNode* pReversedHead = NULL;\nListNode* pNode = pHead;\nListNode* pPrev = NULL;\nwhile (pNode != NULL)\n{\nListNode* pNext = pNode->m_pNext;\n\nif (pNext == NULL)\npReversedHead = pNode;\n\npNode->m_pNext = pPrev;\n\npPrev = pNode;\npNode = pNext;\n}\n\nreturn pReversedHead;", "question": "\nProblem: Implement a function to reverse a linked list, and return the head of the reversed list. A list node is defined as below:\nstruct ListNode\n{\nint m_nKey;\nListNode* m_pNext;\n};\n"},
{"answer": "\nAnalysis: According to declaration above, a queue contains two stacks stack1 and stack2 . Therefore, it is required to implement a queue which follows the rule \u201cFirst In First Out\u201d with two stacks which follow the rule of \u201cFirst In Last Out\u201d.\n\nWe analyze the process to add and delete some elements via some examples. Firstly en element a is inserted. Let us push it into stack1 . There is an element {a} in stack1 and stack2 is empty. We continue to add two more elements b and c (push them into stack1 too). There are three elements {a, b, c} in stack1 now, where c is on its top, and stack2 is still empty (as shown in Figure 1-a).\n\nWe then have a try to delete an element from a queue. According to the rule \u201cFirst in First out\u201d, the first element to be deleted is a since it is added before b and c. The element a is stored in to stack1 , and it is not on the top of stack. Therefore, we cannot pop it directly. We can notice that stack2 has not been used, so it is the time for us to utilize it. If we pop elements from stack1 and push them into stack2 one by one, the order of elements in stack2 is reverse to the order in stack1 . After three popping and pushing operations, stack1 becomes empty and there are three elements {c, b, a} in stack2 . The element a can be popped out now since it is on the top of stack2 . Now there are two elements left {c, b} in stack2 and b is on its top (as shown in Figure 1-b).\n\nHow about to continue deleting more elements from the tail of queue? The element b is inserted into queue before c, so it should be deleted when there are two elements b and c left in queue. It can be popped out since it is on the top of stack2 . After the popping operation, stack1 remains empty and there is only an element c in stack2 (as shown in Figure 1-c).\n\nIt is time to summarize the steps to delete an element from a queue: The top of stack2 can be popped out since it is the first element inserted into queue when stack2 is not empty. When stack2 is empty, we pop all elements from stack1 and push them into stack2 one by one. The first element in a queue is pushed into the bottom of stack1 . It can be popped out directly after popping and pushing operations since it is on the top of stack2 .\n\nLet us insert another element d. How about to push it into stack1 (as shown in Figure1-d)? When we continue to delete the top of stack2 , which is element c, can be popped because it is not empty (as shown in Figure 1-d). The element c is indeed inserted into queue before the element d, so it is a reasonable operation to delete c before d. The final status of the queue is shown as Figure 1-e.\n\n\nWe can write code after we get clear ideas about the process to insert and delete elements. Some sample code is shown below:\n\ntemplate < typename T> void CQueue<T>::appendTail( const T& element)\n{\nstack1.push(element);\n}\n\ntemplate < typename T> T CQueue<T>::deleteHead()\n{\nif (stack2.size()<= 0)\n{\nwhile (stack1.size()>0)\n{\nT& data = stack1.top();\nstack1.pop();\nstack2.push(data);\n}\n}\n\nif (stack2.size() == 0)\nthrow new exception( \"queue is empty\" );\n\nT head = stack2.top();\nstack2.pop();\n\nreturn head;", "question": "\nProblem: Implement a queue with two stacks. The class for queues is declared in C++ as below. Please implement two functions: appendTail to append an element into tail of a queue, and deleteHead to delete an element from head of a queue.\n\ntemplate < typename T> class CQueue\n{\npublic :\nCQueue( void );\n~CQueue( void );\n\nvoid appendTail( const T& node);\nT deleteHead();\n\nprivate :\nstack<T> stack1;\nstack<T> stack2;\n};\n"},
{"answer": "\nAnalysis: Before we analyze how to merge an array of ranges, let\u2019s discuss how to merge two ranges. When two ranges don\u2019t overlap each other, they can\u2019t merge. When two ranges overlap, the less starting value of two ranges becomes the starting value of the merged range, and the greater ending value of two ranges becomes the ending value of the merged range.\n\nTherefore, two ranges [5, 13] and [8, 19] are merged into a new range [5, 19], and two ranges [27, 39] and [31, 37] are merged into a new range [27, 39]. The two merged ranges can\u2019t be merged further because they don\u2019t overlap.\n\nThe next question is: How to check whether two ranges overlap\u00a0each other? When two ranges overlap, there is at least on node in a range is contained in the other range. For instance, the starting value 8 of the range [8, 19] is contained in the range [5, 13], therefore, the two ranges [5, 13] and [8, 19] overlap. No nodes in the range [8, 19] are contained in the range [31, 37], so the two ranges don\u2019t overlap.\n\nThe following code shows how to merge two ranges, as well as to check whether two ranges overlap:\n\n public bool Contains( int value)\n\n {\n\n     if (value >= this .Start && value <= this .End)\n\n     {\n\n         return true ;\n\n     }\n\n  \n\n     return false ;\n\n }\n\n  \n\n public bool Overlaps( Range other)\n\n {\n\n     if (other == null )\n\n     {\n\n         return false ;\n\n     }\n\n  \n\n     if ( this .Contains(other.Start) || this .Contains(other.End)         || other .Contains( this .Start) || other .Contains( this .End) )\n\n     {\n\n         return true ;\n\n     }\n\n  \n\n     return false ;\n\n }\n\n  \n\n public Range Merge( Range other)\n\n {\n\n     if (! this .Overlaps(other))\n\n     {\n\n         throw new ApplicationException ( \"Can't merge tworanges.\" );\n\n     }\n\n  \n\n     int newStart = ( this .Start < other.Start) ? this .Start : other.Start;\n\n     int newEnd = ( this .End > other.End) ? this .End : other.End;\n\n  \n\n     return new Range (newStart, newEnd);\n\n }\n\nNow let\u2019s move on to merge an array of ranges. The first step is to sort the ranges based on their start values. When the ranges [5, 13], [27, 39], [8, 19], and [31, 37] are sorted, they are in the order of [5, 13], [8, 19], [27, 39], and [31, 37].\n\nThe next steps are to merge the sorted ranges. The merged ranges are inserted into a data container. At each step, a range is retrieved from the sorted array, and merged with the existing ranges in the container.\n\nAt first the data container is empty, and the first range [5, 13] is inserted into the container directly, without merging. Now there is only one range [5, 13] in the container.\n\nThen the next range [8, 19] is retrieved. Since it overlaps the range[5, 13], and they become [5, 19] when they merged. There is still only one\u00a0range, which is [5, 19] in the container.\n\nThe next range [27, 39] is retrieved, which does not overlap the range [5, 19] in the container, so it is inserted into the range directly without merging. There are two ranges [5, 19] and [27, 39] in the container.\n\nThe last range in the sorted array is [31, 37]. It overlaps the last range [27, 39] in the container. Therefore, the last range [27, 39] is deleted from the container, and then the merged range is inserted into the container. At this step, the merged range is also [27, 39].\n\nRanges in the container are also sorted based on their starting values, and they don't overlap each other. Notice that it's only necessary to check whether the new range overlap the last range in the container. Why not the other ranges in the container? Let's analyze what would happen when a new range in the sorted array overlap two ranges in the container, with Figure 2:\n\nIn Figure 2, the container has two ranges A and B, and a new range C is retrieved from the sorted array, which overlaps the ranges A and B. Since C overlaps A, the starting value of C should be less than the ending value of A. On the other hand, C is retrieved from the sorted array later than B, the starting value of C is greater than starting value of B. Additionally, B is behind A and they don't overlap, so the starting value of B is greater than the ending value A. Therefore, the starting value of C is greater than the ending value of A. It contradicts.\nSince it's only necessary to merge new ranges from the sorted array with the last range in the container. We implement the container as a stack, and the last range is on the top of the stack.\nThe following is the C# code to merge a sort an array of ranges:\n public static Range []Merge( Range [] ranges)\n {\n     Stack < Range > results = new Stack < Range >();\n     if (ranges != null )\n     {\n         Array .Sort(ranges, CompareRangeByStart);\n  \n         foreach ( var range in ranges)\n         {\n             if (results.Count == 0)\n             {\n                 results.Push(range);\n             }\n             else\n             {\n                 var top =results.Peek();\n                 if (top.Overlaps(range))\n                 {\n                     var union = top.Merge(range);\n                     results.Pop();\n                     results.Push(union);\n                 }\n                 else\n                 {\n                     results.Push(range);\n                 }\n             }\n         }\n     }\n  \n     return results.Reverse().ToArray();\n }\n", "question": "\nQuestions: Given an array of ranges, please merge the overlapping ones. For example, four ranges [5, 13], [27, 39], [8, 19], [31, 37] (in blue in\u00a0 Figure1) are merged into two ranges, which are [5, 19] and [27, 39] (in green in\u00a0Figure 1).\n"},
{"answer": "\nAnalysis: Since numbers come from a stream, the count of numbers is dynamic, and increases over time. If a data container is defined for the numbers from a stream, new numbers will be inserted into the container when they are deserialized. Let us find an appropriate data structure for such a data container.\n\nAn array is the simplest choice. The array should be sorted, because we are going to get its median. Even though it only costs O(lg n ) time to find the position to be inserted with binary search algorithm, it costs O( n ) time to insert a number into a sorted array, because O( n ) numbers will be moved if there are n numbers in the array. It is very efficient to get the median, since it only takes O(1) time to access to a number in an array with an index.\n\nA sorted list is another choice. It takes O( n ) time to find the appropriate position to insert a new number. Additionally, the time to get the median can be optimized to O(1) if we define two pointers which points to the central one or two elements.\n\nA better choice available is a binary search tree, because it only costs O(lg n ) on average to insert a new node. However, the time complexity is O( n ) for the worst cases, when numbers are inserted in sorted (increasingly or decreasingly) order. To get the median number from a binary search tree, auxiliary data to record the number of nodes of its sub-tree is necessary for each node. It also requires O(lg n ) time to get the median node on overage, but O( n ) time for the worst cases.\n\nWe may utilize a balanced binary search tree, AVL, to avoid the worst cases. Usually the balance factor of a node in AVL trees is the height difference between its right sub-tree and left sub-tree. We may modify a little bit here: Define the balance factor as the difference of number of nodes between its right sub-tree and left sub-tree. It costs O(lg n ) time to insert a new node into an AVL, and O(1) time to get the median for all cases.\n\nAn AVL is efficient, but it is not implemented unfortunately in libraries of the most common programming languages. It is also very difficult for candidates to implement the left/right rotation of AVL trees in dozens of minutes during interview. Let us looks for better solutions.\n\nAs shown in Figure 1, if all numbers are sorted, the numbers which are related to the median are indexed by P1 and P2. If the count of numbers is odd, P1 and P2 point to the same central number. If the count is even, P1 and P2 point to two numbers in middle.\n\nMedian can be get or calculated with the numbers pointed by P1 are P2. It is noticeable that all numbers are divided into two parts. The numbers in the first half are less than the numbers in the second half. Moreover, the number indexed by P1 is the greatest number in the first half, and the number indexed by P2 is the least one in the second half.\nTherefore, numbers in the first half are inserted into a max heap, and numbers in the second half are inserted into a min heap. It costs O(lg n ) time to insert a number into a heap. Since the median can be get or calculated with the root of a min heap and a max heap, it only takes O(1) time.\n\nTable 1 compares the solutions above with a sorted array, a sorted list, a binary search tree, an AVL tree, as well as a min heap and a max heap.\nType for Data Container Time to Insert Time to Get Median Sorted Array O( n ) O(1) Sorted List O( n ) O(1) Binary Search Tree O(lg n ) on   average, O( n ) for the worst cases O(lg n ) on average,   O( n ) for the worst cases AVL O(lg n ) O(1) Max Heap and Min Heap O(lg n ) O(1)\nType for Data Container\nTime to Insert\nTime to Get Median\nSorted Array\nO( n )\nO(1)\nSorted List\nO( n )\nO(1)\nBinary Search Tree\nO(lg n ) on   average, O( n ) for the worst cases\nO(lg n ) on average,   O( n ) for the worst cases\nAVL\nO(lg n )\nO(1)\nMax Heap and Min Heap\nO(lg n )\nO(1)\nTable 1: Summary of solutions with a sorted array, a sorted list, a binary search tree, an AVL tree, as well as a min heap and a max heap.\n\nLet us consider the implementation details. All numbers should be evenly divided into two parts, so the count of number in min heap and max heap should diff 1 at most. To achieve such a division, a new number is inserted into the min heap if the count of existing numbers is even; otherwise it is inserted into the max heap.\n\nWe also should make sure that the numbers in the max heap are less than the numbers in the min heap. Supposing the count of existing numbers is even, a new number will be inserted into the min heap. If the new number is less than some numbers in the max heap, it violates our rule that all numbers in the min heap should be greater than numbers in the min heap.\n\nIn such a case, we can insert the new number into the max heap first, and then pop the greatest number from the max heap, and push it into the min heap. Since the number pushed into the min heap is the former greatest number in the max heap, all numbers in the min heap are greater than numbers in the max heap with the newly inserted number.\n\nThe situation is similar when the count of existing numbers is odd and the new number to be inserted is greater than some numbers in the min heap. Please analyze the insertion process carefully by yourself.\n\nThe following is sample code in C++. Even though there are no types for heaps in STL, we can build heaps with vectors utilizing function push_heap and pop_heap . Comparing functor less and greater are employed for max heaps and min heaps correspondingly.\n\ntemplate < typename T> class DynamicArray\n{\npublic :\nvoid Insert(T num)\n{\nif (((minHeap.size() + maxHeap.size()) & 1) == 0)\n{\nif (maxHeap.size() > 0 && num < maxHeap[0])\n{\nmaxHeap.push_back(num);\npush_heap(maxHeap.begin(), maxHeap.end(), less<T>());\n\nnum = maxHeap[0];\n\npop_heap(maxHeap.begin(), maxHeap.end(), less<T>());\nmaxHeap.pop_back();\n}\n\nminHeap.push_back(num);\npush_heap(minHeap.begin(), minHeap.end(), greater<T>());\n}\nelse\n{\nif (minHeap.size() > 0 && minHeap[0] < num)\n{\nminHeap.push_back(num);\npush_heap(minHeap.begin(), minHeap.end(), greater<T>());\n\nnum = minHeap[0];\n\npop_heap(minHeap.begin(), minHeap.end(), greater<T>());\nminHeap.pop_back();\n}\n\nmaxHeap.push_back(num);\npush_heap(maxHeap.begin(), maxHeap.end(), less<T>());\n}\n}\n\nint GetMedian()\n{\nint size = minHeap.size() + maxHeap.size();\nif (size == 0)\nthrow exception( \"No numbers are available\" );\n\nT median = 0;\nif (size & 1 == 1)\nmedian = minHeap[0];\nelse\nmedian = (minHeap[0] + maxHeap[0]) / 2;\n\nreturn median;\n}\n\nprivate :\nvector<T> minHeap;\nvector<T> maxHeap;\n};\n\nIn the code above, function Insert is used to insert a new number deserialized from a stream, and GetMedian is used to get the median of the existing numbers dynamically.", "question": "\nQuestion: How to get the median from a stream of numbers at any time? The median is middle value of numbers. If the count of numbers is even, the median is defined as the average value of the two numbers in middle.\n"},
{"answer": "\nAnalysis: Since numbers come from a stream, the count of numbers is dynamic, and increases over time. If a data container is defined for the numbers from a stream, new numbers will be inserted into the container when they are deserialized. Let us find an appropriate data structure for such a data container.\n\nAn array is the simplest choice. The array should be sorted, because we are going to get its median. Even though it only costs O(lg n ) time to find the position to be inserted with binary search algorithm, it costs O( n ) time to insert a number into a sorted array, because O( n ) numbers will be moved if there are n numbers in the array. It is very efficient to get the median, since it only takes O(1) time to access to a number in an array with an index.\n\nA sorted list is another choice. It takes O( n ) time to find the appropriate position to insert a new number. Additionally, the time to get the median can be optimized to O(1) if we define two pointers which points to the central one or two elements.\n\nA better choice available is a binary search tree, because it only costs O(lg n ) on average to insert a new node. However, the time complexity is O( n ) for the worst cases, when numbers are inserted in sorted (increasingly or decreasingly) order. To get the median number from a binary search tree, auxiliary data to record the number of nodes of its sub-tree is necessary for each node. It also requires O(lg n ) time to get the median node on overage, but O( n ) time for the worst cases.\n\nWe may utilize a balanced binary search tree, AVL, to avoid the worst cases. Usually the balance factor of a node in AVL trees is the height difference between its right sub-tree and left sub-tree. We may modify a little bit here: Define the balance factor as the difference of number of nodes between its right sub-tree and left sub-tree. It costs O(lg n ) time to insert a new node into an AVL, and O(1) time to get the median for all cases.\n\nAn AVL is efficient, but it is not implemented unfortunately in libraries of the most common programming languages. It is also very difficult for candidates to implement the left/right rotation of AVL trees in dozens of minutes during interview. Let us looks for better solutions.\n\nAs shown in Figure 1, if all numbers are sorted, the numbers which are related to the median are indexed by P1 and P2. If the count of numbers is odd, P1 and P2 point to the same central number. If the count is even, P1 and P2 point to two numbers in middle.\n\nMedian can be get or calculated with the numbers pointed by P1 are P2. It is noticeable that all numbers are divided into two parts. The numbers in the first half are less than the numbers in the second half. Moreover, the number indexed by P1 is the greatest number in the first half, and the number indexed by P2 is the least one in the second half.\nTherefore, numbers in the first half are inserted into a max heap, and numbers in the second half are inserted into a min heap. It costs O(lg n ) time to insert a number into a heap. Since the median can be get or calculated with the root of a min heap and a max heap, it only takes O(1) time.\n\nTable 1 compares the solutions above with a sorted array, a sorted list, a binary search tree, an AVL tree, as well as a min heap and a max heap.\nType for Data Container Time to Insert Time to Get Median Sorted Array O( n ) O(1) Sorted List O( n ) O(1) Binary Search Tree O(lg n ) on   average, O( n ) for the worst cases O(lg n ) on average,   O( n ) for the worst cases AVL O(lg n ) O(1) Max Heap and Min Heap O(lg n ) O(1)\nType for Data Container\nTime to Insert\nTime to Get Median\nSorted Array\nO( n )\nO(1)\nSorted List\nO( n )\nO(1)\nBinary Search Tree\nO(lg n ) on   average, O( n ) for the worst cases\nO(lg n ) on average,   O( n ) for the worst cases\nAVL\nO(lg n )\nO(1)\nMax Heap and Min Heap\nO(lg n )\nO(1)\nTable 1: Summary of solutions with a sorted array, a sorted list, a binary search tree, an AVL tree, as well as a min heap and a max heap.\n\nLet us consider the implementation details. All numbers should be evenly divided into two parts, so the count of number in min heap and max heap should diff 1 at most. To achieve such a division, a new number is inserted into the min heap if the count of existing numbers is even; otherwise it is inserted into the max heap.\n\nWe also should make sure that the numbers in the max heap are less than the numbers in the min heap. Supposing the count of existing numbers is even, a new number will be inserted into the min heap. If the new number is less than some numbers in the max heap, it violates our rule that all numbers in the min heap should be greater than numbers in the min heap.\n\nIn such a case, we can insert the new number into the max heap first, and then pop the greatest number from the max heap, and push it into the min heap. Since the number pushed into the min heap is the former greatest number in the max heap, all numbers in the min heap are greater than numbers in the max heap with the newly inserted number.\n\nThe situation is similar when the count of existing numbers is odd and the new number to be inserted is greater than some numbers in the min heap. Please analyze the insertion process carefully by yourself.\n\nThe following is sample code in C++. Even though there are no types for heaps in STL, we can build heaps with vectors utilizing function push_heap and pop_heap . Comparing functor less and greater are employed for max heaps and min heaps correspondingly.\n\ntemplate < typename T> class DynamicArray\n{\npublic :\nvoid Insert(T num)\n{\nif (((minHeap.size() + maxHeap.size()) & 1) == 0)\n{\nif (maxHeap.size() > 0 && num < maxHeap[0])\n{\nmaxHeap.push_back(num);\npush_heap(maxHeap.begin(), maxHeap.end(), less<T>());\n\nnum = maxHeap[0];\n\npop_heap(maxHeap.begin(), maxHeap.end(), less<T>());\nmaxHeap.pop_back();\n}\n\nminHeap.push_back(num);\npush_heap(minHeap.begin(), minHeap.end(), greater<T>());\n}\nelse\n{\nif (minHeap.size() > 0 && minHeap[0] < num)\n{\nminHeap.push_back(num);\npush_heap(minHeap.begin(), minHeap.end(), greater<T>());\n\nnum = minHeap[0];\n\npop_heap(minHeap.begin(), minHeap.end(), greater<T>());\nminHeap.pop_back();\n}\n\nmaxHeap.push_back(num);\npush_heap(maxHeap.begin(), maxHeap.end(), less<T>());\n}\n}\n\nint GetMedian()\n{\nint size = minHeap.size() + maxHeap.size();\nif (size == 0)\nthrow exception( \"No numbers are available\" );\n\nT median = 0;\nif (size & 1 == 1)\nmedian = minHeap[0];\nelse\nmedian = (minHeap[0] + maxHeap[0]) / 2;\n\nreturn median;\n}\n\nprivate :\nvector<T> minHeap;\nvector<T> maxHeap;\n};\n\nIn the code above, function Insert is used to insert a new number deserialized from a stream, and GetMedian is used to get the median of the existing numbers dynamically.", "question": "\nQuestion: How to get the median from a stream of numbers at any time? The median is middle value of numbers. If the count of numbers is even, the median is defined as the average value of the two numbers in middle.\n"},
{"answer": "\nAnalysis : It is a popular interview question. Similar to the problem to get the K th node from end is a list, it has a solution with two pointers.\n\nTwo pointers are initialized at the head of list. One pointer forwards once at each step, and the other forwards twice at each step. If the faster pointer meets the slower one again, there is a loop in the list. Otherwise there is no loop if the faster one reaches the end of list.\n\nThe sample code below is implemented according to this solution. The faster pointer is pFast , and the slower one is pSlow .\n\nbool HasLoop(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn false ;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn false ;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn true ;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn false ;\n}\n\n\nAnalysis : Inspired by the solution of the first problem, we can also solve this problem with two pointers.\n\n\nTwo pointers are initialized at the head of a list. If there are n nodes in the loop, the first pointer forwards n steps firstly. And then they forward together, at same speed. When the second pointer reaches the entry node of loop, the first one travels around the loop and returns back to entry node.\n\nLet us take the list in Figure 1 as an example. Two pointers, P1 and P2 are firstly initialized at the head node of the list (Figure 2-a). There are 4 nodes in the loop of list, so P1 moves 4 steps ahead, and reaches the node with value 5 (Figure 2-b). And then these two pointers move for 2 steps, and they meet at the node with value 3, which is the entry node of the loop.\n\nThe only problem is how to get the numbers in a loop. Let go back to the solution of the first question. We define two pointers, and the faster one meets the slower one if there is a loop. Actually, the meeting node should be inside the loop. Therefore, we can move forward from the meeting node and get the number of nodes in the loop when we arrive at the meeting node again.\n\nThe following function MeetingNode gets the meeting node of two pointers if there is a loop in a list, which is a minor modification of the previous HasLoop :\n\nListNode* MeetingNode(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn NULL;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn NULL;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn pFast;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn NULL;\n}\n\nWe can get the number of nodes in a loop of a list, and the entry node of loop after we know the meeting node, as shown below:\n\nListNode* EntryNodeOfLoop(ListNode* pHead)\n{\nListNode* meetingNode = MeetingNode(pHead);\nif (meetingNode == NULL)\nreturn NULL;\n\n// get the number of nodes in loop\nint nodesInLoop = 1;\nListNode* pNode1 = meetingNode;\nwhile (pNode1->m_pNext != meetingNode)\n{\npNode1 = pNode1->m_pNext;\n++nodesInLoop;\n}\n\n// move pNode1\npNode1 = pHead;\nfor ( int i = 0; i < nodesInLoop; ++i)\npNode1 = pNode1->m_pNext;\n\n// move pNode1 and pNode2\nListNode* pNode2 = pHead;\nwhile (pNode1 != pNode2)\n{\npNode1 = pNode1->m_pNext;\npNode2 = pNode2->m_pNext;\n}\n\nreturn pNode1;\n}", "question": "\nQuestion 1 : How to check whether there is a loop in a linked list? For example, the list in Figure 1 has a loop.\n\nA node in list is defined as the following structure:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n\n\nQuestion 2 : If there is a loop in a linked list, how to get the entry node of the loop? The entry node is the first node in the loop from head of list. For instance, the entry node of loop in the list of Figure 1 is the node with value 3.\n"},
{"answer": "\nAnalysis : It is a popular interview question. Similar to the problem to get the K th node from end is a list, it has a solution with two pointers.\n\nTwo pointers are initialized at the head of list. One pointer forwards once at each step, and the other forwards twice at each step. If the faster pointer meets the slower one again, there is a loop in the list. Otherwise there is no loop if the faster one reaches the end of list.\n\nThe sample code below is implemented according to this solution. The faster pointer is pFast , and the slower one is pSlow .\n\nbool HasLoop(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn false ;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn false ;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn true ;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn false ;\n}\n\n\nAnalysis : Inspired by the solution of the first problem, we can also solve this problem with two pointers.\n\n\nTwo pointers are initialized at the head of a list. If there are n nodes in the loop, the first pointer forwards n steps firstly. And then they forward together, at same speed. When the second pointer reaches the entry node of loop, the first one travels around the loop and returns back to entry node.\n\nLet us take the list in Figure 1 as an example. Two pointers, P1 and P2 are firstly initialized at the head node of the list (Figure 2-a). There are 4 nodes in the loop of list, so P1 moves 4 steps ahead, and reaches the node with value 5 (Figure 2-b). And then these two pointers move for 2 steps, and they meet at the node with value 3, which is the entry node of the loop.\n\nThe only problem is how to get the numbers in a loop. Let go back to the solution of the first question. We define two pointers, and the faster one meets the slower one if there is a loop. Actually, the meeting node should be inside the loop. Therefore, we can move forward from the meeting node and get the number of nodes in the loop when we arrive at the meeting node again.\n\nThe following function MeetingNode gets the meeting node of two pointers if there is a loop in a list, which is a minor modification of the previous HasLoop :\n\nListNode* MeetingNode(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn NULL;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn NULL;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn pFast;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn NULL;\n}\n\nWe can get the number of nodes in a loop of a list, and the entry node of loop after we know the meeting node, as shown below:\n\nListNode* EntryNodeOfLoop(ListNode* pHead)\n{\nListNode* meetingNode = MeetingNode(pHead);\nif (meetingNode == NULL)\nreturn NULL;\n\n// get the number of nodes in loop\nint nodesInLoop = 1;\nListNode* pNode1 = meetingNode;\nwhile (pNode1->m_pNext != meetingNode)\n{\npNode1 = pNode1->m_pNext;\n++nodesInLoop;\n}\n\n// move pNode1\npNode1 = pHead;\nfor ( int i = 0; i < nodesInLoop; ++i)\npNode1 = pNode1->m_pNext;\n\n// move pNode1 and pNode2\nListNode* pNode2 = pHead;\nwhile (pNode1 != pNode2)\n{\npNode1 = pNode1->m_pNext;\npNode2 = pNode2->m_pNext;\n}\n\nreturn pNode1;\n}", "question": "\nQuestion 1 : How to check whether there is a loop in a linked list? For example, the list in Figure 1 has a loop.\n\nA node in list is defined as the following structure:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n\n\nQuestion 2 : If there is a loop in a linked list, how to get the entry node of the loop? The entry node is the first node in the loop from head of list. For instance, the entry node of loop in the list of Figure 1 is the node with value 3.\n"},
{"answer": "\nAnalysis: Since numbers come from a stream, the count of numbers is dynamic, and increases over time. If a data container is defined for the numbers from a stream, new numbers will be inserted into the container when they are deserialized. Let us find an appropriate data structure for such a data container.\n\nAn array is the simplest choice. The array should be sorted, because we are going to get its median. Even though it only costs O(lg n ) time to find the position to be inserted with binary search algorithm, it costs O( n ) time to insert a number into a sorted array, because O( n ) numbers will be moved if there are n numbers in the array. It is very efficient to get the median, since it only takes O(1) time to access to a number in an array with an index.\n\nA sorted list is another choice. It takes O( n ) time to find the appropriate position to insert a new number. Additionally, the time to get the median can be optimized to O(1) if we define two pointers which points to the central one or two elements.\n\nA better choice available is a binary search tree, because it only costs O(lg n ) on average to insert a new node. However, the time complexity is O( n ) for the worst cases, when numbers are inserted in sorted (increasingly or decreasingly) order. To get the median number from a binary search tree, auxiliary data to record the number of nodes of its sub-tree is necessary for each node. It also requires O(lg n ) time to get the median node on overage, but O( n ) time for the worst cases.\n\nWe may utilize a balanced binary search tree, AVL, to avoid the worst cases. Usually the balance factor of a node in AVL trees is the height difference between its right sub-tree and left sub-tree. We may modify a little bit here: Define the balance factor as the difference of number of nodes between its right sub-tree and left sub-tree. It costs O(lg n ) time to insert a new node into an AVL, and O(1) time to get the median for all cases.\n\nAn AVL is efficient, but it is not implemented unfortunately in libraries of the most common programming languages. It is also very difficult for candidates to implement the left/right rotation of AVL trees in dozens of minutes during interview. Let us looks for better solutions.\n\nAs shown in Figure 1, if all numbers are sorted, the numbers which are related to the median are indexed by P1 and P2. If the count of numbers is odd, P1 and P2 point to the same central number. If the count is even, P1 and P2 point to two numbers in middle.\n\nMedian can be get or calculated with the numbers pointed by P1 are P2. It is noticeable that all numbers are divided into two parts. The numbers in the first half are less than the numbers in the second half. Moreover, the number indexed by P1 is the greatest number in the first half, and the number indexed by P2 is the least one in the second half.\nTherefore, numbers in the first half are inserted into a max heap, and numbers in the second half are inserted into a min heap. It costs O(lg n ) time to insert a number into a heap. Since the median can be get or calculated with the root of a min heap and a max heap, it only takes O(1) time.\n\nTable 1 compares the solutions above with a sorted array, a sorted list, a binary search tree, an AVL tree, as well as a min heap and a max heap.\nType for Data Container Time to Insert Time to Get Median Sorted Array O( n ) O(1) Sorted List O( n ) O(1) Binary Search Tree O(lg n ) on   average, O( n ) for the worst cases O(lg n ) on average,   O( n ) for the worst cases AVL O(lg n ) O(1) Max Heap and Min Heap O(lg n ) O(1)\nType for Data Container\nTime to Insert\nTime to Get Median\nSorted Array\nO( n )\nO(1)\nSorted List\nO( n )\nO(1)\nBinary Search Tree\nO(lg n ) on   average, O( n ) for the worst cases\nO(lg n ) on average,   O( n ) for the worst cases\nAVL\nO(lg n )\nO(1)\nMax Heap and Min Heap\nO(lg n )\nO(1)\nTable 1: Summary of solutions with a sorted array, a sorted list, a binary search tree, an AVL tree, as well as a min heap and a max heap.\n\nLet us consider the implementation details. All numbers should be evenly divided into two parts, so the count of number in min heap and max heap should diff 1 at most. To achieve such a division, a new number is inserted into the min heap if the count of existing numbers is even; otherwise it is inserted into the max heap.\n\nWe also should make sure that the numbers in the max heap are less than the numbers in the min heap. Supposing the count of existing numbers is even, a new number will be inserted into the min heap. If the new number is less than some numbers in the max heap, it violates our rule that all numbers in the min heap should be greater than numbers in the min heap.\n\nIn such a case, we can insert the new number into the max heap first, and then pop the greatest number from the max heap, and push it into the min heap. Since the number pushed into the min heap is the former greatest number in the max heap, all numbers in the min heap are greater than numbers in the max heap with the newly inserted number.\n\nThe situation is similar when the count of existing numbers is odd and the new number to be inserted is greater than some numbers in the min heap. Please analyze the insertion process carefully by yourself.\n\nThe following is sample code in C++. Even though there are no types for heaps in STL, we can build heaps with vectors utilizing function push_heap and pop_heap . Comparing functor less and greater are employed for max heaps and min heaps correspondingly.\n\ntemplate < typename T> class DynamicArray\n{\npublic :\nvoid Insert(T num)\n{\nif (((minHeap.size() + maxHeap.size()) & 1) == 0)\n{\nif (maxHeap.size() > 0 && num < maxHeap[0])\n{\nmaxHeap.push_back(num);\npush_heap(maxHeap.begin(), maxHeap.end(), less<T>());\n\nnum = maxHeap[0];\n\npop_heap(maxHeap.begin(), maxHeap.end(), less<T>());\nmaxHeap.pop_back();\n}\n\nminHeap.push_back(num);\npush_heap(minHeap.begin(), minHeap.end(), greater<T>());\n}\nelse\n{\nif (minHeap.size() > 0 && minHeap[0] < num)\n{\nminHeap.push_back(num);\npush_heap(minHeap.begin(), minHeap.end(), greater<T>());\n\nnum = minHeap[0];\n\npop_heap(minHeap.begin(), minHeap.end(), greater<T>());\nminHeap.pop_back();\n}\n\nmaxHeap.push_back(num);\npush_heap(maxHeap.begin(), maxHeap.end(), less<T>());\n}\n}\n\nint GetMedian()\n{\nint size = minHeap.size() + maxHeap.size();\nif (size == 0)\nthrow exception( \"No numbers are available\" );\n\nT median = 0;\nif (size & 1 == 1)\nmedian = minHeap[0];\nelse\nmedian = (minHeap[0] + maxHeap[0]) / 2;\n\nreturn median;\n}\n\nprivate :\nvector<T> minHeap;\nvector<T> maxHeap;\n};\n\nIn the code above, function Insert is used to insert a new number deserialized from a stream, and GetMedian is used to get the median of the existing numbers dynamically.", "question": "\nQuestion: How to get the median from a stream of numbers at any time? The median is middle value of numbers. If the count of numbers is even, the median is defined as the average value of the two numbers in middle.\n"},
{"answer": "\nAnalysis : It is a popular interview question. Similar to the problem to get the K th node from end is a list, it has a solution with two pointers.\n\nTwo pointers are initialized at the head of list. One pointer forwards once at each step, and the other forwards twice at each step. If the faster pointer meets the slower one again, there is a loop in the list. Otherwise there is no loop if the faster one reaches the end of list.\n\nThe sample code below is implemented according to this solution. The faster pointer is pFast , and the slower one is pSlow .\n\nbool HasLoop(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn false ;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn false ;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn true ;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn false ;\n}\n\n\nAnalysis : Inspired by the solution of the first problem, we can also solve this problem with two pointers.\n\n\nTwo pointers are initialized at the head of a list. If there are n nodes in the loop, the first pointer forwards n steps firstly. And then they forward together, at same speed. When the second pointer reaches the entry node of loop, the first one travels around the loop and returns back to entry node.\n\nLet us take the list in Figure 1 as an example. Two pointers, P1 and P2 are firstly initialized at the head node of the list (Figure 2-a). There are 4 nodes in the loop of list, so P1 moves 4 steps ahead, and reaches the node with value 5 (Figure 2-b). And then these two pointers move for 2 steps, and they meet at the node with value 3, which is the entry node of the loop.\n\nThe only problem is how to get the numbers in a loop. Let go back to the solution of the first question. We define two pointers, and the faster one meets the slower one if there is a loop. Actually, the meeting node should be inside the loop. Therefore, we can move forward from the meeting node and get the number of nodes in the loop when we arrive at the meeting node again.\n\nThe following function MeetingNode gets the meeting node of two pointers if there is a loop in a list, which is a minor modification of the previous HasLoop :\n\nListNode* MeetingNode(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn NULL;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn NULL;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn pFast;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn NULL;\n}\n\nWe can get the number of nodes in a loop of a list, and the entry node of loop after we know the meeting node, as shown below:\n\nListNode* EntryNodeOfLoop(ListNode* pHead)\n{\nListNode* meetingNode = MeetingNode(pHead);\nif (meetingNode == NULL)\nreturn NULL;\n\n// get the number of nodes in loop\nint nodesInLoop = 1;\nListNode* pNode1 = meetingNode;\nwhile (pNode1->m_pNext != meetingNode)\n{\npNode1 = pNode1->m_pNext;\n++nodesInLoop;\n}\n\n// move pNode1\npNode1 = pHead;\nfor ( int i = 0; i < nodesInLoop; ++i)\npNode1 = pNode1->m_pNext;\n\n// move pNode1 and pNode2\nListNode* pNode2 = pHead;\nwhile (pNode1 != pNode2)\n{\npNode1 = pNode1->m_pNext;\npNode2 = pNode2->m_pNext;\n}\n\nreturn pNode1;\n}", "question": "\nQuestion 1 : How to check whether there is a loop in a linked list? For example, the list in Figure 1 has a loop.\n\nA node in list is defined as the following structure:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n\n\nQuestion 2 : If there is a loop in a linked list, how to get the entry node of the loop? The entry node is the first node in the loop from head of list. For instance, the entry node of loop in the list of Figure 1 is the node with value 3.\n"},
{"answer": "\nAnalysis : It is a popular interview question. Similar to the problem to get the K th node from end is a list, it has a solution with two pointers.\n\nTwo pointers are initialized at the head of list. One pointer forwards once at each step, and the other forwards twice at each step. If the faster pointer meets the slower one again, there is a loop in the list. Otherwise there is no loop if the faster one reaches the end of list.\n\nThe sample code below is implemented according to this solution. The faster pointer is pFast , and the slower one is pSlow .\n\nbool HasLoop(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn false ;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn false ;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn true ;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn false ;\n}\n\n\nAnalysis : Inspired by the solution of the first problem, we can also solve this problem with two pointers.\n\n\nTwo pointers are initialized at the head of a list. If there are n nodes in the loop, the first pointer forwards n steps firstly. And then they forward together, at same speed. When the second pointer reaches the entry node of loop, the first one travels around the loop and returns back to entry node.\n\nLet us take the list in Figure 1 as an example. Two pointers, P1 and P2 are firstly initialized at the head node of the list (Figure 2-a). There are 4 nodes in the loop of list, so P1 moves 4 steps ahead, and reaches the node with value 5 (Figure 2-b). And then these two pointers move for 2 steps, and they meet at the node with value 3, which is the entry node of the loop.\n\nThe only problem is how to get the numbers in a loop. Let go back to the solution of the first question. We define two pointers, and the faster one meets the slower one if there is a loop. Actually, the meeting node should be inside the loop. Therefore, we can move forward from the meeting node and get the number of nodes in the loop when we arrive at the meeting node again.\n\nThe following function MeetingNode gets the meeting node of two pointers if there is a loop in a list, which is a minor modification of the previous HasLoop :\n\nListNode* MeetingNode(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn NULL;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn NULL;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn pFast;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn NULL;\n}\n\nWe can get the number of nodes in a loop of a list, and the entry node of loop after we know the meeting node, as shown below:\n\nListNode* EntryNodeOfLoop(ListNode* pHead)\n{\nListNode* meetingNode = MeetingNode(pHead);\nif (meetingNode == NULL)\nreturn NULL;\n\n// get the number of nodes in loop\nint nodesInLoop = 1;\nListNode* pNode1 = meetingNode;\nwhile (pNode1->m_pNext != meetingNode)\n{\npNode1 = pNode1->m_pNext;\n++nodesInLoop;\n}\n\n// move pNode1\npNode1 = pHead;\nfor ( int i = 0; i < nodesInLoop; ++i)\npNode1 = pNode1->m_pNext;\n\n// move pNode1 and pNode2\nListNode* pNode2 = pHead;\nwhile (pNode1 != pNode2)\n{\npNode1 = pNode1->m_pNext;\npNode2 = pNode2->m_pNext;\n}\n\nreturn pNode1;\n}", "question": "\nQuestion 1 : How to check whether there is a loop in a linked list? For example, the list in Figure 1 has a loop.\n\nA node in list is defined as the following structure:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n\n\nQuestion 2 : If there is a loop in a linked list, how to get the entry node of the loop? The entry node is the first node in the loop from head of list. For instance, the entry node of loop in the list of Figure 1 is the node with value 3.\n"},
{"answer": "\nAnalysis : It is a popular interview question. Similar to the problem to get the K th node from end is a list, it has a solution with two pointers.\n\nTwo pointers are initialized at the head of list. One pointer forwards once at each step, and the other forwards twice at each step. If the faster pointer meets the slower one again, there is a loop in the list. Otherwise there is no loop if the faster one reaches the end of list.\n\nThe sample code below is implemented according to this solution. The faster pointer is pFast , and the slower one is pSlow .\n\nbool HasLoop(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn false ;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn false ;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn true ;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn false ;\n}\n\n\nAnalysis : Inspired by the solution of the first problem, we can also solve this problem with two pointers.\n\n\nTwo pointers are initialized at the head of a list. If there are n nodes in the loop, the first pointer forwards n steps firstly. And then they forward together, at same speed. When the second pointer reaches the entry node of loop, the first one travels around the loop and returns back to entry node.\n\nLet us take the list in Figure 1 as an example. Two pointers, P1 and P2 are firstly initialized at the head node of the list (Figure 2-a). There are 4 nodes in the loop of list, so P1 moves 4 steps ahead, and reaches the node with value 5 (Figure 2-b). And then these two pointers move for 2 steps, and they meet at the node with value 3, which is the entry node of the loop.\n\nThe only problem is how to get the numbers in a loop. Let go back to the solution of the first question. We define two pointers, and the faster one meets the slower one if there is a loop. Actually, the meeting node should be inside the loop. Therefore, we can move forward from the meeting node and get the number of nodes in the loop when we arrive at the meeting node again.\n\nThe following function MeetingNode gets the meeting node of two pointers if there is a loop in a list, which is a minor modification of the previous HasLoop :\n\nListNode* MeetingNode(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn NULL;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn NULL;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn pFast;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn NULL;\n}\n\nWe can get the number of nodes in a loop of a list, and the entry node of loop after we know the meeting node, as shown below:\n\nListNode* EntryNodeOfLoop(ListNode* pHead)\n{\nListNode* meetingNode = MeetingNode(pHead);\nif (meetingNode == NULL)\nreturn NULL;\n\n// get the number of nodes in loop\nint nodesInLoop = 1;\nListNode* pNode1 = meetingNode;\nwhile (pNode1->m_pNext != meetingNode)\n{\npNode1 = pNode1->m_pNext;\n++nodesInLoop;\n}\n\n// move pNode1\npNode1 = pHead;\nfor ( int i = 0; i < nodesInLoop; ++i)\npNode1 = pNode1->m_pNext;\n\n// move pNode1 and pNode2\nListNode* pNode2 = pHead;\nwhile (pNode1 != pNode2)\n{\npNode1 = pNode1->m_pNext;\npNode2 = pNode2->m_pNext;\n}\n\nreturn pNode1;\n}", "question": "\nQuestion 1 : How to check whether there is a loop in a linked list? For example, the list in Figure 1 has a loop.\n\nA node in list is defined as the following structure:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n\n\nQuestion 2 : If there is a loop in a linked list, how to get the entry node of the loop? The entry node is the first node in the loop from head of list. For instance, the entry node of loop in the list of Figure 1 is the node with value 3.\n"},
{"answer": "\nAnalysis : It is a popular interview question. Similar to the problem to get the K th node from end is a list, it has a solution with two pointers.\n\nTwo pointers are initialized at the head of list. One pointer forwards once at each step, and the other forwards twice at each step. If the faster pointer meets the slower one again, there is a loop in the list. Otherwise there is no loop if the faster one reaches the end of list.\n\nThe sample code below is implemented according to this solution. The faster pointer is pFast , and the slower one is pSlow .\n\nbool HasLoop(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn false ;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn false ;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn true ;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn false ;\n}\n\n\nAnalysis : Inspired by the solution of the first problem, we can also solve this problem with two pointers.\n\n\nTwo pointers are initialized at the head of a list. If there are n nodes in the loop, the first pointer forwards n steps firstly. And then they forward together, at same speed. When the second pointer reaches the entry node of loop, the first one travels around the loop and returns back to entry node.\n\nLet us take the list in Figure 1 as an example. Two pointers, P1 and P2 are firstly initialized at the head node of the list (Figure 2-a). There are 4 nodes in the loop of list, so P1 moves 4 steps ahead, and reaches the node with value 5 (Figure 2-b). And then these two pointers move for 2 steps, and they meet at the node with value 3, which is the entry node of the loop.\n\nThe only problem is how to get the numbers in a loop. Let go back to the solution of the first question. We define two pointers, and the faster one meets the slower one if there is a loop. Actually, the meeting node should be inside the loop. Therefore, we can move forward from the meeting node and get the number of nodes in the loop when we arrive at the meeting node again.\n\nThe following function MeetingNode gets the meeting node of two pointers if there is a loop in a list, which is a minor modification of the previous HasLoop :\n\nListNode* MeetingNode(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn NULL;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn NULL;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn pFast;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn NULL;\n}\n\nWe can get the number of nodes in a loop of a list, and the entry node of loop after we know the meeting node, as shown below:\n\nListNode* EntryNodeOfLoop(ListNode* pHead)\n{\nListNode* meetingNode = MeetingNode(pHead);\nif (meetingNode == NULL)\nreturn NULL;\n\n// get the number of nodes in loop\nint nodesInLoop = 1;\nListNode* pNode1 = meetingNode;\nwhile (pNode1->m_pNext != meetingNode)\n{\npNode1 = pNode1->m_pNext;\n++nodesInLoop;\n}\n\n// move pNode1\npNode1 = pHead;\nfor ( int i = 0; i < nodesInLoop; ++i)\npNode1 = pNode1->m_pNext;\n\n// move pNode1 and pNode2\nListNode* pNode2 = pHead;\nwhile (pNode1 != pNode2)\n{\npNode1 = pNode1->m_pNext;\npNode2 = pNode2->m_pNext;\n}\n\nreturn pNode1;\n}", "question": "\nQuestion 1 : How to check whether there is a loop in a linked list? For example, the list in Figure 1 has a loop.\n\nA node in list is defined as the following structure:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n\n\nQuestion 2 : If there is a loop in a linked list, how to get the entry node of the loop? The entry node is the first node in the loop from head of list. For instance, the entry node of loop in the list of Figure 1 is the node with value 3.\n"},
{"answer": "\nAnalysis: Binary search tree is an important data structure. It has a specific character: Each node is greater than or equal to nodes in its left sub-tree, and less than or equal to nodes in its right sub-tree.\n\nSolution 1: Verify value range of each node\n\nIf a binary search tree is scanned with pre-order traversal algorithm, the value in a root node is accessed to at first. After the root node is visited, it begins to scan nodes in the left sub-tree. The value of left sub-tree nodes should be less than or equal to the value of the root node. If value of a left sub-tree node is greater than the value of the root node, it violates the definition of binary search tree. It is similar for the right sub-tree.\n\nTherefore, when it visits a node in binary search tree, it narrows the value range of left sub-tree and right sub-tree under the current visited node. All nodes are visited with the pre-order traversal algorithm, and their value is verified. If value in any node violates its corresponding range, it is not a binary search tree.\n\nThe following sample code is implemented based on this pre-order traversal solution:\n\nbool isBST_Solution1(BinaryTreeNode* pRoot)\n{\nint min = numeric_limits< int >::min();\nint max = numeric_limits< int >::max();\nreturn isBSTCore_Solution1(pRoot, min, max);\n}\n\nbool isBSTCore_Solution1(BinaryTreeNode* pRoot, int min, int max)\n{\nif (pRoot == NULL)\nreturn true ;\n\nif (pRoot->nValue < min || pRoot->nValue > max)\nreturn false ;\n\nreturn isBSTCore_Solution1(pRoot->pLeft, min, pRoot->nValue)\n&& isBSTCore_Solution1(pRoot->pRight, pRoot->nValue, max);\n}\n\nIn the code above, value of each node should be in the range between min and max . The value of the current visited node is the maximal value of its left sub-tree, and the minimal value of its right sub-tree, so it updates the min and max arguments and verifies sub-trees recursively.\n\nSolution 2: Increasing in-order traversal sequence\n\nThe first solution is based on pre-order traversal algorithm. Let us have another try on in-order traversal. The in-order traversal sequence of the binary search tree in Figure 1 is: 4, 6, 8, 10, 12, 14 and 16. It is noticeable that the sequence is increasingly sorted.\n\nTherefore, a new solution is available: Nodes in a binary tree is scanned with in-order traversal, and compare value of each node against the value of the previously visited node. If the value of the previously visited node is greater than the value of current node, it breaks the definition of binary tree.\n\nThis solution might be implemented in C++ as the following code:\n\nbool isBST_Solution2(BinaryTreeNode* pRoot)\n{\nint prev = numeric_limits< int >::min();\nreturn isBSTCore_Solution2(pRoot, prev);\n}\n\nbool isBSTCore_Solution2(BinaryTreeNode* pRoot, int& prev)\n{\nif (pRoot == NULL)\nreturn true ;\n\nreturn isBSTCore_Solution2(pRoot->pLeft, prev) // previous node\n&& (pRoot->nValue >= prev) // current node\n&& isBSTCore_Solution2(pRoot->pRight, prev = pRoot->nValue); // next node\n}\n\nThe argument prev of the function isBSTCore_Solution2 above is the value of the previously visited node in pre_order traversal.", "question": "\nQuestion: How to verify whether a binary tree is a binary search tree?\n\nFor example, the tree in Figure 1 is a binary search tree.\n\n\nA node in binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pRight;\n};\n"},
{"answer": "\nAnalysis : It is a popular interview question. Similar to the problem to get the K th node from end is a list, it has a solution with two pointers.\n\nTwo pointers are initialized at the head of list. One pointer forwards once at each step, and the other forwards twice at each step. If the faster pointer meets the slower one again, there is a loop in the list. Otherwise there is no loop if the faster one reaches the end of list.\n\nThe sample code below is implemented according to this solution. The faster pointer is pFast , and the slower one is pSlow .\n\nbool HasLoop(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn false ;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn false ;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn true ;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn false ;\n}\n\n\nAnalysis : Inspired by the solution of the first problem, we can also solve this problem with two pointers.\n\n\nTwo pointers are initialized at the head of a list. If there are n nodes in the loop, the first pointer forwards n steps firstly. And then they forward together, at same speed. When the second pointer reaches the entry node of loop, the first one travels around the loop and returns back to entry node.\n\nLet us take the list in Figure 1 as an example. Two pointers, P1 and P2 are firstly initialized at the head node of the list (Figure 2-a). There are 4 nodes in the loop of list, so P1 moves 4 steps ahead, and reaches the node with value 5 (Figure 2-b). And then these two pointers move for 2 steps, and they meet at the node with value 3, which is the entry node of the loop.\n\nThe only problem is how to get the numbers in a loop. Let go back to the solution of the first question. We define two pointers, and the faster one meets the slower one if there is a loop. Actually, the meeting node should be inside the loop. Therefore, we can move forward from the meeting node and get the number of nodes in the loop when we arrive at the meeting node again.\n\nThe following function MeetingNode gets the meeting node of two pointers if there is a loop in a list, which is a minor modification of the previous HasLoop :\n\nListNode* MeetingNode(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn NULL;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn NULL;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn pFast;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn NULL;\n}\n\nWe can get the number of nodes in a loop of a list, and the entry node of loop after we know the meeting node, as shown below:\n\nListNode* EntryNodeOfLoop(ListNode* pHead)\n{\nListNode* meetingNode = MeetingNode(pHead);\nif (meetingNode == NULL)\nreturn NULL;\n\n// get the number of nodes in loop\nint nodesInLoop = 1;\nListNode* pNode1 = meetingNode;\nwhile (pNode1->m_pNext != meetingNode)\n{\npNode1 = pNode1->m_pNext;\n++nodesInLoop;\n}\n\n// move pNode1\npNode1 = pHead;\nfor ( int i = 0; i < nodesInLoop; ++i)\npNode1 = pNode1->m_pNext;\n\n// move pNode1 and pNode2\nListNode* pNode2 = pHead;\nwhile (pNode1 != pNode2)\n{\npNode1 = pNode1->m_pNext;\npNode2 = pNode2->m_pNext;\n}\n\nreturn pNode1;\n}", "question": "\nQuestion 1 : How to check whether there is a loop in a linked list? For example, the list in Figure 1 has a loop.\n\nA node in list is defined as the following structure:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n\n\nQuestion 2 : If there is a loop in a linked list, how to get the entry node of the loop? The entry node is the first node in the loop from head of list. For instance, the entry node of loop in the list of Figure 1 is the node with value 3.\n"},
{"answer": "\nAnalysis : It is a popular interview question. Similar to the problem to get the K th node from end is a list, it has a solution with two pointers.\n\nTwo pointers are initialized at the head of list. One pointer forwards once at each step, and the other forwards twice at each step. If the faster pointer meets the slower one again, there is a loop in the list. Otherwise there is no loop if the faster one reaches the end of list.\n\nThe sample code below is implemented according to this solution. The faster pointer is pFast , and the slower one is pSlow .\n\nbool HasLoop(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn false ;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn false ;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn true ;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn false ;\n}\n\n\nAnalysis : Inspired by the solution of the first problem, we can also solve this problem with two pointers.\n\n\nTwo pointers are initialized at the head of a list. If there are n nodes in the loop, the first pointer forwards n steps firstly. And then they forward together, at same speed. When the second pointer reaches the entry node of loop, the first one travels around the loop and returns back to entry node.\n\nLet us take the list in Figure 1 as an example. Two pointers, P1 and P2 are firstly initialized at the head node of the list (Figure 2-a). There are 4 nodes in the loop of list, so P1 moves 4 steps ahead, and reaches the node with value 5 (Figure 2-b). And then these two pointers move for 2 steps, and they meet at the node with value 3, which is the entry node of the loop.\n\nThe only problem is how to get the numbers in a loop. Let go back to the solution of the first question. We define two pointers, and the faster one meets the slower one if there is a loop. Actually, the meeting node should be inside the loop. Therefore, we can move forward from the meeting node and get the number of nodes in the loop when we arrive at the meeting node again.\n\nThe following function MeetingNode gets the meeting node of two pointers if there is a loop in a list, which is a minor modification of the previous HasLoop :\n\nListNode* MeetingNode(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn NULL;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn NULL;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn pFast;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn NULL;\n}\n\nWe can get the number of nodes in a loop of a list, and the entry node of loop after we know the meeting node, as shown below:\n\nListNode* EntryNodeOfLoop(ListNode* pHead)\n{\nListNode* meetingNode = MeetingNode(pHead);\nif (meetingNode == NULL)\nreturn NULL;\n\n// get the number of nodes in loop\nint nodesInLoop = 1;\nListNode* pNode1 = meetingNode;\nwhile (pNode1->m_pNext != meetingNode)\n{\npNode1 = pNode1->m_pNext;\n++nodesInLoop;\n}\n\n// move pNode1\npNode1 = pHead;\nfor ( int i = 0; i < nodesInLoop; ++i)\npNode1 = pNode1->m_pNext;\n\n// move pNode1 and pNode2\nListNode* pNode2 = pHead;\nwhile (pNode1 != pNode2)\n{\npNode1 = pNode1->m_pNext;\npNode2 = pNode2->m_pNext;\n}\n\nreturn pNode1;\n}", "question": "\nQuestion 1 : How to check whether there is a loop in a linked list? For example, the list in Figure 1 has a loop.\n\nA node in list is defined as the following structure:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n\n\nQuestion 2 : If there is a loop in a linked list, how to get the entry node of the loop? The entry node is the first node in the loop from head of list. For instance, the entry node of loop in the list of Figure 1 is the node with value 3.\n"},
{"answer": "\nAnalysis : It is a popular interview question. Similar to the problem to get the K th node from end is a list, it has a solution with two pointers.\n\nTwo pointers are initialized at the head of list. One pointer forwards once at each step, and the other forwards twice at each step. If the faster pointer meets the slower one again, there is a loop in the list. Otherwise there is no loop if the faster one reaches the end of list.\n\nThe sample code below is implemented according to this solution. The faster pointer is pFast , and the slower one is pSlow .\n\nbool HasLoop(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn false ;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn false ;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn true ;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn false ;\n}\n\n\nAnalysis : Inspired by the solution of the first problem, we can also solve this problem with two pointers.\n\n\nTwo pointers are initialized at the head of a list. If there are n nodes in the loop, the first pointer forwards n steps firstly. And then they forward together, at same speed. When the second pointer reaches the entry node of loop, the first one travels around the loop and returns back to entry node.\n\nLet us take the list in Figure 1 as an example. Two pointers, P1 and P2 are firstly initialized at the head node of the list (Figure 2-a). There are 4 nodes in the loop of list, so P1 moves 4 steps ahead, and reaches the node with value 5 (Figure 2-b). And then these two pointers move for 2 steps, and they meet at the node with value 3, which is the entry node of the loop.\n\nThe only problem is how to get the numbers in a loop. Let go back to the solution of the first question. We define two pointers, and the faster one meets the slower one if there is a loop. Actually, the meeting node should be inside the loop. Therefore, we can move forward from the meeting node and get the number of nodes in the loop when we arrive at the meeting node again.\n\nThe following function MeetingNode gets the meeting node of two pointers if there is a loop in a list, which is a minor modification of the previous HasLoop :\n\nListNode* MeetingNode(ListNode* pHead)\n{\nif (pHead == NULL)\nreturn NULL;\n\nListNode* pSlow = pHead->m_pNext;\nif (pSlow == NULL)\nreturn NULL;\n\nListNode* pFast = pSlow->m_pNext;\nwhile (pFast != NULL && pSlow != NULL)\n{\nif (pFast == pSlow)\nreturn pFast;\n\npSlow = pSlow->m_pNext;\n\npFast = pFast->m_pNext;\nif (pFast != NULL)\npFast = pFast->m_pNext;\n}\n\nreturn NULL;\n}\n\nWe can get the number of nodes in a loop of a list, and the entry node of loop after we know the meeting node, as shown below:\n\nListNode* EntryNodeOfLoop(ListNode* pHead)\n{\nListNode* meetingNode = MeetingNode(pHead);\nif (meetingNode == NULL)\nreturn NULL;\n\n// get the number of nodes in loop\nint nodesInLoop = 1;\nListNode* pNode1 = meetingNode;\nwhile (pNode1->m_pNext != meetingNode)\n{\npNode1 = pNode1->m_pNext;\n++nodesInLoop;\n}\n\n// move pNode1\npNode1 = pHead;\nfor ( int i = 0; i < nodesInLoop; ++i)\npNode1 = pNode1->m_pNext;\n\n// move pNode1 and pNode2\nListNode* pNode2 = pHead;\nwhile (pNode1 != pNode2)\n{\npNode1 = pNode1->m_pNext;\npNode2 = pNode2->m_pNext;\n}\n\nreturn pNode1;\n}", "question": "\nQuestion 1 : How to check whether there is a loop in a linked list? For example, the list in Figure 1 has a loop.\n\nA node in list is defined as the following structure:\n\nstruct ListNode\n{\nint m_nValue;\nListNode* m_pNext;\n};\n\n\nQuestion 2 : If there is a loop in a linked list, how to get the entry node of the loop? The entry node is the first node in the loop from head of list. For instance, the entry node of loop in the list of Figure 1 is the node with value 3.\n"},
{"answer": "\nAnalysis: Binary search tree is an important data structure. It has a specific character: Each node is greater than or equal to nodes in its left sub-tree, and less than or equal to nodes in its right sub-tree.\n\nSolution 1: Verify value range of each node\n\nIf a binary search tree is scanned with pre-order traversal algorithm, the value in a root node is accessed to at first. After the root node is visited, it begins to scan nodes in the left sub-tree. The value of left sub-tree nodes should be less than or equal to the value of the root node. If value of a left sub-tree node is greater than the value of the root node, it violates the definition of binary search tree. It is similar for the right sub-tree.\n\nTherefore, when it visits a node in binary search tree, it narrows the value range of left sub-tree and right sub-tree under the current visited node. All nodes are visited with the pre-order traversal algorithm, and their value is verified. If value in any node violates its corresponding range, it is not a binary search tree.\n\nThe following sample code is implemented based on this pre-order traversal solution:\n\nbool isBST_Solution1(BinaryTreeNode* pRoot)\n{\nint min = numeric_limits< int >::min();\nint max = numeric_limits< int >::max();\nreturn isBSTCore_Solution1(pRoot, min, max);\n}\n\nbool isBSTCore_Solution1(BinaryTreeNode* pRoot, int min, int max)\n{\nif (pRoot == NULL)\nreturn true ;\n\nif (pRoot->nValue < min || pRoot->nValue > max)\nreturn false ;\n\nreturn isBSTCore_Solution1(pRoot->pLeft, min, pRoot->nValue)\n&& isBSTCore_Solution1(pRoot->pRight, pRoot->nValue, max);\n}\n\nIn the code above, value of each node should be in the range between min and max . The value of the current visited node is the maximal value of its left sub-tree, and the minimal value of its right sub-tree, so it updates the min and max arguments and verifies sub-trees recursively.\n\nSolution 2: Increasing in-order traversal sequence\n\nThe first solution is based on pre-order traversal algorithm. Let us have another try on in-order traversal. The in-order traversal sequence of the binary search tree in Figure 1 is: 4, 6, 8, 10, 12, 14 and 16. It is noticeable that the sequence is increasingly sorted.\n\nTherefore, a new solution is available: Nodes in a binary tree is scanned with in-order traversal, and compare value of each node against the value of the previously visited node. If the value of the previously visited node is greater than the value of current node, it breaks the definition of binary tree.\n\nThis solution might be implemented in C++ as the following code:\n\nbool isBST_Solution2(BinaryTreeNode* pRoot)\n{\nint prev = numeric_limits< int >::min();\nreturn isBSTCore_Solution2(pRoot, prev);\n}\n\nbool isBSTCore_Solution2(BinaryTreeNode* pRoot, int& prev)\n{\nif (pRoot == NULL)\nreturn true ;\n\nreturn isBSTCore_Solution2(pRoot->pLeft, prev) // previous node\n&& (pRoot->nValue >= prev) // current node\n&& isBSTCore_Solution2(pRoot->pRight, prev = pRoot->nValue); // next node\n}\n\nThe argument prev of the function isBSTCore_Solution2 above is the value of the previously visited node in pre_order traversal.", "question": "\nQuestion: How to verify whether a binary tree is a binary search tree?\n\nFor example, the tree in Figure 1 is a binary search tree.\n\n\nA node in binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pRight;\n};\n"},
{"answer": "\nAnalysis: Binary search tree is an important data structure. It has a specific character: Each node is greater than or equal to nodes in its left sub-tree, and less than or equal to nodes in its right sub-tree.\n\nSolution 1: Verify value range of each node\n\nIf a binary search tree is scanned with pre-order traversal algorithm, the value in a root node is accessed to at first. After the root node is visited, it begins to scan nodes in the left sub-tree. The value of left sub-tree nodes should be less than or equal to the value of the root node. If value of a left sub-tree node is greater than the value of the root node, it violates the definition of binary search tree. It is similar for the right sub-tree.\n\nTherefore, when it visits a node in binary search tree, it narrows the value range of left sub-tree and right sub-tree under the current visited node. All nodes are visited with the pre-order traversal algorithm, and their value is verified. If value in any node violates its corresponding range, it is not a binary search tree.\n\nThe following sample code is implemented based on this pre-order traversal solution:\n\nbool isBST_Solution1(BinaryTreeNode* pRoot)\n{\nint min = numeric_limits< int >::min();\nint max = numeric_limits< int >::max();\nreturn isBSTCore_Solution1(pRoot, min, max);\n}\n\nbool isBSTCore_Solution1(BinaryTreeNode* pRoot, int min, int max)\n{\nif (pRoot == NULL)\nreturn true ;\n\nif (pRoot->nValue < min || pRoot->nValue > max)\nreturn false ;\n\nreturn isBSTCore_Solution1(pRoot->pLeft, min, pRoot->nValue)\n&& isBSTCore_Solution1(pRoot->pRight, pRoot->nValue, max);\n}\n\nIn the code above, value of each node should be in the range between min and max . The value of the current visited node is the maximal value of its left sub-tree, and the minimal value of its right sub-tree, so it updates the min and max arguments and verifies sub-trees recursively.\n\nSolution 2: Increasing in-order traversal sequence\n\nThe first solution is based on pre-order traversal algorithm. Let us have another try on in-order traversal. The in-order traversal sequence of the binary search tree in Figure 1 is: 4, 6, 8, 10, 12, 14 and 16. It is noticeable that the sequence is increasingly sorted.\n\nTherefore, a new solution is available: Nodes in a binary tree is scanned with in-order traversal, and compare value of each node against the value of the previously visited node. If the value of the previously visited node is greater than the value of current node, it breaks the definition of binary tree.\n\nThis solution might be implemented in C++ as the following code:\n\nbool isBST_Solution2(BinaryTreeNode* pRoot)\n{\nint prev = numeric_limits< int >::min();\nreturn isBSTCore_Solution2(pRoot, prev);\n}\n\nbool isBSTCore_Solution2(BinaryTreeNode* pRoot, int& prev)\n{\nif (pRoot == NULL)\nreturn true ;\n\nreturn isBSTCore_Solution2(pRoot->pLeft, prev) // previous node\n&& (pRoot->nValue >= prev) // current node\n&& isBSTCore_Solution2(pRoot->pRight, prev = pRoot->nValue); // next node\n}\n\nThe argument prev of the function isBSTCore_Solution2 above is the value of the previously visited node in pre_order traversal.", "question": "\nQuestion: How to verify whether a binary tree is a binary search tree?\n\nFor example, the tree in Figure 1 is a binary search tree.\n\n\nA node in binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pRight;\n};\n"},
{"answer": "\nAnalysis: Binary search tree is an important data structure. It has a specific character: Each node is greater than or equal to nodes in its left sub-tree, and less than or equal to nodes in its right sub-tree.\n\nSolution 1: Verify value range of each node\n\nIf a binary search tree is scanned with pre-order traversal algorithm, the value in a root node is accessed to at first. After the root node is visited, it begins to scan nodes in the left sub-tree. The value of left sub-tree nodes should be less than or equal to the value of the root node. If value of a left sub-tree node is greater than the value of the root node, it violates the definition of binary search tree. It is similar for the right sub-tree.\n\nTherefore, when it visits a node in binary search tree, it narrows the value range of left sub-tree and right sub-tree under the current visited node. All nodes are visited with the pre-order traversal algorithm, and their value is verified. If value in any node violates its corresponding range, it is not a binary search tree.\n\nThe following sample code is implemented based on this pre-order traversal solution:\n\nbool isBST_Solution1(BinaryTreeNode* pRoot)\n{\nint min = numeric_limits< int >::min();\nint max = numeric_limits< int >::max();\nreturn isBSTCore_Solution1(pRoot, min, max);\n}\n\nbool isBSTCore_Solution1(BinaryTreeNode* pRoot, int min, int max)\n{\nif (pRoot == NULL)\nreturn true ;\n\nif (pRoot->nValue < min || pRoot->nValue > max)\nreturn false ;\n\nreturn isBSTCore_Solution1(pRoot->pLeft, min, pRoot->nValue)\n&& isBSTCore_Solution1(pRoot->pRight, pRoot->nValue, max);\n}\n\nIn the code above, value of each node should be in the range between min and max . The value of the current visited node is the maximal value of its left sub-tree, and the minimal value of its right sub-tree, so it updates the min and max arguments and verifies sub-trees recursively.\n\nSolution 2: Increasing in-order traversal sequence\n\nThe first solution is based on pre-order traversal algorithm. Let us have another try on in-order traversal. The in-order traversal sequence of the binary search tree in Figure 1 is: 4, 6, 8, 10, 12, 14 and 16. It is noticeable that the sequence is increasingly sorted.\n\nTherefore, a new solution is available: Nodes in a binary tree is scanned with in-order traversal, and compare value of each node against the value of the previously visited node. If the value of the previously visited node is greater than the value of current node, it breaks the definition of binary tree.\n\nThis solution might be implemented in C++ as the following code:\n\nbool isBST_Solution2(BinaryTreeNode* pRoot)\n{\nint prev = numeric_limits< int >::min();\nreturn isBSTCore_Solution2(pRoot, prev);\n}\n\nbool isBSTCore_Solution2(BinaryTreeNode* pRoot, int& prev)\n{\nif (pRoot == NULL)\nreturn true ;\n\nreturn isBSTCore_Solution2(pRoot->pLeft, prev) // previous node\n&& (pRoot->nValue >= prev) // current node\n&& isBSTCore_Solution2(pRoot->pRight, prev = pRoot->nValue); // next node\n}\n\nThe argument prev of the function isBSTCore_Solution2 above is the value of the previously visited node in pre_order traversal.", "question": "\nQuestion: How to verify whether a binary tree is a binary search tree?\n\nFor example, the tree in Figure 1 is a binary search tree.\n\n\nA node in binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pRight;\n};\n"},
{"answer": "\nAnalysis: Binary search tree is an important data structure. It has a specific character: Each node is greater than or equal to nodes in its left sub-tree, and less than or equal to nodes in its right sub-tree.\n\nSolution 1: Verify value range of each node\n\nIf a binary search tree is scanned with pre-order traversal algorithm, the value in a root node is accessed to at first. After the root node is visited, it begins to scan nodes in the left sub-tree. The value of left sub-tree nodes should be less than or equal to the value of the root node. If value of a left sub-tree node is greater than the value of the root node, it violates the definition of binary search tree. It is similar for the right sub-tree.\n\nTherefore, when it visits a node in binary search tree, it narrows the value range of left sub-tree and right sub-tree under the current visited node. All nodes are visited with the pre-order traversal algorithm, and their value is verified. If value in any node violates its corresponding range, it is not a binary search tree.\n\nThe following sample code is implemented based on this pre-order traversal solution:\n\nbool isBST_Solution1(BinaryTreeNode* pRoot)\n{\nint min = numeric_limits< int >::min();\nint max = numeric_limits< int >::max();\nreturn isBSTCore_Solution1(pRoot, min, max);\n}\n\nbool isBSTCore_Solution1(BinaryTreeNode* pRoot, int min, int max)\n{\nif (pRoot == NULL)\nreturn true ;\n\nif (pRoot->nValue < min || pRoot->nValue > max)\nreturn false ;\n\nreturn isBSTCore_Solution1(pRoot->pLeft, min, pRoot->nValue)\n&& isBSTCore_Solution1(pRoot->pRight, pRoot->nValue, max);\n}\n\nIn the code above, value of each node should be in the range between min and max . The value of the current visited node is the maximal value of its left sub-tree, and the minimal value of its right sub-tree, so it updates the min and max arguments and verifies sub-trees recursively.\n\nSolution 2: Increasing in-order traversal sequence\n\nThe first solution is based on pre-order traversal algorithm. Let us have another try on in-order traversal. The in-order traversal sequence of the binary search tree in Figure 1 is: 4, 6, 8, 10, 12, 14 and 16. It is noticeable that the sequence is increasingly sorted.\n\nTherefore, a new solution is available: Nodes in a binary tree is scanned with in-order traversal, and compare value of each node against the value of the previously visited node. If the value of the previously visited node is greater than the value of current node, it breaks the definition of binary tree.\n\nThis solution might be implemented in C++ as the following code:\n\nbool isBST_Solution2(BinaryTreeNode* pRoot)\n{\nint prev = numeric_limits< int >::min();\nreturn isBSTCore_Solution2(pRoot, prev);\n}\n\nbool isBSTCore_Solution2(BinaryTreeNode* pRoot, int& prev)\n{\nif (pRoot == NULL)\nreturn true ;\n\nreturn isBSTCore_Solution2(pRoot->pLeft, prev) // previous node\n&& (pRoot->nValue >= prev) // current node\n&& isBSTCore_Solution2(pRoot->pRight, prev = pRoot->nValue); // next node\n}\n\nThe argument prev of the function isBSTCore_Solution2 above is the value of the previously visited node in pre_order traversal.", "question": "\nQuestion: How to verify whether a binary tree is a binary search tree?\n\nFor example, the tree in Figure 1 is a binary search tree.\n\n\nA node in binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pRight;\n};\n"},
{"answer": "\nAnalysis: Binary search tree is an important data structure. It has a specific character: Each node is greater than or equal to nodes in its left sub-tree, and less than or equal to nodes in its right sub-tree.\n\nSolution 1: Verify value range of each node\n\nIf a binary search tree is scanned with pre-order traversal algorithm, the value in a root node is accessed to at first. After the root node is visited, it begins to scan nodes in the left sub-tree. The value of left sub-tree nodes should be less than or equal to the value of the root node. If value of a left sub-tree node is greater than the value of the root node, it violates the definition of binary search tree. It is similar for the right sub-tree.\n\nTherefore, when it visits a node in binary search tree, it narrows the value range of left sub-tree and right sub-tree under the current visited node. All nodes are visited with the pre-order traversal algorithm, and their value is verified. If value in any node violates its corresponding range, it is not a binary search tree.\n\nThe following sample code is implemented based on this pre-order traversal solution:\n\nbool isBST_Solution1(BinaryTreeNode* pRoot)\n{\nint min = numeric_limits< int >::min();\nint max = numeric_limits< int >::max();\nreturn isBSTCore_Solution1(pRoot, min, max);\n}\n\nbool isBSTCore_Solution1(BinaryTreeNode* pRoot, int min, int max)\n{\nif (pRoot == NULL)\nreturn true ;\n\nif (pRoot->nValue < min || pRoot->nValue > max)\nreturn false ;\n\nreturn isBSTCore_Solution1(pRoot->pLeft, min, pRoot->nValue)\n&& isBSTCore_Solution1(pRoot->pRight, pRoot->nValue, max);\n}\n\nIn the code above, value of each node should be in the range between min and max . The value of the current visited node is the maximal value of its left sub-tree, and the minimal value of its right sub-tree, so it updates the min and max arguments and verifies sub-trees recursively.\n\nSolution 2: Increasing in-order traversal sequence\n\nThe first solution is based on pre-order traversal algorithm. Let us have another try on in-order traversal. The in-order traversal sequence of the binary search tree in Figure 1 is: 4, 6, 8, 10, 12, 14 and 16. It is noticeable that the sequence is increasingly sorted.\n\nTherefore, a new solution is available: Nodes in a binary tree is scanned with in-order traversal, and compare value of each node against the value of the previously visited node. If the value of the previously visited node is greater than the value of current node, it breaks the definition of binary tree.\n\nThis solution might be implemented in C++ as the following code:\n\nbool isBST_Solution2(BinaryTreeNode* pRoot)\n{\nint prev = numeric_limits< int >::min();\nreturn isBSTCore_Solution2(pRoot, prev);\n}\n\nbool isBSTCore_Solution2(BinaryTreeNode* pRoot, int& prev)\n{\nif (pRoot == NULL)\nreturn true ;\n\nreturn isBSTCore_Solution2(pRoot->pLeft, prev) // previous node\n&& (pRoot->nValue >= prev) // current node\n&& isBSTCore_Solution2(pRoot->pRight, prev = pRoot->nValue); // next node\n}\n\nThe argument prev of the function isBSTCore_Solution2 above is the value of the previously visited node in pre_order traversal.", "question": "\nQuestion: How to verify whether a binary tree is a binary search tree?\n\nFor example, the tree in Figure 1 is a binary search tree.\n\n\nA node in binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pRight;\n};\n"},
{"answer": "\nAnalysis: Binary search tree is an important data structure. It has a specific character: Each node is greater than or equal to nodes in its left sub-tree, and less than or equal to nodes in its right sub-tree.\n\nSolution 1: Verify value range of each node\n\nIf a binary search tree is scanned with pre-order traversal algorithm, the value in a root node is accessed to at first. After the root node is visited, it begins to scan nodes in the left sub-tree. The value of left sub-tree nodes should be less than or equal to the value of the root node. If value of a left sub-tree node is greater than the value of the root node, it violates the definition of binary search tree. It is similar for the right sub-tree.\n\nTherefore, when it visits a node in binary search tree, it narrows the value range of left sub-tree and right sub-tree under the current visited node. All nodes are visited with the pre-order traversal algorithm, and their value is verified. If value in any node violates its corresponding range, it is not a binary search tree.\n\nThe following sample code is implemented based on this pre-order traversal solution:\n\nbool isBST_Solution1(BinaryTreeNode* pRoot)\n{\nint min = numeric_limits< int >::min();\nint max = numeric_limits< int >::max();\nreturn isBSTCore_Solution1(pRoot, min, max);\n}\n\nbool isBSTCore_Solution1(BinaryTreeNode* pRoot, int min, int max)\n{\nif (pRoot == NULL)\nreturn true ;\n\nif (pRoot->nValue < min || pRoot->nValue > max)\nreturn false ;\n\nreturn isBSTCore_Solution1(pRoot->pLeft, min, pRoot->nValue)\n&& isBSTCore_Solution1(pRoot->pRight, pRoot->nValue, max);\n}\n\nIn the code above, value of each node should be in the range between min and max . The value of the current visited node is the maximal value of its left sub-tree, and the minimal value of its right sub-tree, so it updates the min and max arguments and verifies sub-trees recursively.\n\nSolution 2: Increasing in-order traversal sequence\n\nThe first solution is based on pre-order traversal algorithm. Let us have another try on in-order traversal. The in-order traversal sequence of the binary search tree in Figure 1 is: 4, 6, 8, 10, 12, 14 and 16. It is noticeable that the sequence is increasingly sorted.\n\nTherefore, a new solution is available: Nodes in a binary tree is scanned with in-order traversal, and compare value of each node against the value of the previously visited node. If the value of the previously visited node is greater than the value of current node, it breaks the definition of binary tree.\n\nThis solution might be implemented in C++ as the following code:\n\nbool isBST_Solution2(BinaryTreeNode* pRoot)\n{\nint prev = numeric_limits< int >::min();\nreturn isBSTCore_Solution2(pRoot, prev);\n}\n\nbool isBSTCore_Solution2(BinaryTreeNode* pRoot, int& prev)\n{\nif (pRoot == NULL)\nreturn true ;\n\nreturn isBSTCore_Solution2(pRoot->pLeft, prev) // previous node\n&& (pRoot->nValue >= prev) // current node\n&& isBSTCore_Solution2(pRoot->pRight, prev = pRoot->nValue); // next node\n}\n\nThe argument prev of the function isBSTCore_Solution2 above is the value of the previously visited node in pre_order traversal.", "question": "\nQuestion: How to verify whether a binary tree is a binary search tree?\n\nFor example, the tree in Figure 1 is a binary search tree.\n\n\nA node in binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pRight;\n};\n"},
{"answer": "\nAnalysis: Binary search tree is an important data structure. It has a specific character: Each node is greater than or equal to nodes in its left sub-tree, and less than or equal to nodes in its right sub-tree.\n\nSolution 1: Verify value range of each node\n\nIf a binary search tree is scanned with pre-order traversal algorithm, the value in a root node is accessed to at first. After the root node is visited, it begins to scan nodes in the left sub-tree. The value of left sub-tree nodes should be less than or equal to the value of the root node. If value of a left sub-tree node is greater than the value of the root node, it violates the definition of binary search tree. It is similar for the right sub-tree.\n\nTherefore, when it visits a node in binary search tree, it narrows the value range of left sub-tree and right sub-tree under the current visited node. All nodes are visited with the pre-order traversal algorithm, and their value is verified. If value in any node violates its corresponding range, it is not a binary search tree.\n\nThe following sample code is implemented based on this pre-order traversal solution:\n\nbool isBST_Solution1(BinaryTreeNode* pRoot)\n{\nint min = numeric_limits< int >::min();\nint max = numeric_limits< int >::max();\nreturn isBSTCore_Solution1(pRoot, min, max);\n}\n\nbool isBSTCore_Solution1(BinaryTreeNode* pRoot, int min, int max)\n{\nif (pRoot == NULL)\nreturn true ;\n\nif (pRoot->nValue < min || pRoot->nValue > max)\nreturn false ;\n\nreturn isBSTCore_Solution1(pRoot->pLeft, min, pRoot->nValue)\n&& isBSTCore_Solution1(pRoot->pRight, pRoot->nValue, max);\n}\n\nIn the code above, value of each node should be in the range between min and max . The value of the current visited node is the maximal value of its left sub-tree, and the minimal value of its right sub-tree, so it updates the min and max arguments and verifies sub-trees recursively.\n\nSolution 2: Increasing in-order traversal sequence\n\nThe first solution is based on pre-order traversal algorithm. Let us have another try on in-order traversal. The in-order traversal sequence of the binary search tree in Figure 1 is: 4, 6, 8, 10, 12, 14 and 16. It is noticeable that the sequence is increasingly sorted.\n\nTherefore, a new solution is available: Nodes in a binary tree is scanned with in-order traversal, and compare value of each node against the value of the previously visited node. If the value of the previously visited node is greater than the value of current node, it breaks the definition of binary tree.\n\nThis solution might be implemented in C++ as the following code:\n\nbool isBST_Solution2(BinaryTreeNode* pRoot)\n{\nint prev = numeric_limits< int >::min();\nreturn isBSTCore_Solution2(pRoot, prev);\n}\n\nbool isBSTCore_Solution2(BinaryTreeNode* pRoot, int& prev)\n{\nif (pRoot == NULL)\nreturn true ;\n\nreturn isBSTCore_Solution2(pRoot->pLeft, prev) // previous node\n&& (pRoot->nValue >= prev) // current node\n&& isBSTCore_Solution2(pRoot->pRight, prev = pRoot->nValue); // next node\n}\n\nThe argument prev of the function isBSTCore_Solution2 above is the value of the previously visited node in pre_order traversal.", "question": "\nQuestion: How to verify whether a binary tree is a binary search tree?\n\nFor example, the tree in Figure 1 is a binary search tree.\n\n\nA node in binary tree is defined as:\n\nstruct BinaryTreeNode\n{\nint nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pRight;\n};\n"},
{"answer": "\nAnalysis: Before we analyze how to merge an array of ranges, let\u2019s discuss how to merge two ranges. When two ranges don\u2019t overlap each other, they can\u2019t merge. When two ranges overlap, the less starting value of two ranges becomes the starting value of the merged range, and the greater ending value of two ranges becomes the ending value of the merged range.\n\nTherefore, two ranges [5, 13] and [8, 19] are merged into a new range [5, 19], and two ranges [27, 39] and [31, 37] are merged into a new range [27, 39]. The two merged ranges can\u2019t be merged further because they don\u2019t overlap.\n\nThe next question is: How to check whether two ranges overlap\u00a0each other? When two ranges overlap, there is at least on node in a range is contained in the other range. For instance, the starting value 8 of the range [8, 19] is contained in the range [5, 13], therefore, the two ranges [5, 13] and [8, 19] overlap. No nodes in the range [8, 19] are contained in the range [31, 37], so the two ranges don\u2019t overlap.\n\nThe following code shows how to merge two ranges, as well as to check whether two ranges overlap:\n\n public bool Contains( int value)\n\n {\n\n     if (value >= this .Start && value <= this .End)\n\n     {\n\n         return true ;\n\n     }\n\n  \n\n     return false ;\n\n }\n\n  \n\n public bool Overlaps( Range other)\n\n {\n\n     if (other == null )\n\n     {\n\n         return false ;\n\n     }\n\n  \n\n     if ( this .Contains(other.Start) || this .Contains(other.End)         || other .Contains( this .Start) || other .Contains( this .End) )\n\n     {\n\n         return true ;\n\n     }\n\n  \n\n     return false ;\n\n }\n\n  \n\n public Range Merge( Range other)\n\n {\n\n     if (! this .Overlaps(other))\n\n     {\n\n         throw new ApplicationException ( \"Can't merge tworanges.\" );\n\n     }\n\n  \n\n     int newStart = ( this .Start < other.Start) ? this .Start : other.Start;\n\n     int newEnd = ( this .End > other.End) ? this .End : other.End;\n\n  \n\n     return new Range (newStart, newEnd);\n\n }\n\nNow let\u2019s move on to merge an array of ranges. The first step is to sort the ranges based on their start values. When the ranges [5, 13], [27, 39], [8, 19], and [31, 37] are sorted, they are in the order of [5, 13], [8, 19], [27, 39], and [31, 37].\n\nThe next steps are to merge the sorted ranges. The merged ranges are inserted into a data container. At each step, a range is retrieved from the sorted array, and merged with the existing ranges in the container.\n\nAt first the data container is empty, and the first range [5, 13] is inserted into the container directly, without merging. Now there is only one range [5, 13] in the container.\n\nThen the next range [8, 19] is retrieved. Since it overlaps the range[5, 13], and they become [5, 19] when they merged. There is still only one\u00a0range, which is [5, 19] in the container.\n\nThe next range [27, 39] is retrieved, which does not overlap the range [5, 19] in the container, so it is inserted into the range directly without merging. There are two ranges [5, 19] and [27, 39] in the container.\n\nThe last range in the sorted array is [31, 37]. It overlaps the last range [27, 39] in the container. Therefore, the last range [27, 39] is deleted from the container, and then the merged range is inserted into the container. At this step, the merged range is also [27, 39].\n\nRanges in the container are also sorted based on their starting values, and they don't overlap each other. Notice that it's only necessary to check whether the new range overlap the last range in the container. Why not the other ranges in the container? Let's analyze what would happen when a new range in the sorted array overlap two ranges in the container, with Figure 2:\n\nIn Figure 2, the container has two ranges A and B, and a new range C is retrieved from the sorted array, which overlaps the ranges A and B. Since C overlaps A, the starting value of C should be less than the ending value of A. On the other hand, C is retrieved from the sorted array later than B, the starting value of C is greater than starting value of B. Additionally, B is behind A and they don't overlap, so the starting value of B is greater than the ending value A. Therefore, the starting value of C is greater than the ending value of A. It contradicts.\nSince it's only necessary to merge new ranges from the sorted array with the last range in the container. We implement the container as a stack, and the last range is on the top of the stack.\nThe following is the C# code to merge a sort an array of ranges:\n public static Range []Merge( Range [] ranges)\n {\n     Stack < Range > results = new Stack < Range >();\n     if (ranges != null )\n     {\n         Array .Sort(ranges, CompareRangeByStart);\n  \n         foreach ( var range in ranges)\n         {\n             if (results.Count == 0)\n             {\n                 results.Push(range);\n             }\n             else\n             {\n                 var top =results.Peek();\n                 if (top.Overlaps(range))\n                 {\n                     var union = top.Merge(range);\n                     results.Pop();\n                     results.Push(union);\n                 }\n                 else\n                 {\n                     results.Push(range);\n                 }\n             }\n         }\n     }\n  \n     return results.Reverse().ToArray();\n }\n", "question": "\nQuestions: Given an array of ranges, please merge the overlapping ones. For example, four ranges [5, 13], [27, 39], [8, 19], [31, 37] (in blue in\u00a0 Figure1) are merged into two ranges, which are [5, 19] and [27, 39] (in green in\u00a0Figure 1).\n"},
{"answer": "\nAnalysis: Before we analyze how to merge an array of ranges, let\u2019s discuss how to merge two ranges. When two ranges don\u2019t overlap each other, they can\u2019t merge. When two ranges overlap, the less starting value of two ranges becomes the starting value of the merged range, and the greater ending value of two ranges becomes the ending value of the merged range.\n\nTherefore, two ranges [5, 13] and [8, 19] are merged into a new range [5, 19], and two ranges [27, 39] and [31, 37] are merged into a new range [27, 39]. The two merged ranges can\u2019t be merged further because they don\u2019t overlap.\n\nThe next question is: How to check whether two ranges overlap\u00a0each other? When two ranges overlap, there is at least on node in a range is contained in the other range. For instance, the starting value 8 of the range [8, 19] is contained in the range [5, 13], therefore, the two ranges [5, 13] and [8, 19] overlap. No nodes in the range [8, 19] are contained in the range [31, 37], so the two ranges don\u2019t overlap.\n\nThe following code shows how to merge two ranges, as well as to check whether two ranges overlap:\n\n public bool Contains( int value)\n\n {\n\n     if (value >= this .Start && value <= this .End)\n\n     {\n\n         return true ;\n\n     }\n\n  \n\n     return false ;\n\n }\n\n  \n\n public bool Overlaps( Range other)\n\n {\n\n     if (other == null )\n\n     {\n\n         return false ;\n\n     }\n\n  \n\n     if ( this .Contains(other.Start) || this .Contains(other.End)         || other .Contains( this .Start) || other .Contains( this .End) )\n\n     {\n\n         return true ;\n\n     }\n\n  \n\n     return false ;\n\n }\n\n  \n\n public Range Merge( Range other)\n\n {\n\n     if (! this .Overlaps(other))\n\n     {\n\n         throw new ApplicationException ( \"Can't merge tworanges.\" );\n\n     }\n\n  \n\n     int newStart = ( this .Start < other.Start) ? this .Start : other.Start;\n\n     int newEnd = ( this .End > other.End) ? this .End : other.End;\n\n  \n\n     return new Range (newStart, newEnd);\n\n }\n\nNow let\u2019s move on to merge an array of ranges. The first step is to sort the ranges based on their start values. When the ranges [5, 13], [27, 39], [8, 19], and [31, 37] are sorted, they are in the order of [5, 13], [8, 19], [27, 39], and [31, 37].\n\nThe next steps are to merge the sorted ranges. The merged ranges are inserted into a data container. At each step, a range is retrieved from the sorted array, and merged with the existing ranges in the container.\n\nAt first the data container is empty, and the first range [5, 13] is inserted into the container directly, without merging. Now there is only one range [5, 13] in the container.\n\nThen the next range [8, 19] is retrieved. Since it overlaps the range[5, 13], and they become [5, 19] when they merged. There is still only one\u00a0range, which is [5, 19] in the container.\n\nThe next range [27, 39] is retrieved, which does not overlap the range [5, 19] in the container, so it is inserted into the range directly without merging. There are two ranges [5, 19] and [27, 39] in the container.\n\nThe last range in the sorted array is [31, 37]. It overlaps the last range [27, 39] in the container. Therefore, the last range [27, 39] is deleted from the container, and then the merged range is inserted into the container. At this step, the merged range is also [27, 39].\n\nRanges in the container are also sorted based on their starting values, and they don't overlap each other. Notice that it's only necessary to check whether the new range overlap the last range in the container. Why not the other ranges in the container? Let's analyze what would happen when a new range in the sorted array overlap two ranges in the container, with Figure 2:\n\nIn Figure 2, the container has two ranges A and B, and a new range C is retrieved from the sorted array, which overlaps the ranges A and B. Since C overlaps A, the starting value of C should be less than the ending value of A. On the other hand, C is retrieved from the sorted array later than B, the starting value of C is greater than starting value of B. Additionally, B is behind A and they don't overlap, so the starting value of B is greater than the ending value A. Therefore, the starting value of C is greater than the ending value of A. It contradicts.\nSince it's only necessary to merge new ranges from the sorted array with the last range in the container. We implement the container as a stack, and the last range is on the top of the stack.\nThe following is the C# code to merge a sort an array of ranges:\n public static Range []Merge( Range [] ranges)\n {\n     Stack < Range > results = new Stack < Range >();\n     if (ranges != null )\n     {\n         Array .Sort(ranges, CompareRangeByStart);\n  \n         foreach ( var range in ranges)\n         {\n             if (results.Count == 0)\n             {\n                 results.Push(range);\n             }\n             else\n             {\n                 var top =results.Peek();\n                 if (top.Overlaps(range))\n                 {\n                     var union = top.Merge(range);\n                     results.Pop();\n                     results.Push(union);\n                 }\n                 else\n                 {\n                     results.Push(range);\n                 }\n             }\n         }\n     }\n  \n     return results.Reverse().ToArray();\n }\n", "question": "\nQuestions: Given an array of ranges, please merge the overlapping ones. For example, four ranges [5, 13], [27, 39], [8, 19], [31, 37] (in blue in\u00a0 Figure1) are merged into two ranges, which are [5, 19] and [27, 39] (in green in\u00a0Figure 1).\n"},
{"answer": "\nAnalysis: According to declaration above, a queue contains two stacks stack1 and stack2 . Therefore, it is required to implement a queue which follows the rule \u201cFirst In First Out\u201d with two stacks which follow the rule of \u201cFirst In Last Out\u201d.\n\nWe analyze the process to add and delete some elements via some examples. Firstly en element a is inserted. Let us push it into stack1 . There is an element {a} in stack1 and stack2 is empty. We continue to add two more elements b and c (push them into stack1 too). There are three elements {a, b, c} in stack1 now, where c is on its top, and stack2 is still empty (as shown in Figure 1-a).\n\nWe then have a try to delete an element from a queue. According to the rule \u201cFirst in First out\u201d, the first element to be deleted is a since it is added before b and c. The element a is stored in to stack1 , and it is not on the top of stack. Therefore, we cannot pop it directly. We can notice that stack2 has not been used, so it is the time for us to utilize it. If we pop elements from stack1 and push them into stack2 one by one, the order of elements in stack2 is reverse to the order in stack1 . After three popping and pushing operations, stack1 becomes empty and there are three elements {c, b, a} in stack2 . The element a can be popped out now since it is on the top of stack2 . Now there are two elements left {c, b} in stack2 and b is on its top (as shown in Figure 1-b).\n\nHow about to continue deleting more elements from the tail of queue? The element b is inserted into queue before c, so it should be deleted when there are two elements b and c left in queue. It can be popped out since it is on the top of stack2 . After the popping operation, stack1 remains empty and there is only an element c in stack2 (as shown in Figure 1-c).\n\nIt is time to summarize the steps to delete an element from a queue: The top of stack2 can be popped out since it is the first element inserted into queue when stack2 is not empty. When stack2 is empty, we pop all elements from stack1 and push them into stack2 one by one. The first element in a queue is pushed into the bottom of stack1 . It can be popped out directly after popping and pushing operations since it is on the top of stack2 .\n\nLet us insert another element d. How about to push it into stack1 (as shown in Figure1-d)? When we continue to delete the top of stack2 , which is element c, can be popped because it is not empty (as shown in Figure 1-d). The element c is indeed inserted into queue before the element d, so it is a reasonable operation to delete c before d. The final status of the queue is shown as Figure 1-e.\n\n\nWe can write code after we get clear ideas about the process to insert and delete elements. Some sample code is shown below:\n\ntemplate < typename T> void CQueue<T>::appendTail( const T& element)\n{\nstack1.push(element);\n}\n\ntemplate < typename T> T CQueue<T>::deleteHead()\n{\nif (stack2.size()<= 0)\n{\nwhile (stack1.size()>0)\n{\nT& data = stack1.top();\nstack1.pop();\nstack2.push(data);\n}\n}\n\nif (stack2.size() == 0)\nthrow new exception( \"queue is empty\" );\n\nT head = stack2.top();\nstack2.pop();\n\nreturn head;", "question": "\nProblem: Implement a queue with two stacks. The class for queues is declared in C++ as below. Please implement two functions: appendTail to append an element into tail of a queue, and deleteHead to delete an element from head of a queue.\n\ntemplate < typename T> class CQueue\n{\npublic :\nCQueue( void );\n~CQueue( void );\n\nvoid appendTail( const T& node);\nT deleteHead();\n\nprivate :\nstack<T> stack1;\nstack<T> stack2;\n};\n"},
{"answer": "\nAnalysis: Before we analyze how to merge an array of ranges, let\u2019s discuss how to merge two ranges. When two ranges don\u2019t overlap each other, they can\u2019t merge. When two ranges overlap, the less starting value of two ranges becomes the starting value of the merged range, and the greater ending value of two ranges becomes the ending value of the merged range.\n\nTherefore, two ranges [5, 13] and [8, 19] are merged into a new range [5, 19], and two ranges [27, 39] and [31, 37] are merged into a new range [27, 39]. The two merged ranges can\u2019t be merged further because they don\u2019t overlap.\n\nThe next question is: How to check whether two ranges overlap\u00a0each other? When two ranges overlap, there is at least on node in a range is contained in the other range. For instance, the starting value 8 of the range [8, 19] is contained in the range [5, 13], therefore, the two ranges [5, 13] and [8, 19] overlap. No nodes in the range [8, 19] are contained in the range [31, 37], so the two ranges don\u2019t overlap.\n\nThe following code shows how to merge two ranges, as well as to check whether two ranges overlap:\n\n public bool Contains( int value)\n\n {\n\n     if (value >= this .Start && value <= this .End)\n\n     {\n\n         return true ;\n\n     }\n\n  \n\n     return false ;\n\n }\n\n  \n\n public bool Overlaps( Range other)\n\n {\n\n     if (other == null )\n\n     {\n\n         return false ;\n\n     }\n\n  \n\n     if ( this .Contains(other.Start) || this .Contains(other.End)         || other .Contains( this .Start) || other .Contains( this .End) )\n\n     {\n\n         return true ;\n\n     }\n\n  \n\n     return false ;\n\n }\n\n  \n\n public Range Merge( Range other)\n\n {\n\n     if (! this .Overlaps(other))\n\n     {\n\n         throw new ApplicationException ( \"Can't merge tworanges.\" );\n\n     }\n\n  \n\n     int newStart = ( this .Start < other.Start) ? this .Start : other.Start;\n\n     int newEnd = ( this .End > other.End) ? this .End : other.End;\n\n  \n\n     return new Range (newStart, newEnd);\n\n }\n\nNow let\u2019s move on to merge an array of ranges. The first step is to sort the ranges based on their start values. When the ranges [5, 13], [27, 39], [8, 19], and [31, 37] are sorted, they are in the order of [5, 13], [8, 19], [27, 39], and [31, 37].\n\nThe next steps are to merge the sorted ranges. The merged ranges are inserted into a data container. At each step, a range is retrieved from the sorted array, and merged with the existing ranges in the container.\n\nAt first the data container is empty, and the first range [5, 13] is inserted into the container directly, without merging. Now there is only one range [5, 13] in the container.\n\nThen the next range [8, 19] is retrieved. Since it overlaps the range[5, 13], and they become [5, 19] when they merged. There is still only one\u00a0range, which is [5, 19] in the container.\n\nThe next range [27, 39] is retrieved, which does not overlap the range [5, 19] in the container, so it is inserted into the range directly without merging. There are two ranges [5, 19] and [27, 39] in the container.\n\nThe last range in the sorted array is [31, 37]. It overlaps the last range [27, 39] in the container. Therefore, the last range [27, 39] is deleted from the container, and then the merged range is inserted into the container. At this step, the merged range is also [27, 39].\n\nRanges in the container are also sorted based on their starting values, and they don't overlap each other. Notice that it's only necessary to check whether the new range overlap the last range in the container. Why not the other ranges in the container? Let's analyze what would happen when a new range in the sorted array overlap two ranges in the container, with Figure 2:\n\nIn Figure 2, the container has two ranges A and B, and a new range C is retrieved from the sorted array, which overlaps the ranges A and B. Since C overlaps A, the starting value of C should be less than the ending value of A. On the other hand, C is retrieved from the sorted array later than B, the starting value of C is greater than starting value of B. Additionally, B is behind A and they don't overlap, so the starting value of B is greater than the ending value A. Therefore, the starting value of C is greater than the ending value of A. It contradicts.\nSince it's only necessary to merge new ranges from the sorted array with the last range in the container. We implement the container as a stack, and the last range is on the top of the stack.\nThe following is the C# code to merge a sort an array of ranges:\n public static Range []Merge( Range [] ranges)\n {\n     Stack < Range > results = new Stack < Range >();\n     if (ranges != null )\n     {\n         Array .Sort(ranges, CompareRangeByStart);\n  \n         foreach ( var range in ranges)\n         {\n             if (results.Count == 0)\n             {\n                 results.Push(range);\n             }\n             else\n             {\n                 var top =results.Peek();\n                 if (top.Overlaps(range))\n                 {\n                     var union = top.Merge(range);\n                     results.Pop();\n                     results.Push(union);\n                 }\n                 else\n                 {\n                     results.Push(range);\n                 }\n             }\n         }\n     }\n  \n     return results.Reverse().ToArray();\n }\n", "question": "\nQuestions: Given an array of ranges, please merge the overlapping ones. For example, four ranges [5, 13], [27, 39], [8, 19], [31, 37] (in blue in\u00a0 Figure1) are merged into two ranges, which are [5, 19] and [27, 39] (in green in\u00a0Figure 1).\n"},
{"answer": "\nAnalysis: Before we analyze how to merge an array of ranges, let\u2019s discuss how to merge two ranges. When two ranges don\u2019t overlap each other, they can\u2019t merge. When two ranges overlap, the less starting value of two ranges becomes the starting value of the merged range, and the greater ending value of two ranges becomes the ending value of the merged range.\n\nTherefore, two ranges [5, 13] and [8, 19] are merged into a new range [5, 19], and two ranges [27, 39] and [31, 37] are merged into a new range [27, 39]. The two merged ranges can\u2019t be merged further because they don\u2019t overlap.\n\nThe next question is: How to check whether two ranges overlap\u00a0each other? When two ranges overlap, there is at least on node in a range is contained in the other range. For instance, the starting value 8 of the range [8, 19] is contained in the range [5, 13], therefore, the two ranges [5, 13] and [8, 19] overlap. No nodes in the range [8, 19] are contained in the range [31, 37], so the two ranges don\u2019t overlap.\n\nThe following code shows how to merge two ranges, as well as to check whether two ranges overlap:\n\n public bool Contains( int value)\n\n {\n\n     if (value >= this .Start && value <= this .End)\n\n     {\n\n         return true ;\n\n     }\n\n  \n\n     return false ;\n\n }\n\n  \n\n public bool Overlaps( Range other)\n\n {\n\n     if (other == null )\n\n     {\n\n         return false ;\n\n     }\n\n  \n\n     if ( this .Contains(other.Start) || this .Contains(other.End)         || other .Contains( this .Start) || other .Contains( this .End) )\n\n     {\n\n         return true ;\n\n     }\n\n  \n\n     return false ;\n\n }\n\n  \n\n public Range Merge( Range other)\n\n {\n\n     if (! this .Overlaps(other))\n\n     {\n\n         throw new ApplicationException ( \"Can't merge tworanges.\" );\n\n     }\n\n  \n\n     int newStart = ( this .Start < other.Start) ? this .Start : other.Start;\n\n     int newEnd = ( this .End > other.End) ? this .End : other.End;\n\n  \n\n     return new Range (newStart, newEnd);\n\n }\n\nNow let\u2019s move on to merge an array of ranges. The first step is to sort the ranges based on their start values. When the ranges [5, 13], [27, 39], [8, 19], and [31, 37] are sorted, they are in the order of [5, 13], [8, 19], [27, 39], and [31, 37].\n\nThe next steps are to merge the sorted ranges. The merged ranges are inserted into a data container. At each step, a range is retrieved from the sorted array, and merged with the existing ranges in the container.\n\nAt first the data container is empty, and the first range [5, 13] is inserted into the container directly, without merging. Now there is only one range [5, 13] in the container.\n\nThen the next range [8, 19] is retrieved. Since it overlaps the range[5, 13], and they become [5, 19] when they merged. There is still only one\u00a0range, which is [5, 19] in the container.\n\nThe next range [27, 39] is retrieved, which does not overlap the range [5, 19] in the container, so it is inserted into the range directly without merging. There are two ranges [5, 19] and [27, 39] in the container.\n\nThe last range in the sorted array is [31, 37]. It overlaps the last range [27, 39] in the container. Therefore, the last range [27, 39] is deleted from the container, and then the merged range is inserted into the container. At this step, the merged range is also [27, 39].\n\nRanges in the container are also sorted based on their starting values, and they don't overlap each other. Notice that it's only necessary to check whether the new range overlap the last range in the container. Why not the other ranges in the container? Let's analyze what would happen when a new range in the sorted array overlap two ranges in the container, with Figure 2:\n\nIn Figure 2, the container has two ranges A and B, and a new range C is retrieved from the sorted array, which overlaps the ranges A and B. Since C overlaps A, the starting value of C should be less than the ending value of A. On the other hand, C is retrieved from the sorted array later than B, the starting value of C is greater than starting value of B. Additionally, B is behind A and they don't overlap, so the starting value of B is greater than the ending value A. Therefore, the starting value of C is greater than the ending value of A. It contradicts.\nSince it's only necessary to merge new ranges from the sorted array with the last range in the container. We implement the container as a stack, and the last range is on the top of the stack.\nThe following is the C# code to merge a sort an array of ranges:\n public static Range []Merge( Range [] ranges)\n {\n     Stack < Range > results = new Stack < Range >();\n     if (ranges != null )\n     {\n         Array .Sort(ranges, CompareRangeByStart);\n  \n         foreach ( var range in ranges)\n         {\n             if (results.Count == 0)\n             {\n                 results.Push(range);\n             }\n             else\n             {\n                 var top =results.Peek();\n                 if (top.Overlaps(range))\n                 {\n                     var union = top.Merge(range);\n                     results.Pop();\n                     results.Push(union);\n                 }\n                 else\n                 {\n                     results.Push(range);\n                 }\n             }\n         }\n     }\n  \n     return results.Reverse().ToArray();\n }\n", "question": "\nQuestions: Given an array of ranges, please merge the overlapping ones. For example, four ranges [5, 13], [27, 39], [8, 19], [31, 37] (in blue in\u00a0 Figure1) are merged into two ranges, which are [5, 19] and [27, 39] (in green in\u00a0Figure 1).\n"},
{"answer": "\nAnalysis: According to declaration above, a queue contains two stacks stack1 and stack2 . Therefore, it is required to implement a queue which follows the rule \u201cFirst In First Out\u201d with two stacks which follow the rule of \u201cFirst In Last Out\u201d.\n\nWe analyze the process to add and delete some elements via some examples. Firstly en element a is inserted. Let us push it into stack1 . There is an element {a} in stack1 and stack2 is empty. We continue to add two more elements b and c (push them into stack1 too). There are three elements {a, b, c} in stack1 now, where c is on its top, and stack2 is still empty (as shown in Figure 1-a).\n\nWe then have a try to delete an element from a queue. According to the rule \u201cFirst in First out\u201d, the first element to be deleted is a since it is added before b and c. The element a is stored in to stack1 , and it is not on the top of stack. Therefore, we cannot pop it directly. We can notice that stack2 has not been used, so it is the time for us to utilize it. If we pop elements from stack1 and push them into stack2 one by one, the order of elements in stack2 is reverse to the order in stack1 . After three popping and pushing operations, stack1 becomes empty and there are three elements {c, b, a} in stack2 . The element a can be popped out now since it is on the top of stack2 . Now there are two elements left {c, b} in stack2 and b is on its top (as shown in Figure 1-b).\n\nHow about to continue deleting more elements from the tail of queue? The element b is inserted into queue before c, so it should be deleted when there are two elements b and c left in queue. It can be popped out since it is on the top of stack2 . After the popping operation, stack1 remains empty and there is only an element c in stack2 (as shown in Figure 1-c).\n\nIt is time to summarize the steps to delete an element from a queue: The top of stack2 can be popped out since it is the first element inserted into queue when stack2 is not empty. When stack2 is empty, we pop all elements from stack1 and push them into stack2 one by one. The first element in a queue is pushed into the bottom of stack1 . It can be popped out directly after popping and pushing operations since it is on the top of stack2 .\n\nLet us insert another element d. How about to push it into stack1 (as shown in Figure1-d)? When we continue to delete the top of stack2 , which is element c, can be popped because it is not empty (as shown in Figure 1-d). The element c is indeed inserted into queue before the element d, so it is a reasonable operation to delete c before d. The final status of the queue is shown as Figure 1-e.\n\n\nWe can write code after we get clear ideas about the process to insert and delete elements. Some sample code is shown below:\n\ntemplate < typename T> void CQueue<T>::appendTail( const T& element)\n{\nstack1.push(element);\n}\n\ntemplate < typename T> T CQueue<T>::deleteHead()\n{\nif (stack2.size()<= 0)\n{\nwhile (stack1.size()>0)\n{\nT& data = stack1.top();\nstack1.pop();\nstack2.push(data);\n}\n}\n\nif (stack2.size() == 0)\nthrow new exception( \"queue is empty\" );\n\nT head = stack2.top();\nstack2.pop();\n\nreturn head;", "question": "\nProblem: Implement a queue with two stacks. The class for queues is declared in C++ as below. Please implement two functions: appendTail to append an element into tail of a queue, and deleteHead to delete an element from head of a queue.\n\ntemplate < typename T> class CQueue\n{\npublic :\nCQueue( void );\n~CQueue( void );\n\nvoid appendTail( const T& node);\nT deleteHead();\n\nprivate :\nstack<T> stack1;\nstack<T> stack2;\n};\n"},
{"answer": "\nAnalysis: An intuitive thought on this problem is to create an auxiliary stack. We push the numbers in the first sequence one by one, and try to pop them out according to the order in the second sequence.\n\nTake the sequence 4, 5, 3, 2, 1 as an example to analyze the process to push and pop. The first number to be popped is 4, so we need to push it into a stack. The pushing order is defined in the first sequence, where there are numbers 1, 2 and 3 prior to 4. Therefore, numbers 1, 2, and 3 are pushed into a stack before 4 is pushed. At this time, there are 4 numbers in a stack, which are 1, 2, 3 and 4, with 4 on top. When 4 is popped, numbers 1, 2 and 3 are left. The next number to be popped is 5, which is not on top of stack, so we have to push numbers in the first sequence into stack until 5 is pushed. When number 5 is on top of a stack, we can pop it. The next three numbers to be popped are 3, 2 and 1. Since these numbers are on top of a stack before pop operations, they can be popped directly. The whole process to push and pop is summarized in Table 1.\n\nStep Operation Stack Status Popped Step Operation Stack Status Popped 1 Push 1 1 6 Push 5 1, 2, 3, 5 2 Push 2 1, 2 7 Pop 1, 2, 3 5 3 Push 3 1, 2, 3 8 Pop 1, 2 3 4 Push 4 1, 2, 3, 4 9 Pop 1 2 5 Pop 1, 2, 3 4 10 Pop 1\nStep\nOperation\nStack Status\nPopped\nStep\nOperation\nStack Status\nPopped\n1\nPush 1\n1\n\n6\nPush 5\n1, 2, 3, 5\n\n2\nPush 2\n1, 2\n\n7\nPop\n1, 2, 3\n5\n3\nPush 3\n1, 2, 3\n\n8\nPop\n1, 2\n3\n4\nPush 4\n1, 2, 3, 4\n\n9\nPop\n1\n2\n5\nPop\n1, 2, 3\n4\n10\nPop\n\n1\nTable 1: The process to push and pop with a push sequence 1, 2, 3, 4, 5 and pop sequence 4, 5, 3, 2, 1\n\nLet us continue to analyze another pop sequence 4, 3, 5, 1, 2. The process to pop the first number 4 is similar to the process above. After the number 4 is popped, 3 is on the top of stack and it can be popped. The next number to be popped is 5. Since it is not on top, we have to push numbers in the first sequence until the number 5 is pushed. The number 5 can be popped when it is pushed onto the top of a stack. After 5 is popped out, there are only two numbers 1 and 2 left in stack. The next number to be popped is 1, but it is not on the top of stack. We have to push numbers in the first sequence until 1 is pushed. However, all numbers in the first sequence have been pushed. Therefore, the sequence 4, 3, 5, 1, 2 is not a pop sequence of the stack with push sequence 1, 2, 3, 4, 5. The whole process to push and pop is summarized in Table 2.\n\nStep Operation Stack Status Popped Step Operation Stack Status Popped 1 Push 1 1 6 Pop 1, 2 3 2 Push 2 1, 2 7 Push 5 1, 2, 5 3 Push 3 1, 2, 3 8 Pop 1, 2 5 4 Push 4 1, 2, 3, 4 The next number to be popped is 1, which is neither on the top of stack,   nor in the remaining numbers of push sequence. 5 Pop 1, 2, 3 4\nStep\nOperation\nStack Status\nPopped\nStep\nOperation\nStack Status\nPopped\n1\nPush 1\n1\n\n6\nPop\n1, 2\n3\n2\nPush 2\n1, 2\n\n7\nPush 5\n1, 2, 5\n\n3\nPush 3\n1, 2, 3\n\n8\nPop\n1, 2\n5\n4\nPush 4\n1, 2, 3, 4\n\nThe next number to be popped is 1, which is neither on the top of stack,   nor in the remaining numbers of push sequence.\n5\nPop\n1, 2, 3\n4\nTable 1: The process to push and pop with a push sequence 1, 2, 3, 4, 5 and pop sequence 4, 3, 5, 1, 2\n\nAccording to the analysis above, we get a solution to check whether a sequence is a pop sequence of a stack or not. If the number to be popped is currently on top of stack, just pop it. If it is not on the top of stack, we have to push remaining numbers into the auxiliary stack until we meet the number to be popped. If the next number to be popped is not remaining in the push sequence, it is not a pop sequence of a stack. The following is some sample code based on this solution:\n\nbool IsPopOrder( const int * pPush, const int * pPop, int nLength)\n{\nbool bPossible = false ;\n\nif (pPush != NULL && pPop != NULL && nLength > 0)\n{\nconst int * pNextPush = pPush;\nconst int * pNextPop = pPop;\n\nstd::stack< int > stackData;\n\nwhile (pNextPop - pPop < nLength)\n{\n// When the number to be popped is not on top of stack,\n// push some numbers in the push sequence into stack\nwhile (stackData.empty() || stackData.top() != *pNextPop)\n{\n// If all numbers have been pushed, break\nif (pNextPush - pPush == nLength)\nbreak ;\n\nstackData.push(*pNextPush);\n\npNextPush ++;\n}\n\nif (stackData.top() != *pNextPop)\nbreak ;\n\nstackData.pop();\npNextPop ++;\n}\n\nif (stackData.empty() && pNextPop - pPop == nLength)\nbPossible = true ;\n}\n\nreturn bPossible;\n}", "question": "\nProblem: Given two integer sequences, one of which is the push sequence of a stack, please check whether the other sequence is a corresponding pop sequence or not.\n\nFor example, if 1, 2, 3, 4, 5 is a push sequence, 4, 5, 3, 2, 1 is a corresponding pop sequence, but the sequence 4, 3, 5, 1, 2 is not.\n"},
{"answer": "\nAnalysis: An intuitive thought on this problem is to create an auxiliary stack. We push the numbers in the first sequence one by one, and try to pop them out according to the order in the second sequence.\n\nTake the sequence 4, 5, 3, 2, 1 as an example to analyze the process to push and pop. The first number to be popped is 4, so we need to push it into a stack. The pushing order is defined in the first sequence, where there are numbers 1, 2 and 3 prior to 4. Therefore, numbers 1, 2, and 3 are pushed into a stack before 4 is pushed. At this time, there are 4 numbers in a stack, which are 1, 2, 3 and 4, with 4 on top. When 4 is popped, numbers 1, 2 and 3 are left. The next number to be popped is 5, which is not on top of stack, so we have to push numbers in the first sequence into stack until 5 is pushed. When number 5 is on top of a stack, we can pop it. The next three numbers to be popped are 3, 2 and 1. Since these numbers are on top of a stack before pop operations, they can be popped directly. The whole process to push and pop is summarized in Table 1.\n\nStep Operation Stack Status Popped Step Operation Stack Status Popped 1 Push 1 1 6 Push 5 1, 2, 3, 5 2 Push 2 1, 2 7 Pop 1, 2, 3 5 3 Push 3 1, 2, 3 8 Pop 1, 2 3 4 Push 4 1, 2, 3, 4 9 Pop 1 2 5 Pop 1, 2, 3 4 10 Pop 1\nStep\nOperation\nStack Status\nPopped\nStep\nOperation\nStack Status\nPopped\n1\nPush 1\n1\n\n6\nPush 5\n1, 2, 3, 5\n\n2\nPush 2\n1, 2\n\n7\nPop\n1, 2, 3\n5\n3\nPush 3\n1, 2, 3\n\n8\nPop\n1, 2\n3\n4\nPush 4\n1, 2, 3, 4\n\n9\nPop\n1\n2\n5\nPop\n1, 2, 3\n4\n10\nPop\n\n1\nTable 1: The process to push and pop with a push sequence 1, 2, 3, 4, 5 and pop sequence 4, 5, 3, 2, 1\n\nLet us continue to analyze another pop sequence 4, 3, 5, 1, 2. The process to pop the first number 4 is similar to the process above. After the number 4 is popped, 3 is on the top of stack and it can be popped. The next number to be popped is 5. Since it is not on top, we have to push numbers in the first sequence until the number 5 is pushed. The number 5 can be popped when it is pushed onto the top of a stack. After 5 is popped out, there are only two numbers 1 and 2 left in stack. The next number to be popped is 1, but it is not on the top of stack. We have to push numbers in the first sequence until 1 is pushed. However, all numbers in the first sequence have been pushed. Therefore, the sequence 4, 3, 5, 1, 2 is not a pop sequence of the stack with push sequence 1, 2, 3, 4, 5. The whole process to push and pop is summarized in Table 2.\n\nStep Operation Stack Status Popped Step Operation Stack Status Popped 1 Push 1 1 6 Pop 1, 2 3 2 Push 2 1, 2 7 Push 5 1, 2, 5 3 Push 3 1, 2, 3 8 Pop 1, 2 5 4 Push 4 1, 2, 3, 4 The next number to be popped is 1, which is neither on the top of stack,   nor in the remaining numbers of push sequence. 5 Pop 1, 2, 3 4\nStep\nOperation\nStack Status\nPopped\nStep\nOperation\nStack Status\nPopped\n1\nPush 1\n1\n\n6\nPop\n1, 2\n3\n2\nPush 2\n1, 2\n\n7\nPush 5\n1, 2, 5\n\n3\nPush 3\n1, 2, 3\n\n8\nPop\n1, 2\n5\n4\nPush 4\n1, 2, 3, 4\n\nThe next number to be popped is 1, which is neither on the top of stack,   nor in the remaining numbers of push sequence.\n5\nPop\n1, 2, 3\n4\nTable 1: The process to push and pop with a push sequence 1, 2, 3, 4, 5 and pop sequence 4, 3, 5, 1, 2\n\nAccording to the analysis above, we get a solution to check whether a sequence is a pop sequence of a stack or not. If the number to be popped is currently on top of stack, just pop it. If it is not on the top of stack, we have to push remaining numbers into the auxiliary stack until we meet the number to be popped. If the next number to be popped is not remaining in the push sequence, it is not a pop sequence of a stack. The following is some sample code based on this solution:\n\nbool IsPopOrder( const int * pPush, const int * pPop, int nLength)\n{\nbool bPossible = false ;\n\nif (pPush != NULL && pPop != NULL && nLength > 0)\n{\nconst int * pNextPush = pPush;\nconst int * pNextPop = pPop;\n\nstd::stack< int > stackData;\n\nwhile (pNextPop - pPop < nLength)\n{\n// When the number to be popped is not on top of stack,\n// push some numbers in the push sequence into stack\nwhile (stackData.empty() || stackData.top() != *pNextPop)\n{\n// If all numbers have been pushed, break\nif (pNextPush - pPush == nLength)\nbreak ;\n\nstackData.push(*pNextPush);\n\npNextPush ++;\n}\n\nif (stackData.top() != *pNextPop)\nbreak ;\n\nstackData.pop();\npNextPop ++;\n}\n\nif (stackData.empty() && pNextPop - pPop == nLength)\nbPossible = true ;\n}\n\nreturn bPossible;\n}", "question": "\nProblem: Given two integer sequences, one of which is the push sequence of a stack, please check whether the other sequence is a corresponding pop sequence or not.\n\nFor example, if 1, 2, 3, 4, 5 is a push sequence, 4, 5, 3, 2, 1 is a corresponding pop sequence, but the sequence 4, 3, 5, 1, 2 is not.\n"},
{"answer": "\nAnalysis: According to declaration above, a queue contains two stacks stack1 and stack2 . Therefore, it is required to implement a queue which follows the rule \u201cFirst In First Out\u201d with two stacks which follow the rule of \u201cFirst In Last Out\u201d.\n\nWe analyze the process to add and delete some elements via some examples. Firstly en element a is inserted. Let us push it into stack1 . There is an element {a} in stack1 and stack2 is empty. We continue to add two more elements b and c (push them into stack1 too). There are three elements {a, b, c} in stack1 now, where c is on its top, and stack2 is still empty (as shown in Figure 1-a).\n\nWe then have a try to delete an element from a queue. According to the rule \u201cFirst in First out\u201d, the first element to be deleted is a since it is added before b and c. The element a is stored in to stack1 , and it is not on the top of stack. Therefore, we cannot pop it directly. We can notice that stack2 has not been used, so it is the time for us to utilize it. If we pop elements from stack1 and push them into stack2 one by one, the order of elements in stack2 is reverse to the order in stack1 . After three popping and pushing operations, stack1 becomes empty and there are three elements {c, b, a} in stack2 . The element a can be popped out now since it is on the top of stack2 . Now there are two elements left {c, b} in stack2 and b is on its top (as shown in Figure 1-b).\n\nHow about to continue deleting more elements from the tail of queue? The element b is inserted into queue before c, so it should be deleted when there are two elements b and c left in queue. It can be popped out since it is on the top of stack2 . After the popping operation, stack1 remains empty and there is only an element c in stack2 (as shown in Figure 1-c).\n\nIt is time to summarize the steps to delete an element from a queue: The top of stack2 can be popped out since it is the first element inserted into queue when stack2 is not empty. When stack2 is empty, we pop all elements from stack1 and push them into stack2 one by one. The first element in a queue is pushed into the bottom of stack1 . It can be popped out directly after popping and pushing operations since it is on the top of stack2 .\n\nLet us insert another element d. How about to push it into stack1 (as shown in Figure1-d)? When we continue to delete the top of stack2 , which is element c, can be popped because it is not empty (as shown in Figure 1-d). The element c is indeed inserted into queue before the element d, so it is a reasonable operation to delete c before d. The final status of the queue is shown as Figure 1-e.\n\n\nWe can write code after we get clear ideas about the process to insert and delete elements. Some sample code is shown below:\n\ntemplate < typename T> void CQueue<T>::appendTail( const T& element)\n{\nstack1.push(element);\n}\n\ntemplate < typename T> T CQueue<T>::deleteHead()\n{\nif (stack2.size()<= 0)\n{\nwhile (stack1.size()>0)\n{\nT& data = stack1.top();\nstack1.pop();\nstack2.push(data);\n}\n}\n\nif (stack2.size() == 0)\nthrow new exception( \"queue is empty\" );\n\nT head = stack2.top();\nstack2.pop();\n\nreturn head;", "question": "\nProblem: Implement a queue with two stacks. The class for queues is declared in C++ as below. Please implement two functions: appendTail to append an element into tail of a queue, and deleteHead to delete an element from head of a queue.\n\ntemplate < typename T> class CQueue\n{\npublic :\nCQueue( void );\n~CQueue( void );\n\nvoid appendTail( const T& node);\nT deleteHead();\n\nprivate :\nstack<T> stack1;\nstack<T> stack2;\n};\n"},
{"answer": "\nAnalysis: According to declaration above, a queue contains two stacks stack1 and stack2 . Therefore, it is required to implement a queue which follows the rule \u201cFirst In First Out\u201d with two stacks which follow the rule of \u201cFirst In Last Out\u201d.\n\nWe analyze the process to add and delete some elements via some examples. Firstly en element a is inserted. Let us push it into stack1 . There is an element {a} in stack1 and stack2 is empty. We continue to add two more elements b and c (push them into stack1 too). There are three elements {a, b, c} in stack1 now, where c is on its top, and stack2 is still empty (as shown in Figure 1-a).\n\nWe then have a try to delete an element from a queue. According to the rule \u201cFirst in First out\u201d, the first element to be deleted is a since it is added before b and c. The element a is stored in to stack1 , and it is not on the top of stack. Therefore, we cannot pop it directly. We can notice that stack2 has not been used, so it is the time for us to utilize it. If we pop elements from stack1 and push them into stack2 one by one, the order of elements in stack2 is reverse to the order in stack1 . After three popping and pushing operations, stack1 becomes empty and there are three elements {c, b, a} in stack2 . The element a can be popped out now since it is on the top of stack2 . Now there are two elements left {c, b} in stack2 and b is on its top (as shown in Figure 1-b).\n\nHow about to continue deleting more elements from the tail of queue? The element b is inserted into queue before c, so it should be deleted when there are two elements b and c left in queue. It can be popped out since it is on the top of stack2 . After the popping operation, stack1 remains empty and there is only an element c in stack2 (as shown in Figure 1-c).\n\nIt is time to summarize the steps to delete an element from a queue: The top of stack2 can be popped out since it is the first element inserted into queue when stack2 is not empty. When stack2 is empty, we pop all elements from stack1 and push them into stack2 one by one. The first element in a queue is pushed into the bottom of stack1 . It can be popped out directly after popping and pushing operations since it is on the top of stack2 .\n\nLet us insert another element d. How about to push it into stack1 (as shown in Figure1-d)? When we continue to delete the top of stack2 , which is element c, can be popped because it is not empty (as shown in Figure 1-d). The element c is indeed inserted into queue before the element d, so it is a reasonable operation to delete c before d. The final status of the queue is shown as Figure 1-e.\n\n\nWe can write code after we get clear ideas about the process to insert and delete elements. Some sample code is shown below:\n\ntemplate < typename T> void CQueue<T>::appendTail( const T& element)\n{\nstack1.push(element);\n}\n\ntemplate < typename T> T CQueue<T>::deleteHead()\n{\nif (stack2.size()<= 0)\n{\nwhile (stack1.size()>0)\n{\nT& data = stack1.top();\nstack1.pop();\nstack2.push(data);\n}\n}\n\nif (stack2.size() == 0)\nthrow new exception( \"queue is empty\" );\n\nT head = stack2.top();\nstack2.pop();\n\nreturn head;", "question": "\nProblem: Implement a queue with two stacks. The class for queues is declared in C++ as below. Please implement two functions: appendTail to append an element into tail of a queue, and deleteHead to delete an element from head of a queue.\n\ntemplate < typename T> class CQueue\n{\npublic :\nCQueue( void );\n~CQueue( void );\n\nvoid appendTail( const T& node);\nT deleteHead();\n\nprivate :\nstack<T> stack1;\nstack<T> stack2;\n};\n"},
{"answer": "\nAnalysis: An intuitive thought on this problem is to create an auxiliary stack. We push the numbers in the first sequence one by one, and try to pop them out according to the order in the second sequence.\n\nTake the sequence 4, 5, 3, 2, 1 as an example to analyze the process to push and pop. The first number to be popped is 4, so we need to push it into a stack. The pushing order is defined in the first sequence, where there are numbers 1, 2 and 3 prior to 4. Therefore, numbers 1, 2, and 3 are pushed into a stack before 4 is pushed. At this time, there are 4 numbers in a stack, which are 1, 2, 3 and 4, with 4 on top. When 4 is popped, numbers 1, 2 and 3 are left. The next number to be popped is 5, which is not on top of stack, so we have to push numbers in the first sequence into stack until 5 is pushed. When number 5 is on top of a stack, we can pop it. The next three numbers to be popped are 3, 2 and 1. Since these numbers are on top of a stack before pop operations, they can be popped directly. The whole process to push and pop is summarized in Table 1.\n\nStep Operation Stack Status Popped Step Operation Stack Status Popped 1 Push 1 1 6 Push 5 1, 2, 3, 5 2 Push 2 1, 2 7 Pop 1, 2, 3 5 3 Push 3 1, 2, 3 8 Pop 1, 2 3 4 Push 4 1, 2, 3, 4 9 Pop 1 2 5 Pop 1, 2, 3 4 10 Pop 1\nStep\nOperation\nStack Status\nPopped\nStep\nOperation\nStack Status\nPopped\n1\nPush 1\n1\n\n6\nPush 5\n1, 2, 3, 5\n\n2\nPush 2\n1, 2\n\n7\nPop\n1, 2, 3\n5\n3\nPush 3\n1, 2, 3\n\n8\nPop\n1, 2\n3\n4\nPush 4\n1, 2, 3, 4\n\n9\nPop\n1\n2\n5\nPop\n1, 2, 3\n4\n10\nPop\n\n1\nTable 1: The process to push and pop with a push sequence 1, 2, 3, 4, 5 and pop sequence 4, 5, 3, 2, 1\n\nLet us continue to analyze another pop sequence 4, 3, 5, 1, 2. The process to pop the first number 4 is similar to the process above. After the number 4 is popped, 3 is on the top of stack and it can be popped. The next number to be popped is 5. Since it is not on top, we have to push numbers in the first sequence until the number 5 is pushed. The number 5 can be popped when it is pushed onto the top of a stack. After 5 is popped out, there are only two numbers 1 and 2 left in stack. The next number to be popped is 1, but it is not on the top of stack. We have to push numbers in the first sequence until 1 is pushed. However, all numbers in the first sequence have been pushed. Therefore, the sequence 4, 3, 5, 1, 2 is not a pop sequence of the stack with push sequence 1, 2, 3, 4, 5. The whole process to push and pop is summarized in Table 2.\n\nStep Operation Stack Status Popped Step Operation Stack Status Popped 1 Push 1 1 6 Pop 1, 2 3 2 Push 2 1, 2 7 Push 5 1, 2, 5 3 Push 3 1, 2, 3 8 Pop 1, 2 5 4 Push 4 1, 2, 3, 4 The next number to be popped is 1, which is neither on the top of stack,   nor in the remaining numbers of push sequence. 5 Pop 1, 2, 3 4\nStep\nOperation\nStack Status\nPopped\nStep\nOperation\nStack Status\nPopped\n1\nPush 1\n1\n\n6\nPop\n1, 2\n3\n2\nPush 2\n1, 2\n\n7\nPush 5\n1, 2, 5\n\n3\nPush 3\n1, 2, 3\n\n8\nPop\n1, 2\n5\n4\nPush 4\n1, 2, 3, 4\n\nThe next number to be popped is 1, which is neither on the top of stack,   nor in the remaining numbers of push sequence.\n5\nPop\n1, 2, 3\n4\nTable 1: The process to push and pop with a push sequence 1, 2, 3, 4, 5 and pop sequence 4, 3, 5, 1, 2\n\nAccording to the analysis above, we get a solution to check whether a sequence is a pop sequence of a stack or not. If the number to be popped is currently on top of stack, just pop it. If it is not on the top of stack, we have to push remaining numbers into the auxiliary stack until we meet the number to be popped. If the next number to be popped is not remaining in the push sequence, it is not a pop sequence of a stack. The following is some sample code based on this solution:\n\nbool IsPopOrder( const int * pPush, const int * pPop, int nLength)\n{\nbool bPossible = false ;\n\nif (pPush != NULL && pPop != NULL && nLength > 0)\n{\nconst int * pNextPush = pPush;\nconst int * pNextPop = pPop;\n\nstd::stack< int > stackData;\n\nwhile (pNextPop - pPop < nLength)\n{\n// When the number to be popped is not on top of stack,\n// push some numbers in the push sequence into stack\nwhile (stackData.empty() || stackData.top() != *pNextPop)\n{\n// If all numbers have been pushed, break\nif (pNextPush - pPush == nLength)\nbreak ;\n\nstackData.push(*pNextPush);\n\npNextPush ++;\n}\n\nif (stackData.top() != *pNextPop)\nbreak ;\n\nstackData.pop();\npNextPop ++;\n}\n\nif (stackData.empty() && pNextPop - pPop == nLength)\nbPossible = true ;\n}\n\nreturn bPossible;\n}", "question": "\nProblem: Given two integer sequences, one of which is the push sequence of a stack, please check whether the other sequence is a corresponding pop sequence or not.\n\nFor example, if 1, 2, 3, 4, 5 is a push sequence, 4, 5, 3, 2, 1 is a corresponding pop sequence, but the sequence 4, 3, 5, 1, 2 is not.\n"},
{"answer": "\nAnalysis: An intuitive thought on this problem is to create an auxiliary stack. We push the numbers in the first sequence one by one, and try to pop them out according to the order in the second sequence.\n\nTake the sequence 4, 5, 3, 2, 1 as an example to analyze the process to push and pop. The first number to be popped is 4, so we need to push it into a stack. The pushing order is defined in the first sequence, where there are numbers 1, 2 and 3 prior to 4. Therefore, numbers 1, 2, and 3 are pushed into a stack before 4 is pushed. At this time, there are 4 numbers in a stack, which are 1, 2, 3 and 4, with 4 on top. When 4 is popped, numbers 1, 2 and 3 are left. The next number to be popped is 5, which is not on top of stack, so we have to push numbers in the first sequence into stack until 5 is pushed. When number 5 is on top of a stack, we can pop it. The next three numbers to be popped are 3, 2 and 1. Since these numbers are on top of a stack before pop operations, they can be popped directly. The whole process to push and pop is summarized in Table 1.\n\nStep Operation Stack Status Popped Step Operation Stack Status Popped 1 Push 1 1 6 Push 5 1, 2, 3, 5 2 Push 2 1, 2 7 Pop 1, 2, 3 5 3 Push 3 1, 2, 3 8 Pop 1, 2 3 4 Push 4 1, 2, 3, 4 9 Pop 1 2 5 Pop 1, 2, 3 4 10 Pop 1\nStep\nOperation\nStack Status\nPopped\nStep\nOperation\nStack Status\nPopped\n1\nPush 1\n1\n\n6\nPush 5\n1, 2, 3, 5\n\n2\nPush 2\n1, 2\n\n7\nPop\n1, 2, 3\n5\n3\nPush 3\n1, 2, 3\n\n8\nPop\n1, 2\n3\n4\nPush 4\n1, 2, 3, 4\n\n9\nPop\n1\n2\n5\nPop\n1, 2, 3\n4\n10\nPop\n\n1\nTable 1: The process to push and pop with a push sequence 1, 2, 3, 4, 5 and pop sequence 4, 5, 3, 2, 1\n\nLet us continue to analyze another pop sequence 4, 3, 5, 1, 2. The process to pop the first number 4 is similar to the process above. After the number 4 is popped, 3 is on the top of stack and it can be popped. The next number to be popped is 5. Since it is not on top, we have to push numbers in the first sequence until the number 5 is pushed. The number 5 can be popped when it is pushed onto the top of a stack. After 5 is popped out, there are only two numbers 1 and 2 left in stack. The next number to be popped is 1, but it is not on the top of stack. We have to push numbers in the first sequence until 1 is pushed. However, all numbers in the first sequence have been pushed. Therefore, the sequence 4, 3, 5, 1, 2 is not a pop sequence of the stack with push sequence 1, 2, 3, 4, 5. The whole process to push and pop is summarized in Table 2.\n\nStep Operation Stack Status Popped Step Operation Stack Status Popped 1 Push 1 1 6 Pop 1, 2 3 2 Push 2 1, 2 7 Push 5 1, 2, 5 3 Push 3 1, 2, 3 8 Pop 1, 2 5 4 Push 4 1, 2, 3, 4 The next number to be popped is 1, which is neither on the top of stack,   nor in the remaining numbers of push sequence. 5 Pop 1, 2, 3 4\nStep\nOperation\nStack Status\nPopped\nStep\nOperation\nStack Status\nPopped\n1\nPush 1\n1\n\n6\nPop\n1, 2\n3\n2\nPush 2\n1, 2\n\n7\nPush 5\n1, 2, 5\n\n3\nPush 3\n1, 2, 3\n\n8\nPop\n1, 2\n5\n4\nPush 4\n1, 2, 3, 4\n\nThe next number to be popped is 1, which is neither on the top of stack,   nor in the remaining numbers of push sequence.\n5\nPop\n1, 2, 3\n4\nTable 1: The process to push and pop with a push sequence 1, 2, 3, 4, 5 and pop sequence 4, 3, 5, 1, 2\n\nAccording to the analysis above, we get a solution to check whether a sequence is a pop sequence of a stack or not. If the number to be popped is currently on top of stack, just pop it. If it is not on the top of stack, we have to push remaining numbers into the auxiliary stack until we meet the number to be popped. If the next number to be popped is not remaining in the push sequence, it is not a pop sequence of a stack. The following is some sample code based on this solution:\n\nbool IsPopOrder( const int * pPush, const int * pPop, int nLength)\n{\nbool bPossible = false ;\n\nif (pPush != NULL && pPop != NULL && nLength > 0)\n{\nconst int * pNextPush = pPush;\nconst int * pNextPop = pPop;\n\nstd::stack< int > stackData;\n\nwhile (pNextPop - pPop < nLength)\n{\n// When the number to be popped is not on top of stack,\n// push some numbers in the push sequence into stack\nwhile (stackData.empty() || stackData.top() != *pNextPop)\n{\n// If all numbers have been pushed, break\nif (pNextPush - pPush == nLength)\nbreak ;\n\nstackData.push(*pNextPush);\n\npNextPush ++;\n}\n\nif (stackData.top() != *pNextPop)\nbreak ;\n\nstackData.pop();\npNextPop ++;\n}\n\nif (stackData.empty() && pNextPop - pPop == nLength)\nbPossible = true ;\n}\n\nreturn bPossible;\n}", "question": "\nProblem: Given two integer sequences, one of which is the push sequence of a stack, please check whether the other sequence is a corresponding pop sequence or not.\n\nFor example, if 1, 2, 3, 4, 5 is a push sequence, 4, 5, 3, 2, 1 is a corresponding pop sequence, but the sequence 4, 3, 5, 1, 2 is not.\n"},
{"answer": "\nAnalysis: Before we analyze how to merge an array of ranges, let\u2019s discuss how to merge two ranges. When two ranges don\u2019t overlap each other, they can\u2019t merge. When two ranges overlap, the less starting value of two ranges becomes the starting value of the merged range, and the greater ending value of two ranges becomes the ending value of the merged range.\n\nTherefore, two ranges [5, 13] and [8, 19] are merged into a new range [5, 19], and two ranges [27, 39] and [31, 37] are merged into a new range [27, 39]. The two merged ranges can\u2019t be merged further because they don\u2019t overlap.\n\nThe next question is: How to check whether two ranges overlap\u00a0each other? When two ranges overlap, there is at least on node in a range is contained in the other range. For instance, the starting value 8 of the range [8, 19] is contained in the range [5, 13], therefore, the two ranges [5, 13] and [8, 19] overlap. No nodes in the range [8, 19] are contained in the range [31, 37], so the two ranges don\u2019t overlap.\n\nThe following code shows how to merge two ranges, as well as to check whether two ranges overlap:\n\n public bool Contains( int value)\n\n {\n\n     if (value >= this .Start && value <= this .End)\n\n     {\n\n         return true ;\n\n     }\n\n  \n\n     return false ;\n\n }\n\n  \n\n public bool Overlaps( Range other)\n\n {\n\n     if (other == null )\n\n     {\n\n         return false ;\n\n     }\n\n  \n\n     if ( this .Contains(other.Start) || this .Contains(other.End)         || other .Contains( this .Start) || other .Contains( this .End) )\n\n     {\n\n         return true ;\n\n     }\n\n  \n\n     return false ;\n\n }\n\n  \n\n public Range Merge( Range other)\n\n {\n\n     if (! this .Overlaps(other))\n\n     {\n\n         throw new ApplicationException ( \"Can't merge tworanges.\" );\n\n     }\n\n  \n\n     int newStart = ( this .Start < other.Start) ? this .Start : other.Start;\n\n     int newEnd = ( this .End > other.End) ? this .End : other.End;\n\n  \n\n     return new Range (newStart, newEnd);\n\n }\n\nNow let\u2019s move on to merge an array of ranges. The first step is to sort the ranges based on their start values. When the ranges [5, 13], [27, 39], [8, 19], and [31, 37] are sorted, they are in the order of [5, 13], [8, 19], [27, 39], and [31, 37].\n\nThe next steps are to merge the sorted ranges. The merged ranges are inserted into a data container. At each step, a range is retrieved from the sorted array, and merged with the existing ranges in the container.\n\nAt first the data container is empty, and the first range [5, 13] is inserted into the container directly, without merging. Now there is only one range [5, 13] in the container.\n\nThen the next range [8, 19] is retrieved. Since it overlaps the range[5, 13], and they become [5, 19] when they merged. There is still only one\u00a0range, which is [5, 19] in the container.\n\nThe next range [27, 39] is retrieved, which does not overlap the range [5, 19] in the container, so it is inserted into the range directly without merging. There are two ranges [5, 19] and [27, 39] in the container.\n\nThe last range in the sorted array is [31, 37]. It overlaps the last range [27, 39] in the container. Therefore, the last range [27, 39] is deleted from the container, and then the merged range is inserted into the container. At this step, the merged range is also [27, 39].\n\nRanges in the container are also sorted based on their starting values, and they don't overlap each other. Notice that it's only necessary to check whether the new range overlap the last range in the container. Why not the other ranges in the container? Let's analyze what would happen when a new range in the sorted array overlap two ranges in the container, with Figure 2:\n\nIn Figure 2, the container has two ranges A and B, and a new range C is retrieved from the sorted array, which overlaps the ranges A and B. Since C overlaps A, the starting value of C should be less than the ending value of A. On the other hand, C is retrieved from the sorted array later than B, the starting value of C is greater than starting value of B. Additionally, B is behind A and they don't overlap, so the starting value of B is greater than the ending value A. Therefore, the starting value of C is greater than the ending value of A. It contradicts.\nSince it's only necessary to merge new ranges from the sorted array with the last range in the container. We implement the container as a stack, and the last range is on the top of the stack.\nThe following is the C# code to merge a sort an array of ranges:\n public static Range []Merge( Range [] ranges)\n {\n     Stack < Range > results = new Stack < Range >();\n     if (ranges != null )\n     {\n         Array .Sort(ranges, CompareRangeByStart);\n  \n         foreach ( var range in ranges)\n         {\n             if (results.Count == 0)\n             {\n                 results.Push(range);\n             }\n             else\n             {\n                 var top =results.Peek();\n                 if (top.Overlaps(range))\n                 {\n                     var union = top.Merge(range);\n                     results.Pop();\n                     results.Push(union);\n                 }\n                 else\n                 {\n                     results.Push(range);\n                 }\n             }\n         }\n     }\n  \n     return results.Reverse().ToArray();\n }\n", "question": "\nQuestions: Given an array of ranges, please merge the overlapping ones. For example, four ranges [5, 13], [27, 39], [8, 19], [31, 37] (in blue in\u00a0 Figure1) are merged into two ranges, which are [5, 19] and [27, 39] (in green in\u00a0Figure 1).\n"},
{"answer": "\nAnalysis: Firstly let us define a function f(t) which is the minimal number of coins to make change for total value t. If there are n different coins, we have n choices to make change for value t: we can add a coin with value v 1 into a set of coins whose total value is t-v 1 . The minimal number of coins to get value t-v 1 is f(t-v 1 ). Similarly, we can add a coin with value v 2 into a set of coins whose total value is t-v 2 . The minimal number of coins to get value t-v 2 is f(t-v 2 )\u2026\n\nTherefore, we divide a problem to calculate f(t) into n sub-problems: f(t-v 1 ), f(t-v 2 ), \u2026, f(t-v n ). We can get a formal equation for f(t) as the following accordingly:\n\n\n\nThis equation can be implemented with recursion easily. However, the recursive solution will cause serious performance issues since there are overlaps when we divide this problem into n sub-problems. A better solution is to utilize iteration, and store the result of sub-problems into a table (as the Table 1).\n\nIn the Table 1, each column except the first one is to denote the number of coins to make change for a specific value. We can calculate the numbers in the Table 1 from left to right, to simulate the iterative process to get the result of f(15).\n\nFor instance, there are two numbers 4 and 2 under the column title \u201c6\u201d. We have two alternatives to make change for 6: the first one is to add a coin with value 1 to a set of coins whose total value is 5. Since the minimal number of coins to get value 5 is 3 (highlighted number under the column tile \u201c5\u201d), the number in the first cell under column title \u201c6\u201d is 4 (4=3+1). The second choice is to add a coin with value 3 to a set of coins whose total value is 3. Since the minimal number of coins to get value 3 is 1 (highlighted number under the column tile \u201c3\u201d), the number in the second cell under column title \u201c6\u201d is 2 (2=1+1). We highlight the number 2 in the column under tile 6 because 2 is less than 4.\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n1\n0\n1\n2\n3\n2\n3\n4\n3\n4\n5\n2\n2\n3\n3\n4\n5\n3\n0\n-\n-\n1\n2\n3\n2\n3\n4\n3\n4\n5\n2\n2\n3\n3\n9\n0\n-\n-\n-\n-\n-\n-\n-\n-\n1\n2\n3\n2\n3\n4\n3\n10\n0\n-\n-\n-\n-\n-\n-\n-\n-\n-\n1\n2\n3\n2\n3\n4\nTable 1: The iterative process to calculate the minimal number of coins to make changes for 15.\n\nEven though we have a 2-D matrix to show the iterative process, it only requires a 1-D array for coding, because it is only necessary to store the minimal number of coins to make change for each total value. The sample code is shown below:\n\nint GetMinCount( int total, int * coins, int length)\n{\nint * counts = new int [total + 1];\ncounts[0] = 0;\n\nconst int MAX = 0x7FFFFFFF;\n\nfor ( int i = 1; i <= total; ++ i)\n{\nint count = MAX;\nfor ( int j = 0; j < length; ++ j)\n{\nif (i - coins[j] >= 0 && count > counts[i - coins[j]])\ncount = counts[i - coins[j]];\n}\n\nif (count < MAX)\ncounts[i] = count + 1;\nelse\ncounts[i] = MAX;\n}\n\nint minCount = counts[total];\ndelete [] counts;\n\nreturn minCount;", "question": "\nProblem: Please implement a function which gets the minimal number of coins, whose value is v 1 , v 2 , \u2026, v n , to make change for an amount of money with value t. Any coin with value v i may duplicate for any times to make change.\n\nFor example, the minimal number of coins to make change for 15 out of a set of coins with value 1, 3, 9, 10 is 3. We can choose two coins with value 3 and a coin with value 9. The number of coins for other choices should be greater than 3.\n"},
{"answer": "\nAnalysis: Firstly let us define a function f(t) which is the minimal number of coins to make change for total value t. If there are n different coins, we have n choices to make change for value t: we can add a coin with value v 1 into a set of coins whose total value is t-v 1 . The minimal number of coins to get value t-v 1 is f(t-v 1 ). Similarly, we can add a coin with value v 2 into a set of coins whose total value is t-v 2 . The minimal number of coins to get value t-v 2 is f(t-v 2 )\u2026\n\nTherefore, we divide a problem to calculate f(t) into n sub-problems: f(t-v 1 ), f(t-v 2 ), \u2026, f(t-v n ). We can get a formal equation for f(t) as the following accordingly:\n\n\n\nThis equation can be implemented with recursion easily. However, the recursive solution will cause serious performance issues since there are overlaps when we divide this problem into n sub-problems. A better solution is to utilize iteration, and store the result of sub-problems into a table (as the Table 1).\n\nIn the Table 1, each column except the first one is to denote the number of coins to make change for a specific value. We can calculate the numbers in the Table 1 from left to right, to simulate the iterative process to get the result of f(15).\n\nFor instance, there are two numbers 4 and 2 under the column title \u201c6\u201d. We have two alternatives to make change for 6: the first one is to add a coin with value 1 to a set of coins whose total value is 5. Since the minimal number of coins to get value 5 is 3 (highlighted number under the column tile \u201c5\u201d), the number in the first cell under column title \u201c6\u201d is 4 (4=3+1). The second choice is to add a coin with value 3 to a set of coins whose total value is 3. Since the minimal number of coins to get value 3 is 1 (highlighted number under the column tile \u201c3\u201d), the number in the second cell under column title \u201c6\u201d is 2 (2=1+1). We highlight the number 2 in the column under tile 6 because 2 is less than 4.\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n1\n0\n1\n2\n3\n2\n3\n4\n3\n4\n5\n2\n2\n3\n3\n4\n5\n3\n0\n-\n-\n1\n2\n3\n2\n3\n4\n3\n4\n5\n2\n2\n3\n3\n9\n0\n-\n-\n-\n-\n-\n-\n-\n-\n1\n2\n3\n2\n3\n4\n3\n10\n0\n-\n-\n-\n-\n-\n-\n-\n-\n-\n1\n2\n3\n2\n3\n4\nTable 1: The iterative process to calculate the minimal number of coins to make changes for 15.\n\nEven though we have a 2-D matrix to show the iterative process, it only requires a 1-D array for coding, because it is only necessary to store the minimal number of coins to make change for each total value. The sample code is shown below:\n\nint GetMinCount( int total, int * coins, int length)\n{\nint * counts = new int [total + 1];\ncounts[0] = 0;\n\nconst int MAX = 0x7FFFFFFF;\n\nfor ( int i = 1; i <= total; ++ i)\n{\nint count = MAX;\nfor ( int j = 0; j < length; ++ j)\n{\nif (i - coins[j] >= 0 && count > counts[i - coins[j]])\ncount = counts[i - coins[j]];\n}\n\nif (count < MAX)\ncounts[i] = count + 1;\nelse\ncounts[i] = MAX;\n}\n\nint minCount = counts[total];\ndelete [] counts;\n\nreturn minCount;", "question": "\nProblem: Please implement a function which gets the minimal number of coins, whose value is v 1 , v 2 , \u2026, v n , to make change for an amount of money with value t. Any coin with value v i may duplicate for any times to make change.\n\nFor example, the minimal number of coins to make change for 15 out of a set of coins with value 1, 3, 9, 10 is 3. We can choose two coins with value 3 and a coin with value 9. The number of coins for other choices should be greater than 3.\n"},
{"answer": "\nAnalysis: If a function f(i, j) is defined to indicate the edit difference between the substring of the \u00a0first string ending with the j th character and the substring of the second string ending with the i th character. It is obvious that f(i, 0) = i, because when we delete i characters from the substring of the first string ending with the i th character, we get an empty string (it is also the substring of the second string ending with the 0-th string). Similarly, f(0, j) = j.\n\nLet discuss the cases when both i and j are greater than 1. If the i th character of the second string is same as the j th character of the first string, no edit operations are necessary. Therefore, f(i, j) = f(i-1, j-1).\n\nWhen the j th character of the first string is different from the i th character of the second string, there are three options available: (1) Insert the i th character of second string into the first string. In this case, f(i, j) = f(i-1, j) + 1. (2) Delete the j th character of the first string. In this case, f(i, j) = f(i, j-1) + 1. (3) Replace the j th character of the first string with the i th character of the second string. In this case, f(i, j) = f(i-1, j-1) + 1. What is the final value for f(i, j)? It should be the minimal value of the three cases.\nIf we draw a table to show the edit distance values f(i, j) between \u201cSaturday\u201d and \u201cSunday\u201d, it looks like the Table 1.\n\nS a t u r d a y 0 1 2 3 4 5 6 7 8 S 1 0 1 2 3 4 5 6 7 u 2 1 1 2 2 3 4 5 6 n 3 2 2 2 3 3 4 5 6 d 4 3 3 3 3 4 3 4 5 a 5 4 3 4 4 4 4 3 4 y 6 5 4 4 5 5 5 4 3\n\n\nS\na\nt\nu\nr\nd\na\ny\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\nS\n1\n0\n1\n2\n3\n4\n5\n6\n7\nu\n2\n1\n1\n2\n2\n3\n4\n5\n6\nn\n3\n2\n2\n2\n3\n3\n4\n5\n6\nd\n4\n3\n3\n3\n3\n4\n3\n4\n5\na\n5\n4\n3\n4\n4\n4\n4\n3\n4\ny\n6\n5\n4\n4\n5\n5\n5\n4\n3\nTable 1: Edit distance value f(i, j) between \u201cSaturday\u201d and \u201cSunday\u201d.\n\nThe edit distance of two strings is at the right-bottom corner of the table for edit distance values.\nA formal equation can be defined for this problem:\n\n\n\n\nIt is not difficult to develop code based on the equation above. An edit distance value table can be implemented as a 2-D array. Some sample code is shown as below:\n\nint getEditDistance( char * str1, char * str2)\n{\nif (str1 == NULL || str2 == NULL)\nreturn -1;\n\nint len1 = strlen(str1);\nint len2 = strlen(str2);\n\nint ** distances = ( int **) new int [len2 + 1];\nfor ( int i = 0; i < len2 + 1; ++ i)\ndistances[i] = new int [len1 + 1];\n\nint editDistance = getEditDistance(str1, str2, distances, len1, len2);\n\nfor ( int i = 0; i < len2 + 1; ++ i)\ndelete [] distances[i];\ndelete [] distances;\n\nreturn editDistance;\n}\n\nint getEditDistance( char * str1, char * str2, int ** distances, int len1, int len2)\n{\nfor ( int i = 0; i < len2 + 1; ++ i)\ndistances[i][0] = i;\nfor ( int j = 0; j < len1 + 1; ++ j)\ndistances[0][j] = j;\n\nfor ( int i = 1; i < len2 + 1; ++ i)\n{\nfor ( int j = 1; j < len1 + 1; ++ j)\n{\nif (str1[j - 1] == str2[i - 1])\ndistances[i][j] = distances[i - 1][j - 1];\nelse\n{\nint deletion = distances[i][j - 1] + 1;\nint insertion = distances[i - 1][j] + 1;\nint substitution = distances[i - 1][j - 1] + 1;\ndistances[i][j] = min(deletion, insertion, substitution);\n}\n}\n}\n\nreturn distances[len2][len1];\n}\n\nint min( int num1, int num2, int num3)\n{\nint less = (num1 < num2) ? num1 : num2;\nreturn (less < num3) ? less : num3;\n}\n", "question": "\nProblem: Implement a function which gets the edit distance of two input strings. There are three types of edit operations: insertion, deletion and substitution. Edit distance is the minimal number of edit operations to modify a string from one to the other.\n\nFor example, the edit distance between \u201cSaturday\u201d and \u201cSunday\u201d is 3, since the following three edit operations are required to modify one into the other:\n1. S a turday \u2192 Sturday (deletion of \u2018a\u2019)\n2. S t urday\u2192 Surday (deletion of \u2018t\u2019)\n3. Su r day \u2192 Su n day (substitution of \u2018n\u2019 for \u2018r\u2019)\n\nThere is no way to achieve it with fewer than three operations.\n"},
{"answer": "\nAnalysis: If a function f(i, j) is defined to indicate the edit difference between the substring of the \u00a0first string ending with the j th character and the substring of the second string ending with the i th character. It is obvious that f(i, 0) = i, because when we delete i characters from the substring of the first string ending with the i th character, we get an empty string (it is also the substring of the second string ending with the 0-th string). Similarly, f(0, j) = j.\n\nLet discuss the cases when both i and j are greater than 1. If the i th character of the second string is same as the j th character of the first string, no edit operations are necessary. Therefore, f(i, j) = f(i-1, j-1).\n\nWhen the j th character of the first string is different from the i th character of the second string, there are three options available: (1) Insert the i th character of second string into the first string. In this case, f(i, j) = f(i-1, j) + 1. (2) Delete the j th character of the first string. In this case, f(i, j) = f(i, j-1) + 1. (3) Replace the j th character of the first string with the i th character of the second string. In this case, f(i, j) = f(i-1, j-1) + 1. What is the final value for f(i, j)? It should be the minimal value of the three cases.\nIf we draw a table to show the edit distance values f(i, j) between \u201cSaturday\u201d and \u201cSunday\u201d, it looks like the Table 1.\n\nS a t u r d a y 0 1 2 3 4 5 6 7 8 S 1 0 1 2 3 4 5 6 7 u 2 1 1 2 2 3 4 5 6 n 3 2 2 2 3 3 4 5 6 d 4 3 3 3 3 4 3 4 5 a 5 4 3 4 4 4 4 3 4 y 6 5 4 4 5 5 5 4 3\n\n\nS\na\nt\nu\nr\nd\na\ny\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\nS\n1\n0\n1\n2\n3\n4\n5\n6\n7\nu\n2\n1\n1\n2\n2\n3\n4\n5\n6\nn\n3\n2\n2\n2\n3\n3\n4\n5\n6\nd\n4\n3\n3\n3\n3\n4\n3\n4\n5\na\n5\n4\n3\n4\n4\n4\n4\n3\n4\ny\n6\n5\n4\n4\n5\n5\n5\n4\n3\nTable 1: Edit distance value f(i, j) between \u201cSaturday\u201d and \u201cSunday\u201d.\n\nThe edit distance of two strings is at the right-bottom corner of the table for edit distance values.\nA formal equation can be defined for this problem:\n\n\n\n\nIt is not difficult to develop code based on the equation above. An edit distance value table can be implemented as a 2-D array. Some sample code is shown as below:\n\nint getEditDistance( char * str1, char * str2)\n{\nif (str1 == NULL || str2 == NULL)\nreturn -1;\n\nint len1 = strlen(str1);\nint len2 = strlen(str2);\n\nint ** distances = ( int **) new int [len2 + 1];\nfor ( int i = 0; i < len2 + 1; ++ i)\ndistances[i] = new int [len1 + 1];\n\nint editDistance = getEditDistance(str1, str2, distances, len1, len2);\n\nfor ( int i = 0; i < len2 + 1; ++ i)\ndelete [] distances[i];\ndelete [] distances;\n\nreturn editDistance;\n}\n\nint getEditDistance( char * str1, char * str2, int ** distances, int len1, int len2)\n{\nfor ( int i = 0; i < len2 + 1; ++ i)\ndistances[i][0] = i;\nfor ( int j = 0; j < len1 + 1; ++ j)\ndistances[0][j] = j;\n\nfor ( int i = 1; i < len2 + 1; ++ i)\n{\nfor ( int j = 1; j < len1 + 1; ++ j)\n{\nif (str1[j - 1] == str2[i - 1])\ndistances[i][j] = distances[i - 1][j - 1];\nelse\n{\nint deletion = distances[i][j - 1] + 1;\nint insertion = distances[i - 1][j] + 1;\nint substitution = distances[i - 1][j - 1] + 1;\ndistances[i][j] = min(deletion, insertion, substitution);\n}\n}\n}\n\nreturn distances[len2][len1];\n}\n\nint min( int num1, int num2, int num3)\n{\nint less = (num1 < num2) ? num1 : num2;\nreturn (less < num3) ? less : num3;\n}\n", "question": "\nProblem: Implement a function which gets the edit distance of two input strings. There are three types of edit operations: insertion, deletion and substitution. Edit distance is the minimal number of edit operations to modify a string from one to the other.\n\nFor example, the edit distance between \u201cSaturday\u201d and \u201cSunday\u201d is 3, since the following three edit operations are required to modify one into the other:\n1. S a turday \u2192 Sturday (deletion of \u2018a\u2019)\n2. S t urday\u2192 Surday (deletion of \u2018t\u2019)\n3. Su r day \u2192 Su n day (substitution of \u2018n\u2019 for \u2018r\u2019)\n\nThere is no way to achieve it with fewer than three operations.\n"},
{"answer": "\nAnalysis: An intuitive thought on this problem is to create an auxiliary stack. We push the numbers in the first sequence one by one, and try to pop them out according to the order in the second sequence.\n\nTake the sequence 4, 5, 3, 2, 1 as an example to analyze the process to push and pop. The first number to be popped is 4, so we need to push it into a stack. The pushing order is defined in the first sequence, where there are numbers 1, 2 and 3 prior to 4. Therefore, numbers 1, 2, and 3 are pushed into a stack before 4 is pushed. At this time, there are 4 numbers in a stack, which are 1, 2, 3 and 4, with 4 on top. When 4 is popped, numbers 1, 2 and 3 are left. The next number to be popped is 5, which is not on top of stack, so we have to push numbers in the first sequence into stack until 5 is pushed. When number 5 is on top of a stack, we can pop it. The next three numbers to be popped are 3, 2 and 1. Since these numbers are on top of a stack before pop operations, they can be popped directly. The whole process to push and pop is summarized in Table 1.\n\nStep Operation Stack Status Popped Step Operation Stack Status Popped 1 Push 1 1 6 Push 5 1, 2, 3, 5 2 Push 2 1, 2 7 Pop 1, 2, 3 5 3 Push 3 1, 2, 3 8 Pop 1, 2 3 4 Push 4 1, 2, 3, 4 9 Pop 1 2 5 Pop 1, 2, 3 4 10 Pop 1\nStep\nOperation\nStack Status\nPopped\nStep\nOperation\nStack Status\nPopped\n1\nPush 1\n1\n\n6\nPush 5\n1, 2, 3, 5\n\n2\nPush 2\n1, 2\n\n7\nPop\n1, 2, 3\n5\n3\nPush 3\n1, 2, 3\n\n8\nPop\n1, 2\n3\n4\nPush 4\n1, 2, 3, 4\n\n9\nPop\n1\n2\n5\nPop\n1, 2, 3\n4\n10\nPop\n\n1\nTable 1: The process to push and pop with a push sequence 1, 2, 3, 4, 5 and pop sequence 4, 5, 3, 2, 1\n\nLet us continue to analyze another pop sequence 4, 3, 5, 1, 2. The process to pop the first number 4 is similar to the process above. After the number 4 is popped, 3 is on the top of stack and it can be popped. The next number to be popped is 5. Since it is not on top, we have to push numbers in the first sequence until the number 5 is pushed. The number 5 can be popped when it is pushed onto the top of a stack. After 5 is popped out, there are only two numbers 1 and 2 left in stack. The next number to be popped is 1, but it is not on the top of stack. We have to push numbers in the first sequence until 1 is pushed. However, all numbers in the first sequence have been pushed. Therefore, the sequence 4, 3, 5, 1, 2 is not a pop sequence of the stack with push sequence 1, 2, 3, 4, 5. The whole process to push and pop is summarized in Table 2.\n\nStep Operation Stack Status Popped Step Operation Stack Status Popped 1 Push 1 1 6 Pop 1, 2 3 2 Push 2 1, 2 7 Push 5 1, 2, 5 3 Push 3 1, 2, 3 8 Pop 1, 2 5 4 Push 4 1, 2, 3, 4 The next number to be popped is 1, which is neither on the top of stack,   nor in the remaining numbers of push sequence. 5 Pop 1, 2, 3 4\nStep\nOperation\nStack Status\nPopped\nStep\nOperation\nStack Status\nPopped\n1\nPush 1\n1\n\n6\nPop\n1, 2\n3\n2\nPush 2\n1, 2\n\n7\nPush 5\n1, 2, 5\n\n3\nPush 3\n1, 2, 3\n\n8\nPop\n1, 2\n5\n4\nPush 4\n1, 2, 3, 4\n\nThe next number to be popped is 1, which is neither on the top of stack,   nor in the remaining numbers of push sequence.\n5\nPop\n1, 2, 3\n4\nTable 1: The process to push and pop with a push sequence 1, 2, 3, 4, 5 and pop sequence 4, 3, 5, 1, 2\n\nAccording to the analysis above, we get a solution to check whether a sequence is a pop sequence of a stack or not. If the number to be popped is currently on top of stack, just pop it. If it is not on the top of stack, we have to push remaining numbers into the auxiliary stack until we meet the number to be popped. If the next number to be popped is not remaining in the push sequence, it is not a pop sequence of a stack. The following is some sample code based on this solution:\n\nbool IsPopOrder( const int * pPush, const int * pPop, int nLength)\n{\nbool bPossible = false ;\n\nif (pPush != NULL && pPop != NULL && nLength > 0)\n{\nconst int * pNextPush = pPush;\nconst int * pNextPop = pPop;\n\nstd::stack< int > stackData;\n\nwhile (pNextPop - pPop < nLength)\n{\n// When the number to be popped is not on top of stack,\n// push some numbers in the push sequence into stack\nwhile (stackData.empty() || stackData.top() != *pNextPop)\n{\n// If all numbers have been pushed, break\nif (pNextPush - pPush == nLength)\nbreak ;\n\nstackData.push(*pNextPush);\n\npNextPush ++;\n}\n\nif (stackData.top() != *pNextPop)\nbreak ;\n\nstackData.pop();\npNextPop ++;\n}\n\nif (stackData.empty() && pNextPop - pPop == nLength)\nbPossible = true ;\n}\n\nreturn bPossible;\n}", "question": "\nProblem: Given two integer sequences, one of which is the push sequence of a stack, please check whether the other sequence is a corresponding pop sequence or not.\n\nFor example, if 1, 2, 3, 4, 5 is a push sequence, 4, 5, 3, 2, 1 is a corresponding pop sequence, but the sequence 4, 3, 5, 1, 2 is not.\n"},
{"answer": "\nAnalysis: An intuitive thought on this problem is to create an auxiliary stack. We push the numbers in the first sequence one by one, and try to pop them out according to the order in the second sequence.\n\nTake the sequence 4, 5, 3, 2, 1 as an example to analyze the process to push and pop. The first number to be popped is 4, so we need to push it into a stack. The pushing order is defined in the first sequence, where there are numbers 1, 2 and 3 prior to 4. Therefore, numbers 1, 2, and 3 are pushed into a stack before 4 is pushed. At this time, there are 4 numbers in a stack, which are 1, 2, 3 and 4, with 4 on top. When 4 is popped, numbers 1, 2 and 3 are left. The next number to be popped is 5, which is not on top of stack, so we have to push numbers in the first sequence into stack until 5 is pushed. When number 5 is on top of a stack, we can pop it. The next three numbers to be popped are 3, 2 and 1. Since these numbers are on top of a stack before pop operations, they can be popped directly. The whole process to push and pop is summarized in Table 1.\n\nStep Operation Stack Status Popped Step Operation Stack Status Popped 1 Push 1 1 6 Push 5 1, 2, 3, 5 2 Push 2 1, 2 7 Pop 1, 2, 3 5 3 Push 3 1, 2, 3 8 Pop 1, 2 3 4 Push 4 1, 2, 3, 4 9 Pop 1 2 5 Pop 1, 2, 3 4 10 Pop 1\nStep\nOperation\nStack Status\nPopped\nStep\nOperation\nStack Status\nPopped\n1\nPush 1\n1\n\n6\nPush 5\n1, 2, 3, 5\n\n2\nPush 2\n1, 2\n\n7\nPop\n1, 2, 3\n5\n3\nPush 3\n1, 2, 3\n\n8\nPop\n1, 2\n3\n4\nPush 4\n1, 2, 3, 4\n\n9\nPop\n1\n2\n5\nPop\n1, 2, 3\n4\n10\nPop\n\n1\nTable 1: The process to push and pop with a push sequence 1, 2, 3, 4, 5 and pop sequence 4, 5, 3, 2, 1\n\nLet us continue to analyze another pop sequence 4, 3, 5, 1, 2. The process to pop the first number 4 is similar to the process above. After the number 4 is popped, 3 is on the top of stack and it can be popped. The next number to be popped is 5. Since it is not on top, we have to push numbers in the first sequence until the number 5 is pushed. The number 5 can be popped when it is pushed onto the top of a stack. After 5 is popped out, there are only two numbers 1 and 2 left in stack. The next number to be popped is 1, but it is not on the top of stack. We have to push numbers in the first sequence until 1 is pushed. However, all numbers in the first sequence have been pushed. Therefore, the sequence 4, 3, 5, 1, 2 is not a pop sequence of the stack with push sequence 1, 2, 3, 4, 5. The whole process to push and pop is summarized in Table 2.\n\nStep Operation Stack Status Popped Step Operation Stack Status Popped 1 Push 1 1 6 Pop 1, 2 3 2 Push 2 1, 2 7 Push 5 1, 2, 5 3 Push 3 1, 2, 3 8 Pop 1, 2 5 4 Push 4 1, 2, 3, 4 The next number to be popped is 1, which is neither on the top of stack,   nor in the remaining numbers of push sequence. 5 Pop 1, 2, 3 4\nStep\nOperation\nStack Status\nPopped\nStep\nOperation\nStack Status\nPopped\n1\nPush 1\n1\n\n6\nPop\n1, 2\n3\n2\nPush 2\n1, 2\n\n7\nPush 5\n1, 2, 5\n\n3\nPush 3\n1, 2, 3\n\n8\nPop\n1, 2\n5\n4\nPush 4\n1, 2, 3, 4\n\nThe next number to be popped is 1, which is neither on the top of stack,   nor in the remaining numbers of push sequence.\n5\nPop\n1, 2, 3\n4\nTable 1: The process to push and pop with a push sequence 1, 2, 3, 4, 5 and pop sequence 4, 3, 5, 1, 2\n\nAccording to the analysis above, we get a solution to check whether a sequence is a pop sequence of a stack or not. If the number to be popped is currently on top of stack, just pop it. If it is not on the top of stack, we have to push remaining numbers into the auxiliary stack until we meet the number to be popped. If the next number to be popped is not remaining in the push sequence, it is not a pop sequence of a stack. The following is some sample code based on this solution:\n\nbool IsPopOrder( const int * pPush, const int * pPop, int nLength)\n{\nbool bPossible = false ;\n\nif (pPush != NULL && pPop != NULL && nLength > 0)\n{\nconst int * pNextPush = pPush;\nconst int * pNextPop = pPop;\n\nstd::stack< int > stackData;\n\nwhile (pNextPop - pPop < nLength)\n{\n// When the number to be popped is not on top of stack,\n// push some numbers in the push sequence into stack\nwhile (stackData.empty() || stackData.top() != *pNextPop)\n{\n// If all numbers have been pushed, break\nif (pNextPush - pPush == nLength)\nbreak ;\n\nstackData.push(*pNextPush);\n\npNextPush ++;\n}\n\nif (stackData.top() != *pNextPop)\nbreak ;\n\nstackData.pop();\npNextPop ++;\n}\n\nif (stackData.empty() && pNextPop - pPop == nLength)\nbPossible = true ;\n}\n\nreturn bPossible;\n}", "question": "\nProblem: Given two integer sequences, one of which is the push sequence of a stack, please check whether the other sequence is a corresponding pop sequence or not.\n\nFor example, if 1, 2, 3, 4, 5 is a push sequence, 4, 5, 3, 2, 1 is a corresponding pop sequence, but the sequence 4, 3, 5, 1, 2 is not.\n"},
{"answer": "\nAnalysis: An intuitive thought on this problem is to create an auxiliary stack. We push the numbers in the first sequence one by one, and try to pop them out according to the order in the second sequence.\n\nTake the sequence 4, 5, 3, 2, 1 as an example to analyze the process to push and pop. The first number to be popped is 4, so we need to push it into a stack. The pushing order is defined in the first sequence, where there are numbers 1, 2 and 3 prior to 4. Therefore, numbers 1, 2, and 3 are pushed into a stack before 4 is pushed. At this time, there are 4 numbers in a stack, which are 1, 2, 3 and 4, with 4 on top. When 4 is popped, numbers 1, 2 and 3 are left. The next number to be popped is 5, which is not on top of stack, so we have to push numbers in the first sequence into stack until 5 is pushed. When number 5 is on top of a stack, we can pop it. The next three numbers to be popped are 3, 2 and 1. Since these numbers are on top of a stack before pop operations, they can be popped directly. The whole process to push and pop is summarized in Table 1.\n\nStep Operation Stack Status Popped Step Operation Stack Status Popped 1 Push 1 1 6 Push 5 1, 2, 3, 5 2 Push 2 1, 2 7 Pop 1, 2, 3 5 3 Push 3 1, 2, 3 8 Pop 1, 2 3 4 Push 4 1, 2, 3, 4 9 Pop 1 2 5 Pop 1, 2, 3 4 10 Pop 1\nStep\nOperation\nStack Status\nPopped\nStep\nOperation\nStack Status\nPopped\n1\nPush 1\n1\n\n6\nPush 5\n1, 2, 3, 5\n\n2\nPush 2\n1, 2\n\n7\nPop\n1, 2, 3\n5\n3\nPush 3\n1, 2, 3\n\n8\nPop\n1, 2\n3\n4\nPush 4\n1, 2, 3, 4\n\n9\nPop\n1\n2\n5\nPop\n1, 2, 3\n4\n10\nPop\n\n1\nTable 1: The process to push and pop with a push sequence 1, 2, 3, 4, 5 and pop sequence 4, 5, 3, 2, 1\n\nLet us continue to analyze another pop sequence 4, 3, 5, 1, 2. The process to pop the first number 4 is similar to the process above. After the number 4 is popped, 3 is on the top of stack and it can be popped. The next number to be popped is 5. Since it is not on top, we have to push numbers in the first sequence until the number 5 is pushed. The number 5 can be popped when it is pushed onto the top of a stack. After 5 is popped out, there are only two numbers 1 and 2 left in stack. The next number to be popped is 1, but it is not on the top of stack. We have to push numbers in the first sequence until 1 is pushed. However, all numbers in the first sequence have been pushed. Therefore, the sequence 4, 3, 5, 1, 2 is not a pop sequence of the stack with push sequence 1, 2, 3, 4, 5. The whole process to push and pop is summarized in Table 2.\n\nStep Operation Stack Status Popped Step Operation Stack Status Popped 1 Push 1 1 6 Pop 1, 2 3 2 Push 2 1, 2 7 Push 5 1, 2, 5 3 Push 3 1, 2, 3 8 Pop 1, 2 5 4 Push 4 1, 2, 3, 4 The next number to be popped is 1, which is neither on the top of stack,   nor in the remaining numbers of push sequence. 5 Pop 1, 2, 3 4\nStep\nOperation\nStack Status\nPopped\nStep\nOperation\nStack Status\nPopped\n1\nPush 1\n1\n\n6\nPop\n1, 2\n3\n2\nPush 2\n1, 2\n\n7\nPush 5\n1, 2, 5\n\n3\nPush 3\n1, 2, 3\n\n8\nPop\n1, 2\n5\n4\nPush 4\n1, 2, 3, 4\n\nThe next number to be popped is 1, which is neither on the top of stack,   nor in the remaining numbers of push sequence.\n5\nPop\n1, 2, 3\n4\nTable 1: The process to push and pop with a push sequence 1, 2, 3, 4, 5 and pop sequence 4, 3, 5, 1, 2\n\nAccording to the analysis above, we get a solution to check whether a sequence is a pop sequence of a stack or not. If the number to be popped is currently on top of stack, just pop it. If it is not on the top of stack, we have to push remaining numbers into the auxiliary stack until we meet the number to be popped. If the next number to be popped is not remaining in the push sequence, it is not a pop sequence of a stack. The following is some sample code based on this solution:\n\nbool IsPopOrder( const int * pPush, const int * pPop, int nLength)\n{\nbool bPossible = false ;\n\nif (pPush != NULL && pPop != NULL && nLength > 0)\n{\nconst int * pNextPush = pPush;\nconst int * pNextPop = pPop;\n\nstd::stack< int > stackData;\n\nwhile (pNextPop - pPop < nLength)\n{\n// When the number to be popped is not on top of stack,\n// push some numbers in the push sequence into stack\nwhile (stackData.empty() || stackData.top() != *pNextPop)\n{\n// If all numbers have been pushed, break\nif (pNextPush - pPush == nLength)\nbreak ;\n\nstackData.push(*pNextPush);\n\npNextPush ++;\n}\n\nif (stackData.top() != *pNextPop)\nbreak ;\n\nstackData.pop();\npNextPop ++;\n}\n\nif (stackData.empty() && pNextPop - pPop == nLength)\nbPossible = true ;\n}\n\nreturn bPossible;\n}", "question": "\nProblem: Given two integer sequences, one of which is the push sequence of a stack, please check whether the other sequence is a corresponding pop sequence or not.\n\nFor example, if 1, 2, 3, 4, 5 is a push sequence, 4, 5, 3, 2, 1 is a corresponding pop sequence, but the sequence 4, 3, 5, 1, 2 is not.\n"},
{"answer": "\nAnalysis: If a function f(i, j) is defined to indicate the edit difference between the substring of the \u00a0first string ending with the j th character and the substring of the second string ending with the i th character. It is obvious that f(i, 0) = i, because when we delete i characters from the substring of the first string ending with the i th character, we get an empty string (it is also the substring of the second string ending with the 0-th string). Similarly, f(0, j) = j.\n\nLet discuss the cases when both i and j are greater than 1. If the i th character of the second string is same as the j th character of the first string, no edit operations are necessary. Therefore, f(i, j) = f(i-1, j-1).\n\nWhen the j th character of the first string is different from the i th character of the second string, there are three options available: (1) Insert the i th character of second string into the first string. In this case, f(i, j) = f(i-1, j) + 1. (2) Delete the j th character of the first string. In this case, f(i, j) = f(i, j-1) + 1. (3) Replace the j th character of the first string with the i th character of the second string. In this case, f(i, j) = f(i-1, j-1) + 1. What is the final value for f(i, j)? It should be the minimal value of the three cases.\nIf we draw a table to show the edit distance values f(i, j) between \u201cSaturday\u201d and \u201cSunday\u201d, it looks like the Table 1.\n\nS a t u r d a y 0 1 2 3 4 5 6 7 8 S 1 0 1 2 3 4 5 6 7 u 2 1 1 2 2 3 4 5 6 n 3 2 2 2 3 3 4 5 6 d 4 3 3 3 3 4 3 4 5 a 5 4 3 4 4 4 4 3 4 y 6 5 4 4 5 5 5 4 3\n\n\nS\na\nt\nu\nr\nd\na\ny\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\nS\n1\n0\n1\n2\n3\n4\n5\n6\n7\nu\n2\n1\n1\n2\n2\n3\n4\n5\n6\nn\n3\n2\n2\n2\n3\n3\n4\n5\n6\nd\n4\n3\n3\n3\n3\n4\n3\n4\n5\na\n5\n4\n3\n4\n4\n4\n4\n3\n4\ny\n6\n5\n4\n4\n5\n5\n5\n4\n3\nTable 1: Edit distance value f(i, j) between \u201cSaturday\u201d and \u201cSunday\u201d.\n\nThe edit distance of two strings is at the right-bottom corner of the table for edit distance values.\nA formal equation can be defined for this problem:\n\n\n\n\nIt is not difficult to develop code based on the equation above. An edit distance value table can be implemented as a 2-D array. Some sample code is shown as below:\n\nint getEditDistance( char * str1, char * str2)\n{\nif (str1 == NULL || str2 == NULL)\nreturn -1;\n\nint len1 = strlen(str1);\nint len2 = strlen(str2);\n\nint ** distances = ( int **) new int [len2 + 1];\nfor ( int i = 0; i < len2 + 1; ++ i)\ndistances[i] = new int [len1 + 1];\n\nint editDistance = getEditDistance(str1, str2, distances, len1, len2);\n\nfor ( int i = 0; i < len2 + 1; ++ i)\ndelete [] distances[i];\ndelete [] distances;\n\nreturn editDistance;\n}\n\nint getEditDistance( char * str1, char * str2, int ** distances, int len1, int len2)\n{\nfor ( int i = 0; i < len2 + 1; ++ i)\ndistances[i][0] = i;\nfor ( int j = 0; j < len1 + 1; ++ j)\ndistances[0][j] = j;\n\nfor ( int i = 1; i < len2 + 1; ++ i)\n{\nfor ( int j = 1; j < len1 + 1; ++ j)\n{\nif (str1[j - 1] == str2[i - 1])\ndistances[i][j] = distances[i - 1][j - 1];\nelse\n{\nint deletion = distances[i][j - 1] + 1;\nint insertion = distances[i - 1][j] + 1;\nint substitution = distances[i - 1][j - 1] + 1;\ndistances[i][j] = min(deletion, insertion, substitution);\n}\n}\n}\n\nreturn distances[len2][len1];\n}\n\nint min( int num1, int num2, int num3)\n{\nint less = (num1 < num2) ? num1 : num2;\nreturn (less < num3) ? less : num3;\n}\n", "question": "\nProblem: Implement a function which gets the edit distance of two input strings. There are three types of edit operations: insertion, deletion and substitution. Edit distance is the minimal number of edit operations to modify a string from one to the other.\n\nFor example, the edit distance between \u201cSaturday\u201d and \u201cSunday\u201d is 3, since the following three edit operations are required to modify one into the other:\n1. S a turday \u2192 Sturday (deletion of \u2018a\u2019)\n2. S t urday\u2192 Surday (deletion of \u2018t\u2019)\n3. Su r day \u2192 Su n day (substitution of \u2018n\u2019 for \u2018r\u2019)\n\nThere is no way to achieve it with fewer than three operations.\n"},
{"answer": "\nAnalysis: All numbers in the matrix are scanned one by one. When a 1 is met, a group of 1s has been found, and then all 1s in the group are flipped to 0s.\nTherefore, the overall function to count the groups of 1s in a matrix can be implemented in the following C++ code:\n     int group = 0;\n     return group;\nLet\u2019s move on to flip 1s inside a group. Actually, it is an application of the seed filling algorithm. When we are going to flip a group starting from an entry, we take the entry as a seed and push it into a stack. At each step, we get an entry from the top of the stack, flip it, and then push its neighboring entries into the stack. The process continues until the stack is empty. The following code implements this algorithm:\n         int row = topIndex / cols;\n         // up", "question": ""},
{"answer": "\nAnalysis: All numbers in the matrix are scanned one by one. When a 1 is met, a group of 1s has been found, and then all 1s in the group are flipped to 0s.\nTherefore, the overall function to count the groups of 1s in a matrix can be implemented in the following C++ code:\n     int group = 0;\n     return group;\nLet\u2019s move on to flip 1s inside a group. Actually, it is an application of the seed filling algorithm. When we are going to flip a group starting from an entry, we take the entry as a seed and push it into a stack. At each step, we get an entry from the top of the stack, flip it, and then push its neighboring entries into the stack. The process continues until the stack is empty. The following code implements this algorithm:\n         int row = topIndex / cols;\n         // up", "question": ""},
{"answer": "\nAnalysis: All numbers in the matrix are scanned one by one. When a 1 is met, a group of 1s has been found, and then all 1s in the group are flipped to 0s.\nTherefore, the overall function to count the groups of 1s in a matrix can be implemented in the following C++ code:\n     int group = 0;\n     return group;\nLet\u2019s move on to flip 1s inside a group. Actually, it is an application of the seed filling algorithm. When we are going to flip a group starting from an entry, we take the entry as a seed and push it into a stack. At each step, we get an entry from the top of the stack, flip it, and then push its neighboring entries into the stack. The process continues until the stack is empty. The following code implements this algorithm:\n         int row = topIndex / cols;\n         // up", "question": ""},
{"answer": "\nAnalysis: All numbers in the matrix are scanned one by one. When a 1 is met, a group of 1s has been found, and then all 1s in the group are flipped to 0s.\nTherefore, the overall function to count the groups of 1s in a matrix can be implemented in the following C++ code:\n     int group = 0;\n     return group;\nLet\u2019s move on to flip 1s inside a group. Actually, it is an application of the seed filling algorithm. When we are going to flip a group starting from an entry, we take the entry as a seed and push it into a stack. At each step, we get an entry from the top of the stack, flip it, and then push its neighboring entries into the stack. The process continues until the stack is empty. The following code implements this algorithm:\n         int row = topIndex / cols;\n         // up", "question": ""},
{"answer": "\nAnalysis: All numbers in the matrix are scanned one by one. When a 1 is met, a group of 1s has been found, and then all 1s in the group are flipped to 0s.\nTherefore, the overall function to count the groups of 1s in a matrix can be implemented in the following C++ code:\n     int group = 0;\n     return group;\nLet\u2019s move on to flip 1s inside a group. Actually, it is an application of the seed filling algorithm. When we are going to flip a group starting from an entry, we take the entry as a seed and push it into a stack. At each step, we get an entry from the top of the stack, flip it, and then push its neighboring entries into the stack. The process continues until the stack is empty. The following code implements this algorithm:\n         int row = topIndex / cols;\n         // up", "question": ""},
{"answer": "\nAnalysis: All numbers in the matrix are scanned one by one. When a 1 is met, a group of 1s has been found, and then all 1s in the group are flipped to 0s.\nTherefore, the overall function to count the groups of 1s in a matrix can be implemented in the following C++ code:\n     int group = 0;\n     return group;\nLet\u2019s move on to flip 1s inside a group. Actually, it is an application of the seed filling algorithm. When we are going to flip a group starting from an entry, we take the entry as a seed and push it into a stack. At each step, we get an entry from the top of the stack, flip it, and then push its neighboring entries into the stack. The process continues until the stack is empty. The following code implements this algorithm:\n         int row = topIndex / cols;\n         // up", "question": ""},
{"answer": "\nAnalysis: The most straightforward solution for this problem is to scan the whole array from the beginning to end. When a target number is scanned, remove it and move all number behind it backward. The overall complexity is O( n 2 ), since we have to move O( n ) numbers when a target value is removed.\n\nWe can notice that it is not required to keep the order for the remaining numbers, and it does not care what numbers left beyond the new length. Therefore, we can move all target numbers to be removed to the end of the array.\n\nTwo pointers are defined to solve this problem: The first pointer (denoted as p1 ) moves forward until it reaches a number equal to the target value, which is initialized to the beginning of array. The other (denoted as p2 ) moves backward until it reaches a number not equal to the target value, which is initialized to the end of array. Two numbers pointed by p1 and p2 are swapped. We repeat the moving and swapping operations until all target numbers are scanned.\n\nThe sample code is shown as below:\n\nunsigned int Remove( int * numbers, unsigned int length, int n)\n{\nif (numbers == NULL || length < 1)\nreturn 0;\n\nint * p1 = numbers;\nint * p2 = numbers + length - 1;\nwhile (p1 < p2)\n{\nwhile (*p1 != n && (p1 - numbers) < length)\n++p1;\nwhile (*p2 == n && (p2 - numbers) > 0)\n--p2;\n\nif (p1 < p2)\n{\n*p1 = *p2;\n*p2 = n;\n}\n}\n\nreturn p1 - numbers;\n}\n\nBecause p1 points to the first target number in the array after scanning and swap, all elements at the left side of p2 are the remaining numbers. The new length can be calculated by the difference between the beginning of array and p1 .\n\nSince it is only required to scan the whole array once, and it costs O(1) time to swap a target value to the end of array, the overall time complexity is O( n ) for an array with n numbers.", "question": "\nQuestion: Given an array and a value, how to implement a function to remove all instances of that value in place and return the new length? The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\nFor example, if the input array is {4, 3, 2, 1, 2, 3, 6}, the result array after removing value 2 contains numbers {4, 3, 1, 3, 6}, and the new length of the remaining array is 5."},
{"answer": "\nAnalysis: Let us firstly have a try to select two numbers (denoted as num1 and num2 ) of the input array. If their sum equals to s , we are fortunate because the required numbers have been found. If the sum is less than s , we may replace num1 with its next number, because the array is increasingly sorted and its next number should be greater. If the sum is greater than s , num2 can be replaced with its previous number in the sorted array, which should be less than num2 .\n\nTake the array { 1 , 2 , 4 , 7 , 11 , 15 } and number 15 as an example. We define two pointers. At the first step, they point to the first number (also the least one) 1 and the last number (also the greatest one) 15. We move the second pointer forward to number 11, since their sum 16 and it is greater than 15.\n\nAt the second step, the two numbers are 1 and 11, and their sum 12 is less than 15. Therefore, we can move the first pointer afterward and let it point to 2.\n\nThe two numbers are 2 and 11 accordingly at the third step. Since their sum 13 is less than 15, we move the first pointer afterward again.\n\nNow the two numbers are 4 and 11, and their sum is 15 which is the expected sum. Therefore, we have found two numbers whose sum is 15.\n\nThe process is summarized as in Table 1:\n\nStep Num1 Num2 Sum Comparing with s Operation 1 1 15 16 Greater Select the previous   number of Num2 2 1 11 12 Less Select the next number of Num1 3 2 11 13 Less Select the next number   of Num1 4 4 11 15 Equal\nStep\nNum1\nNum2\nSum\nComparing with s\nOperation\n1\n1\n15\n16\nGreater\nSelect the previous   number of Num2\n2\n1\n11\n12\nLess\nSelect the next number of Num1\n3\n2\n11\n13\nLess\nSelect the next number   of Num1\n4\n4\n11\n15\nEqual\n\nTable 1: Find a pair of numbers with sum 15 out of array {1 \u3001 2 \u3001 4 \u3001 7 \u3001 11 \u3001 15}\n\nAfter interviewers approve our solution, we can begin to write code. The following is a piece of sample code:\n\nbool FindNumbersWithSum( int data[], int length, int sum,\nint * num1, int * num2)\n{\nbool found = false ;\nif (length < 1 || num1 == NULL || num2 == NULL)\nreturn found;\n\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\n*num1 = data[behind];\n*num2 = data[ahead];\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\n\nIn the code above, ahead is the index of the first number, and behind is the index of the second number. Since we only need to scan the input array once, its time complexity is O(n).\n\n\nAnalysis: This problem is also required to find some numbers with a given array and sum, it is similar to the first problem. We may get some hints from the solution above.\n\nSince the input of the previous problem is an increasingly sorted array, we can also firstly sort the input array increasingly. Secondly we scan the array. When we reach the i-th number with value n , we try to find whether there are two numbers whose sum is \u2013n in the array excluding the i-th number.\n\nIt is time for us to write some code. We modify the function FindNumbersWithSum above a little bit:\n\nbool FindNumbersWithSum( int data[], int length, int sum, int excludeIndex)\n{\nbool found = false ;\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nif (ahead == excludeIndex)\nahead --;\nif (behind == excludeIndex)\nbehind ++;\n\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\nIt determines whether there are two numbers whose sum is sum in array data excluding the number with index excludeIndex . We can determine whether there are three numbers in an array with sum 0 based on this function:\nbool HasThreeNumbersWithSum0( int data[], int length)\n{\nbool found = false ;\nif (data == NULL || length < 3)\nreturn found;\n\nstd::sort(data, data + length - 1);\n\nfor ( int i = 0; i < length; ++i)\n{\nint sum = -data[i];\nint num1, num2;\nfound = FindNumbersWithSum(data, length, sum, i);\n\nif (found)\nbreak ;\n}\n\nreturn found;\n}\n\n\nIt contains two steps in function HasThreeNumbersWithSum0 . It costs O(n log n)time to sort n numbers at its first step. At its second step it costs O(n) time for each number to call FindNumberWithSum , so it costs O(n 2 ) time in the for loop. Therefore, its overall time complexity is O(n 2 ).", "question": "\nProblem 1: Given an increasingly sorted array and a number s , please find two numbers whose sum is s. If there are multiple pairs with sum s, just output any one of them.\n\nFor example, if the inputs are an array { 1 , 2 , 4 , 7 , 11 , 15 } and a number 15, please out two numbers 4 and 11 since 4+11=15.\n\n\nProblem 2: Given an array, please determine whether it contains three numbers whose sum equals to 0.\n"},
{"answer": "", "question": ""},
{"answer": "\nAnalysis: Binary search is suitable for sorted arrays. Let us try to utilize it on a rotation of a sorted array. Notice that a rotation of a sorted array can be partitioned into two sorted sub-arrays, and numbers in the first sub-array are greater than numbers in the second one.\nTwo pointers P1 and P2 are utilized. P1 references to the first element in the array, and P2 references to the last element. According to the rotation rule, the first element should be greater than the last one.\nThe algorithm always compares the number in middle with numbers pointed by P1 and P2 during binary search. If the middle number is in the first increasingly sorted sub-array, it is greater than the number pointed by P1.\nIf the value of target number to be search is between the number pointed by P1 and the middle number, we then search the target number in the first half sub-array. In such a case the first half sub-array is in the first increasing sub-array, we could utilize the binary search algorithm. For example, if we search the number 4 in a rotation {3, 4, 5, 1, 2}, we could search the target number 4 in the sub-array {3, 4, 5} because 4 is between the first number 3 and the middle number 5.\nIf the value of target number is not between the number pointed by P1 and the middle number, we search the target in the second half sub-array. Notice that the second half sub-array also contains two increasing sub-array and itself is also a rotation, so we could search recursively with the same strategy. For example, if we search the number 1 in a rotation {3, 4, 5, 1, 2}, we could search the target number 1 in the sub-array {5, 1, 2} recursively.\nThe analysis above is for two cases when the middle number is in the first increasing sub-array. Please analyze the other two cases when the middle number is in the second increasing sub-array yourself, when the middle number is less than the number pointed by P2.\nThe code implementing this algorithm is listed below, in C/C++:\nint searchInRotation( int numbers[], int length, int k)\n{\nif (numbers == NULL || length <= 0)\nreturn -1;\n\nreturn searchInRotation(numbers, k, 0, length - 1);\n}\n\nint searchInRotation( int numbers[], int k, int start, int end)\n{\nif (start > end)\nreturn -1;\n\nint middle = start + (end - start) / 2;\nif (numbers[middle] == k)\nreturn middle;\n\n// the middle number is in the first increasing sub-array\nif (numbers[middle] >= numbers[start])\n{\nif (k >= numbers[start] && k < numbers[middle])\nreturn binarySearch(numbers, k, start, middle - 1);\nreturn searchInRotation(numbers, k, middle + 1, end);\n}\n// the middle number is in the second increasing sub-array\nelse if (numbers[middle] <= numbers[end])\n{\nif (k > numbers[middle] && k <= numbers[end])\nreturn binarySearch(numbers, k, middle + 1, end);\nreturn searchInRotation(numbers, k, start, middle - 1);\n}\n\n// It should never reach here if the input is valid\nassert( false );\n}\nSince the function binarySearch is for the classic binary search algorithm, it is not listed here. You might implement your own binary search code if you are interested.\nIn each round of search, half of the array is excluded for the next round, so the time complexity is O(log n ).\nYou may wonder why we assume there are no duplications in the input array. We determine whether the middle number is in the first or second sub-array by comparing the middle number and the numbers pointed by P1 or P2. When the middle number, the number pointed by P1 and P2 are identical, we don\u2019t know whether the middle number is in the first or second increasing sub-array.\nLet\u2019s look at some examples. Two arrays {1, 0, 1, 1, 1} and {1, 1, 1, 0, 1} are both rotations of an increasingly sorted array {0, 1, 1, 1, 1}, which are visualized in Figure 1.\n\n\nFigure 1 : Two rotations of an increasingly sorted array {0, 1, 1, 1, 1}: {1, 0, 1, 1, 1} and {1, 1, 1, 0, 1}. Elements with gray background are in the second increasing sub-array.\nIn Figure 1, the elements pointed by P1 and P2, as well as the middle element are all 1. The middle element with index 2 is in the second sub-array in Figure 1 (a), while the middle element is in the first sub-array in Figure 1 (b).", "question": "\nQuestion: When some elements at the beginning of an array are moved to the end, it gets a rotation of the original array. Please implement a function to search a number in a rotation of an increasingly sorted array. Assume there are no duplicated numbers in the array.\nFor example, array {3, 4, 5, 1, 2} is a rotation of array {1, 2, 3, 4, 5}. If the target number to be searched is 4, the index of the number 4 in the rotation 1 should be returned. If the target number to be searched is 6, -1 should be returned because the number does not exist in the rotated array."},
{"answer": "\nAnalysis: Let\u2019s analyze this problem step by step, taking the binary search in Figure 1 and 29 as an example.\nWe start from the root node with value 32, and the distance to 29 is 3. Since the value 32 is greater than 29, and all values in the right sub-tree are greater than 32, distances to 29 in the right sub-tree should be greater than 3. We move to the left sub-tree.\nThe next node to be visited contains value 24, and the distance to 29 is 5. Since 5 is greater than the previous closest distance 3, the closest node up to now remains the node with value 32. Additionally, the current value 24 is less than 29, and all values in the left sub-tree\u00a0are less than 24, so distances to 29 in the left sub-tree will be greater than 5. We move on to visit the right sub-tree.\nThe next node to be visited contains value 28, and the distance to 29 is 1. Since 1 is less than the previous closest distance 3, the closest node is updated to the node with value 28. Additionally, the value 28 is less than 29, and all values in the left sub-tree areless than 28, so distances to 29 in the left sub-tree will be greater than 1. Let\u2019s continue to visit the right sub-tree.\nFinally we reach a left node with value 31. The distance to 29 is 2 and it is greater than the previous closest distance 1, so the closest node to 29 is still the node with value 28.\nAccording to the step-by-step analysis above, we could implement the following code:\n         if (distance == 0)\n         if (pNode->m_nValue > value)\n     return pClosest;", "question": ""},
{"answer": "\nAnalysis: In a previous blog , we discussed how to check whether there are two numbers in a sorted array whose sum equals a given value. In order to solve this problem, we initialize a number num1 as the smallest number in the array, and initialize num2 as the greatest one. If the sum of num1 and num2 is same as the given value, two required numbers have been found. If the sum is greater than the given value, we move num2 to the previous number in the array (with less value). Similarly, we move num1 to the next number in the array (with greater value) if the sum is less than the given value.\nInspired by the solution, we may find two nodes with a given sum in a binary search tree with similar strategy. Firstly we initialize a pointer P1 to the smallest node in the tree, and another pointer P2 to the greatest node. When the sum of two values in the nodes pointed by P1 and P2 is same as the given value, two required nodes have been found. If their sum is greater than the given value, we move P2 to the previous node (containing less value). Moreover, we move P1 to the next node (containing greater value) if their sum is less than the given value.\nIt is not difficult to get the least and greatest value of a binary search tree. If we move along the links to left children, and the leaf node we arrive at finally contains the least value. For instance, if we move along the links to left children in Figure 1, the nodes on the path contain value 32, 24, 21 and 14, and 14 is the least value in the binary search tree.\nSimilarly, if we move along links to right children, and the leaf node we arrive at finally contains the greatest value.\nThe key to solve this problem is how to get the next nodes (with greater values) and the previous nodes (with less values) in a binary search tree. Let\u2019s utilize stacks.\nIn order to get next nodes,\u00a0we scan the tree along the links to leaf children, and push the scanned nodes into a stack. That\u2019s to say, there are four nodes in the stack (nodes 32, 24, 21 and 14), and node 14 is on the top.\nWhen the top of the stack is popped, node 21 on the top of stack is the next node of 14. And when the node 21 is popped, the node 24 on the top is the next node of 21.\nThe steps to get the next node of node 24 are more complex, because the node 24 has a right child. We pop the node 24, and push its right child, node 28, into the stack. And then, we scan the nodes from the right child along the links to left children. Therefore, the node 31 will also be pushed into the stack. At this time, there are three nodes in the stack (nodes 32, 28 and 25), and the top on the stack (node 25) is the next node of node 24.\nLet\u2019s summarize the steps to get next nodes. If the node on the top does not have a right child, the node is popped off, and the next node is on the top again. If the node on the top has a right child, after the node is popped off and then the right child is pushed, and all nodes along the links to left children are pushed into the stack. The last pushed node on the top is the next node. We continue the steps to pop and push until the stack is empty.\nIf you are interested, please try to analyze the steps to the next nodes after the node 25 by yourself.\nThe steps to get previous nodes are quite similar. At first we push the root node, and nodes along the links to right children. The node with least is on the top of stack. In order to get the previous nodes with less values, the top is popped off. If the top does not have a left child, the previous node is the new top node in the stack. If the top has the left child, we push its left child, as well as nodes along links to right children. The last pushed node is the previous node of the node popped.\nOur solution can be implemented with the following C++ code:\n bool hasTwoNodes(BinaryTreeNode* pRoot, int sum)\n     BinaryTreeNode* pNext = getNext(nextNodes);\n         if (currentSum < sum)\n     return false ;\n void buildNextNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n void buildPrevNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n BinaryTreeNode* getNext(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pRight = pNext->m_pRight;\n     return pNext;\n BinaryTreeNode* getPrev(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pLeft = pPrev->m_pLeft;\n     return pPrev;\nThis solution costs O( n ) time. The space complexity is O(height of tree), which is O(log n ) on average, and O( n ) in the worst cases.", "question": ""},
{"answer": "\nAnalysis: It is not difficult to get a solution with brute force: Scan numbers in every sliding window to get its maximal value. The overall time complexity is O( nk ) if the length of array is n and the size of sliding windows is k .\n\nThe na\u00efve solution is not the best solution. Let us explore better solutions.\n\nSolution 1: Maximal value in a queue\n\nA window can be viewed as a queue. When it slides, a number is pushed into its back, and its front is popped off. Therefore, the problem is solved if we can get the maximal value of a queue.\n\nThere are no straightforward approaches to getting the maximal value of a queue. However, there are solutions to get the maximal value of a stack, which is similar to the solution introduced in the blog \u201c Stack with Function min() \u201d. Additionally, a queue can also be implemented with two stacks (details are discussed in another blog \u201c Queue implemented with Two Stacks \u201d).\n\nIf a new type of queue is implemented with two stacks, in which a function max() is defined to get the maximal value, the maximal value in a queue is the greater number of the two maximal numbers in two stacks.\n\nThis solution is workable. However, we may not have enough time to write all code to implement our own queue and stack data structures during interviews. Let us continue exploring a more concise solution.\n\nSolution 2: Saving the maximal value into the front of a queue\n\nInstead of pushing every numbers inside a sliding window into a queue, we try to push the candidates of maximum only into a queue. Let us take the array {2, 3, 4, 2, 6, 2, 5, 1} as an example to analyze the solution step by step.\n\nThe first number in the array is 2, we push it into a queue. The second number is 3, which is greater than the previous number 2. The number 2 should be popped off, because it is less than 3 and it has no chance to be the maximal value. There is only one number left in the queue when we pop 2 at the back and push 3 at the back. The operations are similar when we push the next number 4. There is only a number 4 remaining in the queue. Now the sliding window already has three elements, we can get the maximum value at the front of the queue.\n\nWe continue to push the fourth number.\u00a0 It is pushed at the back of queue, because it is less than the previous number 4 and it might be a maximal number in the future when the previous numbers are popped off. There are two numbers, 4 and 2, in the queue, and 4 is the maximum.\n\nThe next number to be pushed is 6. Since it is greater than the existing numbers, 4 and 2, these two numbers can be popped off because they have no chance to be the maximum. Now there is only one number in the queue, which is 6, after the current number is pushed. Of course, the maximum is 6.\nThe next number is 2, which is pushed into the back of the queue because it is less than the previous number 6. There are two numbers in the queue, 6 and 2, and the number 6 at the front of the queue is the maximal value.\n\nIt is time to push the number 5. Because it is greater than the number 2 at the back of the queue, 2 is popped off and then 5 is pushed. There are two numbers in the queue, 6 and 5, and the number 6 at the front of the queue is the maximal value.\n\nNow let us push the last number 1. It can be pushed into the queue. It is noticeable that the number at the front is beyond the scope the current sliding window, and it should be popped off.\u00a0 How do we know whether the number at the front of the queue is out of sliding window? Rather than storing numbers in the queue directly, we can store indices instead. If the distance between the index at the front of queue and the index of the current number to be pushed is greater than or equal to the window size, the number corresponding to be the index at the font of queue is out of sliding window.\n\nThe analysis process above is summarized in Table 2.\n\nStep Number to Be Pushed Numbers in Sliding Window Indices in queue Maximum in Window 1 2 2 0(2) 2 3 2, 3 1(3) 3 4 2, 3, 4 2(4) 4 4 2 3, 4, 2 2(4), 3(2) 4 5 6 4, 2, 6 4(6) 6 6 2 2, 6, 2 4(6), 5(2) 6 7 5 6, 2, 5 4(6), 6(5) 6 8 1 2, 5, 1 6(5), 7(1) 5\nStep\nNumber to Be Pushed\nNumbers in Sliding Window\nIndices in queue\nMaximum in Window\n1\n2\n2\n0(2)\n\n2\n3\n2, 3\n1(3)\n\n3\n4\n2, 3, 4\n2(4)\n4\n4\n2\n3, 4, 2\n2(4), 3(2)\n4\n5\n6\n4, 2, 6\n4(6)\n6\n6\n2\n2, 6, 2\n4(6), 5(2)\n6\n7\n5\n6, 2, 5\n4(6), 6(5)\n6\n8\n1\n2, 5, 1\n6(5), 7(1)\n5\nTable 2: The process to get the maximal number in all sliding windows with window size 3 in the array {2, 3, 4, 2, 6, 2, 5, 1}. In the column \u201cIndices in queue\u201d, the number inside a pair of parentheses is the number indexed by the number before it in the array.\n\nWe can implement a solution based on the analysis above. Some sample code in C++ is shown below, which utilizes the type deque of STL.\n\nvector< int > maxInWindows( const vector< int >& numbers, int windowSize)\n{\nvector< int > maxInSlidingWindows;\nif (numbers.size() >= windowSize && windowSize > 1)\n{\ndeque< int > indices;\n\nfor ( int i = 0; i < windowSize; ++i)\n{\nwhile (!indices.empty() && numbers[i] >= numbers[indices.back()])\nindices.pop_back();\n\nindices.push_back(i);\n}\n\nfor ( int i = windowSize; i < numbers.size(); ++i)\n{\nmaxInSlidingWindows.push_back(numbers[indices.front()]);\n\nwhile (!indices.empty() && numbers[i] >= numbers[indices.back()])\nindices.pop_back();\nif (!indices.empty() && indices.front() <= i - windowSize)\nindices.pop_front();\n\nindices.push_back(i);\n}\nmaxInSlidingWindows.push_back(numbers[indices.front()]);\n}\n\nreturn maxInSlidingWindows;\n}\n\nExtension: Another solution to get the maximum of a queue\n\nAs we mentioned before, a sliding window can be viewed as a queue. Therefore, we can implement a new solution to get the maximal value of a queue based on the second solution to get the maximums of sliding windows.\n\nThe following is the sample code:\n\ntemplate < typename T> class QueueWithMax\n{\npublic :\nQueueWithMax(): currentIndex(0)\n{\n}\n\nvoid push_back(T number)\n{\nwhile (!maximums.empty() && number >= maximums.back().number)\nmaximums.pop_back();\n\nInternalData internalData = {number, currentIndex};\ndata.push_back(internalData);\nmaximums.push_back(internalData);\n\n++currentIndex;\n}\n\nvoid pop_front()\n{\nif (maximums.empty())\nthrow new exception( \"queue is empty\" );\n\nif (maximums.front().index == data.front().index)\nmaximums.pop_front();\n\ndata.pop_front();\n}\n\nT max() const\n{\nif (maximums.empty())\nthrow new exception( \"queue is empty\" );\n\nreturn maximums.front().number;\n}\n\nprivate :\nstruct InternalData\n{\nT number;\nint index;\n};\n\ndeque<InternalData> data;\ndeque<InternalData> maximums;\nint currentIndex;\n};\n\nSince this solution is similar to the second solution to get maximums of sliding windows, we won\u2019t analyze the process step by step, and leave it as an exercise if you are interested.", "question": "\nQuestion: Given an array of numbers and a sliding window size, how to get the maximal numbers in all sliding windows?\n\nFor example, if the input array is {2, 3, 4, 2, 6, 2, 5, 1} and the size of sliding windows is 3, the output of maximums are {4, 4, 6, 6, 6, 5}, as illustrated in Table1.\n\nSliding Windows in an Array Maximums in Sliding Windows [2, 3, 4] , 2, 6, 2, 5, 1 4 2, [3, 4, 2] , 6, 2, 5, 1 4 2, 3, [4, 2, 6] , 2, 5, 1 6 2, 3, 4, [2, 6, 2] , 5, 1 6 2, 3, 4, 2, [6, 2, 5] , 1 6 2, 3, 4, 2, 6, [2, 5, 1] 5\nSliding Windows in an Array\nMaximums in Sliding Windows\n[2, 3, 4] , 2, 6, 2, 5, 1\n4\n2, [3, 4, 2] , 6, 2, 5, 1\n4\n2, 3, [4, 2, 6] , 2, 5, 1\n6\n2, 3, 4, [2, 6, 2] , 5, 1\n6\n2, 3, 4, 2, [6, 2, 5] , 1\n6\n2, 3, 4, 2, 6, [2, 5, 1]\n5\nTable 1: Maximums of all sliding windows with size 3 in an array {2, 3, 4, 2, 6, 2, 5, 1}. A pair of brackets indicates a sliding window.\n"},
{"answer": "\nAnalysis: A na\u00efve solution with brute force is quite straightforward: We can get the result for each number minus every number on its right side, and then get the maximal difference after comparisons. Since O(n) minus operations are required for each number in an array with n numbers, the overall time complexity is O(n 2 ). Brutal force solution usually is not the best solution. Let us try to reduce the times of minus operations.\n\nSolution 1: via divide and conquer\n\nWe divide an array into two sub-arrays with same size. The maximal difference of all pairs occurs in one of the three following situations: (1) two numbers of a pair are both in the first sub-array; (2) two numbers of a pair are both in the second sub-array; (3) the minuend is in the greatest number in the first sub-array, and the subtrahend is the least number in the second sub-array.\n\nIt is not a difficult to get the maximal number in the first sub-array and the minimal number in the second sub-array. How about to get the maximal difference of all pairs in two sub-arrays? They are actually sub-problems of the original problem, and we can solve them via recursion. The following are the sample code of this solution:\n\nint MaxDiff_Solution1( int numbers[], unsigned length)\n{\nif (numbers == NULL || length < 2)\nreturn 0;\n\nint max, min;\nreturn MaxDiffCore(numbers, numbers + length - 1, &max, &min);\n}\n\nint MaxDiffCore( int * start, int * end, int * max, int * min)\n{\nif (end == start)\n{\n*max = *min = *start;\nreturn 0x80000000;\n}\n\nint * middle = start + (end - start) / 2;\n\nint maxLeft, minLeft;\nint leftDiff = MaxDiffCore(start, middle, &maxLeft, &minLeft);\n\nint maxRight, minRight;\nint rightDiff = MaxDiffCore(middle + 1, end, &maxRight, &minRight);\n\nint crossDiff = maxLeft - minRight;\n\n*max = (maxLeft > maxRight) ? maxLeft : maxRight;\n*min = (minLeft < minRight) ? minLeft : minRight;\n\nint maxDiff = (leftDiff > rightDiff) ? leftDiff : rightDiff;\nmaxDiff = (maxDiff > crossDiff) ? maxDiff : crossDiff;\nreturn maxDiff;\n}\n\nIn the function MaxDiffCore , we get the maximal difference of pairs in the first sub-array ( leftDiff ), and then get the maximal difference of pairs in the second sub-array ( rightDiff ). We continue to calculate the difference between the maximum in the first sub-array and the minimal number in the second sub-array ( crossDiff ). The greatest value of the three differences is the maximal difference of the whole array.\n\nWe can get the minimal and maximal numbers, as well as their difference in O(1) time, based on the result of two sub-arrays, so the time complexity of the recursive solution is T(n)=2(n/2)+O(1). We can demonstrate its time complexity is O(n).\n\nSolution 2: get the maximum numbers while scanning\n\nLet us define diff[i] for the difference of a pair whose subtrahend is the i th number in an array. The minuend corresponding to the maximal diff[i] should be the maximum of all numbers on the left side of i th number in an array. We can get the maximal numbers on the left side of each i th number in an array while scanning the array once, and subtract the i th number for them. The following code is based on this solution:\n\nint MaxDiff_Solution3( int numbers[], unsigned length)\n{\nif (numbers == NULL || length < 2)\nreturn 0;\n\nint max = numbers[0];\nint maxDiff =\u00a0 max - numbers[1];\n\nfor ( int i = 2; i < length; ++i)\n{\nif (numbers[i - 1] > max)\nmax = numbers[i - 1];\n\nint currentDiff = max - numbers[i];\nif (currentDiff > maxDiff)\nmaxDiff = currentDiff;\n}\n\nreturn maxDiff;\n}\n\nIt is obviously that its time complexity is O(n) since it is only necessary to scan an array with length n once. It is more efficient than the first solution on memory requirement, which requires O( log n) memory for call stack for the recursion.", "question": "\nProblem: A pair contains two numbers, and its second number is on the right side of the first one in an array. The difference of a pair is the minus result while subtracting the second number from the first one. Please implement a function which gets the maximal difference of all pairs in an array. For example, the maximal difference in the array {2, 4, 1, 16, 7, 5, 11, 9} is 11, which is the minus result of pair (16, 5).\n"},
{"answer": "\nAnalysis: During interviews, many candidates can solve it by enumerating all of sub-arrays and calculate their sum. An array with n elements has n(n+1)/2 sub-arrays. It costs O(n 2 ) time at least to calculate their sum. Usually the intuitive and forceful solution is not the most optimized one. Interviewers will tell us that there are better solutions.\n\nSolution 1: Analyze arrays number by number\n\nWe try to accumulate every number in the example array from first to end. We initialize sum as 0. At our first step, add the first number 1, and sum is 1. And then if we add the second number -2, sum becomes -1. At the third step, we add the third number 3. We can notice that sum is less than 0, so the new sum will be 2 and it is less than the third number 3 itself if we add it with a negative sum . Therefore, the accumulated sum can be discarded.\n\nWe continue accumulating from the third number with sum 3. When we add it with the fourth number 10, sum becomes 13, and it decreases to 9 when we add it with the fifth number -4. We can notice that the sum with -4 is less than the previous sum since -4 is a negative number. Therefore, we should store the previous sum 13, since it might be the max sum of sub-arrays. At the sixth step, we add the sixth number 7 and sum is 16. Now sum is greater than the previous max sum of sub-arrays, we need to update it to 16. It is same when we add the seventh number 2. The max sum of sub-arrays is updated to 18. Lastly we add -5 and sum becomes 13. Since it is less than the previous max sum of sub-arrays, it final max sum of sub-array is 18, and the sub-array is { 3, 10, -4, 7, 2 } accordingly. We can summarize the whole process with the Table 1:\n\nStep Operation Accumulated sum of sub-arrays Maximum sum 1 Add 1 1 1 2 Add -2 -1 1 3 Discard previous sum -1, add 3 3 3 4 Add 10 13 13 5 Add -4 9 13 6 Add 7 16 16 7 Add 2 18 18 8 Add -5 13 18\nStep\nOperation\nAccumulated sum of sub-arrays\nMaximum sum\n1\nAdd 1\n1\n1\n2\nAdd -2\n-1\n1\n3\nDiscard previous sum -1, add 3\n3\n3\n4\nAdd 10\n13\n13\n5\nAdd -4\n9\n13\n6\nAdd 7\n16\n16\n7\nAdd 2\n18\n18\n8\nAdd -5\n13\n18\nTable 1: The process to calculate the maximum sum of all sub-arrays in the array {1, -2, 3, 10, -4, 7, 2, -5}\n\nAfter we get clear ideas of this solution, we are ready to develop some code. The following is the sample code:\n\nbool g_InvalidInput = false ;\n\nint FindGreatestSumOfSubArray( int *pData, int nLength)\n{\nif ((pData == NULL) || (nLength <= 0))\n{\ng_InvalidInput = true ;\nreturn 0;\n}\n\ng_InvalidInput = false ;\n\nint nCurSum = 0;\nint nGreatestSum = 0x80000000;\nfor ( int i = 0; i < nLength; ++i)\n{\nif (nCurSum <= 0)\nnCurSum = pData[i];\nelse\nnCurSum += pData[i];\n\nif (nCurSum > nGreatestSum)\nnGreatestSum = nCurSum;\n}\n\nreturn nGreatestSum;\n}\n\nWe should keep invalid inputs during interview, such as the pointer parameter of array is NULL or its length is 0. What should be return for the invalid inputs? If it is 0, how can we distinguish the two situations: one is for the actual maximum sum of sub-arrays is 0 and the other is for invalid inputs? Therefore, we define a global variable to make whether inputs are invalid or not.\n\nSolution 2: Dynamic programming\n\nIf we have a deep understanding of algorithm, we may solve this problem with dynamic programming. If function f(i) stands for the maximum sum of a sum-array ended with the i th number, what it is to get is max[f(i)] . We can calculate f(i) with the following recursive equation:\n\n\n\nIn the equation above, if the sum of sub-array ended with the (i-1) th number is negative, the sum of sub-array ended with the i th number should be the i th number itself (it is the third step in the Table 1). Otherwise, we can get the sum of sub-array ended with the i th number by adding the i th number and the sum of sub-array ended with the previous number.\n", "question": "\nQuestion: A sub-array has one number of some continuous numbers. Given an integer array with positive numbers and negative numbers, get the maximum sum of all sub-arrays. Time complexity should be O(n).\n\nFor example, in the array { 1, -2, 3, 10, -4, 7, 2, -5 }, its sub-array { 3, 10, -4, 7, 2 } has the maximum sum 18.\n\n"},
{"answer": "\nAnalysis: Our intuition for this problem might be that we sort all of numbers in the stack when we push a new one, and keep the minimum number on the top of stack. In this way we can get the minimum number in O(1) time. However, we cannot assure that the last number pushed in to container will be the first one to be popped out, so it is no longer a stack.\n\nWe may add a new member variable in a stack to keep the minimum number. When we push a new number which is less than the minimum number, we will update it. It sounds good. However, how to get the next minimum number when the current minimum one is popped? Fortunately, we have two solutions for this problem.\n\nSolution 1: With Auxiliary Stack\n\nIt is not enough to have only a member variable to keep the minimum number. When the minimum one is popped, we need to get the next minimum one. Therefore, we need to store the next minimum number before push the current minimum one.\n\nHow about to store each minimum number (the less value of current minimum number and the number to be pushed) into an auxiliary stack? We may analyze the process to push and pop numbers via some examples (Table 1).\n\nStep Operation Data Stack Auxiliary Stack Minimum 1 Push 3 3 3 3 2 Push 4 3, 4 3, 3 3 3 Push 2 3, 4, 2 3, 3, 2 2 4 Push 1 3, 4, 2, 1 3, 3, 2, 1 1 5 Pop 3, 4, 2 3, 3, 2 2 6 Pop 3, 4 3, 3 3 7 Push 0 3, 4, 0 3, 3, 0 0\nStep\nOperation\nData Stack\nAuxiliary Stack\nMinimum\n1\nPush 3\n3\n3\n3\n2\nPush 4\n3, 4\n3, 3\n3\n3\nPush 2\n3, 4, 2\n3, 3, 2\n2\n4\nPush 1\n3, 4, 2, 1\n3, 3, 2, 1\n1\n5\nPop\n3, 4, 2\n3, 3, 2\n2\n6\nPop\n3, 4\n3, 3\n3\n7\nPush 0\n3, 4, 0\n3, 3, 0\n0\nTable 1: The status of data stack, auxiliary stack, minimum value when we push 3, 4, 2, 1, pop twice, and then push 0\n\nAt first we push 3 into both data stack and auxiliary stack. Secondly we push 4 into the data stack. We push 3 again into the auxiliary stack because 4 is greater than 3. Thirdly, we continue pushing 2 into the data stack. We update the minimum number as 2 and push it into the auxiliary stack since 2 is less the previous minimum number 3. It is same in the fourth step when we push 1. We also need to update the minimum number and push 1 into the auxiliary stack. We can notice that the top of auxiliary stack is always the minimum number if we push the minimum number into auxiliary stack in each step.\n\nWhenever we pop a number from data stack, we also pop a number from auxiliary stack. If the minimum number is popped, the next minimum number should be also on the top of auxiliary stack. In the fifth step we pop 1 from the data stack, and we also pop the number on the top of auxiliary (which is 1). We can see that the next minimum number 2 is now on the top of auxiliary stack. If we continue popping from both the data and auxiliary stacks, there are only two numbers 3 and 4 left in the data stack. The minimum number 3 is indeed on the top of the auxiliary stack. Therefore, it demonstrates that our solution is correct.\n\nNow we can develop the required stack. The stack is declared as the following:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nstd::stack<T>\u00a0\u00a0 m_min; // auxiliary stack, to store minimum numbers\n};\n\nThe function push, pop and min and top can be implemented as:\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\n// push the new number into data stack\nm_data.push(value);\n\n// push the new number into auxiliary stack\n// if it is less than the previous minimum number,\n// otherwise push a replication of the minimum number\nif (m_min.size() == 0 || value < m_min.top())\nm_min.push(value);\nelse\nm_min.push(m_min.top());\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nm_data.pop();\nm_min.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nreturn m_min.top();\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nreturn m_data.top();\n}\n\nThe length of auxiliary stack should be n if we push n numbers into data stack. Therefore, we need O( n ) auxiliary memory for this solution.\n\nSolution 2: Without Auxiliary Stack\n\nThe second solution is trickier without an auxiliary stack. We do not always push numbers into data stack directly, but we have some tricky calculation before pushing.\n\nSupposing that we are going to push a number value into a stack with minimum number min . If value is greater than or equal to the min , it is pushed directly into data stack. If it is less than min , we push 2* value - min , and update min as value since a new minimum number is pushed. How about to pop? We pop it directly if the top of data stack (it is denoted as top ) is greater than or equal to min . Otherwise the number top is not the real pushed number. The real pushed number is stored is min . After the current minimum number is popped, we need to restore the previous minimum number, which is 2* min - top .\n\n\nNow let us demonstrate its correctness of this solution. Since value is greater than or equal to min , it is pushed into data stack direct without updating min . Therefore, when we find that the top of data stack is greater than or equal to min , we can pop directly without updating min . However, if we find value is less then min , we push 2* value - min . We should notice that 2* value - min should be less than value . Then we update current min as value . Therefore, the new top of data stack ( top ) is less than the current min . Therefore, when we find that the top of data stack is less then min , the real top (real pushed number value ) is stored in min . After we pop the top of data stack, we have to restore the previous minimum number. Since top = 2* value -previous min and value is current min , pervious min is 2*current min - top .\n\nIt sounds great. We feel confident to write code now with the correctness demonstration. The following is the sample code:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nT\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_min; // minimum number\n};\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\nif (m_data.size() == 0)\n{\nm_data.push(value);\nm_min = value;\n}\nelse if (value >= m_min)\n{\nm_data.push(value);\n}\nelse\n{\nm_data.push(2 * value - m_min);\nm_min = value;\n}\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0);\n\nif (m_data.top() < m_min)\nm_min = 2 * m_min - m_data.top();\n\nm_data.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0);\n\nreturn m_min;\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nT top = m_data.top();\nif (top < m_min)\ntop = m_min;\n\nreturn top;\n}\n", "question": ""},
{"answer": "\nAnalysis: It looks like a simple question about binary numbers, and we have many solutions for it. Unfortunately, the most intuitive solution for many candidates is incorrect. We should be careful.\n\nSolution 1: Check the most right bit, possibly with endless loop\n\nWhen candidates are interviewed with this problem, many of them find a solution in short time: check whether the most right bit is 0 or 1, and then right shit the integer one bit and check the most right bit again. It continues in a loop until the integer becomes 0. How to check whether the most right bit of an integer is 0 or 1? It is simple since we have AND operation. There is only one bit of 1, which is the most right bit, in the binary format of integer 1. When we have AND operation on an integer and 1, we can check whether the most right bit is 0 or 1. When the result of AND operation is 1, it indicates the right most bit is 1; otherwise it is 0. We can implement a function base on this solution quickly:\n\nint NumberOf1( int n ) { int count = 0; while ( n ) { if ( n & 1) count ++; n = n >> 1; } return count; }\n\nInterviewers may ask a question when they are told this solution: What is the result when the input integer is a negative number such as 0x80000000? When we right shift the negative number 0x80000000 a bit, it become 0xC0000000 rather than 0x40000000, which is the result to move the first bit of 1 to the second bit. The integer 0x8000000 is negative before shift, so we should guarantee it is also negative after shift. Therefore, when a negative integer is right shifted, the first bit is set as 1 after the right shift operation. If we continue to shift to right side, a negative integer will be 0xFFFFFFFF eventually and it is trapped in an endless loop.\n\nSolution 2: Check the most right bit, with left shift operation on 1\n\nWe should not right shift the input integer to avoid endless loop. Instead of shifting the input integer n to right, we may shift the number 1 to left. We may check firstly the least important bit of n , and then shift the number 1 to left, and continue to check the second least important bit of n . Now we can rewrite our code based on this solution:\n\nint NumberOf1( int n)\n{\nint count = 0;\nunsigned int flag = 1;\nwhile (flag)\n{\nif (n & flag)\ncount ++;\n\nflag = flag << 1;\n}\n\nreturn count;\n}\n\nIn the code above, it loops 32 times on 32-bit numbers.\n\nSolution 3: Creative solution\n\nLet us analyze that what happens when a number minus 1. There is at least one bit 1 in a non-zero number. We firstly assume the right most bit is 1. It becomes 0 if the number minus 1 and other bits keep unchanged. This result is identical to the not operation on the most right bit of a number, which also turns the right most bit from 1 into 0.\n\nSecondly we assume the right most bit is 0. Since there is at least one bit 1 in a non-zero number, we suppose the m th bit is the most right bit of 1. When it minus 1, the m th bit becomes 0, and all 0 bits behind the m th bit become 1. For instance, the second bit of binary number 1100 is the most right bit of 1. When it minus 1, the second bit becomes 0, and the third and fourth bits become 1, so the result is 1011.\n\nIn both situations above, the most right of bit 1 becomes 0 when it minus 1. When there are some 0 bits at right side, all of them become 1. The result of bit and operation on the original number and minus result is identical to result to modify the most right 1 into 0. Take the binary number 1100 as an example again. Its result is 1011 when it minus 1. The result of and operation on 1100 and 1011 is 1000. If we change the most right of 1 bit in number 1100, it also becomes 1000.\n\nThe analysis can be summarized as: If we first minus a number with 1, and have and operation on the original number and the minus result, the most right of 1 bit becomes 0. We continue these operations until the number becomes 0. We can develop the following code accordingly:\n\nint NumberOf1( int n)\n{\nint count = 0;\n\nwhile (n)\n{\n++ count;\nn = (n - 1) & n;\n}\n\nreturn count;\n}\n\nThe number of times in the while loops equals to the number of 1 in the binary format of input n .", "question": "\nProblem: Please implement a function to get the number of 1s in an integer. For example, the integer 9 is 1001 in binary, so it returns 2 since there are two bits of 1s.\n"},
{"answer": "\nAnalysis: When a digit in a number is swapped with a greater digit on its right side, the number becomes greater. For example, if the digit 3 in the number 34722641 is swapped with digit 7, the result is 74322641 which is greater than the original number. The remaining issue how to get least number which is greater than the original one.\nSince we are going to get the least number after reordering digits, let\u2019s find digits to be swapped on the right side. The first three digits on the right side of 34722641 are 641 which are decreasingly sorted. The two digits among them are swapped, the whole number will become less.\nLet\u2019s move on to the left digits. The next digit on the right side is 2, which is less than 6 and 4 on its right side. If the digit 2 is swapped with 6 or 4, the whole number will be become greater. Since we are going to keep the swapped number as less as possible, the digit 2 is swapped with 4, which is less one between 4 and 6. The number becomes 34724621.\nNow 34724621 is greater than the original number 34722641, but it\u2019s not the least one which is greater than 34722641. The three digits on the right side, 6, 2 and 1, should be increasingly sorted, in order to form the least number 34724126 among numbers which are greater than of 34722641.\nThe solution can be implemented with the following JAVA code:\n public static String getLeastGreaterNumber(String number) {\n     if (isGreatestNumber(firstDecreasing)) {\n     String prefix = \"\" ;\n     StringBuilder resultBuilder = new StringBuilder(prefix);\n     Collections.sort(decreasingChars);\nWhen all digits are already increasingly sorted in the input number, the number itself is the greatest number with given digits. We should discuss with our interviewers what to return for this case during interviewers. Here we just return an empty string for this case.\nWhen firstDecreasing is 0, it means all digits are increasingly sorted, and the input number is the greatest number with given digits, as listed in the following method isGreatestNumber .\n private static Boolean isGreatestNumber( int firstDecreasing) {\nThe following method getDecreasingChars gets the longest sequence of decreasing digits on the right side of a number:\n private static int getDecreasingChars(String number, List<Character>decreasing) {\n     return firstDecreasing;\nThe following method swapLeastGreater swaps the digit before the decreasing digits on the right side ( target ) and the least digit which is greater than target :\n private static char swapLeastGreater(List<Character> chars, char target) {\n     return finding;\nThe following method appendList appends characters from a list into a string builder:\n private static void appendList(StringBuilder str, List<Character>chars) {\nExtended Problem 1 : Given a set of digits, please output all numbers permutated by the digits in increasing order. For example, if the input are five digits 1, 2, 3, 4, 5, the output are numbers from 12345, 12354, ..., to 54321 in increasing order.\nExtended Problem 2: Given a number n , please out put all numbers with n bits of 1 in increasing order. For example, if the input is 3, the output are numbers 7, 11, 13, \u2026", "question": "\nProblem: Reorder the digits of a number, in order to get the next number which is the least one that is greater than the input number. For example, the number 34724126 is the next number of 34722641 when reordering digits."},
{"answer": "\nAnalysis: We try to get the maximum length of all increasing subsequences ending with each element in the array.\n\nFor instance, when we analyze the maximum length of all increasing subsequences ending with number 5, we compare it with each number before it. The first number 7 is greater than 5. If the subsequence comes from 7, 7 cannot be included into the subsequence. Therefore, its length is 1. The following three numbers 2, 3 and 1 in the input array before 5 are less than 5. If the previous number of 5 in the increasing subsequence is 2, the maximum incremental length is 2. If the previous number of 5 in the increasing subsequence is 3, the maximum incremental length is 3 (with number 2, 3, and 5) since the maximum length of all subsequences ending with number 3 is 2 (with number 2 and 3). Similarly, its maximum length is 2 if the previous number is number 1. The whole process can be summarized in Table 1.\n\n7 2 3 1 5 8 9 6 7 1 NA NA NA NA NA NA NA 2 1 1 NA NA NA NA NA NA 3 1 2 1 NA NA NA NA NA 1 1 1 1 1 NA NA NA NA 5 1 2 3 2 1 NA NA NA 8 2 2 3 2 4 1 NA NA 9 2 2 3 2 4 5 1 NA 6 1 2 3 2 4 1 1 1\n\n7\n2\n3\n1\n5\n8\n9\n6\n7\n1\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n2\n1\n1\nNA\nNA\nNA\nNA\nNA\nNA\n3\n1\n2\n1\nNA\nNA\nNA\nNA\nNA\n1\n1\n1\n1\n1\nNA\nNA\nNA\nNA\n5\n1\n2\n3\n2\n1\nNA\nNA\nNA\n8\n2\n2\n3\n2\n4\n1\nNA\nNA\n9\n2\n2\n3\n2\n4\n5\n1\nNA\n6\n1\n2\n3\n2\n4\n1\n1\n1\nTable 1: Process to get the maximum length of increasing subsequences in array {7, 2, 3, 1, 5, 8, 9, 6}. Numbers in each row indicate length of subsequences ending with row title with previous number in the column title. Highlighted numbers with yellow background are the maximum lengths. \u00a0The highlighted number 5 with yellow background and red font is the maximum length of all incremental subsequences in the input array.\n\nWe are ready to write code with the detailed analysis above. The following is sample code:\n\nint LengthOfIncreasing( int * data, int length)\n{\nif (data == NULL || length < 0)\nreturn 0;\n\nint * longest = new int [length];\nlongest[0] = 1;\n\nint max = 0;\nfor ( int i = 1; i < length; ++ i)\n{\nmax = 0;\nfor ( int j = 0; j < i; ++ j)\n{\nif (data[j] < data[i] && longest[j] > max)\nmax = longest[j];\n}\n\nlongest[i] = max + 1;\n}\n\nmax = 0;\nfor ( int i = 0; i < length; ++ i)\nif (longest[i] > max)\nmax = longest[i];\n\nreturn max;\n}\n\nEven though a 2-D matrix is needed to analyze the process, only a 1-D array is necessary in our code to store the maximum length of subsequences ending with each number in the input array.\n\nIf we are familiar with dynamic programming, we can get a direct solution quickly in a formal way. We can define a function f(i) indicating the maximum length of all subsequences ending with the i th number in the input array (denoted as A[i]). We define another function g(i, j) which stands for the maximum length of incremental subsequences ending with A[i] coming from A[j]. The required output is max(f(i)) where 0<=i<n and n is the length of array. We can get f(i) with the following equation:\n\n\nActually, same code will be implemented based on this equation. The function f(i) is longest[i] in the code above. Therefore, it is identical to the previous solution.", "question": "\nProblem: Given an unsorted array, find the max length of subsequence in which the numbers are in incremental order.\n\nFor example: If the input array is {7, 2, 3, 1, 5, 8, 9, 6}, a subsequence with the most numbers in incremental order is {2, 3, 5, 8, 9} and the expected output is 5.\n"},
{"answer": "\nAnalysis: Our native solution for this problem may be scanning the input string from its beginning to end. We compare the current scanned character with every one behind it. If there is no duplication after it, it is a character appearing once. Since it compares each character with O(n) ones behind it, the overall time complexity is O(n 2 ) if there are n characters in a string.\n\nIn order to get the numbers of occurrence times of each character in a string, a data container is needed. It is required to get and update the occurrence time of each character in a string, so the data container is used to project a character to a number. Hash tables fulfill this kind of requirement. We can implement a hash table, in which keys are characters and values are their occurrence times in a string.\n\nIt is necessary to scan strings twice: When a character is visited, we increase the corresponding occurrence time in the hash table during the first scanning. In second round of scanning, whenever a character is visited we also check its occurrence time in the hash table. The first character with occurrence time 1 is the required output.\n\nHash tables are complex, and they are not implemented in the C++ standard template library. Therefore, we have to implement one by ourselves.\n\nCharacters have 8 bits, so there only 256 variances. We can create an array with 255 numbers, in which indexes are ASCII values of all characters, and numbers are their occurrence times in a string. That is to say, we have a hash table whose size if 256, with ASCII values of characters as keys.\n\nIt is time for programming after we get a clear solution. The following are some sample code:\n\nchar FirstNotRepeatingChar( char * pString)\n{\nif (pString == NULL)\nreturn '\\0' ;\n\nconst int tableSize = 256;\nunsigned int hashTable[tableSize];\nfor ( unsigned int i = 0; i<tableSize; ++ i)\nhashTable[i] = 0;\n\nchar * pHashKey = pString;\nwhile (*(pHashKey) != '\\0' )\nhashTable[*(pHashKey++)] ++;\n\npHashKey = pString;\nwhile (*pHashKey != '\\0' )\n{\nif (hashTable[*pHashKey] == 1)\nreturn *pHashKey;\n\npHashKey++;\n}\n\nreturn '\\0' ;\n}\n\nIn the code above, it costs O(1) time to increase the occurrence time for each character. The time complexity for the first scanning is O(n) if the length of string is n. It takes O(1) time to get the occurrence time for each character, so it costs O(n) time for the second scanning. Therefore, the overall time it costs is O(n).\n\nIn the meantime, an array with 256 numbers is created, whose size is 1K. Since the size of array is constant, the space complexity of this algorithm is O(1).", "question": "\nProblem: Implement a function to find the first character in a string which only appears once.\nFor example: It returns \u2018b\u2019 when the input is \u201cabaccdeff\u201d.\n"},
{"answer": "\nAnalysis: Mirror of binary trees may be a new concept for many candidates, so they may not find a solution in short time during interviews. In order to get some visual ideas about mirrors, we may draw a binary tree and its mirror according to our daily experience. For example, the binary tree on the right of Figure 1 is the mirror of the left one.\n\nLet us analyze these two trees in Figure 1 carefully to get the steps of mirrors. Their root nodes are identical, but their left and right children are swapped. Firstly we may swap two nodes under the root of the original binary tree, and it becomes the second tree in Figure 2.\n\nFigure 2: Process to get mirror of a binary tree. (a) Swap children of the root node; (b) Swap children of the node 10; (c) Swap the children of node 6.\nNow we can summarize the process for mirror: We visit all nodes in a binary tree with pre-order traversal, and swap the children of current visited node if it has. We will get mirror of a binary tree after we visit all of its nodes.\n\nLet us begin to write code after we get clear ideas about the process. The following is the sample code:\n\nvoid Mirror(BinaryTreeNode *pNode)\n{\nif ((pNode == NULL) || (pNode->m_pLeft == NULL && pNode->m_pRight))\nreturn ;\n\nBinaryTreeNode *pTemp = pNode->m_pLeft;\npNode->m_pLeft = pNode->m_pRight;\npNode->m_pRight = pTemp;\n\nif (pNode->m_pLeft)\nMirrorRecursively(pNode->m_pLeft);\n\nif (pNode->m_pRight)\nMirrorRecursively(pNode->m_pRight);", "question": "\nProblem: Please implement a function which returns mirror of a binary tree.\n\nBinary tree nodes are defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n"},
{"answer": "\nAnalysis: This is a very popular interview question of many companies. It can be solved with two steps: Firstly we reverse all characters in a sentence. If all characters in sentence \u201cI am a student.\u201d are reversed, it becomes \u201c.tneduts a ma I\u201d. Not only the order of words is reversed, but also the order of characters inside each word is reversed. Secondly, we reverse characters in every word. We can get \u201cstudent. a am I\u201d from the example input string with these two steps.\n\nThe key of our solution is to implement a function to reverse a string, which is shown as the Reverse function below:\n\nvoid Reverse( char *pBegin, char *pEnd)\n{\nif (pBegin == NULL || pEnd == NULL)\nreturn ;\n\nwhile (pBegin < pEnd)\n{\nchar temp = *pBegin;\n*pBegin = *pEnd;\n*pEnd = temp;\n\npBegin ++, pEnd --;\n}\n}\n\nNow we can reverse the whole sentence and each word based on this Reverse function with the following code:\n\nchar * ReverseSentence( char *pData)\n{\nif (pData == NULL)\nreturn NULL;\n\nchar *pBegin = pData;\n\nchar *pEnd = pData;\nwhile (*pEnd != '\\0' )\npEnd ++;\npEnd--;\n\n// Reverse the whole sentence\nReverse(pBegin, pEnd);\n\n// Reverse every word in the sentence\npBegin = pEnd = pData;\nwhile (*pBegin != '\\0' )\n{\nif (*pBegin == ' ' )\n{\npBegin ++;\npEnd ++;\n}\nelse if (*pEnd == ' ' || *pEnd == '\\0' )\n{\nReverse(pBegin, --pEnd);\npBegin = ++pEnd;\n}\nelse\n{\npEnd ++;\n}\n}\n\nreturn pData;\n}\n", "question": "\nProblem: Reverse the order of words in a sentence, but keep words themselves unchanged. Words in a sentence are divided by blanks. For instance, the reversed output should be \u201cstudent. a am I\u201d when the input is \u201cI am a student\u201d.\n"},
{"answer": "", "question": ""},
{"answer": "\nAnalysis: The last number is a post-order traversal sequence is the value of root node. Other numbers in a sequence can be partitioned into two parts: The left numbers, which are less than the value of root node, are value of nodes in left sub-tree; the following numbers, which are greater than the value of root node, are value of nodes in right sub-tree.\n\nTake the input {5, 7, 6, 9, 11, 10, 8} as an example, the last number 8 in this sequence is value of root node. The first 3 numbers (5, 7 and 6), which are less than 8, are value of nodes in left sub-tree. The following 3 numbers (9, 11 and 10), which are greater than 8, are value of nodes in right sub-tree.\n\nWe can continue to construct the left sub-tree and right sub-tree according to the two sub-arrays with the same strategy. In the subsequence {5, 7, 6}, the last number 6 is the root value of the left sub-tree. The number 5 is the value of left child since it is less than root value 6, and 7 is the value of right child since it is greater than 6. Meanwhile, the last number 10 in subsequence {9, 11, 10} is the root value of right sub-tree. The number 9 is value of left child, and 11 is value of right child accordingly.\n\nLet us analyze another array {7, 4, 6, 5}. The last number 5 is the value of root node. Since the first number 7 is greater than 5, there are no nodes in the left sub-tree and numbers 7, 4, 6 are all value of nodes in right sub-tree. However, we notice that a number 4, a value in right sub-tree, is less than the root value 5. It violates the definition of binary search trees. Therefore, there are no binary search trees with post-order traversal sequence {7, 4, 6, 5}.\n\nIt is not difficult to write code after we get the strategy above. Some sample code is shown below:\n\nbool VerifySquenceOfBST( int sequence[], int length)\n{\nif (sequence == NULL || length <= 0)\nreturn false ;\n\nint root = sequence[length - 1];\n\n// nodes in left sub-tree are less than root node\nint i = 0;\nfor (; i < length - 1; ++ i)\n{\nif (sequence[i] > root)\nbreak ;\n}\n\n// nodes in right sub-tree are greater than root node\nint j = i;\nfor (; j < length - 1; ++ j)\n{\nif (sequence[j] < root)\nreturn false ;\n}\n\n// Is left sub-tree a binary search tree?\nbool left = true ;\nif (i > 0)\nleft = VerifySquenceOfBST(sequence, i);\n\n// Is right sub-tree a binary search tree?\nbool right = true ;\nif (i < length - 1)\nright = VerifySquenceOfBST(sequence + i, length - i - 1);\n\nreturn (left && right);", "question": "\nProblem: Determine whether an input array is a post-order traversal sequence of a binary tree or not. If it is, return true; otherwise return false. Assume all numbers in an input array are unique.\n\nFor example, if the input array is {5, 7, 6, 9, 11, 10, 8}, true should be returned, since it is a post-order traversal sequence of the binary search tree in Figure 1. If the input array is {7, 4, 6, 5}, false should be returned since there are no binary search trees whose post-order traversal sequence is such an array."},
{"answer": "\nAnalysis: In a binary tree, each node has two pointers to its children. In a double-linked list, each node also has two pointers, one pointing to the previous node and the other pointing to the next one. Additionally, binary search tree is a sorted data structure. In a binary search tree, value in parent is always greater than value of its left child and less than value of its right child. Therefore, we can adjust a pointer to its left child in binary search tree to its previous node in a double-linked list, and adjust a pointer to its right child to its next node.\n\nIt is required that the converted list should be sorted, so we can adopt in-order traversal. That is because according to the definition of in-order traversal we traverse from nodes with less value to nodes with greater value. When we reach the root of the binary tree in Figure1, the tree may be viewed as three parts: a root with value 10, a left sub-tree with root value 6 and a right sub-tree with root value 14. According to the definition of sorted double-linked list, the root node with value 10 should be linked to the node with the greatest value (the node with value 8) in its left sub-tree, and it should be also linked to the node with the least value (the node with value 12) in its right sub-tree, as shown in Figure 2.\n\n\n\nFigure 2: A tree with three parts: root, left sub-tree, right sub-tree. After we can the left sub-tree and right sub-tree, and we link them with the root, and then we can get a sorted double-linked list\n\nAccording to the definition of in-order traversal, the sub-tree should be already converted to a sorted list when we reach its root (the node with value 10), and the last node in the sorted list should be the node with the greatest node (the node with value 8). If we link the last node in list to the root node of tree, then the root is the last node in list now. We continue to convert its right sub-tree, and connect the root to the node with its least value. How to convert its left sub-tree and right sub-tree? It should be similar to converting the whole tree. Therefore, we can solve it with recursion.\nWe can write the following code based on the recursive solution:\n\nBinaryTreeNode* Convert(BinaryTreeNode* pRootOfTree)\n{\nBinaryTreeNode *pLastNodeInList = NULL;\nConvertNode(pRootOfTree, &pLastNodeInList);\n\n// pLastNodeInList points to the tail of double-linked list,\n// but we need to return its head\nBinaryTreeNode *pHeadOfList = pLastNodeInList;\nwhile (pHeadOfList != NULL && pHeadOfList->m_pLeft != NULL)\npHeadOfList = pHeadOfList->m_pLeft;\n\nreturn pHeadOfList;\n}\n\nvoid ConvertNode(BinaryTreeNode* pNode, BinaryTreeNode** pLastNodeInList)\n{\nif (pNode == NULL)\nreturn ;\n\nBinaryTreeNode *pCurrent = pNode;\n\nif (pCurrent->m_pLeft != NULL)\nConvertNode(pCurrent->m_pLeft, pLastNodeInList);\n\npCurrent->m_pLeft = *pLastNodeInList;\nif (*pLastNodeInList != NULL)\n(*pLastNodeInList)->m_pRight = pCurrent;\n\n*pLastNodeInList = pCurrent;\n\nif (pCurrent->m_pRight != NULL)\nConvertNode(pCurrent->m_pRight, pLastNodeInList);\n}\n", "question": "\nQuestion: Convert a binary search tree to a sorted double-linked list. We can only change the target of pointers, but cannot create any new nodes.\nFor example, if we input a binary search tree as shown on the left side of the Figure 1, the output double-linked list is shown on the right side.\n\n\n\nFigure 1: The conversion between a binary search tree and a sorted double-linked list\n\nA node of binary search tree is defined in C/C++ is as:\nstruct BinaryTreeNode\n{\nint\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};"},
{"answer": "", "question": ""},
{"answer": "", "question": ""},
{"answer": "", "question": ""},
{"answer": "\nAnalysis: We have discussed how to store nodes of a path in a stack while traversing a binary tree in the blog \" Paths with Specified Sum in Binary Tree \". The depth of a binary tree is the length of the longest path. This solution works, but it is not the most concise one.\n\nThe depth of a binary tree can be gotten in another way. If a binary tree has only one node, its depth is 1. If the root node of a binary tree has only a left subtree, its depth is the depth of the left subtree plus 1. Similarly, its depth is the depth of the right subtree plus 1 if the root node has only a right subtree. What is the depth if the root node has both left subtree and right subtree? It is the greater value of the depth of the left and right subtrees plus 1.\n\nFor example, the root node of the binary tree in Figure\u00a01 has both left and right subtrees. The depth of the left subtree rooted at node 2 is 3, and the depth of the right subtree rooted at node 3 is 2, so the depth of the whole binary tree is 4; 1 plus the greater value of 3 and 2.\n\nIt is easy to implement this solution recursively, with little modification on the post-order traversal algorithm, as shown below:\n\n int TreeDepth(BinaryTreeNode* pRoot)\n {\n     if (pRoot == NULL)\n         return 0;\n\n     int nLeft = TreeDepth(pRoot->m_pLeft);\n     int nRight = TreeDepth(pRoot->m_pRight);\n\n     return (nLeft > nRight) ? (nLeft + 1) : (nRight +1);\n }\n\n\nAnalysis:\n\nSolution 1: Visiting Nodes for Multiple Times\nAccording to the definition of balanced binary trees, this problem can be solved by getting the depth difference between the left and right subtrees of every node. When a node is visited, the function depth is invoked to get the depth of its left and right subtrees. If the depth different is 1 at most for all nodes in a binary tree, it is balanced. This solution can be implemented based on the TreeDepth discussed in the preceding problem, as shown below:\n\n bool IsBalanced_Solution1(BinaryTreeNode* pRoot)\n {\n     if (pRoot == NULL)\n         return true ;\n\n     int left = TreeDepth(pRoot->m_pLeft);\n     int right = TreeDepth(pRoot->m_pRight);\n     int diff = left - right;\n     if (diff > 1 || diff < -1)\n         return false ;\n\n     return IsBalanced_Solution1(pRoot->m_pLeft)\n         && IsBalanced_Solution1(pRoot->m_pRight);\n }  \nThis solution looks concise, but it is inefficient because it visits some nodes for multiple times. Take the binary tree in Figure\u00a01 as an example. When the function TreeDepth takes the node 2 as a parameter, it visits nodes 4, 5, and 7. When it verifies whether the binary tree rooted at node 2 is balanced, it visits nodes 4, 5, and 7 again. Obviously, we could improve performance if nodes are visited only once.\n\nSolution 2: Visiting Every Node Only Once\n\nIf a binary tree is scanned with the post-order algorithm, its left and right subtrees are traversed before the root node. If we record the depth of the currently visited node (the depth of a node is the maximum length of paths from the node to its leaf nodes), we can verify whether the subtree rooted at the currently visited node is balanced. If any subtree is unbalanced, the whole tree is unbalanced.\n\nThis new solution can be implemented as shown in below:\n\nbool IsBalanced_Solution2(BinaryTreeNode* pRoot)\n {\n     int depth = 0;\n     return IsBalanced(pRoot, &depth);\n }\n\n bool IsBalanced(BinaryTreeNode* pRoot, int * pDepth)\n {\n     if (pRoot == NULL)\n     {\n         *pDepth = 0;\n         return true ;\n     }\n\n     int left, right;\n     if (IsBalanced(pRoot->m_pLeft, &left) && IsBalanced(pRoot->m_pRight, &right))\n     {\n         int diff = left - right;\n         if (diff <= 1 && diff >= -1)\n         {\n             *pDepth = 1 + (left > right ? left : right);\n             return true ;\n         }\n     }\n\n     return false ;\n }\n\n\nAfter verifying left and right subtrees of a node, the solution verifies the subtree rooted at the current visited node and passes the depth to verify its parent node. When the recursive process returns to the root node finally, the whole binary tree is verified.\n\n", "question": "\nQuestion 1 : How do you get the depth of a binary tree? Nodes from the root to a leaf form a path. Depth of a binary tree is the maximum length of all paths. For example, the depth of the binary tree in Figure\u00a01 is 4, with the longest path through nodes 1, 2, 5, and 7.\n\nQuestion 2: How do you verify whether a binary tree is balanced? If the depth difference between a left subtree and right subtree of any node in a binary tree is not greater than 1, it is balanced. For instance, the binary tree in Figure\u00a01 is balanced.\n"},
{"answer": "\nAnalysis: Let's take the number 12258 as an example to analyze the steps to translate from the beginning character to the ending one. There are two possible first characters in the translated string. One way is to split the number 12258 into 1 and 2258 two parts, and 1 is translated into 'a'. The other way is to split the number 12258 into 12 and 258 two parts, and 12 is translated into 'l'.\nWhen the first one or two digits are translated into the first character, we can continue to translate the remaining digits. Obviously, we could write a recursive function/method to translate.\nLet's define a function f ( i ) as the count of different ways to translate a number starting from the i th digit, f ( i )= g ( i )* f ( i +1)+ h ( i , i +1)* f ( i +2). The function g (i) gets 1 when the i th digit is in the range 1 to 9 which can be converted to a character, otherwise it gets 0. The function h ( i , i +1) gets 1 the i th and ( i +1) th digits are in the range 10 to 26 which can also be converted to a character. A single digit 0 can't be converted to a character, and two digits starting with a 0, such as 01 and 02, can't be converted either.\nEven though the problem is analyzed with recursion, recursion is not the best approach because of overlapping sub-problems. For example, The problem to translate 12258 is split into two sub-problems: one is to translate 1 and 2258, and the other is to translate 12 and 258. In the next step during recursion, the problem to translate 2258 can also split into two sub-problems: one is to translate 2 and 258, and the other is to translate 22 and 58. Notice the sub-problem to translate 258 reoccurs.\nRecursion solves problem in the top-down order. We could solve this problem in the bottom-up order, in order to eliminate overlap sub-problems. That's to say, we start to translate the number from the ending digits, and then move from right to left during translation.\nThe following is the C# code to solve this problem:\n public static int GetTranslationCount( int number)\n {\n     if (number <= 0)\n     {\n         return 0;\n     }\n  \n     string numberInString = number.ToString();\n     return GetTranslationCount(numberInString);\n }\n  \n private static int GetTranslationCount( string number)\n {\n     int length = number.Length;\n     int [] counts = new int [length];\n  \n     for ( int i = length - 1; i >= 0; --i)\n     {\n         int count = 0;\n         if (number[i] >= '1' && number[i] <= '9' )\n         {\n             if (i < length - 1)\n             {\n                 count += counts[i + 1];\n             }\n             else\n             {\n                 count += 1;\n             }\n         }\n  \n         if (i < length - 1)\n         {\n             int digit1 = number[i] - '0' ;\n             int digit2 = number[i + 1] - '0' ;\n             int converted = digit1 * 10 + digit2;\n             if (converted >= 10 && converted<= 26)\n             {\n                 if (i <length - 2)\n                 {\n                     count += counts[i + 2];\n                 }\n                 else\n                 {\n                     count += 1;\n                 }\n             }\n         }\n  \n         counts[i] = count;\n     }\n  \n     return counts[0];\n }\nIn order to simply the code implementation, we first convert the number into a string, and then translate.\n\n", "question": "\nQuestion: Given a number, please translate it to a string, following the rules: 1 is translated to 'a', 2 to 'b', \u2026, 12 to 'l', \u2026, 26 to 'z'. For example, the number 12258 can be translated to \"abbeh\", \"aveh\", \"abyh\", \"lbeh\" and \"lyh\", so there are 5 different ways to translate 12258. How to write a function/method to count the different ways to translate a number?"},
{"answer": "\nAnalysis : It is a typical problem about dynamic programming. Firstly let\u2019s analyze it with recursion. A function f ( i , j ) is defined for the maximal value of gifts when reaching the cell ( i , j ). There are two possible cells before the cell ( i , j ) is reached: One is ( i - 1, j ), and the other is the cell ( i , j -1). Therefore, f ( i , j )= max ( f ( i -1, j ), f ( i , j -1)) + gift[ i , j ].\nEven though it\u2019s a recursive equation, it\u2019s not a good idea to write code in recursion, because there might be many over-lapping sub-problems. A better solution is to solve is with iteration. A 2-D matrix is utilized, and the value in each cell ( i , j ) is the maximal value of gift when reaching the cell ( i , j ) on the board.\nThe iterative solution can be implemented in the following Java code:\n public static int getMaxValue( int [][] values) {\nOptimization\n\nThe maximal value of gifts when reaching the cell ( i , j ) depends on the cells ( i -1, j ) and ( i , j -1) only, so it is not necessary to save the value of the cells in the rows i -2 and above. Therefore, we can replace the 2-D matrix with an array, as the following code shows:\n\n public static int getMaxValue( int [][] values)  {\n     int rows = values.length;\n     int cols = values[0].length;\n\n     int [] maxValues = new int [cols];\n     for ( int i = 0; i < rows; ++i)  {\n         for ( int j = 0; j < cols; ++j)  {\n             int left = 0;\n             int up = 0;\n\n             if (i > 0)  {\n                 up = maxValues[j];\n             }\n\n             if (j > 0)  {\n                 left = maxValues[j - 1];\n             }\n\n             maxValues[j] = Math .max(left, up) +values[i][j];\n         }\n     }\n\n     return maxValues[cols - 1];\n }", "question": "\nQuestion : A board has n * m cells, and there is a gift with some value (value is greater than 0) in every cell. You can get gifts starting from the top-left cell, and move right or down in each step, and finally reach the cell at the bottom-right cell. What\u2019s the maximal value of gifts you can get from the board?\n\n\nFor example, the maximal value of gift from the board above is 53, and the path is highlighted in red."},
{"answer": "\nAnalysis : It is a typical problem about dynamic programming. Firstly let\u2019s analyze it with recursion. A function f ( i , j ) is defined for the maximal value of gifts when reaching the cell ( i , j ). There are two possible cells before the cell ( i , j ) is reached: One is ( i - 1, j ), and the other is the cell ( i , j -1). Therefore, f ( i , j )= max ( f ( i -1, j ), f ( i , j -1)) + gift[ i , j ].\nEven though it\u2019s a recursive equation, it\u2019s not a good idea to write code in recursion, because there might be many over-lapping sub-problems. A better solution is to solve is with iteration. A 2-D matrix is utilized, and the value in each cell ( i , j ) is the maximal value of gift when reaching the cell ( i , j ) on the board.\nThe iterative solution can be implemented in the following Java code:\n public static int getMaxValue( int [][] values) {\nOptimization\n\nThe maximal value of gifts when reaching the cell ( i , j ) depends on the cells ( i -1, j ) and ( i , j -1) only, so it is not necessary to save the value of the cells in the rows i -2 and above. Therefore, we can replace the 2-D matrix with an array, as the following code shows:\n\n public static int getMaxValue( int [][] values)  {\n     int rows = values.length;\n     int cols = values[0].length;\n\n     int [] maxValues = new int [cols];\n     for ( int i = 0; i < rows; ++i)  {\n         for ( int j = 0; j < cols; ++j)  {\n             int left = 0;\n             int up = 0;\n\n             if (i > 0)  {\n                 up = maxValues[j];\n             }\n\n             if (j > 0)  {\n                 left = maxValues[j - 1];\n             }\n\n             maxValues[j] = Math .max(left, up) +values[i][j];\n         }\n     }\n\n     return maxValues[cols - 1];\n }", "question": "\nQuestion : A board has n * m cells, and there is a gift with some value (value is greater than 0) in every cell. You can get gifts starting from the top-left cell, and move right or down in each step, and finally reach the cell at the bottom-right cell. What\u2019s the maximal value of gifts you can get from the board?\n\n\nFor example, the maximal value of gift from the board above is 53, and the path is highlighted in red."},
{"answer": "\nAnalysis : It is a typical problem about dynamic programming. Firstly let\u2019s analyze it with recursion. A function f ( i , j ) is defined for the maximal value of gifts when reaching the cell ( i , j ). There are two possible cells before the cell ( i , j ) is reached: One is ( i - 1, j ), and the other is the cell ( i , j -1). Therefore, f ( i , j )= max ( f ( i -1, j ), f ( i , j -1)) + gift[ i , j ].\nEven though it\u2019s a recursive equation, it\u2019s not a good idea to write code in recursion, because there might be many over-lapping sub-problems. A better solution is to solve is with iteration. A 2-D matrix is utilized, and the value in each cell ( i , j ) is the maximal value of gift when reaching the cell ( i , j ) on the board.\nThe iterative solution can be implemented in the following Java code:\n public static int getMaxValue( int [][] values) {\nOptimization\n\nThe maximal value of gifts when reaching the cell ( i , j ) depends on the cells ( i -1, j ) and ( i , j -1) only, so it is not necessary to save the value of the cells in the rows i -2 and above. Therefore, we can replace the 2-D matrix with an array, as the following code shows:\n\n public static int getMaxValue( int [][] values)  {\n     int rows = values.length;\n     int cols = values[0].length;\n\n     int [] maxValues = new int [cols];\n     for ( int i = 0; i < rows; ++i)  {\n         for ( int j = 0; j < cols; ++j)  {\n             int left = 0;\n             int up = 0;\n\n             if (i > 0)  {\n                 up = maxValues[j];\n             }\n\n             if (j > 0)  {\n                 left = maxValues[j - 1];\n             }\n\n             maxValues[j] = Math .max(left, up) +values[i][j];\n         }\n     }\n\n     return maxValues[cols - 1];\n }", "question": "\nQuestion : A board has n * m cells, and there is a gift with some value (value is greater than 0) in every cell. You can get gifts starting from the top-left cell, and move right or down in each step, and finally reach the cell at the bottom-right cell. What\u2019s the maximal value of gifts you can get from the board?\n\n\nFor example, the maximal value of gift from the board above is 53, and the path is highlighted in red."},
{"answer": "\nAnalysis: Binary search is suitable for sorted arrays. Let us try to utilize it on a rotation of a sorted array. Notice that a rotation of a sorted array can be partitioned into two sorted sub-arrays, and numbers in the first sub-array are greater than numbers in the second one.\nTwo pointers P1 and P2 are utilized. P1 references to the first element in the array, and P2 references to the last element. According to the rotation rule, the first element should be greater than the last one.\nThe algorithm always compares the number in middle with numbers pointed by P1 and P2 during binary search. If the middle number is in the first increasingly sorted sub-array, it is greater than the number pointed by P1.\nIf the value of target number to be search is between the number pointed by P1 and the middle number, we then search the target number in the first half sub-array. In such a case the first half sub-array is in the first increasing sub-array, we could utilize the binary search algorithm. For example, if we search the number 4 in a rotation {3, 4, 5, 1, 2}, we could search the target number 4 in the sub-array {3, 4, 5} because 4 is between the first number 3 and the middle number 5.\nIf the value of target number is not between the number pointed by P1 and the middle number, we search the target in the second half sub-array. Notice that the second half sub-array also contains two increasing sub-array and itself is also a rotation, so we could search recursively with the same strategy. For example, if we search the number 1 in a rotation {3, 4, 5, 1, 2}, we could search the target number 1 in the sub-array {5, 1, 2} recursively.\nThe analysis above is for two cases when the middle number is in the first increasing sub-array. Please analyze the other two cases when the middle number is in the second increasing sub-array yourself, when the middle number is less than the number pointed by P2.\nThe code implementing this algorithm is listed below, in C/C++:\nint searchInRotation( int numbers[], int length, int k)\n{\nif (numbers == NULL || length <= 0)\nreturn -1;\n\nreturn searchInRotation(numbers, k, 0, length - 1);\n}\n\nint searchInRotation( int numbers[], int k, int start, int end)\n{\nif (start > end)\nreturn -1;\n\nint middle = start + (end - start) / 2;\nif (numbers[middle] == k)\nreturn middle;\n\n// the middle number is in the first increasing sub-array\nif (numbers[middle] >= numbers[start])\n{\nif (k >= numbers[start] && k < numbers[middle])\nreturn binarySearch(numbers, k, start, middle - 1);\nreturn searchInRotation(numbers, k, middle + 1, end);\n}\n// the middle number is in the second increasing sub-array\nelse if (numbers[middle] <= numbers[end])\n{\nif (k > numbers[middle] && k <= numbers[end])\nreturn binarySearch(numbers, k, middle + 1, end);\nreturn searchInRotation(numbers, k, start, middle - 1);\n}\n\n// It should never reach here if the input is valid\nassert( false );\n}\nSince the function binarySearch is for the classic binary search algorithm, it is not listed here. You might implement your own binary search code if you are interested.\nIn each round of search, half of the array is excluded for the next round, so the time complexity is O(log n ).\nYou may wonder why we assume there are no duplications in the input array. We determine whether the middle number is in the first or second sub-array by comparing the middle number and the numbers pointed by P1 or P2. When the middle number, the number pointed by P1 and P2 are identical, we don\u2019t know whether the middle number is in the first or second increasing sub-array.\nLet\u2019s look at some examples. Two arrays {1, 0, 1, 1, 1} and {1, 1, 1, 0, 1} are both rotations of an increasingly sorted array {0, 1, 1, 1, 1}, which are visualized in Figure 1.\n\n\nFigure 1 : Two rotations of an increasingly sorted array {0, 1, 1, 1, 1}: {1, 0, 1, 1, 1} and {1, 1, 1, 0, 1}. Elements with gray background are in the second increasing sub-array.\nIn Figure 1, the elements pointed by P1 and P2, as well as the middle element are all 1. The middle element with index 2 is in the second sub-array in Figure 1 (a), while the middle element is in the first sub-array in Figure 1 (b).", "question": "\nQuestion: When some elements at the beginning of an array are moved to the end, it gets a rotation of the original array. Please implement a function to search a number in a rotation of an increasingly sorted array. Assume there are no duplicated numbers in the array.\nFor example, array {3, 4, 5, 1, 2} is a rotation of array {1, 2, 3, 4, 5}. If the target number to be searched is 4, the index of the number 4 in the rotation 1 should be returned. If the target number to be searched is 6, -1 should be returned because the number does not exist in the rotated array."},
{"answer": "\nAnalysis: Binary search is suitable for sorted arrays. Let us try to utilize it on a rotation of a sorted array. Notice that a rotation of a sorted array can be partitioned into two sorted sub-arrays, and numbers in the first sub-array are greater than numbers in the second one.\nTwo pointers P1 and P2 are utilized. P1 references to the first element in the array, and P2 references to the last element. According to the rotation rule, the first element should be greater than the last one.\nThe algorithm always compares the number in middle with numbers pointed by P1 and P2 during binary search. If the middle number is in the first increasingly sorted sub-array, it is greater than the number pointed by P1.\nIf the value of target number to be search is between the number pointed by P1 and the middle number, we then search the target number in the first half sub-array. In such a case the first half sub-array is in the first increasing sub-array, we could utilize the binary search algorithm. For example, if we search the number 4 in a rotation {3, 4, 5, 1, 2}, we could search the target number 4 in the sub-array {3, 4, 5} because 4 is between the first number 3 and the middle number 5.\nIf the value of target number is not between the number pointed by P1 and the middle number, we search the target in the second half sub-array. Notice that the second half sub-array also contains two increasing sub-array and itself is also a rotation, so we could search recursively with the same strategy. For example, if we search the number 1 in a rotation {3, 4, 5, 1, 2}, we could search the target number 1 in the sub-array {5, 1, 2} recursively.\nThe analysis above is for two cases when the middle number is in the first increasing sub-array. Please analyze the other two cases when the middle number is in the second increasing sub-array yourself, when the middle number is less than the number pointed by P2.\nThe code implementing this algorithm is listed below, in C/C++:\nint searchInRotation( int numbers[], int length, int k)\n{\nif (numbers == NULL || length <= 0)\nreturn -1;\n\nreturn searchInRotation(numbers, k, 0, length - 1);\n}\n\nint searchInRotation( int numbers[], int k, int start, int end)\n{\nif (start > end)\nreturn -1;\n\nint middle = start + (end - start) / 2;\nif (numbers[middle] == k)\nreturn middle;\n\n// the middle number is in the first increasing sub-array\nif (numbers[middle] >= numbers[start])\n{\nif (k >= numbers[start] && k < numbers[middle])\nreturn binarySearch(numbers, k, start, middle - 1);\nreturn searchInRotation(numbers, k, middle + 1, end);\n}\n// the middle number is in the second increasing sub-array\nelse if (numbers[middle] <= numbers[end])\n{\nif (k > numbers[middle] && k <= numbers[end])\nreturn binarySearch(numbers, k, middle + 1, end);\nreturn searchInRotation(numbers, k, start, middle - 1);\n}\n\n// It should never reach here if the input is valid\nassert( false );\n}\nSince the function binarySearch is for the classic binary search algorithm, it is not listed here. You might implement your own binary search code if you are interested.\nIn each round of search, half of the array is excluded for the next round, so the time complexity is O(log n ).\nYou may wonder why we assume there are no duplications in the input array. We determine whether the middle number is in the first or second sub-array by comparing the middle number and the numbers pointed by P1 or P2. When the middle number, the number pointed by P1 and P2 are identical, we don\u2019t know whether the middle number is in the first or second increasing sub-array.\nLet\u2019s look at some examples. Two arrays {1, 0, 1, 1, 1} and {1, 1, 1, 0, 1} are both rotations of an increasingly sorted array {0, 1, 1, 1, 1}, which are visualized in Figure 1.\n\n\nFigure 1 : Two rotations of an increasingly sorted array {0, 1, 1, 1, 1}: {1, 0, 1, 1, 1} and {1, 1, 1, 0, 1}. Elements with gray background are in the second increasing sub-array.\nIn Figure 1, the elements pointed by P1 and P2, as well as the middle element are all 1. The middle element with index 2 is in the second sub-array in Figure 1 (a), while the middle element is in the first sub-array in Figure 1 (b).", "question": "\nQuestion: When some elements at the beginning of an array are moved to the end, it gets a rotation of the original array. Please implement a function to search a number in a rotation of an increasingly sorted array. Assume there are no duplicated numbers in the array.\nFor example, array {3, 4, 5, 1, 2} is a rotation of array {1, 2, 3, 4, 5}. If the target number to be searched is 4, the index of the number 4 in the rotation 1 should be returned. If the target number to be searched is 6, -1 should be returned because the number does not exist in the rotated array."},
{"answer": "\nAnalysis: It is not difficult to get a solution with brute force: Scan numbers in every sliding window to get its maximal value. The overall time complexity is O( nk ) if the length of array is n and the size of sliding windows is k .\n\nThe na\u00efve solution is not the best solution. Let us explore better solutions.\n\nSolution 1: Maximal value in a queue\n\nA window can be viewed as a queue. When it slides, a number is pushed into its back, and its front is popped off. Therefore, the problem is solved if we can get the maximal value of a queue.\n\nThere are no straightforward approaches to getting the maximal value of a queue. However, there are solutions to get the maximal value of a stack, which is similar to the solution introduced in the blog \u201c Stack with Function min() \u201d. Additionally, a queue can also be implemented with two stacks (details are discussed in another blog \u201c Queue implemented with Two Stacks \u201d).\n\nIf a new type of queue is implemented with two stacks, in which a function max() is defined to get the maximal value, the maximal value in a queue is the greater number of the two maximal numbers in two stacks.\n\nThis solution is workable. However, we may not have enough time to write all code to implement our own queue and stack data structures during interviews. Let us continue exploring a more concise solution.\n\nSolution 2: Saving the maximal value into the front of a queue\n\nInstead of pushing every numbers inside a sliding window into a queue, we try to push the candidates of maximum only into a queue. Let us take the array {2, 3, 4, 2, 6, 2, 5, 1} as an example to analyze the solution step by step.\n\nThe first number in the array is 2, we push it into a queue. The second number is 3, which is greater than the previous number 2. The number 2 should be popped off, because it is less than 3 and it has no chance to be the maximal value. There is only one number left in the queue when we pop 2 at the back and push 3 at the back. The operations are similar when we push the next number 4. There is only a number 4 remaining in the queue. Now the sliding window already has three elements, we can get the maximum value at the front of the queue.\n\nWe continue to push the fourth number.\u00a0 It is pushed at the back of queue, because it is less than the previous number 4 and it might be a maximal number in the future when the previous numbers are popped off. There are two numbers, 4 and 2, in the queue, and 4 is the maximum.\n\nThe next number to be pushed is 6. Since it is greater than the existing numbers, 4 and 2, these two numbers can be popped off because they have no chance to be the maximum. Now there is only one number in the queue, which is 6, after the current number is pushed. Of course, the maximum is 6.\nThe next number is 2, which is pushed into the back of the queue because it is less than the previous number 6. There are two numbers in the queue, 6 and 2, and the number 6 at the front of the queue is the maximal value.\n\nIt is time to push the number 5. Because it is greater than the number 2 at the back of the queue, 2 is popped off and then 5 is pushed. There are two numbers in the queue, 6 and 5, and the number 6 at the front of the queue is the maximal value.\n\nNow let us push the last number 1. It can be pushed into the queue. It is noticeable that the number at the front is beyond the scope the current sliding window, and it should be popped off.\u00a0 How do we know whether the number at the front of the queue is out of sliding window? Rather than storing numbers in the queue directly, we can store indices instead. If the distance between the index at the front of queue and the index of the current number to be pushed is greater than or equal to the window size, the number corresponding to be the index at the font of queue is out of sliding window.\n\nThe analysis process above is summarized in Table 2.\n\nStep Number to Be Pushed Numbers in Sliding Window Indices in queue Maximum in Window 1 2 2 0(2) 2 3 2, 3 1(3) 3 4 2, 3, 4 2(4) 4 4 2 3, 4, 2 2(4), 3(2) 4 5 6 4, 2, 6 4(6) 6 6 2 2, 6, 2 4(6), 5(2) 6 7 5 6, 2, 5 4(6), 6(5) 6 8 1 2, 5, 1 6(5), 7(1) 5\nStep\nNumber to Be Pushed\nNumbers in Sliding Window\nIndices in queue\nMaximum in Window\n1\n2\n2\n0(2)\n\n2\n3\n2, 3\n1(3)\n\n3\n4\n2, 3, 4\n2(4)\n4\n4\n2\n3, 4, 2\n2(4), 3(2)\n4\n5\n6\n4, 2, 6\n4(6)\n6\n6\n2\n2, 6, 2\n4(6), 5(2)\n6\n7\n5\n6, 2, 5\n4(6), 6(5)\n6\n8\n1\n2, 5, 1\n6(5), 7(1)\n5\nTable 2: The process to get the maximal number in all sliding windows with window size 3 in the array {2, 3, 4, 2, 6, 2, 5, 1}. In the column \u201cIndices in queue\u201d, the number inside a pair of parentheses is the number indexed by the number before it in the array.\n\nWe can implement a solution based on the analysis above. Some sample code in C++ is shown below, which utilizes the type deque of STL.\n\nvector< int > maxInWindows( const vector< int >& numbers, int windowSize)\n{\nvector< int > maxInSlidingWindows;\nif (numbers.size() >= windowSize && windowSize > 1)\n{\ndeque< int > indices;\n\nfor ( int i = 0; i < windowSize; ++i)\n{\nwhile (!indices.empty() && numbers[i] >= numbers[indices.back()])\nindices.pop_back();\n\nindices.push_back(i);\n}\n\nfor ( int i = windowSize; i < numbers.size(); ++i)\n{\nmaxInSlidingWindows.push_back(numbers[indices.front()]);\n\nwhile (!indices.empty() && numbers[i] >= numbers[indices.back()])\nindices.pop_back();\nif (!indices.empty() && indices.front() <= i - windowSize)\nindices.pop_front();\n\nindices.push_back(i);\n}\nmaxInSlidingWindows.push_back(numbers[indices.front()]);\n}\n\nreturn maxInSlidingWindows;\n}\n\nExtension: Another solution to get the maximum of a queue\n\nAs we mentioned before, a sliding window can be viewed as a queue. Therefore, we can implement a new solution to get the maximal value of a queue based on the second solution to get the maximums of sliding windows.\n\nThe following is the sample code:\n\ntemplate < typename T> class QueueWithMax\n{\npublic :\nQueueWithMax(): currentIndex(0)\n{\n}\n\nvoid push_back(T number)\n{\nwhile (!maximums.empty() && number >= maximums.back().number)\nmaximums.pop_back();\n\nInternalData internalData = {number, currentIndex};\ndata.push_back(internalData);\nmaximums.push_back(internalData);\n\n++currentIndex;\n}\n\nvoid pop_front()\n{\nif (maximums.empty())\nthrow new exception( \"queue is empty\" );\n\nif (maximums.front().index == data.front().index)\nmaximums.pop_front();\n\ndata.pop_front();\n}\n\nT max() const\n{\nif (maximums.empty())\nthrow new exception( \"queue is empty\" );\n\nreturn maximums.front().number;\n}\n\nprivate :\nstruct InternalData\n{\nT number;\nint index;\n};\n\ndeque<InternalData> data;\ndeque<InternalData> maximums;\nint currentIndex;\n};\n\nSince this solution is similar to the second solution to get maximums of sliding windows, we won\u2019t analyze the process step by step, and leave it as an exercise if you are interested.", "question": "\nQuestion: Given an array of numbers and a sliding window size, how to get the maximal numbers in all sliding windows?\n\nFor example, if the input array is {2, 3, 4, 2, 6, 2, 5, 1} and the size of sliding windows is 3, the output of maximums are {4, 4, 6, 6, 6, 5}, as illustrated in Table1.\n\nSliding Windows in an Array Maximums in Sliding Windows [2, 3, 4] , 2, 6, 2, 5, 1 4 2, [3, 4, 2] , 6, 2, 5, 1 4 2, 3, [4, 2, 6] , 2, 5, 1 6 2, 3, 4, [2, 6, 2] , 5, 1 6 2, 3, 4, 2, [6, 2, 5] , 1 6 2, 3, 4, 2, 6, [2, 5, 1] 5\nSliding Windows in an Array\nMaximums in Sliding Windows\n[2, 3, 4] , 2, 6, 2, 5, 1\n4\n2, [3, 4, 2] , 6, 2, 5, 1\n4\n2, 3, [4, 2, 6] , 2, 5, 1\n6\n2, 3, 4, [2, 6, 2] , 5, 1\n6\n2, 3, 4, 2, [6, 2, 5] , 1\n6\n2, 3, 4, 2, 6, [2, 5, 1]\n5\nTable 1: Maximums of all sliding windows with size 3 in an array {2, 3, 4, 2, 6, 2, 5, 1}. A pair of brackets indicates a sliding window.\n"},
{"answer": "\nAnalysis: It is not difficult to get a solution with brute force: Scan numbers in every sliding window to get its maximal value. The overall time complexity is O( nk ) if the length of array is n and the size of sliding windows is k .\n\nThe na\u00efve solution is not the best solution. Let us explore better solutions.\n\nSolution 1: Maximal value in a queue\n\nA window can be viewed as a queue. When it slides, a number is pushed into its back, and its front is popped off. Therefore, the problem is solved if we can get the maximal value of a queue.\n\nThere are no straightforward approaches to getting the maximal value of a queue. However, there are solutions to get the maximal value of a stack, which is similar to the solution introduced in the blog \u201c Stack with Function min() \u201d. Additionally, a queue can also be implemented with two stacks (details are discussed in another blog \u201c Queue implemented with Two Stacks \u201d).\n\nIf a new type of queue is implemented with two stacks, in which a function max() is defined to get the maximal value, the maximal value in a queue is the greater number of the two maximal numbers in two stacks.\n\nThis solution is workable. However, we may not have enough time to write all code to implement our own queue and stack data structures during interviews. Let us continue exploring a more concise solution.\n\nSolution 2: Saving the maximal value into the front of a queue\n\nInstead of pushing every numbers inside a sliding window into a queue, we try to push the candidates of maximum only into a queue. Let us take the array {2, 3, 4, 2, 6, 2, 5, 1} as an example to analyze the solution step by step.\n\nThe first number in the array is 2, we push it into a queue. The second number is 3, which is greater than the previous number 2. The number 2 should be popped off, because it is less than 3 and it has no chance to be the maximal value. There is only one number left in the queue when we pop 2 at the back and push 3 at the back. The operations are similar when we push the next number 4. There is only a number 4 remaining in the queue. Now the sliding window already has three elements, we can get the maximum value at the front of the queue.\n\nWe continue to push the fourth number.\u00a0 It is pushed at the back of queue, because it is less than the previous number 4 and it might be a maximal number in the future when the previous numbers are popped off. There are two numbers, 4 and 2, in the queue, and 4 is the maximum.\n\nThe next number to be pushed is 6. Since it is greater than the existing numbers, 4 and 2, these two numbers can be popped off because they have no chance to be the maximum. Now there is only one number in the queue, which is 6, after the current number is pushed. Of course, the maximum is 6.\nThe next number is 2, which is pushed into the back of the queue because it is less than the previous number 6. There are two numbers in the queue, 6 and 2, and the number 6 at the front of the queue is the maximal value.\n\nIt is time to push the number 5. Because it is greater than the number 2 at the back of the queue, 2 is popped off and then 5 is pushed. There are two numbers in the queue, 6 and 5, and the number 6 at the front of the queue is the maximal value.\n\nNow let us push the last number 1. It can be pushed into the queue. It is noticeable that the number at the front is beyond the scope the current sliding window, and it should be popped off.\u00a0 How do we know whether the number at the front of the queue is out of sliding window? Rather than storing numbers in the queue directly, we can store indices instead. If the distance between the index at the front of queue and the index of the current number to be pushed is greater than or equal to the window size, the number corresponding to be the index at the font of queue is out of sliding window.\n\nThe analysis process above is summarized in Table 2.\n\nStep Number to Be Pushed Numbers in Sliding Window Indices in queue Maximum in Window 1 2 2 0(2) 2 3 2, 3 1(3) 3 4 2, 3, 4 2(4) 4 4 2 3, 4, 2 2(4), 3(2) 4 5 6 4, 2, 6 4(6) 6 6 2 2, 6, 2 4(6), 5(2) 6 7 5 6, 2, 5 4(6), 6(5) 6 8 1 2, 5, 1 6(5), 7(1) 5\nStep\nNumber to Be Pushed\nNumbers in Sliding Window\nIndices in queue\nMaximum in Window\n1\n2\n2\n0(2)\n\n2\n3\n2, 3\n1(3)\n\n3\n4\n2, 3, 4\n2(4)\n4\n4\n2\n3, 4, 2\n2(4), 3(2)\n4\n5\n6\n4, 2, 6\n4(6)\n6\n6\n2\n2, 6, 2\n4(6), 5(2)\n6\n7\n5\n6, 2, 5\n4(6), 6(5)\n6\n8\n1\n2, 5, 1\n6(5), 7(1)\n5\nTable 2: The process to get the maximal number in all sliding windows with window size 3 in the array {2, 3, 4, 2, 6, 2, 5, 1}. In the column \u201cIndices in queue\u201d, the number inside a pair of parentheses is the number indexed by the number before it in the array.\n\nWe can implement a solution based on the analysis above. Some sample code in C++ is shown below, which utilizes the type deque of STL.\n\nvector< int > maxInWindows( const vector< int >& numbers, int windowSize)\n{\nvector< int > maxInSlidingWindows;\nif (numbers.size() >= windowSize && windowSize > 1)\n{\ndeque< int > indices;\n\nfor ( int i = 0; i < windowSize; ++i)\n{\nwhile (!indices.empty() && numbers[i] >= numbers[indices.back()])\nindices.pop_back();\n\nindices.push_back(i);\n}\n\nfor ( int i = windowSize; i < numbers.size(); ++i)\n{\nmaxInSlidingWindows.push_back(numbers[indices.front()]);\n\nwhile (!indices.empty() && numbers[i] >= numbers[indices.back()])\nindices.pop_back();\nif (!indices.empty() && indices.front() <= i - windowSize)\nindices.pop_front();\n\nindices.push_back(i);\n}\nmaxInSlidingWindows.push_back(numbers[indices.front()]);\n}\n\nreturn maxInSlidingWindows;\n}\n\nExtension: Another solution to get the maximum of a queue\n\nAs we mentioned before, a sliding window can be viewed as a queue. Therefore, we can implement a new solution to get the maximal value of a queue based on the second solution to get the maximums of sliding windows.\n\nThe following is the sample code:\n\ntemplate < typename T> class QueueWithMax\n{\npublic :\nQueueWithMax(): currentIndex(0)\n{\n}\n\nvoid push_back(T number)\n{\nwhile (!maximums.empty() && number >= maximums.back().number)\nmaximums.pop_back();\n\nInternalData internalData = {number, currentIndex};\ndata.push_back(internalData);\nmaximums.push_back(internalData);\n\n++currentIndex;\n}\n\nvoid pop_front()\n{\nif (maximums.empty())\nthrow new exception( \"queue is empty\" );\n\nif (maximums.front().index == data.front().index)\nmaximums.pop_front();\n\ndata.pop_front();\n}\n\nT max() const\n{\nif (maximums.empty())\nthrow new exception( \"queue is empty\" );\n\nreturn maximums.front().number;\n}\n\nprivate :\nstruct InternalData\n{\nT number;\nint index;\n};\n\ndeque<InternalData> data;\ndeque<InternalData> maximums;\nint currentIndex;\n};\n\nSince this solution is similar to the second solution to get maximums of sliding windows, we won\u2019t analyze the process step by step, and leave it as an exercise if you are interested.", "question": "\nQuestion: Given an array of numbers and a sliding window size, how to get the maximal numbers in all sliding windows?\n\nFor example, if the input array is {2, 3, 4, 2, 6, 2, 5, 1} and the size of sliding windows is 3, the output of maximums are {4, 4, 6, 6, 6, 5}, as illustrated in Table1.\n\nSliding Windows in an Array Maximums in Sliding Windows [2, 3, 4] , 2, 6, 2, 5, 1 4 2, [3, 4, 2] , 6, 2, 5, 1 4 2, 3, [4, 2, 6] , 2, 5, 1 6 2, 3, 4, [2, 6, 2] , 5, 1 6 2, 3, 4, 2, [6, 2, 5] , 1 6 2, 3, 4, 2, 6, [2, 5, 1] 5\nSliding Windows in an Array\nMaximums in Sliding Windows\n[2, 3, 4] , 2, 6, 2, 5, 1\n4\n2, [3, 4, 2] , 6, 2, 5, 1\n4\n2, 3, [4, 2, 6] , 2, 5, 1\n6\n2, 3, 4, [2, 6, 2] , 5, 1\n6\n2, 3, 4, 2, [6, 2, 5] , 1\n6\n2, 3, 4, 2, 6, [2, 5, 1]\n5\nTable 1: Maximums of all sliding windows with size 3 in an array {2, 3, 4, 2, 6, 2, 5, 1}. A pair of brackets indicates a sliding window.\n"},
{"answer": "\nAnalysis: It is not difficult to get a solution with brute force: Scan numbers in every sliding window to get its maximal value. The overall time complexity is O( nk ) if the length of array is n and the size of sliding windows is k .\n\nThe na\u00efve solution is not the best solution. Let us explore better solutions.\n\nSolution 1: Maximal value in a queue\n\nA window can be viewed as a queue. When it slides, a number is pushed into its back, and its front is popped off. Therefore, the problem is solved if we can get the maximal value of a queue.\n\nThere are no straightforward approaches to getting the maximal value of a queue. However, there are solutions to get the maximal value of a stack, which is similar to the solution introduced in the blog \u201c Stack with Function min() \u201d. Additionally, a queue can also be implemented with two stacks (details are discussed in another blog \u201c Queue implemented with Two Stacks \u201d).\n\nIf a new type of queue is implemented with two stacks, in which a function max() is defined to get the maximal value, the maximal value in a queue is the greater number of the two maximal numbers in two stacks.\n\nThis solution is workable. However, we may not have enough time to write all code to implement our own queue and stack data structures during interviews. Let us continue exploring a more concise solution.\n\nSolution 2: Saving the maximal value into the front of a queue\n\nInstead of pushing every numbers inside a sliding window into a queue, we try to push the candidates of maximum only into a queue. Let us take the array {2, 3, 4, 2, 6, 2, 5, 1} as an example to analyze the solution step by step.\n\nThe first number in the array is 2, we push it into a queue. The second number is 3, which is greater than the previous number 2. The number 2 should be popped off, because it is less than 3 and it has no chance to be the maximal value. There is only one number left in the queue when we pop 2 at the back and push 3 at the back. The operations are similar when we push the next number 4. There is only a number 4 remaining in the queue. Now the sliding window already has three elements, we can get the maximum value at the front of the queue.\n\nWe continue to push the fourth number.\u00a0 It is pushed at the back of queue, because it is less than the previous number 4 and it might be a maximal number in the future when the previous numbers are popped off. There are two numbers, 4 and 2, in the queue, and 4 is the maximum.\n\nThe next number to be pushed is 6. Since it is greater than the existing numbers, 4 and 2, these two numbers can be popped off because they have no chance to be the maximum. Now there is only one number in the queue, which is 6, after the current number is pushed. Of course, the maximum is 6.\nThe next number is 2, which is pushed into the back of the queue because it is less than the previous number 6. There are two numbers in the queue, 6 and 2, and the number 6 at the front of the queue is the maximal value.\n\nIt is time to push the number 5. Because it is greater than the number 2 at the back of the queue, 2 is popped off and then 5 is pushed. There are two numbers in the queue, 6 and 5, and the number 6 at the front of the queue is the maximal value.\n\nNow let us push the last number 1. It can be pushed into the queue. It is noticeable that the number at the front is beyond the scope the current sliding window, and it should be popped off.\u00a0 How do we know whether the number at the front of the queue is out of sliding window? Rather than storing numbers in the queue directly, we can store indices instead. If the distance between the index at the front of queue and the index of the current number to be pushed is greater than or equal to the window size, the number corresponding to be the index at the font of queue is out of sliding window.\n\nThe analysis process above is summarized in Table 2.\n\nStep Number to Be Pushed Numbers in Sliding Window Indices in queue Maximum in Window 1 2 2 0(2) 2 3 2, 3 1(3) 3 4 2, 3, 4 2(4) 4 4 2 3, 4, 2 2(4), 3(2) 4 5 6 4, 2, 6 4(6) 6 6 2 2, 6, 2 4(6), 5(2) 6 7 5 6, 2, 5 4(6), 6(5) 6 8 1 2, 5, 1 6(5), 7(1) 5\nStep\nNumber to Be Pushed\nNumbers in Sliding Window\nIndices in queue\nMaximum in Window\n1\n2\n2\n0(2)\n\n2\n3\n2, 3\n1(3)\n\n3\n4\n2, 3, 4\n2(4)\n4\n4\n2\n3, 4, 2\n2(4), 3(2)\n4\n5\n6\n4, 2, 6\n4(6)\n6\n6\n2\n2, 6, 2\n4(6), 5(2)\n6\n7\n5\n6, 2, 5\n4(6), 6(5)\n6\n8\n1\n2, 5, 1\n6(5), 7(1)\n5\nTable 2: The process to get the maximal number in all sliding windows with window size 3 in the array {2, 3, 4, 2, 6, 2, 5, 1}. In the column \u201cIndices in queue\u201d, the number inside a pair of parentheses is the number indexed by the number before it in the array.\n\nWe can implement a solution based on the analysis above. Some sample code in C++ is shown below, which utilizes the type deque of STL.\n\nvector< int > maxInWindows( const vector< int >& numbers, int windowSize)\n{\nvector< int > maxInSlidingWindows;\nif (numbers.size() >= windowSize && windowSize > 1)\n{\ndeque< int > indices;\n\nfor ( int i = 0; i < windowSize; ++i)\n{\nwhile (!indices.empty() && numbers[i] >= numbers[indices.back()])\nindices.pop_back();\n\nindices.push_back(i);\n}\n\nfor ( int i = windowSize; i < numbers.size(); ++i)\n{\nmaxInSlidingWindows.push_back(numbers[indices.front()]);\n\nwhile (!indices.empty() && numbers[i] >= numbers[indices.back()])\nindices.pop_back();\nif (!indices.empty() && indices.front() <= i - windowSize)\nindices.pop_front();\n\nindices.push_back(i);\n}\nmaxInSlidingWindows.push_back(numbers[indices.front()]);\n}\n\nreturn maxInSlidingWindows;\n}\n\nExtension: Another solution to get the maximum of a queue\n\nAs we mentioned before, a sliding window can be viewed as a queue. Therefore, we can implement a new solution to get the maximal value of a queue based on the second solution to get the maximums of sliding windows.\n\nThe following is the sample code:\n\ntemplate < typename T> class QueueWithMax\n{\npublic :\nQueueWithMax(): currentIndex(0)\n{\n}\n\nvoid push_back(T number)\n{\nwhile (!maximums.empty() && number >= maximums.back().number)\nmaximums.pop_back();\n\nInternalData internalData = {number, currentIndex};\ndata.push_back(internalData);\nmaximums.push_back(internalData);\n\n++currentIndex;\n}\n\nvoid pop_front()\n{\nif (maximums.empty())\nthrow new exception( \"queue is empty\" );\n\nif (maximums.front().index == data.front().index)\nmaximums.pop_front();\n\ndata.pop_front();\n}\n\nT max() const\n{\nif (maximums.empty())\nthrow new exception( \"queue is empty\" );\n\nreturn maximums.front().number;\n}\n\nprivate :\nstruct InternalData\n{\nT number;\nint index;\n};\n\ndeque<InternalData> data;\ndeque<InternalData> maximums;\nint currentIndex;\n};\n\nSince this solution is similar to the second solution to get maximums of sliding windows, we won\u2019t analyze the process step by step, and leave it as an exercise if you are interested.", "question": "\nQuestion: Given an array of numbers and a sliding window size, how to get the maximal numbers in all sliding windows?\n\nFor example, if the input array is {2, 3, 4, 2, 6, 2, 5, 1} and the size of sliding windows is 3, the output of maximums are {4, 4, 6, 6, 6, 5}, as illustrated in Table1.\n\nSliding Windows in an Array Maximums in Sliding Windows [2, 3, 4] , 2, 6, 2, 5, 1 4 2, [3, 4, 2] , 6, 2, 5, 1 4 2, 3, [4, 2, 6] , 2, 5, 1 6 2, 3, 4, [2, 6, 2] , 5, 1 6 2, 3, 4, 2, [6, 2, 5] , 1 6 2, 3, 4, 2, 6, [2, 5, 1] 5\nSliding Windows in an Array\nMaximums in Sliding Windows\n[2, 3, 4] , 2, 6, 2, 5, 1\n4\n2, [3, 4, 2] , 6, 2, 5, 1\n4\n2, 3, [4, 2, 6] , 2, 5, 1\n6\n2, 3, 4, [2, 6, 2] , 5, 1\n6\n2, 3, 4, 2, [6, 2, 5] , 1\n6\n2, 3, 4, 2, 6, [2, 5, 1]\n5\nTable 1: Maximums of all sliding windows with size 3 in an array {2, 3, 4, 2, 6, 2, 5, 1}. A pair of brackets indicates a sliding window.\n"},
{"answer": "\nAnalysis: It is not difficult to get a solution with brute force: Scan numbers in every sliding window to get its maximal value. The overall time complexity is O( nk ) if the length of array is n and the size of sliding windows is k .\n\nThe na\u00efve solution is not the best solution. Let us explore better solutions.\n\nSolution 1: Maximal value in a queue\n\nA window can be viewed as a queue. When it slides, a number is pushed into its back, and its front is popped off. Therefore, the problem is solved if we can get the maximal value of a queue.\n\nThere are no straightforward approaches to getting the maximal value of a queue. However, there are solutions to get the maximal value of a stack, which is similar to the solution introduced in the blog \u201c Stack with Function min() \u201d. Additionally, a queue can also be implemented with two stacks (details are discussed in another blog \u201c Queue implemented with Two Stacks \u201d).\n\nIf a new type of queue is implemented with two stacks, in which a function max() is defined to get the maximal value, the maximal value in a queue is the greater number of the two maximal numbers in two stacks.\n\nThis solution is workable. However, we may not have enough time to write all code to implement our own queue and stack data structures during interviews. Let us continue exploring a more concise solution.\n\nSolution 2: Saving the maximal value into the front of a queue\n\nInstead of pushing every numbers inside a sliding window into a queue, we try to push the candidates of maximum only into a queue. Let us take the array {2, 3, 4, 2, 6, 2, 5, 1} as an example to analyze the solution step by step.\n\nThe first number in the array is 2, we push it into a queue. The second number is 3, which is greater than the previous number 2. The number 2 should be popped off, because it is less than 3 and it has no chance to be the maximal value. There is only one number left in the queue when we pop 2 at the back and push 3 at the back. The operations are similar when we push the next number 4. There is only a number 4 remaining in the queue. Now the sliding window already has three elements, we can get the maximum value at the front of the queue.\n\nWe continue to push the fourth number.\u00a0 It is pushed at the back of queue, because it is less than the previous number 4 and it might be a maximal number in the future when the previous numbers are popped off. There are two numbers, 4 and 2, in the queue, and 4 is the maximum.\n\nThe next number to be pushed is 6. Since it is greater than the existing numbers, 4 and 2, these two numbers can be popped off because they have no chance to be the maximum. Now there is only one number in the queue, which is 6, after the current number is pushed. Of course, the maximum is 6.\nThe next number is 2, which is pushed into the back of the queue because it is less than the previous number 6. There are two numbers in the queue, 6 and 2, and the number 6 at the front of the queue is the maximal value.\n\nIt is time to push the number 5. Because it is greater than the number 2 at the back of the queue, 2 is popped off and then 5 is pushed. There are two numbers in the queue, 6 and 5, and the number 6 at the front of the queue is the maximal value.\n\nNow let us push the last number 1. It can be pushed into the queue. It is noticeable that the number at the front is beyond the scope the current sliding window, and it should be popped off.\u00a0 How do we know whether the number at the front of the queue is out of sliding window? Rather than storing numbers in the queue directly, we can store indices instead. If the distance between the index at the front of queue and the index of the current number to be pushed is greater than or equal to the window size, the number corresponding to be the index at the font of queue is out of sliding window.\n\nThe analysis process above is summarized in Table 2.\n\nStep Number to Be Pushed Numbers in Sliding Window Indices in queue Maximum in Window 1 2 2 0(2) 2 3 2, 3 1(3) 3 4 2, 3, 4 2(4) 4 4 2 3, 4, 2 2(4), 3(2) 4 5 6 4, 2, 6 4(6) 6 6 2 2, 6, 2 4(6), 5(2) 6 7 5 6, 2, 5 4(6), 6(5) 6 8 1 2, 5, 1 6(5), 7(1) 5\nStep\nNumber to Be Pushed\nNumbers in Sliding Window\nIndices in queue\nMaximum in Window\n1\n2\n2\n0(2)\n\n2\n3\n2, 3\n1(3)\n\n3\n4\n2, 3, 4\n2(4)\n4\n4\n2\n3, 4, 2\n2(4), 3(2)\n4\n5\n6\n4, 2, 6\n4(6)\n6\n6\n2\n2, 6, 2\n4(6), 5(2)\n6\n7\n5\n6, 2, 5\n4(6), 6(5)\n6\n8\n1\n2, 5, 1\n6(5), 7(1)\n5\nTable 2: The process to get the maximal number in all sliding windows with window size 3 in the array {2, 3, 4, 2, 6, 2, 5, 1}. In the column \u201cIndices in queue\u201d, the number inside a pair of parentheses is the number indexed by the number before it in the array.\n\nWe can implement a solution based on the analysis above. Some sample code in C++ is shown below, which utilizes the type deque of STL.\n\nvector< int > maxInWindows( const vector< int >& numbers, int windowSize)\n{\nvector< int > maxInSlidingWindows;\nif (numbers.size() >= windowSize && windowSize > 1)\n{\ndeque< int > indices;\n\nfor ( int i = 0; i < windowSize; ++i)\n{\nwhile (!indices.empty() && numbers[i] >= numbers[indices.back()])\nindices.pop_back();\n\nindices.push_back(i);\n}\n\nfor ( int i = windowSize; i < numbers.size(); ++i)\n{\nmaxInSlidingWindows.push_back(numbers[indices.front()]);\n\nwhile (!indices.empty() && numbers[i] >= numbers[indices.back()])\nindices.pop_back();\nif (!indices.empty() && indices.front() <= i - windowSize)\nindices.pop_front();\n\nindices.push_back(i);\n}\nmaxInSlidingWindows.push_back(numbers[indices.front()]);\n}\n\nreturn maxInSlidingWindows;\n}\n\nExtension: Another solution to get the maximum of a queue\n\nAs we mentioned before, a sliding window can be viewed as a queue. Therefore, we can implement a new solution to get the maximal value of a queue based on the second solution to get the maximums of sliding windows.\n\nThe following is the sample code:\n\ntemplate < typename T> class QueueWithMax\n{\npublic :\nQueueWithMax(): currentIndex(0)\n{\n}\n\nvoid push_back(T number)\n{\nwhile (!maximums.empty() && number >= maximums.back().number)\nmaximums.pop_back();\n\nInternalData internalData = {number, currentIndex};\ndata.push_back(internalData);\nmaximums.push_back(internalData);\n\n++currentIndex;\n}\n\nvoid pop_front()\n{\nif (maximums.empty())\nthrow new exception( \"queue is empty\" );\n\nif (maximums.front().index == data.front().index)\nmaximums.pop_front();\n\ndata.pop_front();\n}\n\nT max() const\n{\nif (maximums.empty())\nthrow new exception( \"queue is empty\" );\n\nreturn maximums.front().number;\n}\n\nprivate :\nstruct InternalData\n{\nT number;\nint index;\n};\n\ndeque<InternalData> data;\ndeque<InternalData> maximums;\nint currentIndex;\n};\n\nSince this solution is similar to the second solution to get maximums of sliding windows, we won\u2019t analyze the process step by step, and leave it as an exercise if you are interested.", "question": "\nQuestion: Given an array of numbers and a sliding window size, how to get the maximal numbers in all sliding windows?\n\nFor example, if the input array is {2, 3, 4, 2, 6, 2, 5, 1} and the size of sliding windows is 3, the output of maximums are {4, 4, 6, 6, 6, 5}, as illustrated in Table1.\n\nSliding Windows in an Array Maximums in Sliding Windows [2, 3, 4] , 2, 6, 2, 5, 1 4 2, [3, 4, 2] , 6, 2, 5, 1 4 2, 3, [4, 2, 6] , 2, 5, 1 6 2, 3, 4, [2, 6, 2] , 5, 1 6 2, 3, 4, 2, [6, 2, 5] , 1 6 2, 3, 4, 2, 6, [2, 5, 1] 5\nSliding Windows in an Array\nMaximums in Sliding Windows\n[2, 3, 4] , 2, 6, 2, 5, 1\n4\n2, [3, 4, 2] , 6, 2, 5, 1\n4\n2, 3, [4, 2, 6] , 2, 5, 1\n6\n2, 3, 4, [2, 6, 2] , 5, 1\n6\n2, 3, 4, 2, [6, 2, 5] , 1\n6\n2, 3, 4, 2, 6, [2, 5, 1]\n5\nTable 1: Maximums of all sliding windows with size 3 in an array {2, 3, 4, 2, 6, 2, 5, 1}. A pair of brackets indicates a sliding window.\n"},
{"answer": "\nAnalysis: It is not difficult to get a solution with brute force: Scan numbers in every sliding window to get its maximal value. The overall time complexity is O( nk ) if the length of array is n and the size of sliding windows is k .\n\nThe na\u00efve solution is not the best solution. Let us explore better solutions.\n\nSolution 1: Maximal value in a queue\n\nA window can be viewed as a queue. When it slides, a number is pushed into its back, and its front is popped off. Therefore, the problem is solved if we can get the maximal value of a queue.\n\nThere are no straightforward approaches to getting the maximal value of a queue. However, there are solutions to get the maximal value of a stack, which is similar to the solution introduced in the blog \u201c Stack with Function min() \u201d. Additionally, a queue can also be implemented with two stacks (details are discussed in another blog \u201c Queue implemented with Two Stacks \u201d).\n\nIf a new type of queue is implemented with two stacks, in which a function max() is defined to get the maximal value, the maximal value in a queue is the greater number of the two maximal numbers in two stacks.\n\nThis solution is workable. However, we may not have enough time to write all code to implement our own queue and stack data structures during interviews. Let us continue exploring a more concise solution.\n\nSolution 2: Saving the maximal value into the front of a queue\n\nInstead of pushing every numbers inside a sliding window into a queue, we try to push the candidates of maximum only into a queue. Let us take the array {2, 3, 4, 2, 6, 2, 5, 1} as an example to analyze the solution step by step.\n\nThe first number in the array is 2, we push it into a queue. The second number is 3, which is greater than the previous number 2. The number 2 should be popped off, because it is less than 3 and it has no chance to be the maximal value. There is only one number left in the queue when we pop 2 at the back and push 3 at the back. The operations are similar when we push the next number 4. There is only a number 4 remaining in the queue. Now the sliding window already has three elements, we can get the maximum value at the front of the queue.\n\nWe continue to push the fourth number.\u00a0 It is pushed at the back of queue, because it is less than the previous number 4 and it might be a maximal number in the future when the previous numbers are popped off. There are two numbers, 4 and 2, in the queue, and 4 is the maximum.\n\nThe next number to be pushed is 6. Since it is greater than the existing numbers, 4 and 2, these two numbers can be popped off because they have no chance to be the maximum. Now there is only one number in the queue, which is 6, after the current number is pushed. Of course, the maximum is 6.\nThe next number is 2, which is pushed into the back of the queue because it is less than the previous number 6. There are two numbers in the queue, 6 and 2, and the number 6 at the front of the queue is the maximal value.\n\nIt is time to push the number 5. Because it is greater than the number 2 at the back of the queue, 2 is popped off and then 5 is pushed. There are two numbers in the queue, 6 and 5, and the number 6 at the front of the queue is the maximal value.\n\nNow let us push the last number 1. It can be pushed into the queue. It is noticeable that the number at the front is beyond the scope the current sliding window, and it should be popped off.\u00a0 How do we know whether the number at the front of the queue is out of sliding window? Rather than storing numbers in the queue directly, we can store indices instead. If the distance between the index at the front of queue and the index of the current number to be pushed is greater than or equal to the window size, the number corresponding to be the index at the font of queue is out of sliding window.\n\nThe analysis process above is summarized in Table 2.\n\nStep Number to Be Pushed Numbers in Sliding Window Indices in queue Maximum in Window 1 2 2 0(2) 2 3 2, 3 1(3) 3 4 2, 3, 4 2(4) 4 4 2 3, 4, 2 2(4), 3(2) 4 5 6 4, 2, 6 4(6) 6 6 2 2, 6, 2 4(6), 5(2) 6 7 5 6, 2, 5 4(6), 6(5) 6 8 1 2, 5, 1 6(5), 7(1) 5\nStep\nNumber to Be Pushed\nNumbers in Sliding Window\nIndices in queue\nMaximum in Window\n1\n2\n2\n0(2)\n\n2\n3\n2, 3\n1(3)\n\n3\n4\n2, 3, 4\n2(4)\n4\n4\n2\n3, 4, 2\n2(4), 3(2)\n4\n5\n6\n4, 2, 6\n4(6)\n6\n6\n2\n2, 6, 2\n4(6), 5(2)\n6\n7\n5\n6, 2, 5\n4(6), 6(5)\n6\n8\n1\n2, 5, 1\n6(5), 7(1)\n5\nTable 2: The process to get the maximal number in all sliding windows with window size 3 in the array {2, 3, 4, 2, 6, 2, 5, 1}. In the column \u201cIndices in queue\u201d, the number inside a pair of parentheses is the number indexed by the number before it in the array.\n\nWe can implement a solution based on the analysis above. Some sample code in C++ is shown below, which utilizes the type deque of STL.\n\nvector< int > maxInWindows( const vector< int >& numbers, int windowSize)\n{\nvector< int > maxInSlidingWindows;\nif (numbers.size() >= windowSize && windowSize > 1)\n{\ndeque< int > indices;\n\nfor ( int i = 0; i < windowSize; ++i)\n{\nwhile (!indices.empty() && numbers[i] >= numbers[indices.back()])\nindices.pop_back();\n\nindices.push_back(i);\n}\n\nfor ( int i = windowSize; i < numbers.size(); ++i)\n{\nmaxInSlidingWindows.push_back(numbers[indices.front()]);\n\nwhile (!indices.empty() && numbers[i] >= numbers[indices.back()])\nindices.pop_back();\nif (!indices.empty() && indices.front() <= i - windowSize)\nindices.pop_front();\n\nindices.push_back(i);\n}\nmaxInSlidingWindows.push_back(numbers[indices.front()]);\n}\n\nreturn maxInSlidingWindows;\n}\n\nExtension: Another solution to get the maximum of a queue\n\nAs we mentioned before, a sliding window can be viewed as a queue. Therefore, we can implement a new solution to get the maximal value of a queue based on the second solution to get the maximums of sliding windows.\n\nThe following is the sample code:\n\ntemplate < typename T> class QueueWithMax\n{\npublic :\nQueueWithMax(): currentIndex(0)\n{\n}\n\nvoid push_back(T number)\n{\nwhile (!maximums.empty() && number >= maximums.back().number)\nmaximums.pop_back();\n\nInternalData internalData = {number, currentIndex};\ndata.push_back(internalData);\nmaximums.push_back(internalData);\n\n++currentIndex;\n}\n\nvoid pop_front()\n{\nif (maximums.empty())\nthrow new exception( \"queue is empty\" );\n\nif (maximums.front().index == data.front().index)\nmaximums.pop_front();\n\ndata.pop_front();\n}\n\nT max() const\n{\nif (maximums.empty())\nthrow new exception( \"queue is empty\" );\n\nreturn maximums.front().number;\n}\n\nprivate :\nstruct InternalData\n{\nT number;\nint index;\n};\n\ndeque<InternalData> data;\ndeque<InternalData> maximums;\nint currentIndex;\n};\n\nSince this solution is similar to the second solution to get maximums of sliding windows, we won\u2019t analyze the process step by step, and leave it as an exercise if you are interested.", "question": "\nQuestion: Given an array of numbers and a sliding window size, how to get the maximal numbers in all sliding windows?\n\nFor example, if the input array is {2, 3, 4, 2, 6, 2, 5, 1} and the size of sliding windows is 3, the output of maximums are {4, 4, 6, 6, 6, 5}, as illustrated in Table1.\n\nSliding Windows in an Array Maximums in Sliding Windows [2, 3, 4] , 2, 6, 2, 5, 1 4 2, [3, 4, 2] , 6, 2, 5, 1 4 2, 3, [4, 2, 6] , 2, 5, 1 6 2, 3, 4, [2, 6, 2] , 5, 1 6 2, 3, 4, 2, [6, 2, 5] , 1 6 2, 3, 4, 2, 6, [2, 5, 1] 5\nSliding Windows in an Array\nMaximums in Sliding Windows\n[2, 3, 4] , 2, 6, 2, 5, 1\n4\n2, [3, 4, 2] , 6, 2, 5, 1\n4\n2, 3, [4, 2, 6] , 2, 5, 1\n6\n2, 3, 4, [2, 6, 2] , 5, 1\n6\n2, 3, 4, 2, [6, 2, 5] , 1\n6\n2, 3, 4, 2, 6, [2, 5, 1]\n5\nTable 1: Maximums of all sliding windows with size 3 in an array {2, 3, 4, 2, 6, 2, 5, 1}. A pair of brackets indicates a sliding window.\n"},
{"answer": "\nAnalysis: Our intuition for this problem might be that we sort all of numbers in the stack when we push a new one, and keep the minimum number on the top of stack. In this way we can get the minimum number in O(1) time. However, we cannot assure that the last number pushed in to container will be the first one to be popped out, so it is no longer a stack.\n\nWe may add a new member variable in a stack to keep the minimum number. When we push a new number which is less than the minimum number, we will update it. It sounds good. However, how to get the next minimum number when the current minimum one is popped? Fortunately, we have two solutions for this problem.\n\nSolution 1: With Auxiliary Stack\n\nIt is not enough to have only a member variable to keep the minimum number. When the minimum one is popped, we need to get the next minimum one. Therefore, we need to store the next minimum number before push the current minimum one.\n\nHow about to store each minimum number (the less value of current minimum number and the number to be pushed) into an auxiliary stack? We may analyze the process to push and pop numbers via some examples (Table 1).\n\nStep Operation Data Stack Auxiliary Stack Minimum 1 Push 3 3 3 3 2 Push 4 3, 4 3, 3 3 3 Push 2 3, 4, 2 3, 3, 2 2 4 Push 1 3, 4, 2, 1 3, 3, 2, 1 1 5 Pop 3, 4, 2 3, 3, 2 2 6 Pop 3, 4 3, 3 3 7 Push 0 3, 4, 0 3, 3, 0 0\nStep\nOperation\nData Stack\nAuxiliary Stack\nMinimum\n1\nPush 3\n3\n3\n3\n2\nPush 4\n3, 4\n3, 3\n3\n3\nPush 2\n3, 4, 2\n3, 3, 2\n2\n4\nPush 1\n3, 4, 2, 1\n3, 3, 2, 1\n1\n5\nPop\n3, 4, 2\n3, 3, 2\n2\n6\nPop\n3, 4\n3, 3\n3\n7\nPush 0\n3, 4, 0\n3, 3, 0\n0\nTable 1: The status of data stack, auxiliary stack, minimum value when we push 3, 4, 2, 1, pop twice, and then push 0\n\nAt first we push 3 into both data stack and auxiliary stack. Secondly we push 4 into the data stack. We push 3 again into the auxiliary stack because 4 is greater than 3. Thirdly, we continue pushing 2 into the data stack. We update the minimum number as 2 and push it into the auxiliary stack since 2 is less the previous minimum number 3. It is same in the fourth step when we push 1. We also need to update the minimum number and push 1 into the auxiliary stack. We can notice that the top of auxiliary stack is always the minimum number if we push the minimum number into auxiliary stack in each step.\n\nWhenever we pop a number from data stack, we also pop a number from auxiliary stack. If the minimum number is popped, the next minimum number should be also on the top of auxiliary stack. In the fifth step we pop 1 from the data stack, and we also pop the number on the top of auxiliary (which is 1). We can see that the next minimum number 2 is now on the top of auxiliary stack. If we continue popping from both the data and auxiliary stacks, there are only two numbers 3 and 4 left in the data stack. The minimum number 3 is indeed on the top of the auxiliary stack. Therefore, it demonstrates that our solution is correct.\n\nNow we can develop the required stack. The stack is declared as the following:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nstd::stack<T>\u00a0\u00a0 m_min; // auxiliary stack, to store minimum numbers\n};\n\nThe function push, pop and min and top can be implemented as:\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\n// push the new number into data stack\nm_data.push(value);\n\n// push the new number into auxiliary stack\n// if it is less than the previous minimum number,\n// otherwise push a replication of the minimum number\nif (m_min.size() == 0 || value < m_min.top())\nm_min.push(value);\nelse\nm_min.push(m_min.top());\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nm_data.pop();\nm_min.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nreturn m_min.top();\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nreturn m_data.top();\n}\n\nThe length of auxiliary stack should be n if we push n numbers into data stack. Therefore, we need O( n ) auxiliary memory for this solution.\n\nSolution 2: Without Auxiliary Stack\n\nThe second solution is trickier without an auxiliary stack. We do not always push numbers into data stack directly, but we have some tricky calculation before pushing.\n\nSupposing that we are going to push a number value into a stack with minimum number min . If value is greater than or equal to the min , it is pushed directly into data stack. If it is less than min , we push 2* value - min , and update min as value since a new minimum number is pushed. How about to pop? We pop it directly if the top of data stack (it is denoted as top ) is greater than or equal to min . Otherwise the number top is not the real pushed number. The real pushed number is stored is min . After the current minimum number is popped, we need to restore the previous minimum number, which is 2* min - top .\n\n\nNow let us demonstrate its correctness of this solution. Since value is greater than or equal to min , it is pushed into data stack direct without updating min . Therefore, when we find that the top of data stack is greater than or equal to min , we can pop directly without updating min . However, if we find value is less then min , we push 2* value - min . We should notice that 2* value - min should be less than value . Then we update current min as value . Therefore, the new top of data stack ( top ) is less than the current min . Therefore, when we find that the top of data stack is less then min , the real top (real pushed number value ) is stored in min . After we pop the top of data stack, we have to restore the previous minimum number. Since top = 2* value -previous min and value is current min , pervious min is 2*current min - top .\n\nIt sounds great. We feel confident to write code now with the correctness demonstration. The following is the sample code:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nT\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_min; // minimum number\n};\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\nif (m_data.size() == 0)\n{\nm_data.push(value);\nm_min = value;\n}\nelse if (value >= m_min)\n{\nm_data.push(value);\n}\nelse\n{\nm_data.push(2 * value - m_min);\nm_min = value;\n}\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0);\n\nif (m_data.top() < m_min)\nm_min = 2 * m_min - m_data.top();\n\nm_data.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0);\n\nreturn m_min;\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nT top = m_data.top();\nif (top < m_min)\ntop = m_min;\n\nreturn top;\n}\n", "question": ""},
{"answer": "\nAnalysis: Our intuition for this problem might be that we sort all of numbers in the stack when we push a new one, and keep the minimum number on the top of stack. In this way we can get the minimum number in O(1) time. However, we cannot assure that the last number pushed in to container will be the first one to be popped out, so it is no longer a stack.\n\nWe may add a new member variable in a stack to keep the minimum number. When we push a new number which is less than the minimum number, we will update it. It sounds good. However, how to get the next minimum number when the current minimum one is popped? Fortunately, we have two solutions for this problem.\n\nSolution 1: With Auxiliary Stack\n\nIt is not enough to have only a member variable to keep the minimum number. When the minimum one is popped, we need to get the next minimum one. Therefore, we need to store the next minimum number before push the current minimum one.\n\nHow about to store each minimum number (the less value of current minimum number and the number to be pushed) into an auxiliary stack? We may analyze the process to push and pop numbers via some examples (Table 1).\n\nStep Operation Data Stack Auxiliary Stack Minimum 1 Push 3 3 3 3 2 Push 4 3, 4 3, 3 3 3 Push 2 3, 4, 2 3, 3, 2 2 4 Push 1 3, 4, 2, 1 3, 3, 2, 1 1 5 Pop 3, 4, 2 3, 3, 2 2 6 Pop 3, 4 3, 3 3 7 Push 0 3, 4, 0 3, 3, 0 0\nStep\nOperation\nData Stack\nAuxiliary Stack\nMinimum\n1\nPush 3\n3\n3\n3\n2\nPush 4\n3, 4\n3, 3\n3\n3\nPush 2\n3, 4, 2\n3, 3, 2\n2\n4\nPush 1\n3, 4, 2, 1\n3, 3, 2, 1\n1\n5\nPop\n3, 4, 2\n3, 3, 2\n2\n6\nPop\n3, 4\n3, 3\n3\n7\nPush 0\n3, 4, 0\n3, 3, 0\n0\nTable 1: The status of data stack, auxiliary stack, minimum value when we push 3, 4, 2, 1, pop twice, and then push 0\n\nAt first we push 3 into both data stack and auxiliary stack. Secondly we push 4 into the data stack. We push 3 again into the auxiliary stack because 4 is greater than 3. Thirdly, we continue pushing 2 into the data stack. We update the minimum number as 2 and push it into the auxiliary stack since 2 is less the previous minimum number 3. It is same in the fourth step when we push 1. We also need to update the minimum number and push 1 into the auxiliary stack. We can notice that the top of auxiliary stack is always the minimum number if we push the minimum number into auxiliary stack in each step.\n\nWhenever we pop a number from data stack, we also pop a number from auxiliary stack. If the minimum number is popped, the next minimum number should be also on the top of auxiliary stack. In the fifth step we pop 1 from the data stack, and we also pop the number on the top of auxiliary (which is 1). We can see that the next minimum number 2 is now on the top of auxiliary stack. If we continue popping from both the data and auxiliary stacks, there are only two numbers 3 and 4 left in the data stack. The minimum number 3 is indeed on the top of the auxiliary stack. Therefore, it demonstrates that our solution is correct.\n\nNow we can develop the required stack. The stack is declared as the following:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nstd::stack<T>\u00a0\u00a0 m_min; // auxiliary stack, to store minimum numbers\n};\n\nThe function push, pop and min and top can be implemented as:\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\n// push the new number into data stack\nm_data.push(value);\n\n// push the new number into auxiliary stack\n// if it is less than the previous minimum number,\n// otherwise push a replication of the minimum number\nif (m_min.size() == 0 || value < m_min.top())\nm_min.push(value);\nelse\nm_min.push(m_min.top());\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nm_data.pop();\nm_min.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nreturn m_min.top();\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nreturn m_data.top();\n}\n\nThe length of auxiliary stack should be n if we push n numbers into data stack. Therefore, we need O( n ) auxiliary memory for this solution.\n\nSolution 2: Without Auxiliary Stack\n\nThe second solution is trickier without an auxiliary stack. We do not always push numbers into data stack directly, but we have some tricky calculation before pushing.\n\nSupposing that we are going to push a number value into a stack with minimum number min . If value is greater than or equal to the min , it is pushed directly into data stack. If it is less than min , we push 2* value - min , and update min as value since a new minimum number is pushed. How about to pop? We pop it directly if the top of data stack (it is denoted as top ) is greater than or equal to min . Otherwise the number top is not the real pushed number. The real pushed number is stored is min . After the current minimum number is popped, we need to restore the previous minimum number, which is 2* min - top .\n\n\nNow let us demonstrate its correctness of this solution. Since value is greater than or equal to min , it is pushed into data stack direct without updating min . Therefore, when we find that the top of data stack is greater than or equal to min , we can pop directly without updating min . However, if we find value is less then min , we push 2* value - min . We should notice that 2* value - min should be less than value . Then we update current min as value . Therefore, the new top of data stack ( top ) is less than the current min . Therefore, when we find that the top of data stack is less then min , the real top (real pushed number value ) is stored in min . After we pop the top of data stack, we have to restore the previous minimum number. Since top = 2* value -previous min and value is current min , pervious min is 2*current min - top .\n\nIt sounds great. We feel confident to write code now with the correctness demonstration. The following is the sample code:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nT\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_min; // minimum number\n};\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\nif (m_data.size() == 0)\n{\nm_data.push(value);\nm_min = value;\n}\nelse if (value >= m_min)\n{\nm_data.push(value);\n}\nelse\n{\nm_data.push(2 * value - m_min);\nm_min = value;\n}\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0);\n\nif (m_data.top() < m_min)\nm_min = 2 * m_min - m_data.top();\n\nm_data.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0);\n\nreturn m_min;\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nT top = m_data.top();\nif (top < m_min)\ntop = m_min;\n\nreturn top;\n}\n", "question": ""},
{"answer": "\nAnalysis: Our intuition for this problem might be that we sort all of numbers in the stack when we push a new one, and keep the minimum number on the top of stack. In this way we can get the minimum number in O(1) time. However, we cannot assure that the last number pushed in to container will be the first one to be popped out, so it is no longer a stack.\n\nWe may add a new member variable in a stack to keep the minimum number. When we push a new number which is less than the minimum number, we will update it. It sounds good. However, how to get the next minimum number when the current minimum one is popped? Fortunately, we have two solutions for this problem.\n\nSolution 1: With Auxiliary Stack\n\nIt is not enough to have only a member variable to keep the minimum number. When the minimum one is popped, we need to get the next minimum one. Therefore, we need to store the next minimum number before push the current minimum one.\n\nHow about to store each minimum number (the less value of current minimum number and the number to be pushed) into an auxiliary stack? We may analyze the process to push and pop numbers via some examples (Table 1).\n\nStep Operation Data Stack Auxiliary Stack Minimum 1 Push 3 3 3 3 2 Push 4 3, 4 3, 3 3 3 Push 2 3, 4, 2 3, 3, 2 2 4 Push 1 3, 4, 2, 1 3, 3, 2, 1 1 5 Pop 3, 4, 2 3, 3, 2 2 6 Pop 3, 4 3, 3 3 7 Push 0 3, 4, 0 3, 3, 0 0\nStep\nOperation\nData Stack\nAuxiliary Stack\nMinimum\n1\nPush 3\n3\n3\n3\n2\nPush 4\n3, 4\n3, 3\n3\n3\nPush 2\n3, 4, 2\n3, 3, 2\n2\n4\nPush 1\n3, 4, 2, 1\n3, 3, 2, 1\n1\n5\nPop\n3, 4, 2\n3, 3, 2\n2\n6\nPop\n3, 4\n3, 3\n3\n7\nPush 0\n3, 4, 0\n3, 3, 0\n0\nTable 1: The status of data stack, auxiliary stack, minimum value when we push 3, 4, 2, 1, pop twice, and then push 0\n\nAt first we push 3 into both data stack and auxiliary stack. Secondly we push 4 into the data stack. We push 3 again into the auxiliary stack because 4 is greater than 3. Thirdly, we continue pushing 2 into the data stack. We update the minimum number as 2 and push it into the auxiliary stack since 2 is less the previous minimum number 3. It is same in the fourth step when we push 1. We also need to update the minimum number and push 1 into the auxiliary stack. We can notice that the top of auxiliary stack is always the minimum number if we push the minimum number into auxiliary stack in each step.\n\nWhenever we pop a number from data stack, we also pop a number from auxiliary stack. If the minimum number is popped, the next minimum number should be also on the top of auxiliary stack. In the fifth step we pop 1 from the data stack, and we also pop the number on the top of auxiliary (which is 1). We can see that the next minimum number 2 is now on the top of auxiliary stack. If we continue popping from both the data and auxiliary stacks, there are only two numbers 3 and 4 left in the data stack. The minimum number 3 is indeed on the top of the auxiliary stack. Therefore, it demonstrates that our solution is correct.\n\nNow we can develop the required stack. The stack is declared as the following:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nstd::stack<T>\u00a0\u00a0 m_min; // auxiliary stack, to store minimum numbers\n};\n\nThe function push, pop and min and top can be implemented as:\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\n// push the new number into data stack\nm_data.push(value);\n\n// push the new number into auxiliary stack\n// if it is less than the previous minimum number,\n// otherwise push a replication of the minimum number\nif (m_min.size() == 0 || value < m_min.top())\nm_min.push(value);\nelse\nm_min.push(m_min.top());\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nm_data.pop();\nm_min.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nreturn m_min.top();\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nreturn m_data.top();\n}\n\nThe length of auxiliary stack should be n if we push n numbers into data stack. Therefore, we need O( n ) auxiliary memory for this solution.\n\nSolution 2: Without Auxiliary Stack\n\nThe second solution is trickier without an auxiliary stack. We do not always push numbers into data stack directly, but we have some tricky calculation before pushing.\n\nSupposing that we are going to push a number value into a stack with minimum number min . If value is greater than or equal to the min , it is pushed directly into data stack. If it is less than min , we push 2* value - min , and update min as value since a new minimum number is pushed. How about to pop? We pop it directly if the top of data stack (it is denoted as top ) is greater than or equal to min . Otherwise the number top is not the real pushed number. The real pushed number is stored is min . After the current minimum number is popped, we need to restore the previous minimum number, which is 2* min - top .\n\n\nNow let us demonstrate its correctness of this solution. Since value is greater than or equal to min , it is pushed into data stack direct without updating min . Therefore, when we find that the top of data stack is greater than or equal to min , we can pop directly without updating min . However, if we find value is less then min , we push 2* value - min . We should notice that 2* value - min should be less than value . Then we update current min as value . Therefore, the new top of data stack ( top ) is less than the current min . Therefore, when we find that the top of data stack is less then min , the real top (real pushed number value ) is stored in min . After we pop the top of data stack, we have to restore the previous minimum number. Since top = 2* value -previous min and value is current min , pervious min is 2*current min - top .\n\nIt sounds great. We feel confident to write code now with the correctness demonstration. The following is the sample code:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nT\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_min; // minimum number\n};\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\nif (m_data.size() == 0)\n{\nm_data.push(value);\nm_min = value;\n}\nelse if (value >= m_min)\n{\nm_data.push(value);\n}\nelse\n{\nm_data.push(2 * value - m_min);\nm_min = value;\n}\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0);\n\nif (m_data.top() < m_min)\nm_min = 2 * m_min - m_data.top();\n\nm_data.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0);\n\nreturn m_min;\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nT top = m_data.top();\nif (top < m_min)\ntop = m_min;\n\nreturn top;\n}\n", "question": ""},
{"answer": "\nAnalysis: We try to get the maximum length of all increasing subsequences ending with each element in the array.\n\nFor instance, when we analyze the maximum length of all increasing subsequences ending with number 5, we compare it with each number before it. The first number 7 is greater than 5. If the subsequence comes from 7, 7 cannot be included into the subsequence. Therefore, its length is 1. The following three numbers 2, 3 and 1 in the input array before 5 are less than 5. If the previous number of 5 in the increasing subsequence is 2, the maximum incremental length is 2. If the previous number of 5 in the increasing subsequence is 3, the maximum incremental length is 3 (with number 2, 3, and 5) since the maximum length of all subsequences ending with number 3 is 2 (with number 2 and 3). Similarly, its maximum length is 2 if the previous number is number 1. The whole process can be summarized in Table 1.\n\n7 2 3 1 5 8 9 6 7 1 NA NA NA NA NA NA NA 2 1 1 NA NA NA NA NA NA 3 1 2 1 NA NA NA NA NA 1 1 1 1 1 NA NA NA NA 5 1 2 3 2 1 NA NA NA 8 2 2 3 2 4 1 NA NA 9 2 2 3 2 4 5 1 NA 6 1 2 3 2 4 1 1 1\n\n7\n2\n3\n1\n5\n8\n9\n6\n7\n1\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n2\n1\n1\nNA\nNA\nNA\nNA\nNA\nNA\n3\n1\n2\n1\nNA\nNA\nNA\nNA\nNA\n1\n1\n1\n1\n1\nNA\nNA\nNA\nNA\n5\n1\n2\n3\n2\n1\nNA\nNA\nNA\n8\n2\n2\n3\n2\n4\n1\nNA\nNA\n9\n2\n2\n3\n2\n4\n5\n1\nNA\n6\n1\n2\n3\n2\n4\n1\n1\n1\nTable 1: Process to get the maximum length of increasing subsequences in array {7, 2, 3, 1, 5, 8, 9, 6}. Numbers in each row indicate length of subsequences ending with row title with previous number in the column title. Highlighted numbers with yellow background are the maximum lengths. \u00a0The highlighted number 5 with yellow background and red font is the maximum length of all incremental subsequences in the input array.\n\nWe are ready to write code with the detailed analysis above. The following is sample code:\n\nint LengthOfIncreasing( int * data, int length)\n{\nif (data == NULL || length < 0)\nreturn 0;\n\nint * longest = new int [length];\nlongest[0] = 1;\n\nint max = 0;\nfor ( int i = 1; i < length; ++ i)\n{\nmax = 0;\nfor ( int j = 0; j < i; ++ j)\n{\nif (data[j] < data[i] && longest[j] > max)\nmax = longest[j];\n}\n\nlongest[i] = max + 1;\n}\n\nmax = 0;\nfor ( int i = 0; i < length; ++ i)\nif (longest[i] > max)\nmax = longest[i];\n\nreturn max;\n}\n\nEven though a 2-D matrix is needed to analyze the process, only a 1-D array is necessary in our code to store the maximum length of subsequences ending with each number in the input array.\n\nIf we are familiar with dynamic programming, we can get a direct solution quickly in a formal way. We can define a function f(i) indicating the maximum length of all subsequences ending with the i th number in the input array (denoted as A[i]). We define another function g(i, j) which stands for the maximum length of incremental subsequences ending with A[i] coming from A[j]. The required output is max(f(i)) where 0<=i<n and n is the length of array. We can get f(i) with the following equation:\n\n\nActually, same code will be implemented based on this equation. The function f(i) is longest[i] in the code above. Therefore, it is identical to the previous solution.", "question": "\nProblem: Given an unsorted array, find the max length of subsequence in which the numbers are in incremental order.\n\nFor example: If the input array is {7, 2, 3, 1, 5, 8, 9, 6}, a subsequence with the most numbers in incremental order is {2, 3, 5, 8, 9} and the expected output is 5.\n"},
{"answer": "\nAnalysis: We try to get the maximum length of all increasing subsequences ending with each element in the array.\n\nFor instance, when we analyze the maximum length of all increasing subsequences ending with number 5, we compare it with each number before it. The first number 7 is greater than 5. If the subsequence comes from 7, 7 cannot be included into the subsequence. Therefore, its length is 1. The following three numbers 2, 3 and 1 in the input array before 5 are less than 5. If the previous number of 5 in the increasing subsequence is 2, the maximum incremental length is 2. If the previous number of 5 in the increasing subsequence is 3, the maximum incremental length is 3 (with number 2, 3, and 5) since the maximum length of all subsequences ending with number 3 is 2 (with number 2 and 3). Similarly, its maximum length is 2 if the previous number is number 1. The whole process can be summarized in Table 1.\n\n7 2 3 1 5 8 9 6 7 1 NA NA NA NA NA NA NA 2 1 1 NA NA NA NA NA NA 3 1 2 1 NA NA NA NA NA 1 1 1 1 1 NA NA NA NA 5 1 2 3 2 1 NA NA NA 8 2 2 3 2 4 1 NA NA 9 2 2 3 2 4 5 1 NA 6 1 2 3 2 4 1 1 1\n\n7\n2\n3\n1\n5\n8\n9\n6\n7\n1\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n2\n1\n1\nNA\nNA\nNA\nNA\nNA\nNA\n3\n1\n2\n1\nNA\nNA\nNA\nNA\nNA\n1\n1\n1\n1\n1\nNA\nNA\nNA\nNA\n5\n1\n2\n3\n2\n1\nNA\nNA\nNA\n8\n2\n2\n3\n2\n4\n1\nNA\nNA\n9\n2\n2\n3\n2\n4\n5\n1\nNA\n6\n1\n2\n3\n2\n4\n1\n1\n1\nTable 1: Process to get the maximum length of increasing subsequences in array {7, 2, 3, 1, 5, 8, 9, 6}. Numbers in each row indicate length of subsequences ending with row title with previous number in the column title. Highlighted numbers with yellow background are the maximum lengths. \u00a0The highlighted number 5 with yellow background and red font is the maximum length of all incremental subsequences in the input array.\n\nWe are ready to write code with the detailed analysis above. The following is sample code:\n\nint LengthOfIncreasing( int * data, int length)\n{\nif (data == NULL || length < 0)\nreturn 0;\n\nint * longest = new int [length];\nlongest[0] = 1;\n\nint max = 0;\nfor ( int i = 1; i < length; ++ i)\n{\nmax = 0;\nfor ( int j = 0; j < i; ++ j)\n{\nif (data[j] < data[i] && longest[j] > max)\nmax = longest[j];\n}\n\nlongest[i] = max + 1;\n}\n\nmax = 0;\nfor ( int i = 0; i < length; ++ i)\nif (longest[i] > max)\nmax = longest[i];\n\nreturn max;\n}\n\nEven though a 2-D matrix is needed to analyze the process, only a 1-D array is necessary in our code to store the maximum length of subsequences ending with each number in the input array.\n\nIf we are familiar with dynamic programming, we can get a direct solution quickly in a formal way. We can define a function f(i) indicating the maximum length of all subsequences ending with the i th number in the input array (denoted as A[i]). We define another function g(i, j) which stands for the maximum length of incremental subsequences ending with A[i] coming from A[j]. The required output is max(f(i)) where 0<=i<n and n is the length of array. We can get f(i) with the following equation:\n\n\nActually, same code will be implemented based on this equation. The function f(i) is longest[i] in the code above. Therefore, it is identical to the previous solution.", "question": "\nProblem: Given an unsorted array, find the max length of subsequence in which the numbers are in incremental order.\n\nFor example: If the input array is {7, 2, 3, 1, 5, 8, 9, 6}, a subsequence with the most numbers in incremental order is {2, 3, 5, 8, 9} and the expected output is 5.\n"},
{"answer": "\nAnalysis: We try to get the maximum length of all increasing subsequences ending with each element in the array.\n\nFor instance, when we analyze the maximum length of all increasing subsequences ending with number 5, we compare it with each number before it. The first number 7 is greater than 5. If the subsequence comes from 7, 7 cannot be included into the subsequence. Therefore, its length is 1. The following three numbers 2, 3 and 1 in the input array before 5 are less than 5. If the previous number of 5 in the increasing subsequence is 2, the maximum incremental length is 2. If the previous number of 5 in the increasing subsequence is 3, the maximum incremental length is 3 (with number 2, 3, and 5) since the maximum length of all subsequences ending with number 3 is 2 (with number 2 and 3). Similarly, its maximum length is 2 if the previous number is number 1. The whole process can be summarized in Table 1.\n\n7 2 3 1 5 8 9 6 7 1 NA NA NA NA NA NA NA 2 1 1 NA NA NA NA NA NA 3 1 2 1 NA NA NA NA NA 1 1 1 1 1 NA NA NA NA 5 1 2 3 2 1 NA NA NA 8 2 2 3 2 4 1 NA NA 9 2 2 3 2 4 5 1 NA 6 1 2 3 2 4 1 1 1\n\n7\n2\n3\n1\n5\n8\n9\n6\n7\n1\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n2\n1\n1\nNA\nNA\nNA\nNA\nNA\nNA\n3\n1\n2\n1\nNA\nNA\nNA\nNA\nNA\n1\n1\n1\n1\n1\nNA\nNA\nNA\nNA\n5\n1\n2\n3\n2\n1\nNA\nNA\nNA\n8\n2\n2\n3\n2\n4\n1\nNA\nNA\n9\n2\n2\n3\n2\n4\n5\n1\nNA\n6\n1\n2\n3\n2\n4\n1\n1\n1\nTable 1: Process to get the maximum length of increasing subsequences in array {7, 2, 3, 1, 5, 8, 9, 6}. Numbers in each row indicate length of subsequences ending with row title with previous number in the column title. Highlighted numbers with yellow background are the maximum lengths. \u00a0The highlighted number 5 with yellow background and red font is the maximum length of all incremental subsequences in the input array.\n\nWe are ready to write code with the detailed analysis above. The following is sample code:\n\nint LengthOfIncreasing( int * data, int length)\n{\nif (data == NULL || length < 0)\nreturn 0;\n\nint * longest = new int [length];\nlongest[0] = 1;\n\nint max = 0;\nfor ( int i = 1; i < length; ++ i)\n{\nmax = 0;\nfor ( int j = 0; j < i; ++ j)\n{\nif (data[j] < data[i] && longest[j] > max)\nmax = longest[j];\n}\n\nlongest[i] = max + 1;\n}\n\nmax = 0;\nfor ( int i = 0; i < length; ++ i)\nif (longest[i] > max)\nmax = longest[i];\n\nreturn max;\n}\n\nEven though a 2-D matrix is needed to analyze the process, only a 1-D array is necessary in our code to store the maximum length of subsequences ending with each number in the input array.\n\nIf we are familiar with dynamic programming, we can get a direct solution quickly in a formal way. We can define a function f(i) indicating the maximum length of all subsequences ending with the i th number in the input array (denoted as A[i]). We define another function g(i, j) which stands for the maximum length of incremental subsequences ending with A[i] coming from A[j]. The required output is max(f(i)) where 0<=i<n and n is the length of array. We can get f(i) with the following equation:\n\n\nActually, same code will be implemented based on this equation. The function f(i) is longest[i] in the code above. Therefore, it is identical to the previous solution.", "question": "\nProblem: Given an unsorted array, find the max length of subsequence in which the numbers are in incremental order.\n\nFor example: If the input array is {7, 2, 3, 1, 5, 8, 9, 6}, a subsequence with the most numbers in incremental order is {2, 3, 5, 8, 9} and the expected output is 5.\n"},
{"answer": "\nAnalysis: We try to get the maximum length of all increasing subsequences ending with each element in the array.\n\nFor instance, when we analyze the maximum length of all increasing subsequences ending with number 5, we compare it with each number before it. The first number 7 is greater than 5. If the subsequence comes from 7, 7 cannot be included into the subsequence. Therefore, its length is 1. The following three numbers 2, 3 and 1 in the input array before 5 are less than 5. If the previous number of 5 in the increasing subsequence is 2, the maximum incremental length is 2. If the previous number of 5 in the increasing subsequence is 3, the maximum incremental length is 3 (with number 2, 3, and 5) since the maximum length of all subsequences ending with number 3 is 2 (with number 2 and 3). Similarly, its maximum length is 2 if the previous number is number 1. The whole process can be summarized in Table 1.\n\n7 2 3 1 5 8 9 6 7 1 NA NA NA NA NA NA NA 2 1 1 NA NA NA NA NA NA 3 1 2 1 NA NA NA NA NA 1 1 1 1 1 NA NA NA NA 5 1 2 3 2 1 NA NA NA 8 2 2 3 2 4 1 NA NA 9 2 2 3 2 4 5 1 NA 6 1 2 3 2 4 1 1 1\n\n7\n2\n3\n1\n5\n8\n9\n6\n7\n1\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n2\n1\n1\nNA\nNA\nNA\nNA\nNA\nNA\n3\n1\n2\n1\nNA\nNA\nNA\nNA\nNA\n1\n1\n1\n1\n1\nNA\nNA\nNA\nNA\n5\n1\n2\n3\n2\n1\nNA\nNA\nNA\n8\n2\n2\n3\n2\n4\n1\nNA\nNA\n9\n2\n2\n3\n2\n4\n5\n1\nNA\n6\n1\n2\n3\n2\n4\n1\n1\n1\nTable 1: Process to get the maximum length of increasing subsequences in array {7, 2, 3, 1, 5, 8, 9, 6}. Numbers in each row indicate length of subsequences ending with row title with previous number in the column title. Highlighted numbers with yellow background are the maximum lengths. \u00a0The highlighted number 5 with yellow background and red font is the maximum length of all incremental subsequences in the input array.\n\nWe are ready to write code with the detailed analysis above. The following is sample code:\n\nint LengthOfIncreasing( int * data, int length)\n{\nif (data == NULL || length < 0)\nreturn 0;\n\nint * longest = new int [length];\nlongest[0] = 1;\n\nint max = 0;\nfor ( int i = 1; i < length; ++ i)\n{\nmax = 0;\nfor ( int j = 0; j < i; ++ j)\n{\nif (data[j] < data[i] && longest[j] > max)\nmax = longest[j];\n}\n\nlongest[i] = max + 1;\n}\n\nmax = 0;\nfor ( int i = 0; i < length; ++ i)\nif (longest[i] > max)\nmax = longest[i];\n\nreturn max;\n}\n\nEven though a 2-D matrix is needed to analyze the process, only a 1-D array is necessary in our code to store the maximum length of subsequences ending with each number in the input array.\n\nIf we are familiar with dynamic programming, we can get a direct solution quickly in a formal way. We can define a function f(i) indicating the maximum length of all subsequences ending with the i th number in the input array (denoted as A[i]). We define another function g(i, j) which stands for the maximum length of incremental subsequences ending with A[i] coming from A[j]. The required output is max(f(i)) where 0<=i<n and n is the length of array. We can get f(i) with the following equation:\n\n\nActually, same code will be implemented based on this equation. The function f(i) is longest[i] in the code above. Therefore, it is identical to the previous solution.", "question": "\nProblem: Given an unsorted array, find the max length of subsequence in which the numbers are in incremental order.\n\nFor example: If the input array is {7, 2, 3, 1, 5, 8, 9, 6}, a subsequence with the most numbers in incremental order is {2, 3, 5, 8, 9} and the expected output is 5.\n"},
{"answer": "\nAnalysis: We try to get the maximum length of all increasing subsequences ending with each element in the array.\n\nFor instance, when we analyze the maximum length of all increasing subsequences ending with number 5, we compare it with each number before it. The first number 7 is greater than 5. If the subsequence comes from 7, 7 cannot be included into the subsequence. Therefore, its length is 1. The following three numbers 2, 3 and 1 in the input array before 5 are less than 5. If the previous number of 5 in the increasing subsequence is 2, the maximum incremental length is 2. If the previous number of 5 in the increasing subsequence is 3, the maximum incremental length is 3 (with number 2, 3, and 5) since the maximum length of all subsequences ending with number 3 is 2 (with number 2 and 3). Similarly, its maximum length is 2 if the previous number is number 1. The whole process can be summarized in Table 1.\n\n7 2 3 1 5 8 9 6 7 1 NA NA NA NA NA NA NA 2 1 1 NA NA NA NA NA NA 3 1 2 1 NA NA NA NA NA 1 1 1 1 1 NA NA NA NA 5 1 2 3 2 1 NA NA NA 8 2 2 3 2 4 1 NA NA 9 2 2 3 2 4 5 1 NA 6 1 2 3 2 4 1 1 1\n\n7\n2\n3\n1\n5\n8\n9\n6\n7\n1\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n2\n1\n1\nNA\nNA\nNA\nNA\nNA\nNA\n3\n1\n2\n1\nNA\nNA\nNA\nNA\nNA\n1\n1\n1\n1\n1\nNA\nNA\nNA\nNA\n5\n1\n2\n3\n2\n1\nNA\nNA\nNA\n8\n2\n2\n3\n2\n4\n1\nNA\nNA\n9\n2\n2\n3\n2\n4\n5\n1\nNA\n6\n1\n2\n3\n2\n4\n1\n1\n1\nTable 1: Process to get the maximum length of increasing subsequences in array {7, 2, 3, 1, 5, 8, 9, 6}. Numbers in each row indicate length of subsequences ending with row title with previous number in the column title. Highlighted numbers with yellow background are the maximum lengths. \u00a0The highlighted number 5 with yellow background and red font is the maximum length of all incremental subsequences in the input array.\n\nWe are ready to write code with the detailed analysis above. The following is sample code:\n\nint LengthOfIncreasing( int * data, int length)\n{\nif (data == NULL || length < 0)\nreturn 0;\n\nint * longest = new int [length];\nlongest[0] = 1;\n\nint max = 0;\nfor ( int i = 1; i < length; ++ i)\n{\nmax = 0;\nfor ( int j = 0; j < i; ++ j)\n{\nif (data[j] < data[i] && longest[j] > max)\nmax = longest[j];\n}\n\nlongest[i] = max + 1;\n}\n\nmax = 0;\nfor ( int i = 0; i < length; ++ i)\nif (longest[i] > max)\nmax = longest[i];\n\nreturn max;\n}\n\nEven though a 2-D matrix is needed to analyze the process, only a 1-D array is necessary in our code to store the maximum length of subsequences ending with each number in the input array.\n\nIf we are familiar with dynamic programming, we can get a direct solution quickly in a formal way. We can define a function f(i) indicating the maximum length of all subsequences ending with the i th number in the input array (denoted as A[i]). We define another function g(i, j) which stands for the maximum length of incremental subsequences ending with A[i] coming from A[j]. The required output is max(f(i)) where 0<=i<n and n is the length of array. We can get f(i) with the following equation:\n\n\nActually, same code will be implemented based on this equation. The function f(i) is longest[i] in the code above. Therefore, it is identical to the previous solution.", "question": "\nProblem: Given an unsorted array, find the max length of subsequence in which the numbers are in incremental order.\n\nFor example: If the input array is {7, 2, 3, 1, 5, 8, 9, 6}, a subsequence with the most numbers in incremental order is {2, 3, 5, 8, 9} and the expected output is 5.\n"},
{"answer": "\nAnalysis: This is a very popular interview question of many companies. It can be solved with two steps: Firstly we reverse all characters in a sentence. If all characters in sentence \u201cI am a student.\u201d are reversed, it becomes \u201c.tneduts a ma I\u201d. Not only the order of words is reversed, but also the order of characters inside each word is reversed. Secondly, we reverse characters in every word. We can get \u201cstudent. a am I\u201d from the example input string with these two steps.\n\nThe key of our solution is to implement a function to reverse a string, which is shown as the Reverse function below:\n\nvoid Reverse( char *pBegin, char *pEnd)\n{\nif (pBegin == NULL || pEnd == NULL)\nreturn ;\n\nwhile (pBegin < pEnd)\n{\nchar temp = *pBegin;\n*pBegin = *pEnd;\n*pEnd = temp;\n\npBegin ++, pEnd --;\n}\n}\n\nNow we can reverse the whole sentence and each word based on this Reverse function with the following code:\n\nchar * ReverseSentence( char *pData)\n{\nif (pData == NULL)\nreturn NULL;\n\nchar *pBegin = pData;\n\nchar *pEnd = pData;\nwhile (*pEnd != '\\0' )\npEnd ++;\npEnd--;\n\n// Reverse the whole sentence\nReverse(pBegin, pEnd);\n\n// Reverse every word in the sentence\npBegin = pEnd = pData;\nwhile (*pBegin != '\\0' )\n{\nif (*pBegin == ' ' )\n{\npBegin ++;\npEnd ++;\n}\nelse if (*pEnd == ' ' || *pEnd == '\\0' )\n{\nReverse(pBegin, --pEnd);\npBegin = ++pEnd;\n}\nelse\n{\npEnd ++;\n}\n}\n\nreturn pData;\n}\n", "question": "\nProblem: Reverse the order of words in a sentence, but keep words themselves unchanged. Words in a sentence are divided by blanks. For instance, the reversed output should be \u201cstudent. a am I\u201d when the input is \u201cI am a student\u201d.\n"},
{"answer": "\nAnalysis: This is a very popular interview question of many companies. It can be solved with two steps: Firstly we reverse all characters in a sentence. If all characters in sentence \u201cI am a student.\u201d are reversed, it becomes \u201c.tneduts a ma I\u201d. Not only the order of words is reversed, but also the order of characters inside each word is reversed. Secondly, we reverse characters in every word. We can get \u201cstudent. a am I\u201d from the example input string with these two steps.\n\nThe key of our solution is to implement a function to reverse a string, which is shown as the Reverse function below:\n\nvoid Reverse( char *pBegin, char *pEnd)\n{\nif (pBegin == NULL || pEnd == NULL)\nreturn ;\n\nwhile (pBegin < pEnd)\n{\nchar temp = *pBegin;\n*pBegin = *pEnd;\n*pEnd = temp;\n\npBegin ++, pEnd --;\n}\n}\n\nNow we can reverse the whole sentence and each word based on this Reverse function with the following code:\n\nchar * ReverseSentence( char *pData)\n{\nif (pData == NULL)\nreturn NULL;\n\nchar *pBegin = pData;\n\nchar *pEnd = pData;\nwhile (*pEnd != '\\0' )\npEnd ++;\npEnd--;\n\n// Reverse the whole sentence\nReverse(pBegin, pEnd);\n\n// Reverse every word in the sentence\npBegin = pEnd = pData;\nwhile (*pBegin != '\\0' )\n{\nif (*pBegin == ' ' )\n{\npBegin ++;\npEnd ++;\n}\nelse if (*pEnd == ' ' || *pEnd == '\\0' )\n{\nReverse(pBegin, --pEnd);\npBegin = ++pEnd;\n}\nelse\n{\npEnd ++;\n}\n}\n\nreturn pData;\n}\n", "question": "\nProblem: Reverse the order of words in a sentence, but keep words themselves unchanged. Words in a sentence are divided by blanks. For instance, the reversed output should be \u201cstudent. a am I\u201d when the input is \u201cI am a student\u201d.\n"},
{"answer": "\nAnalysis: This is a very popular interview question of many companies. It can be solved with two steps: Firstly we reverse all characters in a sentence. If all characters in sentence \u201cI am a student.\u201d are reversed, it becomes \u201c.tneduts a ma I\u201d. Not only the order of words is reversed, but also the order of characters inside each word is reversed. Secondly, we reverse characters in every word. We can get \u201cstudent. a am I\u201d from the example input string with these two steps.\n\nThe key of our solution is to implement a function to reverse a string, which is shown as the Reverse function below:\n\nvoid Reverse( char *pBegin, char *pEnd)\n{\nif (pBegin == NULL || pEnd == NULL)\nreturn ;\n\nwhile (pBegin < pEnd)\n{\nchar temp = *pBegin;\n*pBegin = *pEnd;\n*pEnd = temp;\n\npBegin ++, pEnd --;\n}\n}\n\nNow we can reverse the whole sentence and each word based on this Reverse function with the following code:\n\nchar * ReverseSentence( char *pData)\n{\nif (pData == NULL)\nreturn NULL;\n\nchar *pBegin = pData;\n\nchar *pEnd = pData;\nwhile (*pEnd != '\\0' )\npEnd ++;\npEnd--;\n\n// Reverse the whole sentence\nReverse(pBegin, pEnd);\n\n// Reverse every word in the sentence\npBegin = pEnd = pData;\nwhile (*pBegin != '\\0' )\n{\nif (*pBegin == ' ' )\n{\npBegin ++;\npEnd ++;\n}\nelse if (*pEnd == ' ' || *pEnd == '\\0' )\n{\nReverse(pBegin, --pEnd);\npBegin = ++pEnd;\n}\nelse\n{\npEnd ++;\n}\n}\n\nreturn pData;\n}\n", "question": "\nProblem: Reverse the order of words in a sentence, but keep words themselves unchanged. Words in a sentence are divided by blanks. For instance, the reversed output should be \u201cstudent. a am I\u201d when the input is \u201cI am a student\u201d.\n"},
{"answer": "\nAnalysis: In a binary tree, each node has two pointers to its children. In a double-linked list, each node also has two pointers, one pointing to the previous node and the other pointing to the next one. Additionally, binary search tree is a sorted data structure. In a binary search tree, value in parent is always greater than value of its left child and less than value of its right child. Therefore, we can adjust a pointer to its left child in binary search tree to its previous node in a double-linked list, and adjust a pointer to its right child to its next node.\n\nIt is required that the converted list should be sorted, so we can adopt in-order traversal. That is because according to the definition of in-order traversal we traverse from nodes with less value to nodes with greater value. When we reach the root of the binary tree in Figure1, the tree may be viewed as three parts: a root with value 10, a left sub-tree with root value 6 and a right sub-tree with root value 14. According to the definition of sorted double-linked list, the root node with value 10 should be linked to the node with the greatest value (the node with value 8) in its left sub-tree, and it should be also linked to the node with the least value (the node with value 12) in its right sub-tree, as shown in Figure 2.\n\n\n\nFigure 2: A tree with three parts: root, left sub-tree, right sub-tree. After we can the left sub-tree and right sub-tree, and we link them with the root, and then we can get a sorted double-linked list\n\nAccording to the definition of in-order traversal, the sub-tree should be already converted to a sorted list when we reach its root (the node with value 10), and the last node in the sorted list should be the node with the greatest node (the node with value 8). If we link the last node in list to the root node of tree, then the root is the last node in list now. We continue to convert its right sub-tree, and connect the root to the node with its least value. How to convert its left sub-tree and right sub-tree? It should be similar to converting the whole tree. Therefore, we can solve it with recursion.\nWe can write the following code based on the recursive solution:\n\nBinaryTreeNode* Convert(BinaryTreeNode* pRootOfTree)\n{\nBinaryTreeNode *pLastNodeInList = NULL;\nConvertNode(pRootOfTree, &pLastNodeInList);\n\n// pLastNodeInList points to the tail of double-linked list,\n// but we need to return its head\nBinaryTreeNode *pHeadOfList = pLastNodeInList;\nwhile (pHeadOfList != NULL && pHeadOfList->m_pLeft != NULL)\npHeadOfList = pHeadOfList->m_pLeft;\n\nreturn pHeadOfList;\n}\n\nvoid ConvertNode(BinaryTreeNode* pNode, BinaryTreeNode** pLastNodeInList)\n{\nif (pNode == NULL)\nreturn ;\n\nBinaryTreeNode *pCurrent = pNode;\n\nif (pCurrent->m_pLeft != NULL)\nConvertNode(pCurrent->m_pLeft, pLastNodeInList);\n\npCurrent->m_pLeft = *pLastNodeInList;\nif (*pLastNodeInList != NULL)\n(*pLastNodeInList)->m_pRight = pCurrent;\n\n*pLastNodeInList = pCurrent;\n\nif (pCurrent->m_pRight != NULL)\nConvertNode(pCurrent->m_pRight, pLastNodeInList);\n}\n", "question": "\nQuestion: Convert a binary search tree to a sorted double-linked list. We can only change the target of pointers, but cannot create any new nodes.\nFor example, if we input a binary search tree as shown on the left side of the Figure 1, the output double-linked list is shown on the right side.\n\n\n\nFigure 1: The conversion between a binary search tree and a sorted double-linked list\n\nA node of binary search tree is defined in C/C++ is as:\nstruct BinaryTreeNode\n{\nint\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};"},
{"answer": "\nAnalysis: In a binary tree, each node has two pointers to its children. In a double-linked list, each node also has two pointers, one pointing to the previous node and the other pointing to the next one. Additionally, binary search tree is a sorted data structure. In a binary search tree, value in parent is always greater than value of its left child and less than value of its right child. Therefore, we can adjust a pointer to its left child in binary search tree to its previous node in a double-linked list, and adjust a pointer to its right child to its next node.\n\nIt is required that the converted list should be sorted, so we can adopt in-order traversal. That is because according to the definition of in-order traversal we traverse from nodes with less value to nodes with greater value. When we reach the root of the binary tree in Figure1, the tree may be viewed as three parts: a root with value 10, a left sub-tree with root value 6 and a right sub-tree with root value 14. According to the definition of sorted double-linked list, the root node with value 10 should be linked to the node with the greatest value (the node with value 8) in its left sub-tree, and it should be also linked to the node with the least value (the node with value 12) in its right sub-tree, as shown in Figure 2.\n\n\n\nFigure 2: A tree with three parts: root, left sub-tree, right sub-tree. After we can the left sub-tree and right sub-tree, and we link them with the root, and then we can get a sorted double-linked list\n\nAccording to the definition of in-order traversal, the sub-tree should be already converted to a sorted list when we reach its root (the node with value 10), and the last node in the sorted list should be the node with the greatest node (the node with value 8). If we link the last node in list to the root node of tree, then the root is the last node in list now. We continue to convert its right sub-tree, and connect the root to the node with its least value. How to convert its left sub-tree and right sub-tree? It should be similar to converting the whole tree. Therefore, we can solve it with recursion.\nWe can write the following code based on the recursive solution:\n\nBinaryTreeNode* Convert(BinaryTreeNode* pRootOfTree)\n{\nBinaryTreeNode *pLastNodeInList = NULL;\nConvertNode(pRootOfTree, &pLastNodeInList);\n\n// pLastNodeInList points to the tail of double-linked list,\n// but we need to return its head\nBinaryTreeNode *pHeadOfList = pLastNodeInList;\nwhile (pHeadOfList != NULL && pHeadOfList->m_pLeft != NULL)\npHeadOfList = pHeadOfList->m_pLeft;\n\nreturn pHeadOfList;\n}\n\nvoid ConvertNode(BinaryTreeNode* pNode, BinaryTreeNode** pLastNodeInList)\n{\nif (pNode == NULL)\nreturn ;\n\nBinaryTreeNode *pCurrent = pNode;\n\nif (pCurrent->m_pLeft != NULL)\nConvertNode(pCurrent->m_pLeft, pLastNodeInList);\n\npCurrent->m_pLeft = *pLastNodeInList;\nif (*pLastNodeInList != NULL)\n(*pLastNodeInList)->m_pRight = pCurrent;\n\n*pLastNodeInList = pCurrent;\n\nif (pCurrent->m_pRight != NULL)\nConvertNode(pCurrent->m_pRight, pLastNodeInList);\n}\n", "question": "\nQuestion: Convert a binary search tree to a sorted double-linked list. We can only change the target of pointers, but cannot create any new nodes.\nFor example, if we input a binary search tree as shown on the left side of the Figure 1, the output double-linked list is shown on the right side.\n\n\n\nFigure 1: The conversion between a binary search tree and a sorted double-linked list\n\nA node of binary search tree is defined in C/C++ is as:\nstruct BinaryTreeNode\n{\nint\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};"},
{"answer": "\nAnalysis: In a binary tree, each node has two pointers to its children. In a double-linked list, each node also has two pointers, one pointing to the previous node and the other pointing to the next one. Additionally, binary search tree is a sorted data structure. In a binary search tree, value in parent is always greater than value of its left child and less than value of its right child. Therefore, we can adjust a pointer to its left child in binary search tree to its previous node in a double-linked list, and adjust a pointer to its right child to its next node.\n\nIt is required that the converted list should be sorted, so we can adopt in-order traversal. That is because according to the definition of in-order traversal we traverse from nodes with less value to nodes with greater value. When we reach the root of the binary tree in Figure1, the tree may be viewed as three parts: a root with value 10, a left sub-tree with root value 6 and a right sub-tree with root value 14. According to the definition of sorted double-linked list, the root node with value 10 should be linked to the node with the greatest value (the node with value 8) in its left sub-tree, and it should be also linked to the node with the least value (the node with value 12) in its right sub-tree, as shown in Figure 2.\n\n\n\nFigure 2: A tree with three parts: root, left sub-tree, right sub-tree. After we can the left sub-tree and right sub-tree, and we link them with the root, and then we can get a sorted double-linked list\n\nAccording to the definition of in-order traversal, the sub-tree should be already converted to a sorted list when we reach its root (the node with value 10), and the last node in the sorted list should be the node with the greatest node (the node with value 8). If we link the last node in list to the root node of tree, then the root is the last node in list now. We continue to convert its right sub-tree, and connect the root to the node with its least value. How to convert its left sub-tree and right sub-tree? It should be similar to converting the whole tree. Therefore, we can solve it with recursion.\nWe can write the following code based on the recursive solution:\n\nBinaryTreeNode* Convert(BinaryTreeNode* pRootOfTree)\n{\nBinaryTreeNode *pLastNodeInList = NULL;\nConvertNode(pRootOfTree, &pLastNodeInList);\n\n// pLastNodeInList points to the tail of double-linked list,\n// but we need to return its head\nBinaryTreeNode *pHeadOfList = pLastNodeInList;\nwhile (pHeadOfList != NULL && pHeadOfList->m_pLeft != NULL)\npHeadOfList = pHeadOfList->m_pLeft;\n\nreturn pHeadOfList;\n}\n\nvoid ConvertNode(BinaryTreeNode* pNode, BinaryTreeNode** pLastNodeInList)\n{\nif (pNode == NULL)\nreturn ;\n\nBinaryTreeNode *pCurrent = pNode;\n\nif (pCurrent->m_pLeft != NULL)\nConvertNode(pCurrent->m_pLeft, pLastNodeInList);\n\npCurrent->m_pLeft = *pLastNodeInList;\nif (*pLastNodeInList != NULL)\n(*pLastNodeInList)->m_pRight = pCurrent;\n\n*pLastNodeInList = pCurrent;\n\nif (pCurrent->m_pRight != NULL)\nConvertNode(pCurrent->m_pRight, pLastNodeInList);\n}\n", "question": "\nQuestion: Convert a binary search tree to a sorted double-linked list. We can only change the target of pointers, but cannot create any new nodes.\nFor example, if we input a binary search tree as shown on the left side of the Figure 1, the output double-linked list is shown on the right side.\n\n\n\nFigure 1: The conversion between a binary search tree and a sorted double-linked list\n\nA node of binary search tree is defined in C/C++ is as:\nstruct BinaryTreeNode\n{\nint\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};"},
{"answer": "\nAnalysis: In a binary tree, each node has two pointers to its children. In a double-linked list, each node also has two pointers, one pointing to the previous node and the other pointing to the next one. Additionally, binary search tree is a sorted data structure. In a binary search tree, value in parent is always greater than value of its left child and less than value of its right child. Therefore, we can adjust a pointer to its left child in binary search tree to its previous node in a double-linked list, and adjust a pointer to its right child to its next node.\n\nIt is required that the converted list should be sorted, so we can adopt in-order traversal. That is because according to the definition of in-order traversal we traverse from nodes with less value to nodes with greater value. When we reach the root of the binary tree in Figure1, the tree may be viewed as three parts: a root with value 10, a left sub-tree with root value 6 and a right sub-tree with root value 14. According to the definition of sorted double-linked list, the root node with value 10 should be linked to the node with the greatest value (the node with value 8) in its left sub-tree, and it should be also linked to the node with the least value (the node with value 12) in its right sub-tree, as shown in Figure 2.\n\n\n\nFigure 2: A tree with three parts: root, left sub-tree, right sub-tree. After we can the left sub-tree and right sub-tree, and we link them with the root, and then we can get a sorted double-linked list\n\nAccording to the definition of in-order traversal, the sub-tree should be already converted to a sorted list when we reach its root (the node with value 10), and the last node in the sorted list should be the node with the greatest node (the node with value 8). If we link the last node in list to the root node of tree, then the root is the last node in list now. We continue to convert its right sub-tree, and connect the root to the node with its least value. How to convert its left sub-tree and right sub-tree? It should be similar to converting the whole tree. Therefore, we can solve it with recursion.\nWe can write the following code based on the recursive solution:\n\nBinaryTreeNode* Convert(BinaryTreeNode* pRootOfTree)\n{\nBinaryTreeNode *pLastNodeInList = NULL;\nConvertNode(pRootOfTree, &pLastNodeInList);\n\n// pLastNodeInList points to the tail of double-linked list,\n// but we need to return its head\nBinaryTreeNode *pHeadOfList = pLastNodeInList;\nwhile (pHeadOfList != NULL && pHeadOfList->m_pLeft != NULL)\npHeadOfList = pHeadOfList->m_pLeft;\n\nreturn pHeadOfList;\n}\n\nvoid ConvertNode(BinaryTreeNode* pNode, BinaryTreeNode** pLastNodeInList)\n{\nif (pNode == NULL)\nreturn ;\n\nBinaryTreeNode *pCurrent = pNode;\n\nif (pCurrent->m_pLeft != NULL)\nConvertNode(pCurrent->m_pLeft, pLastNodeInList);\n\npCurrent->m_pLeft = *pLastNodeInList;\nif (*pLastNodeInList != NULL)\n(*pLastNodeInList)->m_pRight = pCurrent;\n\n*pLastNodeInList = pCurrent;\n\nif (pCurrent->m_pRight != NULL)\nConvertNode(pCurrent->m_pRight, pLastNodeInList);\n}\n", "question": "\nQuestion: Convert a binary search tree to a sorted double-linked list. We can only change the target of pointers, but cannot create any new nodes.\nFor example, if we input a binary search tree as shown on the left side of the Figure 1, the output double-linked list is shown on the right side.\n\n\n\nFigure 1: The conversion between a binary search tree and a sorted double-linked list\n\nA node of binary search tree is defined in C/C++ is as:\nstruct BinaryTreeNode\n{\nint\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};"},
{"answer": "", "question": ""},
{"answer": "\nAnalysis: In a binary tree, each node has two pointers to its children. In a double-linked list, each node also has two pointers, one pointing to the previous node and the other pointing to the next one. Additionally, binary search tree is a sorted data structure. In a binary search tree, value in parent is always greater than value of its left child and less than value of its right child. Therefore, we can adjust a pointer to its left child in binary search tree to its previous node in a double-linked list, and adjust a pointer to its right child to its next node.\n\nIt is required that the converted list should be sorted, so we can adopt in-order traversal. That is because according to the definition of in-order traversal we traverse from nodes with less value to nodes with greater value. When we reach the root of the binary tree in Figure1, the tree may be viewed as three parts: a root with value 10, a left sub-tree with root value 6 and a right sub-tree with root value 14. According to the definition of sorted double-linked list, the root node with value 10 should be linked to the node with the greatest value (the node with value 8) in its left sub-tree, and it should be also linked to the node with the least value (the node with value 12) in its right sub-tree, as shown in Figure 2.\n\n\n\nFigure 2: A tree with three parts: root, left sub-tree, right sub-tree. After we can the left sub-tree and right sub-tree, and we link them with the root, and then we can get a sorted double-linked list\n\nAccording to the definition of in-order traversal, the sub-tree should be already converted to a sorted list when we reach its root (the node with value 10), and the last node in the sorted list should be the node with the greatest node (the node with value 8). If we link the last node in list to the root node of tree, then the root is the last node in list now. We continue to convert its right sub-tree, and connect the root to the node with its least value. How to convert its left sub-tree and right sub-tree? It should be similar to converting the whole tree. Therefore, we can solve it with recursion.\nWe can write the following code based on the recursive solution:\n\nBinaryTreeNode* Convert(BinaryTreeNode* pRootOfTree)\n{\nBinaryTreeNode *pLastNodeInList = NULL;\nConvertNode(pRootOfTree, &pLastNodeInList);\n\n// pLastNodeInList points to the tail of double-linked list,\n// but we need to return its head\nBinaryTreeNode *pHeadOfList = pLastNodeInList;\nwhile (pHeadOfList != NULL && pHeadOfList->m_pLeft != NULL)\npHeadOfList = pHeadOfList->m_pLeft;\n\nreturn pHeadOfList;\n}\n\nvoid ConvertNode(BinaryTreeNode* pNode, BinaryTreeNode** pLastNodeInList)\n{\nif (pNode == NULL)\nreturn ;\n\nBinaryTreeNode *pCurrent = pNode;\n\nif (pCurrent->m_pLeft != NULL)\nConvertNode(pCurrent->m_pLeft, pLastNodeInList);\n\npCurrent->m_pLeft = *pLastNodeInList;\nif (*pLastNodeInList != NULL)\n(*pLastNodeInList)->m_pRight = pCurrent;\n\n*pLastNodeInList = pCurrent;\n\nif (pCurrent->m_pRight != NULL)\nConvertNode(pCurrent->m_pRight, pLastNodeInList);\n}\n", "question": "\nQuestion: Convert a binary search tree to a sorted double-linked list. We can only change the target of pointers, but cannot create any new nodes.\nFor example, if we input a binary search tree as shown on the left side of the Figure 1, the output double-linked list is shown on the right side.\n\n\n\nFigure 1: The conversion between a binary search tree and a sorted double-linked list\n\nA node of binary search tree is defined in C/C++ is as:\nstruct BinaryTreeNode\n{\nint\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};"},
{"answer": "\nAnalysis: In a binary tree, each node has two pointers to its children. In a double-linked list, each node also has two pointers, one pointing to the previous node and the other pointing to the next one. Additionally, binary search tree is a sorted data structure. In a binary search tree, value in parent is always greater than value of its left child and less than value of its right child. Therefore, we can adjust a pointer to its left child in binary search tree to its previous node in a double-linked list, and adjust a pointer to its right child to its next node.\n\nIt is required that the converted list should be sorted, so we can adopt in-order traversal. That is because according to the definition of in-order traversal we traverse from nodes with less value to nodes with greater value. When we reach the root of the binary tree in Figure1, the tree may be viewed as three parts: a root with value 10, a left sub-tree with root value 6 and a right sub-tree with root value 14. According to the definition of sorted double-linked list, the root node with value 10 should be linked to the node with the greatest value (the node with value 8) in its left sub-tree, and it should be also linked to the node with the least value (the node with value 12) in its right sub-tree, as shown in Figure 2.\n\n\n\nFigure 2: A tree with three parts: root, left sub-tree, right sub-tree. After we can the left sub-tree and right sub-tree, and we link them with the root, and then we can get a sorted double-linked list\n\nAccording to the definition of in-order traversal, the sub-tree should be already converted to a sorted list when we reach its root (the node with value 10), and the last node in the sorted list should be the node with the greatest node (the node with value 8). If we link the last node in list to the root node of tree, then the root is the last node in list now. We continue to convert its right sub-tree, and connect the root to the node with its least value. How to convert its left sub-tree and right sub-tree? It should be similar to converting the whole tree. Therefore, we can solve it with recursion.\nWe can write the following code based on the recursive solution:\n\nBinaryTreeNode* Convert(BinaryTreeNode* pRootOfTree)\n{\nBinaryTreeNode *pLastNodeInList = NULL;\nConvertNode(pRootOfTree, &pLastNodeInList);\n\n// pLastNodeInList points to the tail of double-linked list,\n// but we need to return its head\nBinaryTreeNode *pHeadOfList = pLastNodeInList;\nwhile (pHeadOfList != NULL && pHeadOfList->m_pLeft != NULL)\npHeadOfList = pHeadOfList->m_pLeft;\n\nreturn pHeadOfList;\n}\n\nvoid ConvertNode(BinaryTreeNode* pNode, BinaryTreeNode** pLastNodeInList)\n{\nif (pNode == NULL)\nreturn ;\n\nBinaryTreeNode *pCurrent = pNode;\n\nif (pCurrent->m_pLeft != NULL)\nConvertNode(pCurrent->m_pLeft, pLastNodeInList);\n\npCurrent->m_pLeft = *pLastNodeInList;\nif (*pLastNodeInList != NULL)\n(*pLastNodeInList)->m_pRight = pCurrent;\n\n*pLastNodeInList = pCurrent;\n\nif (pCurrent->m_pRight != NULL)\nConvertNode(pCurrent->m_pRight, pLastNodeInList);\n}\n", "question": "\nQuestion: Convert a binary search tree to a sorted double-linked list. We can only change the target of pointers, but cannot create any new nodes.\nFor example, if we input a binary search tree as shown on the left side of the Figure 1, the output double-linked list is shown on the right side.\n\n\n\nFigure 1: The conversion between a binary search tree and a sorted double-linked list\n\nA node of binary search tree is defined in C/C++ is as:\nstruct BinaryTreeNode\n{\nint\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};"},
{"answer": "\nAnalysis: Let's take the number 12258 as an example to analyze the steps to translate from the beginning character to the ending one. There are two possible first characters in the translated string. One way is to split the number 12258 into 1 and 2258 two parts, and 1 is translated into 'a'. The other way is to split the number 12258 into 12 and 258 two parts, and 12 is translated into 'l'.\nWhen the first one or two digits are translated into the first character, we can continue to translate the remaining digits. Obviously, we could write a recursive function/method to translate.\nLet's define a function f ( i ) as the count of different ways to translate a number starting from the i th digit, f ( i )= g ( i )* f ( i +1)+ h ( i , i +1)* f ( i +2). The function g (i) gets 1 when the i th digit is in the range 1 to 9 which can be converted to a character, otherwise it gets 0. The function h ( i , i +1) gets 1 the i th and ( i +1) th digits are in the range 10 to 26 which can also be converted to a character. A single digit 0 can't be converted to a character, and two digits starting with a 0, such as 01 and 02, can't be converted either.\nEven though the problem is analyzed with recursion, recursion is not the best approach because of overlapping sub-problems. For example, The problem to translate 12258 is split into two sub-problems: one is to translate 1 and 2258, and the other is to translate 12 and 258. In the next step during recursion, the problem to translate 2258 can also split into two sub-problems: one is to translate 2 and 258, and the other is to translate 22 and 58. Notice the sub-problem to translate 258 reoccurs.\nRecursion solves problem in the top-down order. We could solve this problem in the bottom-up order, in order to eliminate overlap sub-problems. That's to say, we start to translate the number from the ending digits, and then move from right to left during translation.\nThe following is the C# code to solve this problem:\n public static int GetTranslationCount( int number)\n {\n     if (number <= 0)\n     {\n         return 0;\n     }\n  \n     string numberInString = number.ToString();\n     return GetTranslationCount(numberInString);\n }\n  \n private static int GetTranslationCount( string number)\n {\n     int length = number.Length;\n     int [] counts = new int [length];\n  \n     for ( int i = length - 1; i >= 0; --i)\n     {\n         int count = 0;\n         if (number[i] >= '1' && number[i] <= '9' )\n         {\n             if (i < length - 1)\n             {\n                 count += counts[i + 1];\n             }\n             else\n             {\n                 count += 1;\n             }\n         }\n  \n         if (i < length - 1)\n         {\n             int digit1 = number[i] - '0' ;\n             int digit2 = number[i + 1] - '0' ;\n             int converted = digit1 * 10 + digit2;\n             if (converted >= 10 && converted<= 26)\n             {\n                 if (i <length - 2)\n                 {\n                     count += counts[i + 2];\n                 }\n                 else\n                 {\n                     count += 1;\n                 }\n             }\n         }\n  \n         counts[i] = count;\n     }\n  \n     return counts[0];\n }\nIn order to simply the code implementation, we first convert the number into a string, and then translate.\n\n", "question": "\nQuestion: Given a number, please translate it to a string, following the rules: 1 is translated to 'a', 2 to 'b', \u2026, 12 to 'l', \u2026, 26 to 'z'. For example, the number 12258 can be translated to \"abbeh\", \"aveh\", \"abyh\", \"lbeh\" and \"lyh\", so there are 5 different ways to translate 12258. How to write a function/method to count the different ways to translate a number?"},
{"answer": "\nAnalysis: In a binary tree, each node has two pointers to its children. In a double-linked list, each node also has two pointers, one pointing to the previous node and the other pointing to the next one. Additionally, binary search tree is a sorted data structure. In a binary search tree, value in parent is always greater than value of its left child and less than value of its right child. Therefore, we can adjust a pointer to its left child in binary search tree to its previous node in a double-linked list, and adjust a pointer to its right child to its next node.\n\nIt is required that the converted list should be sorted, so we can adopt in-order traversal. That is because according to the definition of in-order traversal we traverse from nodes with less value to nodes with greater value. When we reach the root of the binary tree in Figure1, the tree may be viewed as three parts: a root with value 10, a left sub-tree with root value 6 and a right sub-tree with root value 14. According to the definition of sorted double-linked list, the root node with value 10 should be linked to the node with the greatest value (the node with value 8) in its left sub-tree, and it should be also linked to the node with the least value (the node with value 12) in its right sub-tree, as shown in Figure 2.\n\n\n\nFigure 2: A tree with three parts: root, left sub-tree, right sub-tree. After we can the left sub-tree and right sub-tree, and we link them with the root, and then we can get a sorted double-linked list\n\nAccording to the definition of in-order traversal, the sub-tree should be already converted to a sorted list when we reach its root (the node with value 10), and the last node in the sorted list should be the node with the greatest node (the node with value 8). If we link the last node in list to the root node of tree, then the root is the last node in list now. We continue to convert its right sub-tree, and connect the root to the node with its least value. How to convert its left sub-tree and right sub-tree? It should be similar to converting the whole tree. Therefore, we can solve it with recursion.\nWe can write the following code based on the recursive solution:\n\nBinaryTreeNode* Convert(BinaryTreeNode* pRootOfTree)\n{\nBinaryTreeNode *pLastNodeInList = NULL;\nConvertNode(pRootOfTree, &pLastNodeInList);\n\n// pLastNodeInList points to the tail of double-linked list,\n// but we need to return its head\nBinaryTreeNode *pHeadOfList = pLastNodeInList;\nwhile (pHeadOfList != NULL && pHeadOfList->m_pLeft != NULL)\npHeadOfList = pHeadOfList->m_pLeft;\n\nreturn pHeadOfList;\n}\n\nvoid ConvertNode(BinaryTreeNode* pNode, BinaryTreeNode** pLastNodeInList)\n{\nif (pNode == NULL)\nreturn ;\n\nBinaryTreeNode *pCurrent = pNode;\n\nif (pCurrent->m_pLeft != NULL)\nConvertNode(pCurrent->m_pLeft, pLastNodeInList);\n\npCurrent->m_pLeft = *pLastNodeInList;\nif (*pLastNodeInList != NULL)\n(*pLastNodeInList)->m_pRight = pCurrent;\n\n*pLastNodeInList = pCurrent;\n\nif (pCurrent->m_pRight != NULL)\nConvertNode(pCurrent->m_pRight, pLastNodeInList);\n}\n", "question": "\nQuestion: Convert a binary search tree to a sorted double-linked list. We can only change the target of pointers, but cannot create any new nodes.\nFor example, if we input a binary search tree as shown on the left side of the Figure 1, the output double-linked list is shown on the right side.\n\n\n\nFigure 1: The conversion between a binary search tree and a sorted double-linked list\n\nA node of binary search tree is defined in C/C++ is as:\nstruct BinaryTreeNode\n{\nint\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};"},
{"answer": "\nAnalysis: In a binary tree, each node has two pointers to its children. In a double-linked list, each node also has two pointers, one pointing to the previous node and the other pointing to the next one. Additionally, binary search tree is a sorted data structure. In a binary search tree, value in parent is always greater than value of its left child and less than value of its right child. Therefore, we can adjust a pointer to its left child in binary search tree to its previous node in a double-linked list, and adjust a pointer to its right child to its next node.\n\nIt is required that the converted list should be sorted, so we can adopt in-order traversal. That is because according to the definition of in-order traversal we traverse from nodes with less value to nodes with greater value. When we reach the root of the binary tree in Figure1, the tree may be viewed as three parts: a root with value 10, a left sub-tree with root value 6 and a right sub-tree with root value 14. According to the definition of sorted double-linked list, the root node with value 10 should be linked to the node with the greatest value (the node with value 8) in its left sub-tree, and it should be also linked to the node with the least value (the node with value 12) in its right sub-tree, as shown in Figure 2.\n\n\n\nFigure 2: A tree with three parts: root, left sub-tree, right sub-tree. After we can the left sub-tree and right sub-tree, and we link them with the root, and then we can get a sorted double-linked list\n\nAccording to the definition of in-order traversal, the sub-tree should be already converted to a sorted list when we reach its root (the node with value 10), and the last node in the sorted list should be the node with the greatest node (the node with value 8). If we link the last node in list to the root node of tree, then the root is the last node in list now. We continue to convert its right sub-tree, and connect the root to the node with its least value. How to convert its left sub-tree and right sub-tree? It should be similar to converting the whole tree. Therefore, we can solve it with recursion.\nWe can write the following code based on the recursive solution:\n\nBinaryTreeNode* Convert(BinaryTreeNode* pRootOfTree)\n{\nBinaryTreeNode *pLastNodeInList = NULL;\nConvertNode(pRootOfTree, &pLastNodeInList);\n\n// pLastNodeInList points to the tail of double-linked list,\n// but we need to return its head\nBinaryTreeNode *pHeadOfList = pLastNodeInList;\nwhile (pHeadOfList != NULL && pHeadOfList->m_pLeft != NULL)\npHeadOfList = pHeadOfList->m_pLeft;\n\nreturn pHeadOfList;\n}\n\nvoid ConvertNode(BinaryTreeNode* pNode, BinaryTreeNode** pLastNodeInList)\n{\nif (pNode == NULL)\nreturn ;\n\nBinaryTreeNode *pCurrent = pNode;\n\nif (pCurrent->m_pLeft != NULL)\nConvertNode(pCurrent->m_pLeft, pLastNodeInList);\n\npCurrent->m_pLeft = *pLastNodeInList;\nif (*pLastNodeInList != NULL)\n(*pLastNodeInList)->m_pRight = pCurrent;\n\n*pLastNodeInList = pCurrent;\n\nif (pCurrent->m_pRight != NULL)\nConvertNode(pCurrent->m_pRight, pLastNodeInList);\n}\n", "question": "\nQuestion: Convert a binary search tree to a sorted double-linked list. We can only change the target of pointers, but cannot create any new nodes.\nFor example, if we input a binary search tree as shown on the left side of the Figure 1, the output double-linked list is shown on the right side.\n\n\n\nFigure 1: The conversion between a binary search tree and a sorted double-linked list\n\nA node of binary search tree is defined in C/C++ is as:\nstruct BinaryTreeNode\n{\nint\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};"},
{"answer": "\nAnalysis: In a binary tree, each node has two pointers to its children. In a double-linked list, each node also has two pointers, one pointing to the previous node and the other pointing to the next one. Additionally, binary search tree is a sorted data structure. In a binary search tree, value in parent is always greater than value of its left child and less than value of its right child. Therefore, we can adjust a pointer to its left child in binary search tree to its previous node in a double-linked list, and adjust a pointer to its right child to its next node.\n\nIt is required that the converted list should be sorted, so we can adopt in-order traversal. That is because according to the definition of in-order traversal we traverse from nodes with less value to nodes with greater value. When we reach the root of the binary tree in Figure1, the tree may be viewed as three parts: a root with value 10, a left sub-tree with root value 6 and a right sub-tree with root value 14. According to the definition of sorted double-linked list, the root node with value 10 should be linked to the node with the greatest value (the node with value 8) in its left sub-tree, and it should be also linked to the node with the least value (the node with value 12) in its right sub-tree, as shown in Figure 2.\n\n\n\nFigure 2: A tree with three parts: root, left sub-tree, right sub-tree. After we can the left sub-tree and right sub-tree, and we link them with the root, and then we can get a sorted double-linked list\n\nAccording to the definition of in-order traversal, the sub-tree should be already converted to a sorted list when we reach its root (the node with value 10), and the last node in the sorted list should be the node with the greatest node (the node with value 8). If we link the last node in list to the root node of tree, then the root is the last node in list now. We continue to convert its right sub-tree, and connect the root to the node with its least value. How to convert its left sub-tree and right sub-tree? It should be similar to converting the whole tree. Therefore, we can solve it with recursion.\nWe can write the following code based on the recursive solution:\n\nBinaryTreeNode* Convert(BinaryTreeNode* pRootOfTree)\n{\nBinaryTreeNode *pLastNodeInList = NULL;\nConvertNode(pRootOfTree, &pLastNodeInList);\n\n// pLastNodeInList points to the tail of double-linked list,\n// but we need to return its head\nBinaryTreeNode *pHeadOfList = pLastNodeInList;\nwhile (pHeadOfList != NULL && pHeadOfList->m_pLeft != NULL)\npHeadOfList = pHeadOfList->m_pLeft;\n\nreturn pHeadOfList;\n}\n\nvoid ConvertNode(BinaryTreeNode* pNode, BinaryTreeNode** pLastNodeInList)\n{\nif (pNode == NULL)\nreturn ;\n\nBinaryTreeNode *pCurrent = pNode;\n\nif (pCurrent->m_pLeft != NULL)\nConvertNode(pCurrent->m_pLeft, pLastNodeInList);\n\npCurrent->m_pLeft = *pLastNodeInList;\nif (*pLastNodeInList != NULL)\n(*pLastNodeInList)->m_pRight = pCurrent;\n\n*pLastNodeInList = pCurrent;\n\nif (pCurrent->m_pRight != NULL)\nConvertNode(pCurrent->m_pRight, pLastNodeInList);\n}\n", "question": "\nQuestion: Convert a binary search tree to a sorted double-linked list. We can only change the target of pointers, but cannot create any new nodes.\nFor example, if we input a binary search tree as shown on the left side of the Figure 1, the output double-linked list is shown on the right side.\n\n\n\nFigure 1: The conversion between a binary search tree and a sorted double-linked list\n\nA node of binary search tree is defined in C/C++ is as:\nstruct BinaryTreeNode\n{\nint\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};"},
{"answer": "\nAnalysis: The last number is a post-order traversal sequence is the value of root node. Other numbers in a sequence can be partitioned into two parts: The left numbers, which are less than the value of root node, are value of nodes in left sub-tree; the following numbers, which are greater than the value of root node, are value of nodes in right sub-tree.\n\nTake the input {5, 7, 6, 9, 11, 10, 8} as an example, the last number 8 in this sequence is value of root node. The first 3 numbers (5, 7 and 6), which are less than 8, are value of nodes in left sub-tree. The following 3 numbers (9, 11 and 10), which are greater than 8, are value of nodes in right sub-tree.\n\nWe can continue to construct the left sub-tree and right sub-tree according to the two sub-arrays with the same strategy. In the subsequence {5, 7, 6}, the last number 6 is the root value of the left sub-tree. The number 5 is the value of left child since it is less than root value 6, and 7 is the value of right child since it is greater than 6. Meanwhile, the last number 10 in subsequence {9, 11, 10} is the root value of right sub-tree. The number 9 is value of left child, and 11 is value of right child accordingly.\n\nLet us analyze another array {7, 4, 6, 5}. The last number 5 is the value of root node. Since the first number 7 is greater than 5, there are no nodes in the left sub-tree and numbers 7, 4, 6 are all value of nodes in right sub-tree. However, we notice that a number 4, a value in right sub-tree, is less than the root value 5. It violates the definition of binary search trees. Therefore, there are no binary search trees with post-order traversal sequence {7, 4, 6, 5}.\n\nIt is not difficult to write code after we get the strategy above. Some sample code is shown below:\n\nbool VerifySquenceOfBST( int sequence[], int length)\n{\nif (sequence == NULL || length <= 0)\nreturn false ;\n\nint root = sequence[length - 1];\n\n// nodes in left sub-tree are less than root node\nint i = 0;\nfor (; i < length - 1; ++ i)\n{\nif (sequence[i] > root)\nbreak ;\n}\n\n// nodes in right sub-tree are greater than root node\nint j = i;\nfor (; j < length - 1; ++ j)\n{\nif (sequence[j] < root)\nreturn false ;\n}\n\n// Is left sub-tree a binary search tree?\nbool left = true ;\nif (i > 0)\nleft = VerifySquenceOfBST(sequence, i);\n\n// Is right sub-tree a binary search tree?\nbool right = true ;\nif (i < length - 1)\nright = VerifySquenceOfBST(sequence + i, length - i - 1);\n\nreturn (left && right);", "question": "\nProblem: Determine whether an input array is a post-order traversal sequence of a binary tree or not. If it is, return true; otherwise return false. Assume all numbers in an input array are unique.\n\nFor example, if the input array is {5, 7, 6, 9, 11, 10, 8}, true should be returned, since it is a post-order traversal sequence of the binary search tree in Figure 1. If the input array is {7, 4, 6, 5}, false should be returned since there are no binary search trees whose post-order traversal sequence is such an array."},
{"answer": "\nAnalysis: In a binary tree, each node has two pointers to its children. In a double-linked list, each node also has two pointers, one pointing to the previous node and the other pointing to the next one. Additionally, binary search tree is a sorted data structure. In a binary search tree, value in parent is always greater than value of its left child and less than value of its right child. Therefore, we can adjust a pointer to its left child in binary search tree to its previous node in a double-linked list, and adjust a pointer to its right child to its next node.\n\nIt is required that the converted list should be sorted, so we can adopt in-order traversal. That is because according to the definition of in-order traversal we traverse from nodes with less value to nodes with greater value. When we reach the root of the binary tree in Figure1, the tree may be viewed as three parts: a root with value 10, a left sub-tree with root value 6 and a right sub-tree with root value 14. According to the definition of sorted double-linked list, the root node with value 10 should be linked to the node with the greatest value (the node with value 8) in its left sub-tree, and it should be also linked to the node with the least value (the node with value 12) in its right sub-tree, as shown in Figure 2.\n\n\n\nFigure 2: A tree with three parts: root, left sub-tree, right sub-tree. After we can the left sub-tree and right sub-tree, and we link them with the root, and then we can get a sorted double-linked list\n\nAccording to the definition of in-order traversal, the sub-tree should be already converted to a sorted list when we reach its root (the node with value 10), and the last node in the sorted list should be the node with the greatest node (the node with value 8). If we link the last node in list to the root node of tree, then the root is the last node in list now. We continue to convert its right sub-tree, and connect the root to the node with its least value. How to convert its left sub-tree and right sub-tree? It should be similar to converting the whole tree. Therefore, we can solve it with recursion.\nWe can write the following code based on the recursive solution:\n\nBinaryTreeNode* Convert(BinaryTreeNode* pRootOfTree)\n{\nBinaryTreeNode *pLastNodeInList = NULL;\nConvertNode(pRootOfTree, &pLastNodeInList);\n\n// pLastNodeInList points to the tail of double-linked list,\n// but we need to return its head\nBinaryTreeNode *pHeadOfList = pLastNodeInList;\nwhile (pHeadOfList != NULL && pHeadOfList->m_pLeft != NULL)\npHeadOfList = pHeadOfList->m_pLeft;\n\nreturn pHeadOfList;\n}\n\nvoid ConvertNode(BinaryTreeNode* pNode, BinaryTreeNode** pLastNodeInList)\n{\nif (pNode == NULL)\nreturn ;\n\nBinaryTreeNode *pCurrent = pNode;\n\nif (pCurrent->m_pLeft != NULL)\nConvertNode(pCurrent->m_pLeft, pLastNodeInList);\n\npCurrent->m_pLeft = *pLastNodeInList;\nif (*pLastNodeInList != NULL)\n(*pLastNodeInList)->m_pRight = pCurrent;\n\n*pLastNodeInList = pCurrent;\n\nif (pCurrent->m_pRight != NULL)\nConvertNode(pCurrent->m_pRight, pLastNodeInList);\n}\n", "question": "\nQuestion: Convert a binary search tree to a sorted double-linked list. We can only change the target of pointers, but cannot create any new nodes.\nFor example, if we input a binary search tree as shown on the left side of the Figure 1, the output double-linked list is shown on the right side.\n\n\n\nFigure 1: The conversion between a binary search tree and a sorted double-linked list\n\nA node of binary search tree is defined in C/C++ is as:\nstruct BinaryTreeNode\n{\nint\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};"},
{"answer": "\nAnalysis: The last number is a post-order traversal sequence is the value of root node. Other numbers in a sequence can be partitioned into two parts: The left numbers, which are less than the value of root node, are value of nodes in left sub-tree; the following numbers, which are greater than the value of root node, are value of nodes in right sub-tree.\n\nTake the input {5, 7, 6, 9, 11, 10, 8} as an example, the last number 8 in this sequence is value of root node. The first 3 numbers (5, 7 and 6), which are less than 8, are value of nodes in left sub-tree. The following 3 numbers (9, 11 and 10), which are greater than 8, are value of nodes in right sub-tree.\n\nWe can continue to construct the left sub-tree and right sub-tree according to the two sub-arrays with the same strategy. In the subsequence {5, 7, 6}, the last number 6 is the root value of the left sub-tree. The number 5 is the value of left child since it is less than root value 6, and 7 is the value of right child since it is greater than 6. Meanwhile, the last number 10 in subsequence {9, 11, 10} is the root value of right sub-tree. The number 9 is value of left child, and 11 is value of right child accordingly.\n\nLet us analyze another array {7, 4, 6, 5}. The last number 5 is the value of root node. Since the first number 7 is greater than 5, there are no nodes in the left sub-tree and numbers 7, 4, 6 are all value of nodes in right sub-tree. However, we notice that a number 4, a value in right sub-tree, is less than the root value 5. It violates the definition of binary search trees. Therefore, there are no binary search trees with post-order traversal sequence {7, 4, 6, 5}.\n\nIt is not difficult to write code after we get the strategy above. Some sample code is shown below:\n\nbool VerifySquenceOfBST( int sequence[], int length)\n{\nif (sequence == NULL || length <= 0)\nreturn false ;\n\nint root = sequence[length - 1];\n\n// nodes in left sub-tree are less than root node\nint i = 0;\nfor (; i < length - 1; ++ i)\n{\nif (sequence[i] > root)\nbreak ;\n}\n\n// nodes in right sub-tree are greater than root node\nint j = i;\nfor (; j < length - 1; ++ j)\n{\nif (sequence[j] < root)\nreturn false ;\n}\n\n// Is left sub-tree a binary search tree?\nbool left = true ;\nif (i > 0)\nleft = VerifySquenceOfBST(sequence, i);\n\n// Is right sub-tree a binary search tree?\nbool right = true ;\nif (i < length - 1)\nright = VerifySquenceOfBST(sequence + i, length - i - 1);\n\nreturn (left && right);", "question": "\nProblem: Determine whether an input array is a post-order traversal sequence of a binary tree or not. If it is, return true; otherwise return false. Assume all numbers in an input array are unique.\n\nFor example, if the input array is {5, 7, 6, 9, 11, 10, 8}, true should be returned, since it is a post-order traversal sequence of the binary search tree in Figure 1. If the input array is {7, 4, 6, 5}, false should be returned since there are no binary search trees whose post-order traversal sequence is such an array."},
{"answer": "\nAnalysis: The last number is a post-order traversal sequence is the value of root node. Other numbers in a sequence can be partitioned into two parts: The left numbers, which are less than the value of root node, are value of nodes in left sub-tree; the following numbers, which are greater than the value of root node, are value of nodes in right sub-tree.\n\nTake the input {5, 7, 6, 9, 11, 10, 8} as an example, the last number 8 in this sequence is value of root node. The first 3 numbers (5, 7 and 6), which are less than 8, are value of nodes in left sub-tree. The following 3 numbers (9, 11 and 10), which are greater than 8, are value of nodes in right sub-tree.\n\nWe can continue to construct the left sub-tree and right sub-tree according to the two sub-arrays with the same strategy. In the subsequence {5, 7, 6}, the last number 6 is the root value of the left sub-tree. The number 5 is the value of left child since it is less than root value 6, and 7 is the value of right child since it is greater than 6. Meanwhile, the last number 10 in subsequence {9, 11, 10} is the root value of right sub-tree. The number 9 is value of left child, and 11 is value of right child accordingly.\n\nLet us analyze another array {7, 4, 6, 5}. The last number 5 is the value of root node. Since the first number 7 is greater than 5, there are no nodes in the left sub-tree and numbers 7, 4, 6 are all value of nodes in right sub-tree. However, we notice that a number 4, a value in right sub-tree, is less than the root value 5. It violates the definition of binary search trees. Therefore, there are no binary search trees with post-order traversal sequence {7, 4, 6, 5}.\n\nIt is not difficult to write code after we get the strategy above. Some sample code is shown below:\n\nbool VerifySquenceOfBST( int sequence[], int length)\n{\nif (sequence == NULL || length <= 0)\nreturn false ;\n\nint root = sequence[length - 1];\n\n// nodes in left sub-tree are less than root node\nint i = 0;\nfor (; i < length - 1; ++ i)\n{\nif (sequence[i] > root)\nbreak ;\n}\n\n// nodes in right sub-tree are greater than root node\nint j = i;\nfor (; j < length - 1; ++ j)\n{\nif (sequence[j] < root)\nreturn false ;\n}\n\n// Is left sub-tree a binary search tree?\nbool left = true ;\nif (i > 0)\nleft = VerifySquenceOfBST(sequence, i);\n\n// Is right sub-tree a binary search tree?\nbool right = true ;\nif (i < length - 1)\nright = VerifySquenceOfBST(sequence + i, length - i - 1);\n\nreturn (left && right);", "question": "\nProblem: Determine whether an input array is a post-order traversal sequence of a binary tree or not. If it is, return true; otherwise return false. Assume all numbers in an input array are unique.\n\nFor example, if the input array is {5, 7, 6, 9, 11, 10, 8}, true should be returned, since it is a post-order traversal sequence of the binary search tree in Figure 1. If the input array is {7, 4, 6, 5}, false should be returned since there are no binary search trees whose post-order traversal sequence is such an array."},
{"answer": "\nAnalysis: The last number is a post-order traversal sequence is the value of root node. Other numbers in a sequence can be partitioned into two parts: The left numbers, which are less than the value of root node, are value of nodes in left sub-tree; the following numbers, which are greater than the value of root node, are value of nodes in right sub-tree.\n\nTake the input {5, 7, 6, 9, 11, 10, 8} as an example, the last number 8 in this sequence is value of root node. The first 3 numbers (5, 7 and 6), which are less than 8, are value of nodes in left sub-tree. The following 3 numbers (9, 11 and 10), which are greater than 8, are value of nodes in right sub-tree.\n\nWe can continue to construct the left sub-tree and right sub-tree according to the two sub-arrays with the same strategy. In the subsequence {5, 7, 6}, the last number 6 is the root value of the left sub-tree. The number 5 is the value of left child since it is less than root value 6, and 7 is the value of right child since it is greater than 6. Meanwhile, the last number 10 in subsequence {9, 11, 10} is the root value of right sub-tree. The number 9 is value of left child, and 11 is value of right child accordingly.\n\nLet us analyze another array {7, 4, 6, 5}. The last number 5 is the value of root node. Since the first number 7 is greater than 5, there are no nodes in the left sub-tree and numbers 7, 4, 6 are all value of nodes in right sub-tree. However, we notice that a number 4, a value in right sub-tree, is less than the root value 5. It violates the definition of binary search trees. Therefore, there are no binary search trees with post-order traversal sequence {7, 4, 6, 5}.\n\nIt is not difficult to write code after we get the strategy above. Some sample code is shown below:\n\nbool VerifySquenceOfBST( int sequence[], int length)\n{\nif (sequence == NULL || length <= 0)\nreturn false ;\n\nint root = sequence[length - 1];\n\n// nodes in left sub-tree are less than root node\nint i = 0;\nfor (; i < length - 1; ++ i)\n{\nif (sequence[i] > root)\nbreak ;\n}\n\n// nodes in right sub-tree are greater than root node\nint j = i;\nfor (; j < length - 1; ++ j)\n{\nif (sequence[j] < root)\nreturn false ;\n}\n\n// Is left sub-tree a binary search tree?\nbool left = true ;\nif (i > 0)\nleft = VerifySquenceOfBST(sequence, i);\n\n// Is right sub-tree a binary search tree?\nbool right = true ;\nif (i < length - 1)\nright = VerifySquenceOfBST(sequence + i, length - i - 1);\n\nreturn (left && right);", "question": "\nProblem: Determine whether an input array is a post-order traversal sequence of a binary tree or not. If it is, return true; otherwise return false. Assume all numbers in an input array are unique.\n\nFor example, if the input array is {5, 7, 6, 9, 11, 10, 8}, true should be returned, since it is a post-order traversal sequence of the binary search tree in Figure 1. If the input array is {7, 4, 6, 5}, false should be returned since there are no binary search trees whose post-order traversal sequence is such an array."},
{"answer": "\nAnalysis: The last number is a post-order traversal sequence is the value of root node. Other numbers in a sequence can be partitioned into two parts: The left numbers, which are less than the value of root node, are value of nodes in left sub-tree; the following numbers, which are greater than the value of root node, are value of nodes in right sub-tree.\n\nTake the input {5, 7, 6, 9, 11, 10, 8} as an example, the last number 8 in this sequence is value of root node. The first 3 numbers (5, 7 and 6), which are less than 8, are value of nodes in left sub-tree. The following 3 numbers (9, 11 and 10), which are greater than 8, are value of nodes in right sub-tree.\n\nWe can continue to construct the left sub-tree and right sub-tree according to the two sub-arrays with the same strategy. In the subsequence {5, 7, 6}, the last number 6 is the root value of the left sub-tree. The number 5 is the value of left child since it is less than root value 6, and 7 is the value of right child since it is greater than 6. Meanwhile, the last number 10 in subsequence {9, 11, 10} is the root value of right sub-tree. The number 9 is value of left child, and 11 is value of right child accordingly.\n\nLet us analyze another array {7, 4, 6, 5}. The last number 5 is the value of root node. Since the first number 7 is greater than 5, there are no nodes in the left sub-tree and numbers 7, 4, 6 are all value of nodes in right sub-tree. However, we notice that a number 4, a value in right sub-tree, is less than the root value 5. It violates the definition of binary search trees. Therefore, there are no binary search trees with post-order traversal sequence {7, 4, 6, 5}.\n\nIt is not difficult to write code after we get the strategy above. Some sample code is shown below:\n\nbool VerifySquenceOfBST( int sequence[], int length)\n{\nif (sequence == NULL || length <= 0)\nreturn false ;\n\nint root = sequence[length - 1];\n\n// nodes in left sub-tree are less than root node\nint i = 0;\nfor (; i < length - 1; ++ i)\n{\nif (sequence[i] > root)\nbreak ;\n}\n\n// nodes in right sub-tree are greater than root node\nint j = i;\nfor (; j < length - 1; ++ j)\n{\nif (sequence[j] < root)\nreturn false ;\n}\n\n// Is left sub-tree a binary search tree?\nbool left = true ;\nif (i > 0)\nleft = VerifySquenceOfBST(sequence, i);\n\n// Is right sub-tree a binary search tree?\nbool right = true ;\nif (i < length - 1)\nright = VerifySquenceOfBST(sequence + i, length - i - 1);\n\nreturn (left && right);", "question": "\nProblem: Determine whether an input array is a post-order traversal sequence of a binary tree or not. If it is, return true; otherwise return false. Assume all numbers in an input array are unique.\n\nFor example, if the input array is {5, 7, 6, 9, 11, 10, 8}, true should be returned, since it is a post-order traversal sequence of the binary search tree in Figure 1. If the input array is {7, 4, 6, 5}, false should be returned since there are no binary search trees whose post-order traversal sequence is such an array."},
{"answer": "\nAnalysis: The last number is a post-order traversal sequence is the value of root node. Other numbers in a sequence can be partitioned into two parts: The left numbers, which are less than the value of root node, are value of nodes in left sub-tree; the following numbers, which are greater than the value of root node, are value of nodes in right sub-tree.\n\nTake the input {5, 7, 6, 9, 11, 10, 8} as an example, the last number 8 in this sequence is value of root node. The first 3 numbers (5, 7 and 6), which are less than 8, are value of nodes in left sub-tree. The following 3 numbers (9, 11 and 10), which are greater than 8, are value of nodes in right sub-tree.\n\nWe can continue to construct the left sub-tree and right sub-tree according to the two sub-arrays with the same strategy. In the subsequence {5, 7, 6}, the last number 6 is the root value of the left sub-tree. The number 5 is the value of left child since it is less than root value 6, and 7 is the value of right child since it is greater than 6. Meanwhile, the last number 10 in subsequence {9, 11, 10} is the root value of right sub-tree. The number 9 is value of left child, and 11 is value of right child accordingly.\n\nLet us analyze another array {7, 4, 6, 5}. The last number 5 is the value of root node. Since the first number 7 is greater than 5, there are no nodes in the left sub-tree and numbers 7, 4, 6 are all value of nodes in right sub-tree. However, we notice that a number 4, a value in right sub-tree, is less than the root value 5. It violates the definition of binary search trees. Therefore, there are no binary search trees with post-order traversal sequence {7, 4, 6, 5}.\n\nIt is not difficult to write code after we get the strategy above. Some sample code is shown below:\n\nbool VerifySquenceOfBST( int sequence[], int length)\n{\nif (sequence == NULL || length <= 0)\nreturn false ;\n\nint root = sequence[length - 1];\n\n// nodes in left sub-tree are less than root node\nint i = 0;\nfor (; i < length - 1; ++ i)\n{\nif (sequence[i] > root)\nbreak ;\n}\n\n// nodes in right sub-tree are greater than root node\nint j = i;\nfor (; j < length - 1; ++ j)\n{\nif (sequence[j] < root)\nreturn false ;\n}\n\n// Is left sub-tree a binary search tree?\nbool left = true ;\nif (i > 0)\nleft = VerifySquenceOfBST(sequence, i);\n\n// Is right sub-tree a binary search tree?\nbool right = true ;\nif (i < length - 1)\nright = VerifySquenceOfBST(sequence + i, length - i - 1);\n\nreturn (left && right);", "question": "\nProblem: Determine whether an input array is a post-order traversal sequence of a binary tree or not. If it is, return true; otherwise return false. Assume all numbers in an input array are unique.\n\nFor example, if the input array is {5, 7, 6, 9, 11, 10, 8}, true should be returned, since it is a post-order traversal sequence of the binary search tree in Figure 1. If the input array is {7, 4, 6, 5}, false should be returned since there are no binary search trees whose post-order traversal sequence is such an array."},
{"answer": "\nAnalysis: The last number is a post-order traversal sequence is the value of root node. Other numbers in a sequence can be partitioned into two parts: The left numbers, which are less than the value of root node, are value of nodes in left sub-tree; the following numbers, which are greater than the value of root node, are value of nodes in right sub-tree.\n\nTake the input {5, 7, 6, 9, 11, 10, 8} as an example, the last number 8 in this sequence is value of root node. The first 3 numbers (5, 7 and 6), which are less than 8, are value of nodes in left sub-tree. The following 3 numbers (9, 11 and 10), which are greater than 8, are value of nodes in right sub-tree.\n\nWe can continue to construct the left sub-tree and right sub-tree according to the two sub-arrays with the same strategy. In the subsequence {5, 7, 6}, the last number 6 is the root value of the left sub-tree. The number 5 is the value of left child since it is less than root value 6, and 7 is the value of right child since it is greater than 6. Meanwhile, the last number 10 in subsequence {9, 11, 10} is the root value of right sub-tree. The number 9 is value of left child, and 11 is value of right child accordingly.\n\nLet us analyze another array {7, 4, 6, 5}. The last number 5 is the value of root node. Since the first number 7 is greater than 5, there are no nodes in the left sub-tree and numbers 7, 4, 6 are all value of nodes in right sub-tree. However, we notice that a number 4, a value in right sub-tree, is less than the root value 5. It violates the definition of binary search trees. Therefore, there are no binary search trees with post-order traversal sequence {7, 4, 6, 5}.\n\nIt is not difficult to write code after we get the strategy above. Some sample code is shown below:\n\nbool VerifySquenceOfBST( int sequence[], int length)\n{\nif (sequence == NULL || length <= 0)\nreturn false ;\n\nint root = sequence[length - 1];\n\n// nodes in left sub-tree are less than root node\nint i = 0;\nfor (; i < length - 1; ++ i)\n{\nif (sequence[i] > root)\nbreak ;\n}\n\n// nodes in right sub-tree are greater than root node\nint j = i;\nfor (; j < length - 1; ++ j)\n{\nif (sequence[j] < root)\nreturn false ;\n}\n\n// Is left sub-tree a binary search tree?\nbool left = true ;\nif (i > 0)\nleft = VerifySquenceOfBST(sequence, i);\n\n// Is right sub-tree a binary search tree?\nbool right = true ;\nif (i < length - 1)\nright = VerifySquenceOfBST(sequence + i, length - i - 1);\n\nreturn (left && right);", "question": "\nProblem: Determine whether an input array is a post-order traversal sequence of a binary tree or not. If it is, return true; otherwise return false. Assume all numbers in an input array are unique.\n\nFor example, if the input array is {5, 7, 6, 9, 11, 10, 8}, true should be returned, since it is a post-order traversal sequence of the binary search tree in Figure 1. If the input array is {7, 4, 6, 5}, false should be returned since there are no binary search trees whose post-order traversal sequence is such an array."},
{"answer": "\nAnalysis: This is a very popular interview question of many companies. It can be solved with two steps: Firstly we reverse all characters in a sentence. If all characters in sentence \u201cI am a student.\u201d are reversed, it becomes \u201c.tneduts a ma I\u201d. Not only the order of words is reversed, but also the order of characters inside each word is reversed. Secondly, we reverse characters in every word. We can get \u201cstudent. a am I\u201d from the example input string with these two steps.\n\nThe key of our solution is to implement a function to reverse a string, which is shown as the Reverse function below:\n\nvoid Reverse( char *pBegin, char *pEnd)\n{\nif (pBegin == NULL || pEnd == NULL)\nreturn ;\n\nwhile (pBegin < pEnd)\n{\nchar temp = *pBegin;\n*pBegin = *pEnd;\n*pEnd = temp;\n\npBegin ++, pEnd --;\n}\n}\n\nNow we can reverse the whole sentence and each word based on this Reverse function with the following code:\n\nchar * ReverseSentence( char *pData)\n{\nif (pData == NULL)\nreturn NULL;\n\nchar *pBegin = pData;\n\nchar *pEnd = pData;\nwhile (*pEnd != '\\0' )\npEnd ++;\npEnd--;\n\n// Reverse the whole sentence\nReverse(pBegin, pEnd);\n\n// Reverse every word in the sentence\npBegin = pEnd = pData;\nwhile (*pBegin != '\\0' )\n{\nif (*pBegin == ' ' )\n{\npBegin ++;\npEnd ++;\n}\nelse if (*pEnd == ' ' || *pEnd == '\\0' )\n{\nReverse(pBegin, --pEnd);\npBegin = ++pEnd;\n}\nelse\n{\npEnd ++;\n}\n}\n\nreturn pData;\n}\n", "question": "\nProblem: Reverse the order of words in a sentence, but keep words themselves unchanged. Words in a sentence are divided by blanks. For instance, the reversed output should be \u201cstudent. a am I\u201d when the input is \u201cI am a student\u201d.\n"},
{"answer": "\nAnalysis: This is a very popular interview question of many companies. It can be solved with two steps: Firstly we reverse all characters in a sentence. If all characters in sentence \u201cI am a student.\u201d are reversed, it becomes \u201c.tneduts a ma I\u201d. Not only the order of words is reversed, but also the order of characters inside each word is reversed. Secondly, we reverse characters in every word. We can get \u201cstudent. a am I\u201d from the example input string with these two steps.\n\nThe key of our solution is to implement a function to reverse a string, which is shown as the Reverse function below:\n\nvoid Reverse( char *pBegin, char *pEnd)\n{\nif (pBegin == NULL || pEnd == NULL)\nreturn ;\n\nwhile (pBegin < pEnd)\n{\nchar temp = *pBegin;\n*pBegin = *pEnd;\n*pEnd = temp;\n\npBegin ++, pEnd --;\n}\n}\n\nNow we can reverse the whole sentence and each word based on this Reverse function with the following code:\n\nchar * ReverseSentence( char *pData)\n{\nif (pData == NULL)\nreturn NULL;\n\nchar *pBegin = pData;\n\nchar *pEnd = pData;\nwhile (*pEnd != '\\0' )\npEnd ++;\npEnd--;\n\n// Reverse the whole sentence\nReverse(pBegin, pEnd);\n\n// Reverse every word in the sentence\npBegin = pEnd = pData;\nwhile (*pBegin != '\\0' )\n{\nif (*pBegin == ' ' )\n{\npBegin ++;\npEnd ++;\n}\nelse if (*pEnd == ' ' || *pEnd == '\\0' )\n{\nReverse(pBegin, --pEnd);\npBegin = ++pEnd;\n}\nelse\n{\npEnd ++;\n}\n}\n\nreturn pData;\n}\n", "question": "\nProblem: Reverse the order of words in a sentence, but keep words themselves unchanged. Words in a sentence are divided by blanks. For instance, the reversed output should be \u201cstudent. a am I\u201d when the input is \u201cI am a student\u201d.\n"},
{"answer": "\nAnalysis: This is a very popular interview question of many companies. It can be solved with two steps: Firstly we reverse all characters in a sentence. If all characters in sentence \u201cI am a student.\u201d are reversed, it becomes \u201c.tneduts a ma I\u201d. Not only the order of words is reversed, but also the order of characters inside each word is reversed. Secondly, we reverse characters in every word. We can get \u201cstudent. a am I\u201d from the example input string with these two steps.\n\nThe key of our solution is to implement a function to reverse a string, which is shown as the Reverse function below:\n\nvoid Reverse( char *pBegin, char *pEnd)\n{\nif (pBegin == NULL || pEnd == NULL)\nreturn ;\n\nwhile (pBegin < pEnd)\n{\nchar temp = *pBegin;\n*pBegin = *pEnd;\n*pEnd = temp;\n\npBegin ++, pEnd --;\n}\n}\n\nNow we can reverse the whole sentence and each word based on this Reverse function with the following code:\n\nchar * ReverseSentence( char *pData)\n{\nif (pData == NULL)\nreturn NULL;\n\nchar *pBegin = pData;\n\nchar *pEnd = pData;\nwhile (*pEnd != '\\0' )\npEnd ++;\npEnd--;\n\n// Reverse the whole sentence\nReverse(pBegin, pEnd);\n\n// Reverse every word in the sentence\npBegin = pEnd = pData;\nwhile (*pBegin != '\\0' )\n{\nif (*pBegin == ' ' )\n{\npBegin ++;\npEnd ++;\n}\nelse if (*pEnd == ' ' || *pEnd == '\\0' )\n{\nReverse(pBegin, --pEnd);\npBegin = ++pEnd;\n}\nelse\n{\npEnd ++;\n}\n}\n\nreturn pData;\n}\n", "question": "\nProblem: Reverse the order of words in a sentence, but keep words themselves unchanged. Words in a sentence are divided by blanks. For instance, the reversed output should be \u201cstudent. a am I\u201d when the input is \u201cI am a student\u201d.\n"},
{"answer": "\nAnalysis: This is a very popular interview question of many companies. It can be solved with two steps: Firstly we reverse all characters in a sentence. If all characters in sentence \u201cI am a student.\u201d are reversed, it becomes \u201c.tneduts a ma I\u201d. Not only the order of words is reversed, but also the order of characters inside each word is reversed. Secondly, we reverse characters in every word. We can get \u201cstudent. a am I\u201d from the example input string with these two steps.\n\nThe key of our solution is to implement a function to reverse a string, which is shown as the Reverse function below:\n\nvoid Reverse( char *pBegin, char *pEnd)\n{\nif (pBegin == NULL || pEnd == NULL)\nreturn ;\n\nwhile (pBegin < pEnd)\n{\nchar temp = *pBegin;\n*pBegin = *pEnd;\n*pEnd = temp;\n\npBegin ++, pEnd --;\n}\n}\n\nNow we can reverse the whole sentence and each word based on this Reverse function with the following code:\n\nchar * ReverseSentence( char *pData)\n{\nif (pData == NULL)\nreturn NULL;\n\nchar *pBegin = pData;\n\nchar *pEnd = pData;\nwhile (*pEnd != '\\0' )\npEnd ++;\npEnd--;\n\n// Reverse the whole sentence\nReverse(pBegin, pEnd);\n\n// Reverse every word in the sentence\npBegin = pEnd = pData;\nwhile (*pBegin != '\\0' )\n{\nif (*pBegin == ' ' )\n{\npBegin ++;\npEnd ++;\n}\nelse if (*pEnd == ' ' || *pEnd == '\\0' )\n{\nReverse(pBegin, --pEnd);\npBegin = ++pEnd;\n}\nelse\n{\npEnd ++;\n}\n}\n\nreturn pData;\n}\n", "question": "\nProblem: Reverse the order of words in a sentence, but keep words themselves unchanged. Words in a sentence are divided by blanks. For instance, the reversed output should be \u201cstudent. a am I\u201d when the input is \u201cI am a student\u201d.\n"},
{"answer": "\nAnalysis: This is a very popular interview question of many companies. It can be solved with two steps: Firstly we reverse all characters in a sentence. If all characters in sentence \u201cI am a student.\u201d are reversed, it becomes \u201c.tneduts a ma I\u201d. Not only the order of words is reversed, but also the order of characters inside each word is reversed. Secondly, we reverse characters in every word. We can get \u201cstudent. a am I\u201d from the example input string with these two steps.\n\nThe key of our solution is to implement a function to reverse a string, which is shown as the Reverse function below:\n\nvoid Reverse( char *pBegin, char *pEnd)\n{\nif (pBegin == NULL || pEnd == NULL)\nreturn ;\n\nwhile (pBegin < pEnd)\n{\nchar temp = *pBegin;\n*pBegin = *pEnd;\n*pEnd = temp;\n\npBegin ++, pEnd --;\n}\n}\n\nNow we can reverse the whole sentence and each word based on this Reverse function with the following code:\n\nchar * ReverseSentence( char *pData)\n{\nif (pData == NULL)\nreturn NULL;\n\nchar *pBegin = pData;\n\nchar *pEnd = pData;\nwhile (*pEnd != '\\0' )\npEnd ++;\npEnd--;\n\n// Reverse the whole sentence\nReverse(pBegin, pEnd);\n\n// Reverse every word in the sentence\npBegin = pEnd = pData;\nwhile (*pBegin != '\\0' )\n{\nif (*pBegin == ' ' )\n{\npBegin ++;\npEnd ++;\n}\nelse if (*pEnd == ' ' || *pEnd == '\\0' )\n{\nReverse(pBegin, --pEnd);\npBegin = ++pEnd;\n}\nelse\n{\npEnd ++;\n}\n}\n\nreturn pData;\n}\n", "question": "\nProblem: Reverse the order of words in a sentence, but keep words themselves unchanged. Words in a sentence are divided by blanks. For instance, the reversed output should be \u201cstudent. a am I\u201d when the input is \u201cI am a student\u201d.\n"},
{"answer": "\nAnalysis: Mirror of binary trees may be a new concept for many candidates, so they may not find a solution in short time during interviews. In order to get some visual ideas about mirrors, we may draw a binary tree and its mirror according to our daily experience. For example, the binary tree on the right of Figure 1 is the mirror of the left one.\n\nLet us analyze these two trees in Figure 1 carefully to get the steps of mirrors. Their root nodes are identical, but their left and right children are swapped. Firstly we may swap two nodes under the root of the original binary tree, and it becomes the second tree in Figure 2.\n\nFigure 2: Process to get mirror of a binary tree. (a) Swap children of the root node; (b) Swap children of the node 10; (c) Swap the children of node 6.\nNow we can summarize the process for mirror: We visit all nodes in a binary tree with pre-order traversal, and swap the children of current visited node if it has. We will get mirror of a binary tree after we visit all of its nodes.\n\nLet us begin to write code after we get clear ideas about the process. The following is the sample code:\n\nvoid Mirror(BinaryTreeNode *pNode)\n{\nif ((pNode == NULL) || (pNode->m_pLeft == NULL && pNode->m_pRight))\nreturn ;\n\nBinaryTreeNode *pTemp = pNode->m_pLeft;\npNode->m_pLeft = pNode->m_pRight;\npNode->m_pRight = pTemp;\n\nif (pNode->m_pLeft)\nMirrorRecursively(pNode->m_pLeft);\n\nif (pNode->m_pRight)\nMirrorRecursively(pNode->m_pRight);", "question": "\nProblem: Please implement a function which returns mirror of a binary tree.\n\nBinary tree nodes are defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n"},
{"answer": "\nAnalysis: Mirror of binary trees may be a new concept for many candidates, so they may not find a solution in short time during interviews. In order to get some visual ideas about mirrors, we may draw a binary tree and its mirror according to our daily experience. For example, the binary tree on the right of Figure 1 is the mirror of the left one.\n\nLet us analyze these two trees in Figure 1 carefully to get the steps of mirrors. Their root nodes are identical, but their left and right children are swapped. Firstly we may swap two nodes under the root of the original binary tree, and it becomes the second tree in Figure 2.\n\nFigure 2: Process to get mirror of a binary tree. (a) Swap children of the root node; (b) Swap children of the node 10; (c) Swap the children of node 6.\nNow we can summarize the process for mirror: We visit all nodes in a binary tree with pre-order traversal, and swap the children of current visited node if it has. We will get mirror of a binary tree after we visit all of its nodes.\n\nLet us begin to write code after we get clear ideas about the process. The following is the sample code:\n\nvoid Mirror(BinaryTreeNode *pNode)\n{\nif ((pNode == NULL) || (pNode->m_pLeft == NULL && pNode->m_pRight))\nreturn ;\n\nBinaryTreeNode *pTemp = pNode->m_pLeft;\npNode->m_pLeft = pNode->m_pRight;\npNode->m_pRight = pTemp;\n\nif (pNode->m_pLeft)\nMirrorRecursively(pNode->m_pLeft);\n\nif (pNode->m_pRight)\nMirrorRecursively(pNode->m_pRight);", "question": "\nProblem: Please implement a function which returns mirror of a binary tree.\n\nBinary tree nodes are defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n"},
{"answer": "\nAnalysis: Mirror of binary trees may be a new concept for many candidates, so they may not find a solution in short time during interviews. In order to get some visual ideas about mirrors, we may draw a binary tree and its mirror according to our daily experience. For example, the binary tree on the right of Figure 1 is the mirror of the left one.\n\nLet us analyze these two trees in Figure 1 carefully to get the steps of mirrors. Their root nodes are identical, but their left and right children are swapped. Firstly we may swap two nodes under the root of the original binary tree, and it becomes the second tree in Figure 2.\n\nFigure 2: Process to get mirror of a binary tree. (a) Swap children of the root node; (b) Swap children of the node 10; (c) Swap the children of node 6.\nNow we can summarize the process for mirror: We visit all nodes in a binary tree with pre-order traversal, and swap the children of current visited node if it has. We will get mirror of a binary tree after we visit all of its nodes.\n\nLet us begin to write code after we get clear ideas about the process. The following is the sample code:\n\nvoid Mirror(BinaryTreeNode *pNode)\n{\nif ((pNode == NULL) || (pNode->m_pLeft == NULL && pNode->m_pRight))\nreturn ;\n\nBinaryTreeNode *pTemp = pNode->m_pLeft;\npNode->m_pLeft = pNode->m_pRight;\npNode->m_pRight = pTemp;\n\nif (pNode->m_pLeft)\nMirrorRecursively(pNode->m_pLeft);\n\nif (pNode->m_pRight)\nMirrorRecursively(pNode->m_pRight);", "question": "\nProblem: Please implement a function which returns mirror of a binary tree.\n\nBinary tree nodes are defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n"},
{"answer": "\nAnalysis: Mirror of binary trees may be a new concept for many candidates, so they may not find a solution in short time during interviews. In order to get some visual ideas about mirrors, we may draw a binary tree and its mirror according to our daily experience. For example, the binary tree on the right of Figure 1 is the mirror of the left one.\n\nLet us analyze these two trees in Figure 1 carefully to get the steps of mirrors. Their root nodes are identical, but their left and right children are swapped. Firstly we may swap two nodes under the root of the original binary tree, and it becomes the second tree in Figure 2.\n\nFigure 2: Process to get mirror of a binary tree. (a) Swap children of the root node; (b) Swap children of the node 10; (c) Swap the children of node 6.\nNow we can summarize the process for mirror: We visit all nodes in a binary tree with pre-order traversal, and swap the children of current visited node if it has. We will get mirror of a binary tree after we visit all of its nodes.\n\nLet us begin to write code after we get clear ideas about the process. The following is the sample code:\n\nvoid Mirror(BinaryTreeNode *pNode)\n{\nif ((pNode == NULL) || (pNode->m_pLeft == NULL && pNode->m_pRight))\nreturn ;\n\nBinaryTreeNode *pTemp = pNode->m_pLeft;\npNode->m_pLeft = pNode->m_pRight;\npNode->m_pRight = pTemp;\n\nif (pNode->m_pLeft)\nMirrorRecursively(pNode->m_pLeft);\n\nif (pNode->m_pRight)\nMirrorRecursively(pNode->m_pRight);", "question": "\nProblem: Please implement a function which returns mirror of a binary tree.\n\nBinary tree nodes are defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n"},
{"answer": "\nAnalysis: Mirror of binary trees may be a new concept for many candidates, so they may not find a solution in short time during interviews. In order to get some visual ideas about mirrors, we may draw a binary tree and its mirror according to our daily experience. For example, the binary tree on the right of Figure 1 is the mirror of the left one.\n\nLet us analyze these two trees in Figure 1 carefully to get the steps of mirrors. Their root nodes are identical, but their left and right children are swapped. Firstly we may swap two nodes under the root of the original binary tree, and it becomes the second tree in Figure 2.\n\nFigure 2: Process to get mirror of a binary tree. (a) Swap children of the root node; (b) Swap children of the node 10; (c) Swap the children of node 6.\nNow we can summarize the process for mirror: We visit all nodes in a binary tree with pre-order traversal, and swap the children of current visited node if it has. We will get mirror of a binary tree after we visit all of its nodes.\n\nLet us begin to write code after we get clear ideas about the process. The following is the sample code:\n\nvoid Mirror(BinaryTreeNode *pNode)\n{\nif ((pNode == NULL) || (pNode->m_pLeft == NULL && pNode->m_pRight))\nreturn ;\n\nBinaryTreeNode *pTemp = pNode->m_pLeft;\npNode->m_pLeft = pNode->m_pRight;\npNode->m_pRight = pTemp;\n\nif (pNode->m_pLeft)\nMirrorRecursively(pNode->m_pLeft);\n\nif (pNode->m_pRight)\nMirrorRecursively(pNode->m_pRight);", "question": "\nProblem: Please implement a function which returns mirror of a binary tree.\n\nBinary tree nodes are defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n"},
{"answer": "\nAnalysis: Mirror of binary trees may be a new concept for many candidates, so they may not find a solution in short time during interviews. In order to get some visual ideas about mirrors, we may draw a binary tree and its mirror according to our daily experience. For example, the binary tree on the right of Figure 1 is the mirror of the left one.\n\nLet us analyze these two trees in Figure 1 carefully to get the steps of mirrors. Their root nodes are identical, but their left and right children are swapped. Firstly we may swap two nodes under the root of the original binary tree, and it becomes the second tree in Figure 2.\n\nFigure 2: Process to get mirror of a binary tree. (a) Swap children of the root node; (b) Swap children of the node 10; (c) Swap the children of node 6.\nNow we can summarize the process for mirror: We visit all nodes in a binary tree with pre-order traversal, and swap the children of current visited node if it has. We will get mirror of a binary tree after we visit all of its nodes.\n\nLet us begin to write code after we get clear ideas about the process. The following is the sample code:\n\nvoid Mirror(BinaryTreeNode *pNode)\n{\nif ((pNode == NULL) || (pNode->m_pLeft == NULL && pNode->m_pRight))\nreturn ;\n\nBinaryTreeNode *pTemp = pNode->m_pLeft;\npNode->m_pLeft = pNode->m_pRight;\npNode->m_pRight = pTemp;\n\nif (pNode->m_pLeft)\nMirrorRecursively(pNode->m_pLeft);\n\nif (pNode->m_pRight)\nMirrorRecursively(pNode->m_pRight);", "question": "\nProblem: Please implement a function which returns mirror of a binary tree.\n\nBinary tree nodes are defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n"},
{"answer": "\nAnalysis: Mirror of binary trees may be a new concept for many candidates, so they may not find a solution in short time during interviews. In order to get some visual ideas about mirrors, we may draw a binary tree and its mirror according to our daily experience. For example, the binary tree on the right of Figure 1 is the mirror of the left one.\n\nLet us analyze these two trees in Figure 1 carefully to get the steps of mirrors. Their root nodes are identical, but their left and right children are swapped. Firstly we may swap two nodes under the root of the original binary tree, and it becomes the second tree in Figure 2.\n\nFigure 2: Process to get mirror of a binary tree. (a) Swap children of the root node; (b) Swap children of the node 10; (c) Swap the children of node 6.\nNow we can summarize the process for mirror: We visit all nodes in a binary tree with pre-order traversal, and swap the children of current visited node if it has. We will get mirror of a binary tree after we visit all of its nodes.\n\nLet us begin to write code after we get clear ideas about the process. The following is the sample code:\n\nvoid Mirror(BinaryTreeNode *pNode)\n{\nif ((pNode == NULL) || (pNode->m_pLeft == NULL && pNode->m_pRight))\nreturn ;\n\nBinaryTreeNode *pTemp = pNode->m_pLeft;\npNode->m_pLeft = pNode->m_pRight;\npNode->m_pRight = pTemp;\n\nif (pNode->m_pLeft)\nMirrorRecursively(pNode->m_pLeft);\n\nif (pNode->m_pRight)\nMirrorRecursively(pNode->m_pRight);", "question": "\nProblem: Please implement a function which returns mirror of a binary tree.\n\nBinary tree nodes are defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n"},
{"answer": "\nAnalysis: Mirror of binary trees may be a new concept for many candidates, so they may not find a solution in short time during interviews. In order to get some visual ideas about mirrors, we may draw a binary tree and its mirror according to our daily experience. For example, the binary tree on the right of Figure 1 is the mirror of the left one.\n\nLet us analyze these two trees in Figure 1 carefully to get the steps of mirrors. Their root nodes are identical, but their left and right children are swapped. Firstly we may swap two nodes under the root of the original binary tree, and it becomes the second tree in Figure 2.\n\nFigure 2: Process to get mirror of a binary tree. (a) Swap children of the root node; (b) Swap children of the node 10; (c) Swap the children of node 6.\nNow we can summarize the process for mirror: We visit all nodes in a binary tree with pre-order traversal, and swap the children of current visited node if it has. We will get mirror of a binary tree after we visit all of its nodes.\n\nLet us begin to write code after we get clear ideas about the process. The following is the sample code:\n\nvoid Mirror(BinaryTreeNode *pNode)\n{\nif ((pNode == NULL) || (pNode->m_pLeft == NULL && pNode->m_pRight))\nreturn ;\n\nBinaryTreeNode *pTemp = pNode->m_pLeft;\npNode->m_pLeft = pNode->m_pRight;\npNode->m_pRight = pTemp;\n\nif (pNode->m_pLeft)\nMirrorRecursively(pNode->m_pLeft);\n\nif (pNode->m_pRight)\nMirrorRecursively(pNode->m_pRight);", "question": "\nProblem: Please implement a function which returns mirror of a binary tree.\n\nBinary tree nodes are defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n"},
{"answer": "\nAnalysis: Mirror of binary trees may be a new concept for many candidates, so they may not find a solution in short time during interviews. In order to get some visual ideas about mirrors, we may draw a binary tree and its mirror according to our daily experience. For example, the binary tree on the right of Figure 1 is the mirror of the left one.\n\nLet us analyze these two trees in Figure 1 carefully to get the steps of mirrors. Their root nodes are identical, but their left and right children are swapped. Firstly we may swap two nodes under the root of the original binary tree, and it becomes the second tree in Figure 2.\n\nFigure 2: Process to get mirror of a binary tree. (a) Swap children of the root node; (b) Swap children of the node 10; (c) Swap the children of node 6.\nNow we can summarize the process for mirror: We visit all nodes in a binary tree with pre-order traversal, and swap the children of current visited node if it has. We will get mirror of a binary tree after we visit all of its nodes.\n\nLet us begin to write code after we get clear ideas about the process. The following is the sample code:\n\nvoid Mirror(BinaryTreeNode *pNode)\n{\nif ((pNode == NULL) || (pNode->m_pLeft == NULL && pNode->m_pRight))\nreturn ;\n\nBinaryTreeNode *pTemp = pNode->m_pLeft;\npNode->m_pLeft = pNode->m_pRight;\npNode->m_pRight = pTemp;\n\nif (pNode->m_pLeft)\nMirrorRecursively(pNode->m_pLeft);\n\nif (pNode->m_pRight)\nMirrorRecursively(pNode->m_pRight);", "question": "\nProblem: Please implement a function which returns mirror of a binary tree.\n\nBinary tree nodes are defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n"},
{"answer": "\nAnalysis: Mirror of binary trees may be a new concept for many candidates, so they may not find a solution in short time during interviews. In order to get some visual ideas about mirrors, we may draw a binary tree and its mirror according to our daily experience. For example, the binary tree on the right of Figure 1 is the mirror of the left one.\n\nLet us analyze these two trees in Figure 1 carefully to get the steps of mirrors. Their root nodes are identical, but their left and right children are swapped. Firstly we may swap two nodes under the root of the original binary tree, and it becomes the second tree in Figure 2.\n\nFigure 2: Process to get mirror of a binary tree. (a) Swap children of the root node; (b) Swap children of the node 10; (c) Swap the children of node 6.\nNow we can summarize the process for mirror: We visit all nodes in a binary tree with pre-order traversal, and swap the children of current visited node if it has. We will get mirror of a binary tree after we visit all of its nodes.\n\nLet us begin to write code after we get clear ideas about the process. The following is the sample code:\n\nvoid Mirror(BinaryTreeNode *pNode)\n{\nif ((pNode == NULL) || (pNode->m_pLeft == NULL && pNode->m_pRight))\nreturn ;\n\nBinaryTreeNode *pTemp = pNode->m_pLeft;\npNode->m_pLeft = pNode->m_pRight;\npNode->m_pRight = pTemp;\n\nif (pNode->m_pLeft)\nMirrorRecursively(pNode->m_pLeft);\n\nif (pNode->m_pRight)\nMirrorRecursively(pNode->m_pRight);", "question": "\nProblem: Please implement a function which returns mirror of a binary tree.\n\nBinary tree nodes are defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n"},
{"answer": "\nAnalysis: Mirror of binary trees may be a new concept for many candidates, so they may not find a solution in short time during interviews. In order to get some visual ideas about mirrors, we may draw a binary tree and its mirror according to our daily experience. For example, the binary tree on the right of Figure 1 is the mirror of the left one.\n\nLet us analyze these two trees in Figure 1 carefully to get the steps of mirrors. Their root nodes are identical, but their left and right children are swapped. Firstly we may swap two nodes under the root of the original binary tree, and it becomes the second tree in Figure 2.\n\nFigure 2: Process to get mirror of a binary tree. (a) Swap children of the root node; (b) Swap children of the node 10; (c) Swap the children of node 6.\nNow we can summarize the process for mirror: We visit all nodes in a binary tree with pre-order traversal, and swap the children of current visited node if it has. We will get mirror of a binary tree after we visit all of its nodes.\n\nLet us begin to write code after we get clear ideas about the process. The following is the sample code:\n\nvoid Mirror(BinaryTreeNode *pNode)\n{\nif ((pNode == NULL) || (pNode->m_pLeft == NULL && pNode->m_pRight))\nreturn ;\n\nBinaryTreeNode *pTemp = pNode->m_pLeft;\npNode->m_pLeft = pNode->m_pRight;\npNode->m_pRight = pTemp;\n\nif (pNode->m_pLeft)\nMirrorRecursively(pNode->m_pLeft);\n\nif (pNode->m_pRight)\nMirrorRecursively(pNode->m_pRight);", "question": "\nProblem: Please implement a function which returns mirror of a binary tree.\n\nBinary tree nodes are defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n"},
{"answer": "\nAnalysis: Mirror of binary trees may be a new concept for many candidates, so they may not find a solution in short time during interviews. In order to get some visual ideas about mirrors, we may draw a binary tree and its mirror according to our daily experience. For example, the binary tree on the right of Figure 1 is the mirror of the left one.\n\nLet us analyze these two trees in Figure 1 carefully to get the steps of mirrors. Their root nodes are identical, but their left and right children are swapped. Firstly we may swap two nodes under the root of the original binary tree, and it becomes the second tree in Figure 2.\n\nFigure 2: Process to get mirror of a binary tree. (a) Swap children of the root node; (b) Swap children of the node 10; (c) Swap the children of node 6.\nNow we can summarize the process for mirror: We visit all nodes in a binary tree with pre-order traversal, and swap the children of current visited node if it has. We will get mirror of a binary tree after we visit all of its nodes.\n\nLet us begin to write code after we get clear ideas about the process. The following is the sample code:\n\nvoid Mirror(BinaryTreeNode *pNode)\n{\nif ((pNode == NULL) || (pNode->m_pLeft == NULL && pNode->m_pRight))\nreturn ;\n\nBinaryTreeNode *pTemp = pNode->m_pLeft;\npNode->m_pLeft = pNode->m_pRight;\npNode->m_pRight = pTemp;\n\nif (pNode->m_pLeft)\nMirrorRecursively(pNode->m_pLeft);\n\nif (pNode->m_pRight)\nMirrorRecursively(pNode->m_pRight);", "question": "\nProblem: Please implement a function which returns mirror of a binary tree.\n\nBinary tree nodes are defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n"},
{"answer": "\nAnalysis: Mirror of binary trees may be a new concept for many candidates, so they may not find a solution in short time during interviews. In order to get some visual ideas about mirrors, we may draw a binary tree and its mirror according to our daily experience. For example, the binary tree on the right of Figure 1 is the mirror of the left one.\n\nLet us analyze these two trees in Figure 1 carefully to get the steps of mirrors. Their root nodes are identical, but their left and right children are swapped. Firstly we may swap two nodes under the root of the original binary tree, and it becomes the second tree in Figure 2.\n\nFigure 2: Process to get mirror of a binary tree. (a) Swap children of the root node; (b) Swap children of the node 10; (c) Swap the children of node 6.\nNow we can summarize the process for mirror: We visit all nodes in a binary tree with pre-order traversal, and swap the children of current visited node if it has. We will get mirror of a binary tree after we visit all of its nodes.\n\nLet us begin to write code after we get clear ideas about the process. The following is the sample code:\n\nvoid Mirror(BinaryTreeNode *pNode)\n{\nif ((pNode == NULL) || (pNode->m_pLeft == NULL && pNode->m_pRight))\nreturn ;\n\nBinaryTreeNode *pTemp = pNode->m_pLeft;\npNode->m_pLeft = pNode->m_pRight;\npNode->m_pRight = pTemp;\n\nif (pNode->m_pLeft)\nMirrorRecursively(pNode->m_pLeft);\n\nif (pNode->m_pRight)\nMirrorRecursively(pNode->m_pRight);", "question": "\nProblem: Please implement a function which returns mirror of a binary tree.\n\nBinary tree nodes are defined as:\n\nstruct BinaryTreeNode\n{\nint m_nValue;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pLeft;\nBinaryTreeNode*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_pRight;\n};\n"},
{"answer": "\nAnalysis: Our native solution for this problem may be scanning the input string from its beginning to end. We compare the current scanned character with every one behind it. If there is no duplication after it, it is a character appearing once. Since it compares each character with O(n) ones behind it, the overall time complexity is O(n 2 ) if there are n characters in a string.\n\nIn order to get the numbers of occurrence times of each character in a string, a data container is needed. It is required to get and update the occurrence time of each character in a string, so the data container is used to project a character to a number. Hash tables fulfill this kind of requirement. We can implement a hash table, in which keys are characters and values are their occurrence times in a string.\n\nIt is necessary to scan strings twice: When a character is visited, we increase the corresponding occurrence time in the hash table during the first scanning. In second round of scanning, whenever a character is visited we also check its occurrence time in the hash table. The first character with occurrence time 1 is the required output.\n\nHash tables are complex, and they are not implemented in the C++ standard template library. Therefore, we have to implement one by ourselves.\n\nCharacters have 8 bits, so there only 256 variances. We can create an array with 255 numbers, in which indexes are ASCII values of all characters, and numbers are their occurrence times in a string. That is to say, we have a hash table whose size if 256, with ASCII values of characters as keys.\n\nIt is time for programming after we get a clear solution. The following are some sample code:\n\nchar FirstNotRepeatingChar( char * pString)\n{\nif (pString == NULL)\nreturn '\\0' ;\n\nconst int tableSize = 256;\nunsigned int hashTable[tableSize];\nfor ( unsigned int i = 0; i<tableSize; ++ i)\nhashTable[i] = 0;\n\nchar * pHashKey = pString;\nwhile (*(pHashKey) != '\\0' )\nhashTable[*(pHashKey++)] ++;\n\npHashKey = pString;\nwhile (*pHashKey != '\\0' )\n{\nif (hashTable[*pHashKey] == 1)\nreturn *pHashKey;\n\npHashKey++;\n}\n\nreturn '\\0' ;\n}\n\nIn the code above, it costs O(1) time to increase the occurrence time for each character. The time complexity for the first scanning is O(n) if the length of string is n. It takes O(1) time to get the occurrence time for each character, so it costs O(n) time for the second scanning. Therefore, the overall time it costs is O(n).\n\nIn the meantime, an array with 256 numbers is created, whose size is 1K. Since the size of array is constant, the space complexity of this algorithm is O(1).", "question": "\nProblem: Implement a function to find the first character in a string which only appears once.\nFor example: It returns \u2018b\u2019 when the input is \u201cabaccdeff\u201d.\n"},
{"answer": "\nAnalysis: Our native solution for this problem may be scanning the input string from its beginning to end. We compare the current scanned character with every one behind it. If there is no duplication after it, it is a character appearing once. Since it compares each character with O(n) ones behind it, the overall time complexity is O(n 2 ) if there are n characters in a string.\n\nIn order to get the numbers of occurrence times of each character in a string, a data container is needed. It is required to get and update the occurrence time of each character in a string, so the data container is used to project a character to a number. Hash tables fulfill this kind of requirement. We can implement a hash table, in which keys are characters and values are their occurrence times in a string.\n\nIt is necessary to scan strings twice: When a character is visited, we increase the corresponding occurrence time in the hash table during the first scanning. In second round of scanning, whenever a character is visited we also check its occurrence time in the hash table. The first character with occurrence time 1 is the required output.\n\nHash tables are complex, and they are not implemented in the C++ standard template library. Therefore, we have to implement one by ourselves.\n\nCharacters have 8 bits, so there only 256 variances. We can create an array with 255 numbers, in which indexes are ASCII values of all characters, and numbers are their occurrence times in a string. That is to say, we have a hash table whose size if 256, with ASCII values of characters as keys.\n\nIt is time for programming after we get a clear solution. The following are some sample code:\n\nchar FirstNotRepeatingChar( char * pString)\n{\nif (pString == NULL)\nreturn '\\0' ;\n\nconst int tableSize = 256;\nunsigned int hashTable[tableSize];\nfor ( unsigned int i = 0; i<tableSize; ++ i)\nhashTable[i] = 0;\n\nchar * pHashKey = pString;\nwhile (*(pHashKey) != '\\0' )\nhashTable[*(pHashKey++)] ++;\n\npHashKey = pString;\nwhile (*pHashKey != '\\0' )\n{\nif (hashTable[*pHashKey] == 1)\nreturn *pHashKey;\n\npHashKey++;\n}\n\nreturn '\\0' ;\n}\n\nIn the code above, it costs O(1) time to increase the occurrence time for each character. The time complexity for the first scanning is O(n) if the length of string is n. It takes O(1) time to get the occurrence time for each character, so it costs O(n) time for the second scanning. Therefore, the overall time it costs is O(n).\n\nIn the meantime, an array with 256 numbers is created, whose size is 1K. Since the size of array is constant, the space complexity of this algorithm is O(1).", "question": "\nProblem: Implement a function to find the first character in a string which only appears once.\nFor example: It returns \u2018b\u2019 when the input is \u201cabaccdeff\u201d.\n"},
{"answer": "\nAnalysis: Our native solution for this problem may be scanning the input string from its beginning to end. We compare the current scanned character with every one behind it. If there is no duplication after it, it is a character appearing once. Since it compares each character with O(n) ones behind it, the overall time complexity is O(n 2 ) if there are n characters in a string.\n\nIn order to get the numbers of occurrence times of each character in a string, a data container is needed. It is required to get and update the occurrence time of each character in a string, so the data container is used to project a character to a number. Hash tables fulfill this kind of requirement. We can implement a hash table, in which keys are characters and values are their occurrence times in a string.\n\nIt is necessary to scan strings twice: When a character is visited, we increase the corresponding occurrence time in the hash table during the first scanning. In second round of scanning, whenever a character is visited we also check its occurrence time in the hash table. The first character with occurrence time 1 is the required output.\n\nHash tables are complex, and they are not implemented in the C++ standard template library. Therefore, we have to implement one by ourselves.\n\nCharacters have 8 bits, so there only 256 variances. We can create an array with 255 numbers, in which indexes are ASCII values of all characters, and numbers are their occurrence times in a string. That is to say, we have a hash table whose size if 256, with ASCII values of characters as keys.\n\nIt is time for programming after we get a clear solution. The following are some sample code:\n\nchar FirstNotRepeatingChar( char * pString)\n{\nif (pString == NULL)\nreturn '\\0' ;\n\nconst int tableSize = 256;\nunsigned int hashTable[tableSize];\nfor ( unsigned int i = 0; i<tableSize; ++ i)\nhashTable[i] = 0;\n\nchar * pHashKey = pString;\nwhile (*(pHashKey) != '\\0' )\nhashTable[*(pHashKey++)] ++;\n\npHashKey = pString;\nwhile (*pHashKey != '\\0' )\n{\nif (hashTable[*pHashKey] == 1)\nreturn *pHashKey;\n\npHashKey++;\n}\n\nreturn '\\0' ;\n}\n\nIn the code above, it costs O(1) time to increase the occurrence time for each character. The time complexity for the first scanning is O(n) if the length of string is n. It takes O(1) time to get the occurrence time for each character, so it costs O(n) time for the second scanning. Therefore, the overall time it costs is O(n).\n\nIn the meantime, an array with 256 numbers is created, whose size is 1K. Since the size of array is constant, the space complexity of this algorithm is O(1).", "question": "\nProblem: Implement a function to find the first character in a string which only appears once.\nFor example: It returns \u2018b\u2019 when the input is \u201cabaccdeff\u201d.\n"},
{"answer": "\nAnalysis: Our native solution for this problem may be scanning the input string from its beginning to end. We compare the current scanned character with every one behind it. If there is no duplication after it, it is a character appearing once. Since it compares each character with O(n) ones behind it, the overall time complexity is O(n 2 ) if there are n characters in a string.\n\nIn order to get the numbers of occurrence times of each character in a string, a data container is needed. It is required to get and update the occurrence time of each character in a string, so the data container is used to project a character to a number. Hash tables fulfill this kind of requirement. We can implement a hash table, in which keys are characters and values are their occurrence times in a string.\n\nIt is necessary to scan strings twice: When a character is visited, we increase the corresponding occurrence time in the hash table during the first scanning. In second round of scanning, whenever a character is visited we also check its occurrence time in the hash table. The first character with occurrence time 1 is the required output.\n\nHash tables are complex, and they are not implemented in the C++ standard template library. Therefore, we have to implement one by ourselves.\n\nCharacters have 8 bits, so there only 256 variances. We can create an array with 255 numbers, in which indexes are ASCII values of all characters, and numbers are their occurrence times in a string. That is to say, we have a hash table whose size if 256, with ASCII values of characters as keys.\n\nIt is time for programming after we get a clear solution. The following are some sample code:\n\nchar FirstNotRepeatingChar( char * pString)\n{\nif (pString == NULL)\nreturn '\\0' ;\n\nconst int tableSize = 256;\nunsigned int hashTable[tableSize];\nfor ( unsigned int i = 0; i<tableSize; ++ i)\nhashTable[i] = 0;\n\nchar * pHashKey = pString;\nwhile (*(pHashKey) != '\\0' )\nhashTable[*(pHashKey++)] ++;\n\npHashKey = pString;\nwhile (*pHashKey != '\\0' )\n{\nif (hashTable[*pHashKey] == 1)\nreturn *pHashKey;\n\npHashKey++;\n}\n\nreturn '\\0' ;\n}\n\nIn the code above, it costs O(1) time to increase the occurrence time for each character. The time complexity for the first scanning is O(n) if the length of string is n. It takes O(1) time to get the occurrence time for each character, so it costs O(n) time for the second scanning. Therefore, the overall time it costs is O(n).\n\nIn the meantime, an array with 256 numbers is created, whose size is 1K. Since the size of array is constant, the space complexity of this algorithm is O(1).", "question": "\nProblem: Implement a function to find the first character in a string which only appears once.\nFor example: It returns \u2018b\u2019 when the input is \u201cabaccdeff\u201d.\n"},
{"answer": "\nAnalysis: Our native solution for this problem may be scanning the input string from its beginning to end. We compare the current scanned character with every one behind it. If there is no duplication after it, it is a character appearing once. Since it compares each character with O(n) ones behind it, the overall time complexity is O(n 2 ) if there are n characters in a string.\n\nIn order to get the numbers of occurrence times of each character in a string, a data container is needed. It is required to get and update the occurrence time of each character in a string, so the data container is used to project a character to a number. Hash tables fulfill this kind of requirement. We can implement a hash table, in which keys are characters and values are their occurrence times in a string.\n\nIt is necessary to scan strings twice: When a character is visited, we increase the corresponding occurrence time in the hash table during the first scanning. In second round of scanning, whenever a character is visited we also check its occurrence time in the hash table. The first character with occurrence time 1 is the required output.\n\nHash tables are complex, and they are not implemented in the C++ standard template library. Therefore, we have to implement one by ourselves.\n\nCharacters have 8 bits, so there only 256 variances. We can create an array with 255 numbers, in which indexes are ASCII values of all characters, and numbers are their occurrence times in a string. That is to say, we have a hash table whose size if 256, with ASCII values of characters as keys.\n\nIt is time for programming after we get a clear solution. The following are some sample code:\n\nchar FirstNotRepeatingChar( char * pString)\n{\nif (pString == NULL)\nreturn '\\0' ;\n\nconst int tableSize = 256;\nunsigned int hashTable[tableSize];\nfor ( unsigned int i = 0; i<tableSize; ++ i)\nhashTable[i] = 0;\n\nchar * pHashKey = pString;\nwhile (*(pHashKey) != '\\0' )\nhashTable[*(pHashKey++)] ++;\n\npHashKey = pString;\nwhile (*pHashKey != '\\0' )\n{\nif (hashTable[*pHashKey] == 1)\nreturn *pHashKey;\n\npHashKey++;\n}\n\nreturn '\\0' ;\n}\n\nIn the code above, it costs O(1) time to increase the occurrence time for each character. The time complexity for the first scanning is O(n) if the length of string is n. It takes O(1) time to get the occurrence time for each character, so it costs O(n) time for the second scanning. Therefore, the overall time it costs is O(n).\n\nIn the meantime, an array with 256 numbers is created, whose size is 1K. Since the size of array is constant, the space complexity of this algorithm is O(1).", "question": "\nProblem: Implement a function to find the first character in a string which only appears once.\nFor example: It returns \u2018b\u2019 when the input is \u201cabaccdeff\u201d.\n"},
{"answer": "\nAnalysis: Our native solution for this problem may be scanning the input string from its beginning to end. We compare the current scanned character with every one behind it. If there is no duplication after it, it is a character appearing once. Since it compares each character with O(n) ones behind it, the overall time complexity is O(n 2 ) if there are n characters in a string.\n\nIn order to get the numbers of occurrence times of each character in a string, a data container is needed. It is required to get and update the occurrence time of each character in a string, so the data container is used to project a character to a number. Hash tables fulfill this kind of requirement. We can implement a hash table, in which keys are characters and values are their occurrence times in a string.\n\nIt is necessary to scan strings twice: When a character is visited, we increase the corresponding occurrence time in the hash table during the first scanning. In second round of scanning, whenever a character is visited we also check its occurrence time in the hash table. The first character with occurrence time 1 is the required output.\n\nHash tables are complex, and they are not implemented in the C++ standard template library. Therefore, we have to implement one by ourselves.\n\nCharacters have 8 bits, so there only 256 variances. We can create an array with 255 numbers, in which indexes are ASCII values of all characters, and numbers are their occurrence times in a string. That is to say, we have a hash table whose size if 256, with ASCII values of characters as keys.\n\nIt is time for programming after we get a clear solution. The following are some sample code:\n\nchar FirstNotRepeatingChar( char * pString)\n{\nif (pString == NULL)\nreturn '\\0' ;\n\nconst int tableSize = 256;\nunsigned int hashTable[tableSize];\nfor ( unsigned int i = 0; i<tableSize; ++ i)\nhashTable[i] = 0;\n\nchar * pHashKey = pString;\nwhile (*(pHashKey) != '\\0' )\nhashTable[*(pHashKey++)] ++;\n\npHashKey = pString;\nwhile (*pHashKey != '\\0' )\n{\nif (hashTable[*pHashKey] == 1)\nreturn *pHashKey;\n\npHashKey++;\n}\n\nreturn '\\0' ;\n}\n\nIn the code above, it costs O(1) time to increase the occurrence time for each character. The time complexity for the first scanning is O(n) if the length of string is n. It takes O(1) time to get the occurrence time for each character, so it costs O(n) time for the second scanning. Therefore, the overall time it costs is O(n).\n\nIn the meantime, an array with 256 numbers is created, whose size is 1K. Since the size of array is constant, the space complexity of this algorithm is O(1).", "question": "\nProblem: Implement a function to find the first character in a string which only appears once.\nFor example: It returns \u2018b\u2019 when the input is \u201cabaccdeff\u201d.\n"},
{"answer": "\nAnalysis: Our native solution for this problem may be scanning the input string from its beginning to end. We compare the current scanned character with every one behind it. If there is no duplication after it, it is a character appearing once. Since it compares each character with O(n) ones behind it, the overall time complexity is O(n 2 ) if there are n characters in a string.\n\nIn order to get the numbers of occurrence times of each character in a string, a data container is needed. It is required to get and update the occurrence time of each character in a string, so the data container is used to project a character to a number. Hash tables fulfill this kind of requirement. We can implement a hash table, in which keys are characters and values are their occurrence times in a string.\n\nIt is necessary to scan strings twice: When a character is visited, we increase the corresponding occurrence time in the hash table during the first scanning. In second round of scanning, whenever a character is visited we also check its occurrence time in the hash table. The first character with occurrence time 1 is the required output.\n\nHash tables are complex, and they are not implemented in the C++ standard template library. Therefore, we have to implement one by ourselves.\n\nCharacters have 8 bits, so there only 256 variances. We can create an array with 255 numbers, in which indexes are ASCII values of all characters, and numbers are their occurrence times in a string. That is to say, we have a hash table whose size if 256, with ASCII values of characters as keys.\n\nIt is time for programming after we get a clear solution. The following are some sample code:\n\nchar FirstNotRepeatingChar( char * pString)\n{\nif (pString == NULL)\nreturn '\\0' ;\n\nconst int tableSize = 256;\nunsigned int hashTable[tableSize];\nfor ( unsigned int i = 0; i<tableSize; ++ i)\nhashTable[i] = 0;\n\nchar * pHashKey = pString;\nwhile (*(pHashKey) != '\\0' )\nhashTable[*(pHashKey++)] ++;\n\npHashKey = pString;\nwhile (*pHashKey != '\\0' )\n{\nif (hashTable[*pHashKey] == 1)\nreturn *pHashKey;\n\npHashKey++;\n}\n\nreturn '\\0' ;\n}\n\nIn the code above, it costs O(1) time to increase the occurrence time for each character. The time complexity for the first scanning is O(n) if the length of string is n. It takes O(1) time to get the occurrence time for each character, so it costs O(n) time for the second scanning. Therefore, the overall time it costs is O(n).\n\nIn the meantime, an array with 256 numbers is created, whose size is 1K. Since the size of array is constant, the space complexity of this algorithm is O(1).", "question": "\nProblem: Implement a function to find the first character in a string which only appears once.\nFor example: It returns \u2018b\u2019 when the input is \u201cabaccdeff\u201d.\n"},
{"answer": "\nAnalysis: Our native solution for this problem may be scanning the input string from its beginning to end. We compare the current scanned character with every one behind it. If there is no duplication after it, it is a character appearing once. Since it compares each character with O(n) ones behind it, the overall time complexity is O(n 2 ) if there are n characters in a string.\n\nIn order to get the numbers of occurrence times of each character in a string, a data container is needed. It is required to get and update the occurrence time of each character in a string, so the data container is used to project a character to a number. Hash tables fulfill this kind of requirement. We can implement a hash table, in which keys are characters and values are their occurrence times in a string.\n\nIt is necessary to scan strings twice: When a character is visited, we increase the corresponding occurrence time in the hash table during the first scanning. In second round of scanning, whenever a character is visited we also check its occurrence time in the hash table. The first character with occurrence time 1 is the required output.\n\nHash tables are complex, and they are not implemented in the C++ standard template library. Therefore, we have to implement one by ourselves.\n\nCharacters have 8 bits, so there only 256 variances. We can create an array with 255 numbers, in which indexes are ASCII values of all characters, and numbers are their occurrence times in a string. That is to say, we have a hash table whose size if 256, with ASCII values of characters as keys.\n\nIt is time for programming after we get a clear solution. The following are some sample code:\n\nchar FirstNotRepeatingChar( char * pString)\n{\nif (pString == NULL)\nreturn '\\0' ;\n\nconst int tableSize = 256;\nunsigned int hashTable[tableSize];\nfor ( unsigned int i = 0; i<tableSize; ++ i)\nhashTable[i] = 0;\n\nchar * pHashKey = pString;\nwhile (*(pHashKey) != '\\0' )\nhashTable[*(pHashKey++)] ++;\n\npHashKey = pString;\nwhile (*pHashKey != '\\0' )\n{\nif (hashTable[*pHashKey] == 1)\nreturn *pHashKey;\n\npHashKey++;\n}\n\nreturn '\\0' ;\n}\n\nIn the code above, it costs O(1) time to increase the occurrence time for each character. The time complexity for the first scanning is O(n) if the length of string is n. It takes O(1) time to get the occurrence time for each character, so it costs O(n) time for the second scanning. Therefore, the overall time it costs is O(n).\n\nIn the meantime, an array with 256 numbers is created, whose size is 1K. Since the size of array is constant, the space complexity of this algorithm is O(1).", "question": "\nProblem: Implement a function to find the first character in a string which only appears once.\nFor example: It returns \u2018b\u2019 when the input is \u201cabaccdeff\u201d.\n"},
{"answer": "\nAnalysis: Our native solution for this problem may be scanning the input string from its beginning to end. We compare the current scanned character with every one behind it. If there is no duplication after it, it is a character appearing once. Since it compares each character with O(n) ones behind it, the overall time complexity is O(n 2 ) if there are n characters in a string.\n\nIn order to get the numbers of occurrence times of each character in a string, a data container is needed. It is required to get and update the occurrence time of each character in a string, so the data container is used to project a character to a number. Hash tables fulfill this kind of requirement. We can implement a hash table, in which keys are characters and values are their occurrence times in a string.\n\nIt is necessary to scan strings twice: When a character is visited, we increase the corresponding occurrence time in the hash table during the first scanning. In second round of scanning, whenever a character is visited we also check its occurrence time in the hash table. The first character with occurrence time 1 is the required output.\n\nHash tables are complex, and they are not implemented in the C++ standard template library. Therefore, we have to implement one by ourselves.\n\nCharacters have 8 bits, so there only 256 variances. We can create an array with 255 numbers, in which indexes are ASCII values of all characters, and numbers are their occurrence times in a string. That is to say, we have a hash table whose size if 256, with ASCII values of characters as keys.\n\nIt is time for programming after we get a clear solution. The following are some sample code:\n\nchar FirstNotRepeatingChar( char * pString)\n{\nif (pString == NULL)\nreturn '\\0' ;\n\nconst int tableSize = 256;\nunsigned int hashTable[tableSize];\nfor ( unsigned int i = 0; i<tableSize; ++ i)\nhashTable[i] = 0;\n\nchar * pHashKey = pString;\nwhile (*(pHashKey) != '\\0' )\nhashTable[*(pHashKey++)] ++;\n\npHashKey = pString;\nwhile (*pHashKey != '\\0' )\n{\nif (hashTable[*pHashKey] == 1)\nreturn *pHashKey;\n\npHashKey++;\n}\n\nreturn '\\0' ;\n}\n\nIn the code above, it costs O(1) time to increase the occurrence time for each character. The time complexity for the first scanning is O(n) if the length of string is n. It takes O(1) time to get the occurrence time for each character, so it costs O(n) time for the second scanning. Therefore, the overall time it costs is O(n).\n\nIn the meantime, an array with 256 numbers is created, whose size is 1K. Since the size of array is constant, the space complexity of this algorithm is O(1).", "question": "\nProblem: Implement a function to find the first character in a string which only appears once.\nFor example: It returns \u2018b\u2019 when the input is \u201cabaccdeff\u201d.\n"},
{"answer": "\nAnalysis: Our native solution for this problem may be scanning the input string from its beginning to end. We compare the current scanned character with every one behind it. If there is no duplication after it, it is a character appearing once. Since it compares each character with O(n) ones behind it, the overall time complexity is O(n 2 ) if there are n characters in a string.\n\nIn order to get the numbers of occurrence times of each character in a string, a data container is needed. It is required to get and update the occurrence time of each character in a string, so the data container is used to project a character to a number. Hash tables fulfill this kind of requirement. We can implement a hash table, in which keys are characters and values are their occurrence times in a string.\n\nIt is necessary to scan strings twice: When a character is visited, we increase the corresponding occurrence time in the hash table during the first scanning. In second round of scanning, whenever a character is visited we also check its occurrence time in the hash table. The first character with occurrence time 1 is the required output.\n\nHash tables are complex, and they are not implemented in the C++ standard template library. Therefore, we have to implement one by ourselves.\n\nCharacters have 8 bits, so there only 256 variances. We can create an array with 255 numbers, in which indexes are ASCII values of all characters, and numbers are their occurrence times in a string. That is to say, we have a hash table whose size if 256, with ASCII values of characters as keys.\n\nIt is time for programming after we get a clear solution. The following are some sample code:\n\nchar FirstNotRepeatingChar( char * pString)\n{\nif (pString == NULL)\nreturn '\\0' ;\n\nconst int tableSize = 256;\nunsigned int hashTable[tableSize];\nfor ( unsigned int i = 0; i<tableSize; ++ i)\nhashTable[i] = 0;\n\nchar * pHashKey = pString;\nwhile (*(pHashKey) != '\\0' )\nhashTable[*(pHashKey++)] ++;\n\npHashKey = pString;\nwhile (*pHashKey != '\\0' )\n{\nif (hashTable[*pHashKey] == 1)\nreturn *pHashKey;\n\npHashKey++;\n}\n\nreturn '\\0' ;\n}\n\nIn the code above, it costs O(1) time to increase the occurrence time for each character. The time complexity for the first scanning is O(n) if the length of string is n. It takes O(1) time to get the occurrence time for each character, so it costs O(n) time for the second scanning. Therefore, the overall time it costs is O(n).\n\nIn the meantime, an array with 256 numbers is created, whose size is 1K. Since the size of array is constant, the space complexity of this algorithm is O(1).", "question": "\nProblem: Implement a function to find the first character in a string which only appears once.\nFor example: It returns \u2018b\u2019 when the input is \u201cabaccdeff\u201d.\n"},
{"answer": "\nAnalysis: Our native solution for this problem may be scanning the input string from its beginning to end. We compare the current scanned character with every one behind it. If there is no duplication after it, it is a character appearing once. Since it compares each character with O(n) ones behind it, the overall time complexity is O(n 2 ) if there are n characters in a string.\n\nIn order to get the numbers of occurrence times of each character in a string, a data container is needed. It is required to get and update the occurrence time of each character in a string, so the data container is used to project a character to a number. Hash tables fulfill this kind of requirement. We can implement a hash table, in which keys are characters and values are their occurrence times in a string.\n\nIt is necessary to scan strings twice: When a character is visited, we increase the corresponding occurrence time in the hash table during the first scanning. In second round of scanning, whenever a character is visited we also check its occurrence time in the hash table. The first character with occurrence time 1 is the required output.\n\nHash tables are complex, and they are not implemented in the C++ standard template library. Therefore, we have to implement one by ourselves.\n\nCharacters have 8 bits, so there only 256 variances. We can create an array with 255 numbers, in which indexes are ASCII values of all characters, and numbers are their occurrence times in a string. That is to say, we have a hash table whose size if 256, with ASCII values of characters as keys.\n\nIt is time for programming after we get a clear solution. The following are some sample code:\n\nchar FirstNotRepeatingChar( char * pString)\n{\nif (pString == NULL)\nreturn '\\0' ;\n\nconst int tableSize = 256;\nunsigned int hashTable[tableSize];\nfor ( unsigned int i = 0; i<tableSize; ++ i)\nhashTable[i] = 0;\n\nchar * pHashKey = pString;\nwhile (*(pHashKey) != '\\0' )\nhashTable[*(pHashKey++)] ++;\n\npHashKey = pString;\nwhile (*pHashKey != '\\0' )\n{\nif (hashTable[*pHashKey] == 1)\nreturn *pHashKey;\n\npHashKey++;\n}\n\nreturn '\\0' ;\n}\n\nIn the code above, it costs O(1) time to increase the occurrence time for each character. The time complexity for the first scanning is O(n) if the length of string is n. It takes O(1) time to get the occurrence time for each character, so it costs O(n) time for the second scanning. Therefore, the overall time it costs is O(n).\n\nIn the meantime, an array with 256 numbers is created, whose size is 1K. Since the size of array is constant, the space complexity of this algorithm is O(1).", "question": "\nProblem: Implement a function to find the first character in a string which only appears once.\nFor example: It returns \u2018b\u2019 when the input is \u201cabaccdeff\u201d.\n"},
{"answer": "\nAnalysis: Our native solution for this problem may be scanning the input string from its beginning to end. We compare the current scanned character with every one behind it. If there is no duplication after it, it is a character appearing once. Since it compares each character with O(n) ones behind it, the overall time complexity is O(n 2 ) if there are n characters in a string.\n\nIn order to get the numbers of occurrence times of each character in a string, a data container is needed. It is required to get and update the occurrence time of each character in a string, so the data container is used to project a character to a number. Hash tables fulfill this kind of requirement. We can implement a hash table, in which keys are characters and values are their occurrence times in a string.\n\nIt is necessary to scan strings twice: When a character is visited, we increase the corresponding occurrence time in the hash table during the first scanning. In second round of scanning, whenever a character is visited we also check its occurrence time in the hash table. The first character with occurrence time 1 is the required output.\n\nHash tables are complex, and they are not implemented in the C++ standard template library. Therefore, we have to implement one by ourselves.\n\nCharacters have 8 bits, so there only 256 variances. We can create an array with 255 numbers, in which indexes are ASCII values of all characters, and numbers are their occurrence times in a string. That is to say, we have a hash table whose size if 256, with ASCII values of characters as keys.\n\nIt is time for programming after we get a clear solution. The following are some sample code:\n\nchar FirstNotRepeatingChar( char * pString)\n{\nif (pString == NULL)\nreturn '\\0' ;\n\nconst int tableSize = 256;\nunsigned int hashTable[tableSize];\nfor ( unsigned int i = 0; i<tableSize; ++ i)\nhashTable[i] = 0;\n\nchar * pHashKey = pString;\nwhile (*(pHashKey) != '\\0' )\nhashTable[*(pHashKey++)] ++;\n\npHashKey = pString;\nwhile (*pHashKey != '\\0' )\n{\nif (hashTable[*pHashKey] == 1)\nreturn *pHashKey;\n\npHashKey++;\n}\n\nreturn '\\0' ;\n}\n\nIn the code above, it costs O(1) time to increase the occurrence time for each character. The time complexity for the first scanning is O(n) if the length of string is n. It takes O(1) time to get the occurrence time for each character, so it costs O(n) time for the second scanning. Therefore, the overall time it costs is O(n).\n\nIn the meantime, an array with 256 numbers is created, whose size is 1K. Since the size of array is constant, the space complexity of this algorithm is O(1).", "question": "\nProblem: Implement a function to find the first character in a string which only appears once.\nFor example: It returns \u2018b\u2019 when the input is \u201cabaccdeff\u201d.\n"},
{"answer": "\nAnalysis: Our native solution for this problem may be scanning the input string from its beginning to end. We compare the current scanned character with every one behind it. If there is no duplication after it, it is a character appearing once. Since it compares each character with O(n) ones behind it, the overall time complexity is O(n 2 ) if there are n characters in a string.\n\nIn order to get the numbers of occurrence times of each character in a string, a data container is needed. It is required to get and update the occurrence time of each character in a string, so the data container is used to project a character to a number. Hash tables fulfill this kind of requirement. We can implement a hash table, in which keys are characters and values are their occurrence times in a string.\n\nIt is necessary to scan strings twice: When a character is visited, we increase the corresponding occurrence time in the hash table during the first scanning. In second round of scanning, whenever a character is visited we also check its occurrence time in the hash table. The first character with occurrence time 1 is the required output.\n\nHash tables are complex, and they are not implemented in the C++ standard template library. Therefore, we have to implement one by ourselves.\n\nCharacters have 8 bits, so there only 256 variances. We can create an array with 255 numbers, in which indexes are ASCII values of all characters, and numbers are their occurrence times in a string. That is to say, we have a hash table whose size if 256, with ASCII values of characters as keys.\n\nIt is time for programming after we get a clear solution. The following are some sample code:\n\nchar FirstNotRepeatingChar( char * pString)\n{\nif (pString == NULL)\nreturn '\\0' ;\n\nconst int tableSize = 256;\nunsigned int hashTable[tableSize];\nfor ( unsigned int i = 0; i<tableSize; ++ i)\nhashTable[i] = 0;\n\nchar * pHashKey = pString;\nwhile (*(pHashKey) != '\\0' )\nhashTable[*(pHashKey++)] ++;\n\npHashKey = pString;\nwhile (*pHashKey != '\\0' )\n{\nif (hashTable[*pHashKey] == 1)\nreturn *pHashKey;\n\npHashKey++;\n}\n\nreturn '\\0' ;\n}\n\nIn the code above, it costs O(1) time to increase the occurrence time for each character. The time complexity for the first scanning is O(n) if the length of string is n. It takes O(1) time to get the occurrence time for each character, so it costs O(n) time for the second scanning. Therefore, the overall time it costs is O(n).\n\nIn the meantime, an array with 256 numbers is created, whose size is 1K. Since the size of array is constant, the space complexity of this algorithm is O(1).", "question": "\nProblem: Implement a function to find the first character in a string which only appears once.\nFor example: It returns \u2018b\u2019 when the input is \u201cabaccdeff\u201d.\n"},
{"answer": "\nAnalysis: Our native solution for this problem may be scanning the input string from its beginning to end. We compare the current scanned character with every one behind it. If there is no duplication after it, it is a character appearing once. Since it compares each character with O(n) ones behind it, the overall time complexity is O(n 2 ) if there are n characters in a string.\n\nIn order to get the numbers of occurrence times of each character in a string, a data container is needed. It is required to get and update the occurrence time of each character in a string, so the data container is used to project a character to a number. Hash tables fulfill this kind of requirement. We can implement a hash table, in which keys are characters and values are their occurrence times in a string.\n\nIt is necessary to scan strings twice: When a character is visited, we increase the corresponding occurrence time in the hash table during the first scanning. In second round of scanning, whenever a character is visited we also check its occurrence time in the hash table. The first character with occurrence time 1 is the required output.\n\nHash tables are complex, and they are not implemented in the C++ standard template library. Therefore, we have to implement one by ourselves.\n\nCharacters have 8 bits, so there only 256 variances. We can create an array with 255 numbers, in which indexes are ASCII values of all characters, and numbers are their occurrence times in a string. That is to say, we have a hash table whose size if 256, with ASCII values of characters as keys.\n\nIt is time for programming after we get a clear solution. The following are some sample code:\n\nchar FirstNotRepeatingChar( char * pString)\n{\nif (pString == NULL)\nreturn '\\0' ;\n\nconst int tableSize = 256;\nunsigned int hashTable[tableSize];\nfor ( unsigned int i = 0; i<tableSize; ++ i)\nhashTable[i] = 0;\n\nchar * pHashKey = pString;\nwhile (*(pHashKey) != '\\0' )\nhashTable[*(pHashKey++)] ++;\n\npHashKey = pString;\nwhile (*pHashKey != '\\0' )\n{\nif (hashTable[*pHashKey] == 1)\nreturn *pHashKey;\n\npHashKey++;\n}\n\nreturn '\\0' ;\n}\n\nIn the code above, it costs O(1) time to increase the occurrence time for each character. The time complexity for the first scanning is O(n) if the length of string is n. It takes O(1) time to get the occurrence time for each character, so it costs O(n) time for the second scanning. Therefore, the overall time it costs is O(n).\n\nIn the meantime, an array with 256 numbers is created, whose size is 1K. Since the size of array is constant, the space complexity of this algorithm is O(1).", "question": "\nProblem: Implement a function to find the first character in a string which only appears once.\nFor example: It returns \u2018b\u2019 when the input is \u201cabaccdeff\u201d.\n"},
{"answer": "\nAnalysis: Our native solution for this problem may be scanning the input string from its beginning to end. We compare the current scanned character with every one behind it. If there is no duplication after it, it is a character appearing once. Since it compares each character with O(n) ones behind it, the overall time complexity is O(n 2 ) if there are n characters in a string.\n\nIn order to get the numbers of occurrence times of each character in a string, a data container is needed. It is required to get and update the occurrence time of each character in a string, so the data container is used to project a character to a number. Hash tables fulfill this kind of requirement. We can implement a hash table, in which keys are characters and values are their occurrence times in a string.\n\nIt is necessary to scan strings twice: When a character is visited, we increase the corresponding occurrence time in the hash table during the first scanning. In second round of scanning, whenever a character is visited we also check its occurrence time in the hash table. The first character with occurrence time 1 is the required output.\n\nHash tables are complex, and they are not implemented in the C++ standard template library. Therefore, we have to implement one by ourselves.\n\nCharacters have 8 bits, so there only 256 variances. We can create an array with 255 numbers, in which indexes are ASCII values of all characters, and numbers are their occurrence times in a string. That is to say, we have a hash table whose size if 256, with ASCII values of characters as keys.\n\nIt is time for programming after we get a clear solution. The following are some sample code:\n\nchar FirstNotRepeatingChar( char * pString)\n{\nif (pString == NULL)\nreturn '\\0' ;\n\nconst int tableSize = 256;\nunsigned int hashTable[tableSize];\nfor ( unsigned int i = 0; i<tableSize; ++ i)\nhashTable[i] = 0;\n\nchar * pHashKey = pString;\nwhile (*(pHashKey) != '\\0' )\nhashTable[*(pHashKey++)] ++;\n\npHashKey = pString;\nwhile (*pHashKey != '\\0' )\n{\nif (hashTable[*pHashKey] == 1)\nreturn *pHashKey;\n\npHashKey++;\n}\n\nreturn '\\0' ;\n}\n\nIn the code above, it costs O(1) time to increase the occurrence time for each character. The time complexity for the first scanning is O(n) if the length of string is n. It takes O(1) time to get the occurrence time for each character, so it costs O(n) time for the second scanning. Therefore, the overall time it costs is O(n).\n\nIn the meantime, an array with 256 numbers is created, whose size is 1K. Since the size of array is constant, the space complexity of this algorithm is O(1).", "question": "\nProblem: Implement a function to find the first character in a string which only appears once.\nFor example: It returns \u2018b\u2019 when the input is \u201cabaccdeff\u201d.\n"},
{"answer": "\nAnalysis: We try to get the maximum length of all increasing subsequences ending with each element in the array.\n\nFor instance, when we analyze the maximum length of all increasing subsequences ending with number 5, we compare it with each number before it. The first number 7 is greater than 5. If the subsequence comes from 7, 7 cannot be included into the subsequence. Therefore, its length is 1. The following three numbers 2, 3 and 1 in the input array before 5 are less than 5. If the previous number of 5 in the increasing subsequence is 2, the maximum incremental length is 2. If the previous number of 5 in the increasing subsequence is 3, the maximum incremental length is 3 (with number 2, 3, and 5) since the maximum length of all subsequences ending with number 3 is 2 (with number 2 and 3). Similarly, its maximum length is 2 if the previous number is number 1. The whole process can be summarized in Table 1.\n\n7 2 3 1 5 8 9 6 7 1 NA NA NA NA NA NA NA 2 1 1 NA NA NA NA NA NA 3 1 2 1 NA NA NA NA NA 1 1 1 1 1 NA NA NA NA 5 1 2 3 2 1 NA NA NA 8 2 2 3 2 4 1 NA NA 9 2 2 3 2 4 5 1 NA 6 1 2 3 2 4 1 1 1\n\n7\n2\n3\n1\n5\n8\n9\n6\n7\n1\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n2\n1\n1\nNA\nNA\nNA\nNA\nNA\nNA\n3\n1\n2\n1\nNA\nNA\nNA\nNA\nNA\n1\n1\n1\n1\n1\nNA\nNA\nNA\nNA\n5\n1\n2\n3\n2\n1\nNA\nNA\nNA\n8\n2\n2\n3\n2\n4\n1\nNA\nNA\n9\n2\n2\n3\n2\n4\n5\n1\nNA\n6\n1\n2\n3\n2\n4\n1\n1\n1\nTable 1: Process to get the maximum length of increasing subsequences in array {7, 2, 3, 1, 5, 8, 9, 6}. Numbers in each row indicate length of subsequences ending with row title with previous number in the column title. Highlighted numbers with yellow background are the maximum lengths. \u00a0The highlighted number 5 with yellow background and red font is the maximum length of all incremental subsequences in the input array.\n\nWe are ready to write code with the detailed analysis above. The following is sample code:\n\nint LengthOfIncreasing( int * data, int length)\n{\nif (data == NULL || length < 0)\nreturn 0;\n\nint * longest = new int [length];\nlongest[0] = 1;\n\nint max = 0;\nfor ( int i = 1; i < length; ++ i)\n{\nmax = 0;\nfor ( int j = 0; j < i; ++ j)\n{\nif (data[j] < data[i] && longest[j] > max)\nmax = longest[j];\n}\n\nlongest[i] = max + 1;\n}\n\nmax = 0;\nfor ( int i = 0; i < length; ++ i)\nif (longest[i] > max)\nmax = longest[i];\n\nreturn max;\n}\n\nEven though a 2-D matrix is needed to analyze the process, only a 1-D array is necessary in our code to store the maximum length of subsequences ending with each number in the input array.\n\nIf we are familiar with dynamic programming, we can get a direct solution quickly in a formal way. We can define a function f(i) indicating the maximum length of all subsequences ending with the i th number in the input array (denoted as A[i]). We define another function g(i, j) which stands for the maximum length of incremental subsequences ending with A[i] coming from A[j]. The required output is max(f(i)) where 0<=i<n and n is the length of array. We can get f(i) with the following equation:\n\n\nActually, same code will be implemented based on this equation. The function f(i) is longest[i] in the code above. Therefore, it is identical to the previous solution.", "question": "\nProblem: Given an unsorted array, find the max length of subsequence in which the numbers are in incremental order.\n\nFor example: If the input array is {7, 2, 3, 1, 5, 8, 9, 6}, a subsequence with the most numbers in incremental order is {2, 3, 5, 8, 9} and the expected output is 5.\n"},
{"answer": "\nAnalysis: We try to get the maximum length of all increasing subsequences ending with each element in the array.\n\nFor instance, when we analyze the maximum length of all increasing subsequences ending with number 5, we compare it with each number before it. The first number 7 is greater than 5. If the subsequence comes from 7, 7 cannot be included into the subsequence. Therefore, its length is 1. The following three numbers 2, 3 and 1 in the input array before 5 are less than 5. If the previous number of 5 in the increasing subsequence is 2, the maximum incremental length is 2. If the previous number of 5 in the increasing subsequence is 3, the maximum incremental length is 3 (with number 2, 3, and 5) since the maximum length of all subsequences ending with number 3 is 2 (with number 2 and 3). Similarly, its maximum length is 2 if the previous number is number 1. The whole process can be summarized in Table 1.\n\n7 2 3 1 5 8 9 6 7 1 NA NA NA NA NA NA NA 2 1 1 NA NA NA NA NA NA 3 1 2 1 NA NA NA NA NA 1 1 1 1 1 NA NA NA NA 5 1 2 3 2 1 NA NA NA 8 2 2 3 2 4 1 NA NA 9 2 2 3 2 4 5 1 NA 6 1 2 3 2 4 1 1 1\n\n7\n2\n3\n1\n5\n8\n9\n6\n7\n1\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n2\n1\n1\nNA\nNA\nNA\nNA\nNA\nNA\n3\n1\n2\n1\nNA\nNA\nNA\nNA\nNA\n1\n1\n1\n1\n1\nNA\nNA\nNA\nNA\n5\n1\n2\n3\n2\n1\nNA\nNA\nNA\n8\n2\n2\n3\n2\n4\n1\nNA\nNA\n9\n2\n2\n3\n2\n4\n5\n1\nNA\n6\n1\n2\n3\n2\n4\n1\n1\n1\nTable 1: Process to get the maximum length of increasing subsequences in array {7, 2, 3, 1, 5, 8, 9, 6}. Numbers in each row indicate length of subsequences ending with row title with previous number in the column title. Highlighted numbers with yellow background are the maximum lengths. \u00a0The highlighted number 5 with yellow background and red font is the maximum length of all incremental subsequences in the input array.\n\nWe are ready to write code with the detailed analysis above. The following is sample code:\n\nint LengthOfIncreasing( int * data, int length)\n{\nif (data == NULL || length < 0)\nreturn 0;\n\nint * longest = new int [length];\nlongest[0] = 1;\n\nint max = 0;\nfor ( int i = 1; i < length; ++ i)\n{\nmax = 0;\nfor ( int j = 0; j < i; ++ j)\n{\nif (data[j] < data[i] && longest[j] > max)\nmax = longest[j];\n}\n\nlongest[i] = max + 1;\n}\n\nmax = 0;\nfor ( int i = 0; i < length; ++ i)\nif (longest[i] > max)\nmax = longest[i];\n\nreturn max;\n}\n\nEven though a 2-D matrix is needed to analyze the process, only a 1-D array is necessary in our code to store the maximum length of subsequences ending with each number in the input array.\n\nIf we are familiar with dynamic programming, we can get a direct solution quickly in a formal way. We can define a function f(i) indicating the maximum length of all subsequences ending with the i th number in the input array (denoted as A[i]). We define another function g(i, j) which stands for the maximum length of incremental subsequences ending with A[i] coming from A[j]. The required output is max(f(i)) where 0<=i<n and n is the length of array. We can get f(i) with the following equation:\n\n\nActually, same code will be implemented based on this equation. The function f(i) is longest[i] in the code above. Therefore, it is identical to the previous solution.", "question": "\nProblem: Given an unsorted array, find the max length of subsequence in which the numbers are in incremental order.\n\nFor example: If the input array is {7, 2, 3, 1, 5, 8, 9, 6}, a subsequence with the most numbers in incremental order is {2, 3, 5, 8, 9} and the expected output is 5.\n"},
{"answer": "\nAnalysis: We try to get the maximum length of all increasing subsequences ending with each element in the array.\n\nFor instance, when we analyze the maximum length of all increasing subsequences ending with number 5, we compare it with each number before it. The first number 7 is greater than 5. If the subsequence comes from 7, 7 cannot be included into the subsequence. Therefore, its length is 1. The following three numbers 2, 3 and 1 in the input array before 5 are less than 5. If the previous number of 5 in the increasing subsequence is 2, the maximum incremental length is 2. If the previous number of 5 in the increasing subsequence is 3, the maximum incremental length is 3 (with number 2, 3, and 5) since the maximum length of all subsequences ending with number 3 is 2 (with number 2 and 3). Similarly, its maximum length is 2 if the previous number is number 1. The whole process can be summarized in Table 1.\n\n7 2 3 1 5 8 9 6 7 1 NA NA NA NA NA NA NA 2 1 1 NA NA NA NA NA NA 3 1 2 1 NA NA NA NA NA 1 1 1 1 1 NA NA NA NA 5 1 2 3 2 1 NA NA NA 8 2 2 3 2 4 1 NA NA 9 2 2 3 2 4 5 1 NA 6 1 2 3 2 4 1 1 1\n\n7\n2\n3\n1\n5\n8\n9\n6\n7\n1\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n2\n1\n1\nNA\nNA\nNA\nNA\nNA\nNA\n3\n1\n2\n1\nNA\nNA\nNA\nNA\nNA\n1\n1\n1\n1\n1\nNA\nNA\nNA\nNA\n5\n1\n2\n3\n2\n1\nNA\nNA\nNA\n8\n2\n2\n3\n2\n4\n1\nNA\nNA\n9\n2\n2\n3\n2\n4\n5\n1\nNA\n6\n1\n2\n3\n2\n4\n1\n1\n1\nTable 1: Process to get the maximum length of increasing subsequences in array {7, 2, 3, 1, 5, 8, 9, 6}. Numbers in each row indicate length of subsequences ending with row title with previous number in the column title. Highlighted numbers with yellow background are the maximum lengths. \u00a0The highlighted number 5 with yellow background and red font is the maximum length of all incremental subsequences in the input array.\n\nWe are ready to write code with the detailed analysis above. The following is sample code:\n\nint LengthOfIncreasing( int * data, int length)\n{\nif (data == NULL || length < 0)\nreturn 0;\n\nint * longest = new int [length];\nlongest[0] = 1;\n\nint max = 0;\nfor ( int i = 1; i < length; ++ i)\n{\nmax = 0;\nfor ( int j = 0; j < i; ++ j)\n{\nif (data[j] < data[i] && longest[j] > max)\nmax = longest[j];\n}\n\nlongest[i] = max + 1;\n}\n\nmax = 0;\nfor ( int i = 0; i < length; ++ i)\nif (longest[i] > max)\nmax = longest[i];\n\nreturn max;\n}\n\nEven though a 2-D matrix is needed to analyze the process, only a 1-D array is necessary in our code to store the maximum length of subsequences ending with each number in the input array.\n\nIf we are familiar with dynamic programming, we can get a direct solution quickly in a formal way. We can define a function f(i) indicating the maximum length of all subsequences ending with the i th number in the input array (denoted as A[i]). We define another function g(i, j) which stands for the maximum length of incremental subsequences ending with A[i] coming from A[j]. The required output is max(f(i)) where 0<=i<n and n is the length of array. We can get f(i) with the following equation:\n\n\nActually, same code will be implemented based on this equation. The function f(i) is longest[i] in the code above. Therefore, it is identical to the previous solution.", "question": "\nProblem: Given an unsorted array, find the max length of subsequence in which the numbers are in incremental order.\n\nFor example: If the input array is {7, 2, 3, 1, 5, 8, 9, 6}, a subsequence with the most numbers in incremental order is {2, 3, 5, 8, 9} and the expected output is 5.\n"},
{"answer": "\nAnalysis: We try to get the maximum length of all increasing subsequences ending with each element in the array.\n\nFor instance, when we analyze the maximum length of all increasing subsequences ending with number 5, we compare it with each number before it. The first number 7 is greater than 5. If the subsequence comes from 7, 7 cannot be included into the subsequence. Therefore, its length is 1. The following three numbers 2, 3 and 1 in the input array before 5 are less than 5. If the previous number of 5 in the increasing subsequence is 2, the maximum incremental length is 2. If the previous number of 5 in the increasing subsequence is 3, the maximum incremental length is 3 (with number 2, 3, and 5) since the maximum length of all subsequences ending with number 3 is 2 (with number 2 and 3). Similarly, its maximum length is 2 if the previous number is number 1. The whole process can be summarized in Table 1.\n\n7 2 3 1 5 8 9 6 7 1 NA NA NA NA NA NA NA 2 1 1 NA NA NA NA NA NA 3 1 2 1 NA NA NA NA NA 1 1 1 1 1 NA NA NA NA 5 1 2 3 2 1 NA NA NA 8 2 2 3 2 4 1 NA NA 9 2 2 3 2 4 5 1 NA 6 1 2 3 2 4 1 1 1\n\n7\n2\n3\n1\n5\n8\n9\n6\n7\n1\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n2\n1\n1\nNA\nNA\nNA\nNA\nNA\nNA\n3\n1\n2\n1\nNA\nNA\nNA\nNA\nNA\n1\n1\n1\n1\n1\nNA\nNA\nNA\nNA\n5\n1\n2\n3\n2\n1\nNA\nNA\nNA\n8\n2\n2\n3\n2\n4\n1\nNA\nNA\n9\n2\n2\n3\n2\n4\n5\n1\nNA\n6\n1\n2\n3\n2\n4\n1\n1\n1\nTable 1: Process to get the maximum length of increasing subsequences in array {7, 2, 3, 1, 5, 8, 9, 6}. Numbers in each row indicate length of subsequences ending with row title with previous number in the column title. Highlighted numbers with yellow background are the maximum lengths. \u00a0The highlighted number 5 with yellow background and red font is the maximum length of all incremental subsequences in the input array.\n\nWe are ready to write code with the detailed analysis above. The following is sample code:\n\nint LengthOfIncreasing( int * data, int length)\n{\nif (data == NULL || length < 0)\nreturn 0;\n\nint * longest = new int [length];\nlongest[0] = 1;\n\nint max = 0;\nfor ( int i = 1; i < length; ++ i)\n{\nmax = 0;\nfor ( int j = 0; j < i; ++ j)\n{\nif (data[j] < data[i] && longest[j] > max)\nmax = longest[j];\n}\n\nlongest[i] = max + 1;\n}\n\nmax = 0;\nfor ( int i = 0; i < length; ++ i)\nif (longest[i] > max)\nmax = longest[i];\n\nreturn max;\n}\n\nEven though a 2-D matrix is needed to analyze the process, only a 1-D array is necessary in our code to store the maximum length of subsequences ending with each number in the input array.\n\nIf we are familiar with dynamic programming, we can get a direct solution quickly in a formal way. We can define a function f(i) indicating the maximum length of all subsequences ending with the i th number in the input array (denoted as A[i]). We define another function g(i, j) which stands for the maximum length of incremental subsequences ending with A[i] coming from A[j]. The required output is max(f(i)) where 0<=i<n and n is the length of array. We can get f(i) with the following equation:\n\n\nActually, same code will be implemented based on this equation. The function f(i) is longest[i] in the code above. Therefore, it is identical to the previous solution.", "question": "\nProblem: Given an unsorted array, find the max length of subsequence in which the numbers are in incremental order.\n\nFor example: If the input array is {7, 2, 3, 1, 5, 8, 9, 6}, a subsequence with the most numbers in incremental order is {2, 3, 5, 8, 9} and the expected output is 5.\n"},
{"answer": "\nAnalysis: We try to get the maximum length of all increasing subsequences ending with each element in the array.\n\nFor instance, when we analyze the maximum length of all increasing subsequences ending with number 5, we compare it with each number before it. The first number 7 is greater than 5. If the subsequence comes from 7, 7 cannot be included into the subsequence. Therefore, its length is 1. The following three numbers 2, 3 and 1 in the input array before 5 are less than 5. If the previous number of 5 in the increasing subsequence is 2, the maximum incremental length is 2. If the previous number of 5 in the increasing subsequence is 3, the maximum incremental length is 3 (with number 2, 3, and 5) since the maximum length of all subsequences ending with number 3 is 2 (with number 2 and 3). Similarly, its maximum length is 2 if the previous number is number 1. The whole process can be summarized in Table 1.\n\n7 2 3 1 5 8 9 6 7 1 NA NA NA NA NA NA NA 2 1 1 NA NA NA NA NA NA 3 1 2 1 NA NA NA NA NA 1 1 1 1 1 NA NA NA NA 5 1 2 3 2 1 NA NA NA 8 2 2 3 2 4 1 NA NA 9 2 2 3 2 4 5 1 NA 6 1 2 3 2 4 1 1 1\n\n7\n2\n3\n1\n5\n8\n9\n6\n7\n1\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n2\n1\n1\nNA\nNA\nNA\nNA\nNA\nNA\n3\n1\n2\n1\nNA\nNA\nNA\nNA\nNA\n1\n1\n1\n1\n1\nNA\nNA\nNA\nNA\n5\n1\n2\n3\n2\n1\nNA\nNA\nNA\n8\n2\n2\n3\n2\n4\n1\nNA\nNA\n9\n2\n2\n3\n2\n4\n5\n1\nNA\n6\n1\n2\n3\n2\n4\n1\n1\n1\nTable 1: Process to get the maximum length of increasing subsequences in array {7, 2, 3, 1, 5, 8, 9, 6}. Numbers in each row indicate length of subsequences ending with row title with previous number in the column title. Highlighted numbers with yellow background are the maximum lengths. \u00a0The highlighted number 5 with yellow background and red font is the maximum length of all incremental subsequences in the input array.\n\nWe are ready to write code with the detailed analysis above. The following is sample code:\n\nint LengthOfIncreasing( int * data, int length)\n{\nif (data == NULL || length < 0)\nreturn 0;\n\nint * longest = new int [length];\nlongest[0] = 1;\n\nint max = 0;\nfor ( int i = 1; i < length; ++ i)\n{\nmax = 0;\nfor ( int j = 0; j < i; ++ j)\n{\nif (data[j] < data[i] && longest[j] > max)\nmax = longest[j];\n}\n\nlongest[i] = max + 1;\n}\n\nmax = 0;\nfor ( int i = 0; i < length; ++ i)\nif (longest[i] > max)\nmax = longest[i];\n\nreturn max;\n}\n\nEven though a 2-D matrix is needed to analyze the process, only a 1-D array is necessary in our code to store the maximum length of subsequences ending with each number in the input array.\n\nIf we are familiar with dynamic programming, we can get a direct solution quickly in a formal way. We can define a function f(i) indicating the maximum length of all subsequences ending with the i th number in the input array (denoted as A[i]). We define another function g(i, j) which stands for the maximum length of incremental subsequences ending with A[i] coming from A[j]. The required output is max(f(i)) where 0<=i<n and n is the length of array. We can get f(i) with the following equation:\n\n\nActually, same code will be implemented based on this equation. The function f(i) is longest[i] in the code above. Therefore, it is identical to the previous solution.", "question": "\nProblem: Given an unsorted array, find the max length of subsequence in which the numbers are in incremental order.\n\nFor example: If the input array is {7, 2, 3, 1, 5, 8, 9, 6}, a subsequence with the most numbers in incremental order is {2, 3, 5, 8, 9} and the expected output is 5.\n"},
{"answer": "\nAnalysis: We try to get the maximum length of all increasing subsequences ending with each element in the array.\n\nFor instance, when we analyze the maximum length of all increasing subsequences ending with number 5, we compare it with each number before it. The first number 7 is greater than 5. If the subsequence comes from 7, 7 cannot be included into the subsequence. Therefore, its length is 1. The following three numbers 2, 3 and 1 in the input array before 5 are less than 5. If the previous number of 5 in the increasing subsequence is 2, the maximum incremental length is 2. If the previous number of 5 in the increasing subsequence is 3, the maximum incremental length is 3 (with number 2, 3, and 5) since the maximum length of all subsequences ending with number 3 is 2 (with number 2 and 3). Similarly, its maximum length is 2 if the previous number is number 1. The whole process can be summarized in Table 1.\n\n7 2 3 1 5 8 9 6 7 1 NA NA NA NA NA NA NA 2 1 1 NA NA NA NA NA NA 3 1 2 1 NA NA NA NA NA 1 1 1 1 1 NA NA NA NA 5 1 2 3 2 1 NA NA NA 8 2 2 3 2 4 1 NA NA 9 2 2 3 2 4 5 1 NA 6 1 2 3 2 4 1 1 1\n\n7\n2\n3\n1\n5\n8\n9\n6\n7\n1\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n2\n1\n1\nNA\nNA\nNA\nNA\nNA\nNA\n3\n1\n2\n1\nNA\nNA\nNA\nNA\nNA\n1\n1\n1\n1\n1\nNA\nNA\nNA\nNA\n5\n1\n2\n3\n2\n1\nNA\nNA\nNA\n8\n2\n2\n3\n2\n4\n1\nNA\nNA\n9\n2\n2\n3\n2\n4\n5\n1\nNA\n6\n1\n2\n3\n2\n4\n1\n1\n1\nTable 1: Process to get the maximum length of increasing subsequences in array {7, 2, 3, 1, 5, 8, 9, 6}. Numbers in each row indicate length of subsequences ending with row title with previous number in the column title. Highlighted numbers with yellow background are the maximum lengths. \u00a0The highlighted number 5 with yellow background and red font is the maximum length of all incremental subsequences in the input array.\n\nWe are ready to write code with the detailed analysis above. The following is sample code:\n\nint LengthOfIncreasing( int * data, int length)\n{\nif (data == NULL || length < 0)\nreturn 0;\n\nint * longest = new int [length];\nlongest[0] = 1;\n\nint max = 0;\nfor ( int i = 1; i < length; ++ i)\n{\nmax = 0;\nfor ( int j = 0; j < i; ++ j)\n{\nif (data[j] < data[i] && longest[j] > max)\nmax = longest[j];\n}\n\nlongest[i] = max + 1;\n}\n\nmax = 0;\nfor ( int i = 0; i < length; ++ i)\nif (longest[i] > max)\nmax = longest[i];\n\nreturn max;\n}\n\nEven though a 2-D matrix is needed to analyze the process, only a 1-D array is necessary in our code to store the maximum length of subsequences ending with each number in the input array.\n\nIf we are familiar with dynamic programming, we can get a direct solution quickly in a formal way. We can define a function f(i) indicating the maximum length of all subsequences ending with the i th number in the input array (denoted as A[i]). We define another function g(i, j) which stands for the maximum length of incremental subsequences ending with A[i] coming from A[j]. The required output is max(f(i)) where 0<=i<n and n is the length of array. We can get f(i) with the following equation:\n\n\nActually, same code will be implemented based on this equation. The function f(i) is longest[i] in the code above. Therefore, it is identical to the previous solution.", "question": "\nProblem: Given an unsorted array, find the max length of subsequence in which the numbers are in incremental order.\n\nFor example: If the input array is {7, 2, 3, 1, 5, 8, 9, 6}, a subsequence with the most numbers in incremental order is {2, 3, 5, 8, 9} and the expected output is 5.\n"},
{"answer": "\nAnalysis: It looks like a simple question about binary numbers, and we have many solutions for it. Unfortunately, the most intuitive solution for many candidates is incorrect. We should be careful.\n\nSolution 1: Check the most right bit, possibly with endless loop\n\nWhen candidates are interviewed with this problem, many of them find a solution in short time: check whether the most right bit is 0 or 1, and then right shit the integer one bit and check the most right bit again. It continues in a loop until the integer becomes 0. How to check whether the most right bit of an integer is 0 or 1? It is simple since we have AND operation. There is only one bit of 1, which is the most right bit, in the binary format of integer 1. When we have AND operation on an integer and 1, we can check whether the most right bit is 0 or 1. When the result of AND operation is 1, it indicates the right most bit is 1; otherwise it is 0. We can implement a function base on this solution quickly:\n\nint NumberOf1( int n ) { int count = 0; while ( n ) { if ( n & 1) count ++; n = n >> 1; } return count; }\n\nInterviewers may ask a question when they are told this solution: What is the result when the input integer is a negative number such as 0x80000000? When we right shift the negative number 0x80000000 a bit, it become 0xC0000000 rather than 0x40000000, which is the result to move the first bit of 1 to the second bit. The integer 0x8000000 is negative before shift, so we should guarantee it is also negative after shift. Therefore, when a negative integer is right shifted, the first bit is set as 1 after the right shift operation. If we continue to shift to right side, a negative integer will be 0xFFFFFFFF eventually and it is trapped in an endless loop.\n\nSolution 2: Check the most right bit, with left shift operation on 1\n\nWe should not right shift the input integer to avoid endless loop. Instead of shifting the input integer n to right, we may shift the number 1 to left. We may check firstly the least important bit of n , and then shift the number 1 to left, and continue to check the second least important bit of n . Now we can rewrite our code based on this solution:\n\nint NumberOf1( int n)\n{\nint count = 0;\nunsigned int flag = 1;\nwhile (flag)\n{\nif (n & flag)\ncount ++;\n\nflag = flag << 1;\n}\n\nreturn count;\n}\n\nIn the code above, it loops 32 times on 32-bit numbers.\n\nSolution 3: Creative solution\n\nLet us analyze that what happens when a number minus 1. There is at least one bit 1 in a non-zero number. We firstly assume the right most bit is 1. It becomes 0 if the number minus 1 and other bits keep unchanged. This result is identical to the not operation on the most right bit of a number, which also turns the right most bit from 1 into 0.\n\nSecondly we assume the right most bit is 0. Since there is at least one bit 1 in a non-zero number, we suppose the m th bit is the most right bit of 1. When it minus 1, the m th bit becomes 0, and all 0 bits behind the m th bit become 1. For instance, the second bit of binary number 1100 is the most right bit of 1. When it minus 1, the second bit becomes 0, and the third and fourth bits become 1, so the result is 1011.\n\nIn both situations above, the most right of bit 1 becomes 0 when it minus 1. When there are some 0 bits at right side, all of them become 1. The result of bit and operation on the original number and minus result is identical to result to modify the most right 1 into 0. Take the binary number 1100 as an example again. Its result is 1011 when it minus 1. The result of and operation on 1100 and 1011 is 1000. If we change the most right of 1 bit in number 1100, it also becomes 1000.\n\nThe analysis can be summarized as: If we first minus a number with 1, and have and operation on the original number and the minus result, the most right of 1 bit becomes 0. We continue these operations until the number becomes 0. We can develop the following code accordingly:\n\nint NumberOf1( int n)\n{\nint count = 0;\n\nwhile (n)\n{\n++ count;\nn = (n - 1) & n;\n}\n\nreturn count;\n}\n\nThe number of times in the while loops equals to the number of 1 in the binary format of input n .", "question": "\nProblem: Please implement a function to get the number of 1s in an integer. For example, the integer 9 is 1001 in binary, so it returns 2 since there are two bits of 1s.\n"},
{"answer": "\nAnalysis: It looks like a simple question about binary numbers, and we have many solutions for it. Unfortunately, the most intuitive solution for many candidates is incorrect. We should be careful.\n\nSolution 1: Check the most right bit, possibly with endless loop\n\nWhen candidates are interviewed with this problem, many of them find a solution in short time: check whether the most right bit is 0 or 1, and then right shit the integer one bit and check the most right bit again. It continues in a loop until the integer becomes 0. How to check whether the most right bit of an integer is 0 or 1? It is simple since we have AND operation. There is only one bit of 1, which is the most right bit, in the binary format of integer 1. When we have AND operation on an integer and 1, we can check whether the most right bit is 0 or 1. When the result of AND operation is 1, it indicates the right most bit is 1; otherwise it is 0. We can implement a function base on this solution quickly:\n\nint NumberOf1( int n ) { int count = 0; while ( n ) { if ( n & 1) count ++; n = n >> 1; } return count; }\n\nInterviewers may ask a question when they are told this solution: What is the result when the input integer is a negative number such as 0x80000000? When we right shift the negative number 0x80000000 a bit, it become 0xC0000000 rather than 0x40000000, which is the result to move the first bit of 1 to the second bit. The integer 0x8000000 is negative before shift, so we should guarantee it is also negative after shift. Therefore, when a negative integer is right shifted, the first bit is set as 1 after the right shift operation. If we continue to shift to right side, a negative integer will be 0xFFFFFFFF eventually and it is trapped in an endless loop.\n\nSolution 2: Check the most right bit, with left shift operation on 1\n\nWe should not right shift the input integer to avoid endless loop. Instead of shifting the input integer n to right, we may shift the number 1 to left. We may check firstly the least important bit of n , and then shift the number 1 to left, and continue to check the second least important bit of n . Now we can rewrite our code based on this solution:\n\nint NumberOf1( int n)\n{\nint count = 0;\nunsigned int flag = 1;\nwhile (flag)\n{\nif (n & flag)\ncount ++;\n\nflag = flag << 1;\n}\n\nreturn count;\n}\n\nIn the code above, it loops 32 times on 32-bit numbers.\n\nSolution 3: Creative solution\n\nLet us analyze that what happens when a number minus 1. There is at least one bit 1 in a non-zero number. We firstly assume the right most bit is 1. It becomes 0 if the number minus 1 and other bits keep unchanged. This result is identical to the not operation on the most right bit of a number, which also turns the right most bit from 1 into 0.\n\nSecondly we assume the right most bit is 0. Since there is at least one bit 1 in a non-zero number, we suppose the m th bit is the most right bit of 1. When it minus 1, the m th bit becomes 0, and all 0 bits behind the m th bit become 1. For instance, the second bit of binary number 1100 is the most right bit of 1. When it minus 1, the second bit becomes 0, and the third and fourth bits become 1, so the result is 1011.\n\nIn both situations above, the most right of bit 1 becomes 0 when it minus 1. When there are some 0 bits at right side, all of them become 1. The result of bit and operation on the original number and minus result is identical to result to modify the most right 1 into 0. Take the binary number 1100 as an example again. Its result is 1011 when it minus 1. The result of and operation on 1100 and 1011 is 1000. If we change the most right of 1 bit in number 1100, it also becomes 1000.\n\nThe analysis can be summarized as: If we first minus a number with 1, and have and operation on the original number and the minus result, the most right of 1 bit becomes 0. We continue these operations until the number becomes 0. We can develop the following code accordingly:\n\nint NumberOf1( int n)\n{\nint count = 0;\n\nwhile (n)\n{\n++ count;\nn = (n - 1) & n;\n}\n\nreturn count;\n}\n\nThe number of times in the while loops equals to the number of 1 in the binary format of input n .", "question": "\nProblem: Please implement a function to get the number of 1s in an integer. For example, the integer 9 is 1001 in binary, so it returns 2 since there are two bits of 1s.\n"},
{"answer": "\nAnalysis: It looks like a simple question about binary numbers, and we have many solutions for it. Unfortunately, the most intuitive solution for many candidates is incorrect. We should be careful.\n\nSolution 1: Check the most right bit, possibly with endless loop\n\nWhen candidates are interviewed with this problem, many of them find a solution in short time: check whether the most right bit is 0 or 1, and then right shit the integer one bit and check the most right bit again. It continues in a loop until the integer becomes 0. How to check whether the most right bit of an integer is 0 or 1? It is simple since we have AND operation. There is only one bit of 1, which is the most right bit, in the binary format of integer 1. When we have AND operation on an integer and 1, we can check whether the most right bit is 0 or 1. When the result of AND operation is 1, it indicates the right most bit is 1; otherwise it is 0. We can implement a function base on this solution quickly:\n\nint NumberOf1( int n ) { int count = 0; while ( n ) { if ( n & 1) count ++; n = n >> 1; } return count; }\n\nInterviewers may ask a question when they are told this solution: What is the result when the input integer is a negative number such as 0x80000000? When we right shift the negative number 0x80000000 a bit, it become 0xC0000000 rather than 0x40000000, which is the result to move the first bit of 1 to the second bit. The integer 0x8000000 is negative before shift, so we should guarantee it is also negative after shift. Therefore, when a negative integer is right shifted, the first bit is set as 1 after the right shift operation. If we continue to shift to right side, a negative integer will be 0xFFFFFFFF eventually and it is trapped in an endless loop.\n\nSolution 2: Check the most right bit, with left shift operation on 1\n\nWe should not right shift the input integer to avoid endless loop. Instead of shifting the input integer n to right, we may shift the number 1 to left. We may check firstly the least important bit of n , and then shift the number 1 to left, and continue to check the second least important bit of n . Now we can rewrite our code based on this solution:\n\nint NumberOf1( int n)\n{\nint count = 0;\nunsigned int flag = 1;\nwhile (flag)\n{\nif (n & flag)\ncount ++;\n\nflag = flag << 1;\n}\n\nreturn count;\n}\n\nIn the code above, it loops 32 times on 32-bit numbers.\n\nSolution 3: Creative solution\n\nLet us analyze that what happens when a number minus 1. There is at least one bit 1 in a non-zero number. We firstly assume the right most bit is 1. It becomes 0 if the number minus 1 and other bits keep unchanged. This result is identical to the not operation on the most right bit of a number, which also turns the right most bit from 1 into 0.\n\nSecondly we assume the right most bit is 0. Since there is at least one bit 1 in a non-zero number, we suppose the m th bit is the most right bit of 1. When it minus 1, the m th bit becomes 0, and all 0 bits behind the m th bit become 1. For instance, the second bit of binary number 1100 is the most right bit of 1. When it minus 1, the second bit becomes 0, and the third and fourth bits become 1, so the result is 1011.\n\nIn both situations above, the most right of bit 1 becomes 0 when it minus 1. When there are some 0 bits at right side, all of them become 1. The result of bit and operation on the original number and minus result is identical to result to modify the most right 1 into 0. Take the binary number 1100 as an example again. Its result is 1011 when it minus 1. The result of and operation on 1100 and 1011 is 1000. If we change the most right of 1 bit in number 1100, it also becomes 1000.\n\nThe analysis can be summarized as: If we first minus a number with 1, and have and operation on the original number and the minus result, the most right of 1 bit becomes 0. We continue these operations until the number becomes 0. We can develop the following code accordingly:\n\nint NumberOf1( int n)\n{\nint count = 0;\n\nwhile (n)\n{\n++ count;\nn = (n - 1) & n;\n}\n\nreturn count;\n}\n\nThe number of times in the while loops equals to the number of 1 in the binary format of input n .", "question": "\nProblem: Please implement a function to get the number of 1s in an integer. For example, the integer 9 is 1001 in binary, so it returns 2 since there are two bits of 1s.\n"},
{"answer": "\nAnalysis: It looks like a simple question about binary numbers, and we have many solutions for it. Unfortunately, the most intuitive solution for many candidates is incorrect. We should be careful.\n\nSolution 1: Check the most right bit, possibly with endless loop\n\nWhen candidates are interviewed with this problem, many of them find a solution in short time: check whether the most right bit is 0 or 1, and then right shit the integer one bit and check the most right bit again. It continues in a loop until the integer becomes 0. How to check whether the most right bit of an integer is 0 or 1? It is simple since we have AND operation. There is only one bit of 1, which is the most right bit, in the binary format of integer 1. When we have AND operation on an integer and 1, we can check whether the most right bit is 0 or 1. When the result of AND operation is 1, it indicates the right most bit is 1; otherwise it is 0. We can implement a function base on this solution quickly:\n\nint NumberOf1( int n ) { int count = 0; while ( n ) { if ( n & 1) count ++; n = n >> 1; } return count; }\n\nInterviewers may ask a question when they are told this solution: What is the result when the input integer is a negative number such as 0x80000000? When we right shift the negative number 0x80000000 a bit, it become 0xC0000000 rather than 0x40000000, which is the result to move the first bit of 1 to the second bit. The integer 0x8000000 is negative before shift, so we should guarantee it is also negative after shift. Therefore, when a negative integer is right shifted, the first bit is set as 1 after the right shift operation. If we continue to shift to right side, a negative integer will be 0xFFFFFFFF eventually and it is trapped in an endless loop.\n\nSolution 2: Check the most right bit, with left shift operation on 1\n\nWe should not right shift the input integer to avoid endless loop. Instead of shifting the input integer n to right, we may shift the number 1 to left. We may check firstly the least important bit of n , and then shift the number 1 to left, and continue to check the second least important bit of n . Now we can rewrite our code based on this solution:\n\nint NumberOf1( int n)\n{\nint count = 0;\nunsigned int flag = 1;\nwhile (flag)\n{\nif (n & flag)\ncount ++;\n\nflag = flag << 1;\n}\n\nreturn count;\n}\n\nIn the code above, it loops 32 times on 32-bit numbers.\n\nSolution 3: Creative solution\n\nLet us analyze that what happens when a number minus 1. There is at least one bit 1 in a non-zero number. We firstly assume the right most bit is 1. It becomes 0 if the number minus 1 and other bits keep unchanged. This result is identical to the not operation on the most right bit of a number, which also turns the right most bit from 1 into 0.\n\nSecondly we assume the right most bit is 0. Since there is at least one bit 1 in a non-zero number, we suppose the m th bit is the most right bit of 1. When it minus 1, the m th bit becomes 0, and all 0 bits behind the m th bit become 1. For instance, the second bit of binary number 1100 is the most right bit of 1. When it minus 1, the second bit becomes 0, and the third and fourth bits become 1, so the result is 1011.\n\nIn both situations above, the most right of bit 1 becomes 0 when it minus 1. When there are some 0 bits at right side, all of them become 1. The result of bit and operation on the original number and minus result is identical to result to modify the most right 1 into 0. Take the binary number 1100 as an example again. Its result is 1011 when it minus 1. The result of and operation on 1100 and 1011 is 1000. If we change the most right of 1 bit in number 1100, it also becomes 1000.\n\nThe analysis can be summarized as: If we first minus a number with 1, and have and operation on the original number and the minus result, the most right of 1 bit becomes 0. We continue these operations until the number becomes 0. We can develop the following code accordingly:\n\nint NumberOf1( int n)\n{\nint count = 0;\n\nwhile (n)\n{\n++ count;\nn = (n - 1) & n;\n}\n\nreturn count;\n}\n\nThe number of times in the while loops equals to the number of 1 in the binary format of input n .", "question": "\nProblem: Please implement a function to get the number of 1s in an integer. For example, the integer 9 is 1001 in binary, so it returns 2 since there are two bits of 1s.\n"},
{"answer": "\nAnalysis: It looks like a simple question about binary numbers, and we have many solutions for it. Unfortunately, the most intuitive solution for many candidates is incorrect. We should be careful.\n\nSolution 1: Check the most right bit, possibly with endless loop\n\nWhen candidates are interviewed with this problem, many of them find a solution in short time: check whether the most right bit is 0 or 1, and then right shit the integer one bit and check the most right bit again. It continues in a loop until the integer becomes 0. How to check whether the most right bit of an integer is 0 or 1? It is simple since we have AND operation. There is only one bit of 1, which is the most right bit, in the binary format of integer 1. When we have AND operation on an integer and 1, we can check whether the most right bit is 0 or 1. When the result of AND operation is 1, it indicates the right most bit is 1; otherwise it is 0. We can implement a function base on this solution quickly:\n\nint NumberOf1( int n ) { int count = 0; while ( n ) { if ( n & 1) count ++; n = n >> 1; } return count; }\n\nInterviewers may ask a question when they are told this solution: What is the result when the input integer is a negative number such as 0x80000000? When we right shift the negative number 0x80000000 a bit, it become 0xC0000000 rather than 0x40000000, which is the result to move the first bit of 1 to the second bit. The integer 0x8000000 is negative before shift, so we should guarantee it is also negative after shift. Therefore, when a negative integer is right shifted, the first bit is set as 1 after the right shift operation. If we continue to shift to right side, a negative integer will be 0xFFFFFFFF eventually and it is trapped in an endless loop.\n\nSolution 2: Check the most right bit, with left shift operation on 1\n\nWe should not right shift the input integer to avoid endless loop. Instead of shifting the input integer n to right, we may shift the number 1 to left. We may check firstly the least important bit of n , and then shift the number 1 to left, and continue to check the second least important bit of n . Now we can rewrite our code based on this solution:\n\nint NumberOf1( int n)\n{\nint count = 0;\nunsigned int flag = 1;\nwhile (flag)\n{\nif (n & flag)\ncount ++;\n\nflag = flag << 1;\n}\n\nreturn count;\n}\n\nIn the code above, it loops 32 times on 32-bit numbers.\n\nSolution 3: Creative solution\n\nLet us analyze that what happens when a number minus 1. There is at least one bit 1 in a non-zero number. We firstly assume the right most bit is 1. It becomes 0 if the number minus 1 and other bits keep unchanged. This result is identical to the not operation on the most right bit of a number, which also turns the right most bit from 1 into 0.\n\nSecondly we assume the right most bit is 0. Since there is at least one bit 1 in a non-zero number, we suppose the m th bit is the most right bit of 1. When it minus 1, the m th bit becomes 0, and all 0 bits behind the m th bit become 1. For instance, the second bit of binary number 1100 is the most right bit of 1. When it minus 1, the second bit becomes 0, and the third and fourth bits become 1, so the result is 1011.\n\nIn both situations above, the most right of bit 1 becomes 0 when it minus 1. When there are some 0 bits at right side, all of them become 1. The result of bit and operation on the original number and minus result is identical to result to modify the most right 1 into 0. Take the binary number 1100 as an example again. Its result is 1011 when it minus 1. The result of and operation on 1100 and 1011 is 1000. If we change the most right of 1 bit in number 1100, it also becomes 1000.\n\nThe analysis can be summarized as: If we first minus a number with 1, and have and operation on the original number and the minus result, the most right of 1 bit becomes 0. We continue these operations until the number becomes 0. We can develop the following code accordingly:\n\nint NumberOf1( int n)\n{\nint count = 0;\n\nwhile (n)\n{\n++ count;\nn = (n - 1) & n;\n}\n\nreturn count;\n}\n\nThe number of times in the while loops equals to the number of 1 in the binary format of input n .", "question": "\nProblem: Please implement a function to get the number of 1s in an integer. For example, the integer 9 is 1001 in binary, so it returns 2 since there are two bits of 1s.\n"},
{"answer": "\nAnalysis: It looks like a simple question about binary numbers, and we have many solutions for it. Unfortunately, the most intuitive solution for many candidates is incorrect. We should be careful.\n\nSolution 1: Check the most right bit, possibly with endless loop\n\nWhen candidates are interviewed with this problem, many of them find a solution in short time: check whether the most right bit is 0 or 1, and then right shit the integer one bit and check the most right bit again. It continues in a loop until the integer becomes 0. How to check whether the most right bit of an integer is 0 or 1? It is simple since we have AND operation. There is only one bit of 1, which is the most right bit, in the binary format of integer 1. When we have AND operation on an integer and 1, we can check whether the most right bit is 0 or 1. When the result of AND operation is 1, it indicates the right most bit is 1; otherwise it is 0. We can implement a function base on this solution quickly:\n\nint NumberOf1( int n ) { int count = 0; while ( n ) { if ( n & 1) count ++; n = n >> 1; } return count; }\n\nInterviewers may ask a question when they are told this solution: What is the result when the input integer is a negative number such as 0x80000000? When we right shift the negative number 0x80000000 a bit, it become 0xC0000000 rather than 0x40000000, which is the result to move the first bit of 1 to the second bit. The integer 0x8000000 is negative before shift, so we should guarantee it is also negative after shift. Therefore, when a negative integer is right shifted, the first bit is set as 1 after the right shift operation. If we continue to shift to right side, a negative integer will be 0xFFFFFFFF eventually and it is trapped in an endless loop.\n\nSolution 2: Check the most right bit, with left shift operation on 1\n\nWe should not right shift the input integer to avoid endless loop. Instead of shifting the input integer n to right, we may shift the number 1 to left. We may check firstly the least important bit of n , and then shift the number 1 to left, and continue to check the second least important bit of n . Now we can rewrite our code based on this solution:\n\nint NumberOf1( int n)\n{\nint count = 0;\nunsigned int flag = 1;\nwhile (flag)\n{\nif (n & flag)\ncount ++;\n\nflag = flag << 1;\n}\n\nreturn count;\n}\n\nIn the code above, it loops 32 times on 32-bit numbers.\n\nSolution 3: Creative solution\n\nLet us analyze that what happens when a number minus 1. There is at least one bit 1 in a non-zero number. We firstly assume the right most bit is 1. It becomes 0 if the number minus 1 and other bits keep unchanged. This result is identical to the not operation on the most right bit of a number, which also turns the right most bit from 1 into 0.\n\nSecondly we assume the right most bit is 0. Since there is at least one bit 1 in a non-zero number, we suppose the m th bit is the most right bit of 1. When it minus 1, the m th bit becomes 0, and all 0 bits behind the m th bit become 1. For instance, the second bit of binary number 1100 is the most right bit of 1. When it minus 1, the second bit becomes 0, and the third and fourth bits become 1, so the result is 1011.\n\nIn both situations above, the most right of bit 1 becomes 0 when it minus 1. When there are some 0 bits at right side, all of them become 1. The result of bit and operation on the original number and minus result is identical to result to modify the most right 1 into 0. Take the binary number 1100 as an example again. Its result is 1011 when it minus 1. The result of and operation on 1100 and 1011 is 1000. If we change the most right of 1 bit in number 1100, it also becomes 1000.\n\nThe analysis can be summarized as: If we first minus a number with 1, and have and operation on the original number and the minus result, the most right of 1 bit becomes 0. We continue these operations until the number becomes 0. We can develop the following code accordingly:\n\nint NumberOf1( int n)\n{\nint count = 0;\n\nwhile (n)\n{\n++ count;\nn = (n - 1) & n;\n}\n\nreturn count;\n}\n\nThe number of times in the while loops equals to the number of 1 in the binary format of input n .", "question": "\nProblem: Please implement a function to get the number of 1s in an integer. For example, the integer 9 is 1001 in binary, so it returns 2 since there are two bits of 1s.\n"},
{"answer": "\nAnalysis: It looks like a simple question about binary numbers, and we have many solutions for it. Unfortunately, the most intuitive solution for many candidates is incorrect. We should be careful.\n\nSolution 1: Check the most right bit, possibly with endless loop\n\nWhen candidates are interviewed with this problem, many of them find a solution in short time: check whether the most right bit is 0 or 1, and then right shit the integer one bit and check the most right bit again. It continues in a loop until the integer becomes 0. How to check whether the most right bit of an integer is 0 or 1? It is simple since we have AND operation. There is only one bit of 1, which is the most right bit, in the binary format of integer 1. When we have AND operation on an integer and 1, we can check whether the most right bit is 0 or 1. When the result of AND operation is 1, it indicates the right most bit is 1; otherwise it is 0. We can implement a function base on this solution quickly:\n\nint NumberOf1( int n ) { int count = 0; while ( n ) { if ( n & 1) count ++; n = n >> 1; } return count; }\n\nInterviewers may ask a question when they are told this solution: What is the result when the input integer is a negative number such as 0x80000000? When we right shift the negative number 0x80000000 a bit, it become 0xC0000000 rather than 0x40000000, which is the result to move the first bit of 1 to the second bit. The integer 0x8000000 is negative before shift, so we should guarantee it is also negative after shift. Therefore, when a negative integer is right shifted, the first bit is set as 1 after the right shift operation. If we continue to shift to right side, a negative integer will be 0xFFFFFFFF eventually and it is trapped in an endless loop.\n\nSolution 2: Check the most right bit, with left shift operation on 1\n\nWe should not right shift the input integer to avoid endless loop. Instead of shifting the input integer n to right, we may shift the number 1 to left. We may check firstly the least important bit of n , and then shift the number 1 to left, and continue to check the second least important bit of n . Now we can rewrite our code based on this solution:\n\nint NumberOf1( int n)\n{\nint count = 0;\nunsigned int flag = 1;\nwhile (flag)\n{\nif (n & flag)\ncount ++;\n\nflag = flag << 1;\n}\n\nreturn count;\n}\n\nIn the code above, it loops 32 times on 32-bit numbers.\n\nSolution 3: Creative solution\n\nLet us analyze that what happens when a number minus 1. There is at least one bit 1 in a non-zero number. We firstly assume the right most bit is 1. It becomes 0 if the number minus 1 and other bits keep unchanged. This result is identical to the not operation on the most right bit of a number, which also turns the right most bit from 1 into 0.\n\nSecondly we assume the right most bit is 0. Since there is at least one bit 1 in a non-zero number, we suppose the m th bit is the most right bit of 1. When it minus 1, the m th bit becomes 0, and all 0 bits behind the m th bit become 1. For instance, the second bit of binary number 1100 is the most right bit of 1. When it minus 1, the second bit becomes 0, and the third and fourth bits become 1, so the result is 1011.\n\nIn both situations above, the most right of bit 1 becomes 0 when it minus 1. When there are some 0 bits at right side, all of them become 1. The result of bit and operation on the original number and minus result is identical to result to modify the most right 1 into 0. Take the binary number 1100 as an example again. Its result is 1011 when it minus 1. The result of and operation on 1100 and 1011 is 1000. If we change the most right of 1 bit in number 1100, it also becomes 1000.\n\nThe analysis can be summarized as: If we first minus a number with 1, and have and operation on the original number and the minus result, the most right of 1 bit becomes 0. We continue these operations until the number becomes 0. We can develop the following code accordingly:\n\nint NumberOf1( int n)\n{\nint count = 0;\n\nwhile (n)\n{\n++ count;\nn = (n - 1) & n;\n}\n\nreturn count;\n}\n\nThe number of times in the while loops equals to the number of 1 in the binary format of input n .", "question": "\nProblem: Please implement a function to get the number of 1s in an integer. For example, the integer 9 is 1001 in binary, so it returns 2 since there are two bits of 1s.\n"},
{"answer": "\nAnalysis: Our intuition for this problem might be that we sort all of numbers in the stack when we push a new one, and keep the minimum number on the top of stack. In this way we can get the minimum number in O(1) time. However, we cannot assure that the last number pushed in to container will be the first one to be popped out, so it is no longer a stack.\n\nWe may add a new member variable in a stack to keep the minimum number. When we push a new number which is less than the minimum number, we will update it. It sounds good. However, how to get the next minimum number when the current minimum one is popped? Fortunately, we have two solutions for this problem.\n\nSolution 1: With Auxiliary Stack\n\nIt is not enough to have only a member variable to keep the minimum number. When the minimum one is popped, we need to get the next minimum one. Therefore, we need to store the next minimum number before push the current minimum one.\n\nHow about to store each minimum number (the less value of current minimum number and the number to be pushed) into an auxiliary stack? We may analyze the process to push and pop numbers via some examples (Table 1).\n\nStep Operation Data Stack Auxiliary Stack Minimum 1 Push 3 3 3 3 2 Push 4 3, 4 3, 3 3 3 Push 2 3, 4, 2 3, 3, 2 2 4 Push 1 3, 4, 2, 1 3, 3, 2, 1 1 5 Pop 3, 4, 2 3, 3, 2 2 6 Pop 3, 4 3, 3 3 7 Push 0 3, 4, 0 3, 3, 0 0\nStep\nOperation\nData Stack\nAuxiliary Stack\nMinimum\n1\nPush 3\n3\n3\n3\n2\nPush 4\n3, 4\n3, 3\n3\n3\nPush 2\n3, 4, 2\n3, 3, 2\n2\n4\nPush 1\n3, 4, 2, 1\n3, 3, 2, 1\n1\n5\nPop\n3, 4, 2\n3, 3, 2\n2\n6\nPop\n3, 4\n3, 3\n3\n7\nPush 0\n3, 4, 0\n3, 3, 0\n0\nTable 1: The status of data stack, auxiliary stack, minimum value when we push 3, 4, 2, 1, pop twice, and then push 0\n\nAt first we push 3 into both data stack and auxiliary stack. Secondly we push 4 into the data stack. We push 3 again into the auxiliary stack because 4 is greater than 3. Thirdly, we continue pushing 2 into the data stack. We update the minimum number as 2 and push it into the auxiliary stack since 2 is less the previous minimum number 3. It is same in the fourth step when we push 1. We also need to update the minimum number and push 1 into the auxiliary stack. We can notice that the top of auxiliary stack is always the minimum number if we push the minimum number into auxiliary stack in each step.\n\nWhenever we pop a number from data stack, we also pop a number from auxiliary stack. If the minimum number is popped, the next minimum number should be also on the top of auxiliary stack. In the fifth step we pop 1 from the data stack, and we also pop the number on the top of auxiliary (which is 1). We can see that the next minimum number 2 is now on the top of auxiliary stack. If we continue popping from both the data and auxiliary stacks, there are only two numbers 3 and 4 left in the data stack. The minimum number 3 is indeed on the top of the auxiliary stack. Therefore, it demonstrates that our solution is correct.\n\nNow we can develop the required stack. The stack is declared as the following:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nstd::stack<T>\u00a0\u00a0 m_min; // auxiliary stack, to store minimum numbers\n};\n\nThe function push, pop and min and top can be implemented as:\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\n// push the new number into data stack\nm_data.push(value);\n\n// push the new number into auxiliary stack\n// if it is less than the previous minimum number,\n// otherwise push a replication of the minimum number\nif (m_min.size() == 0 || value < m_min.top())\nm_min.push(value);\nelse\nm_min.push(m_min.top());\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nm_data.pop();\nm_min.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nreturn m_min.top();\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nreturn m_data.top();\n}\n\nThe length of auxiliary stack should be n if we push n numbers into data stack. Therefore, we need O( n ) auxiliary memory for this solution.\n\nSolution 2: Without Auxiliary Stack\n\nThe second solution is trickier without an auxiliary stack. We do not always push numbers into data stack directly, but we have some tricky calculation before pushing.\n\nSupposing that we are going to push a number value into a stack with minimum number min . If value is greater than or equal to the min , it is pushed directly into data stack. If it is less than min , we push 2* value - min , and update min as value since a new minimum number is pushed. How about to pop? We pop it directly if the top of data stack (it is denoted as top ) is greater than or equal to min . Otherwise the number top is not the real pushed number. The real pushed number is stored is min . After the current minimum number is popped, we need to restore the previous minimum number, which is 2* min - top .\n\n\nNow let us demonstrate its correctness of this solution. Since value is greater than or equal to min , it is pushed into data stack direct without updating min . Therefore, when we find that the top of data stack is greater than or equal to min , we can pop directly without updating min . However, if we find value is less then min , we push 2* value - min . We should notice that 2* value - min should be less than value . Then we update current min as value . Therefore, the new top of data stack ( top ) is less than the current min . Therefore, when we find that the top of data stack is less then min , the real top (real pushed number value ) is stored in min . After we pop the top of data stack, we have to restore the previous minimum number. Since top = 2* value -previous min and value is current min , pervious min is 2*current min - top .\n\nIt sounds great. We feel confident to write code now with the correctness demonstration. The following is the sample code:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nT\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_min; // minimum number\n};\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\nif (m_data.size() == 0)\n{\nm_data.push(value);\nm_min = value;\n}\nelse if (value >= m_min)\n{\nm_data.push(value);\n}\nelse\n{\nm_data.push(2 * value - m_min);\nm_min = value;\n}\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0);\n\nif (m_data.top() < m_min)\nm_min = 2 * m_min - m_data.top();\n\nm_data.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0);\n\nreturn m_min;\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nT top = m_data.top();\nif (top < m_min)\ntop = m_min;\n\nreturn top;\n}\n", "question": ""},
{"answer": "\nAnalysis: Our intuition for this problem might be that we sort all of numbers in the stack when we push a new one, and keep the minimum number on the top of stack. In this way we can get the minimum number in O(1) time. However, we cannot assure that the last number pushed in to container will be the first one to be popped out, so it is no longer a stack.\n\nWe may add a new member variable in a stack to keep the minimum number. When we push a new number which is less than the minimum number, we will update it. It sounds good. However, how to get the next minimum number when the current minimum one is popped? Fortunately, we have two solutions for this problem.\n\nSolution 1: With Auxiliary Stack\n\nIt is not enough to have only a member variable to keep the minimum number. When the minimum one is popped, we need to get the next minimum one. Therefore, we need to store the next minimum number before push the current minimum one.\n\nHow about to store each minimum number (the less value of current minimum number and the number to be pushed) into an auxiliary stack? We may analyze the process to push and pop numbers via some examples (Table 1).\n\nStep Operation Data Stack Auxiliary Stack Minimum 1 Push 3 3 3 3 2 Push 4 3, 4 3, 3 3 3 Push 2 3, 4, 2 3, 3, 2 2 4 Push 1 3, 4, 2, 1 3, 3, 2, 1 1 5 Pop 3, 4, 2 3, 3, 2 2 6 Pop 3, 4 3, 3 3 7 Push 0 3, 4, 0 3, 3, 0 0\nStep\nOperation\nData Stack\nAuxiliary Stack\nMinimum\n1\nPush 3\n3\n3\n3\n2\nPush 4\n3, 4\n3, 3\n3\n3\nPush 2\n3, 4, 2\n3, 3, 2\n2\n4\nPush 1\n3, 4, 2, 1\n3, 3, 2, 1\n1\n5\nPop\n3, 4, 2\n3, 3, 2\n2\n6\nPop\n3, 4\n3, 3\n3\n7\nPush 0\n3, 4, 0\n3, 3, 0\n0\nTable 1: The status of data stack, auxiliary stack, minimum value when we push 3, 4, 2, 1, pop twice, and then push 0\n\nAt first we push 3 into both data stack and auxiliary stack. Secondly we push 4 into the data stack. We push 3 again into the auxiliary stack because 4 is greater than 3. Thirdly, we continue pushing 2 into the data stack. We update the minimum number as 2 and push it into the auxiliary stack since 2 is less the previous minimum number 3. It is same in the fourth step when we push 1. We also need to update the minimum number and push 1 into the auxiliary stack. We can notice that the top of auxiliary stack is always the minimum number if we push the minimum number into auxiliary stack in each step.\n\nWhenever we pop a number from data stack, we also pop a number from auxiliary stack. If the minimum number is popped, the next minimum number should be also on the top of auxiliary stack. In the fifth step we pop 1 from the data stack, and we also pop the number on the top of auxiliary (which is 1). We can see that the next minimum number 2 is now on the top of auxiliary stack. If we continue popping from both the data and auxiliary stacks, there are only two numbers 3 and 4 left in the data stack. The minimum number 3 is indeed on the top of the auxiliary stack. Therefore, it demonstrates that our solution is correct.\n\nNow we can develop the required stack. The stack is declared as the following:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nstd::stack<T>\u00a0\u00a0 m_min; // auxiliary stack, to store minimum numbers\n};\n\nThe function push, pop and min and top can be implemented as:\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\n// push the new number into data stack\nm_data.push(value);\n\n// push the new number into auxiliary stack\n// if it is less than the previous minimum number,\n// otherwise push a replication of the minimum number\nif (m_min.size() == 0 || value < m_min.top())\nm_min.push(value);\nelse\nm_min.push(m_min.top());\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nm_data.pop();\nm_min.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nreturn m_min.top();\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nreturn m_data.top();\n}\n\nThe length of auxiliary stack should be n if we push n numbers into data stack. Therefore, we need O( n ) auxiliary memory for this solution.\n\nSolution 2: Without Auxiliary Stack\n\nThe second solution is trickier without an auxiliary stack. We do not always push numbers into data stack directly, but we have some tricky calculation before pushing.\n\nSupposing that we are going to push a number value into a stack with minimum number min . If value is greater than or equal to the min , it is pushed directly into data stack. If it is less than min , we push 2* value - min , and update min as value since a new minimum number is pushed. How about to pop? We pop it directly if the top of data stack (it is denoted as top ) is greater than or equal to min . Otherwise the number top is not the real pushed number. The real pushed number is stored is min . After the current minimum number is popped, we need to restore the previous minimum number, which is 2* min - top .\n\n\nNow let us demonstrate its correctness of this solution. Since value is greater than or equal to min , it is pushed into data stack direct without updating min . Therefore, when we find that the top of data stack is greater than or equal to min , we can pop directly without updating min . However, if we find value is less then min , we push 2* value - min . We should notice that 2* value - min should be less than value . Then we update current min as value . Therefore, the new top of data stack ( top ) is less than the current min . Therefore, when we find that the top of data stack is less then min , the real top (real pushed number value ) is stored in min . After we pop the top of data stack, we have to restore the previous minimum number. Since top = 2* value -previous min and value is current min , pervious min is 2*current min - top .\n\nIt sounds great. We feel confident to write code now with the correctness demonstration. The following is the sample code:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nT\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_min; // minimum number\n};\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\nif (m_data.size() == 0)\n{\nm_data.push(value);\nm_min = value;\n}\nelse if (value >= m_min)\n{\nm_data.push(value);\n}\nelse\n{\nm_data.push(2 * value - m_min);\nm_min = value;\n}\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0);\n\nif (m_data.top() < m_min)\nm_min = 2 * m_min - m_data.top();\n\nm_data.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0);\n\nreturn m_min;\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nT top = m_data.top();\nif (top < m_min)\ntop = m_min;\n\nreturn top;\n}\n", "question": ""},
{"answer": "\nAnalysis: Our intuition for this problem might be that we sort all of numbers in the stack when we push a new one, and keep the minimum number on the top of stack. In this way we can get the minimum number in O(1) time. However, we cannot assure that the last number pushed in to container will be the first one to be popped out, so it is no longer a stack.\n\nWe may add a new member variable in a stack to keep the minimum number. When we push a new number which is less than the minimum number, we will update it. It sounds good. However, how to get the next minimum number when the current minimum one is popped? Fortunately, we have two solutions for this problem.\n\nSolution 1: With Auxiliary Stack\n\nIt is not enough to have only a member variable to keep the minimum number. When the minimum one is popped, we need to get the next minimum one. Therefore, we need to store the next minimum number before push the current minimum one.\n\nHow about to store each minimum number (the less value of current minimum number and the number to be pushed) into an auxiliary stack? We may analyze the process to push and pop numbers via some examples (Table 1).\n\nStep Operation Data Stack Auxiliary Stack Minimum 1 Push 3 3 3 3 2 Push 4 3, 4 3, 3 3 3 Push 2 3, 4, 2 3, 3, 2 2 4 Push 1 3, 4, 2, 1 3, 3, 2, 1 1 5 Pop 3, 4, 2 3, 3, 2 2 6 Pop 3, 4 3, 3 3 7 Push 0 3, 4, 0 3, 3, 0 0\nStep\nOperation\nData Stack\nAuxiliary Stack\nMinimum\n1\nPush 3\n3\n3\n3\n2\nPush 4\n3, 4\n3, 3\n3\n3\nPush 2\n3, 4, 2\n3, 3, 2\n2\n4\nPush 1\n3, 4, 2, 1\n3, 3, 2, 1\n1\n5\nPop\n3, 4, 2\n3, 3, 2\n2\n6\nPop\n3, 4\n3, 3\n3\n7\nPush 0\n3, 4, 0\n3, 3, 0\n0\nTable 1: The status of data stack, auxiliary stack, minimum value when we push 3, 4, 2, 1, pop twice, and then push 0\n\nAt first we push 3 into both data stack and auxiliary stack. Secondly we push 4 into the data stack. We push 3 again into the auxiliary stack because 4 is greater than 3. Thirdly, we continue pushing 2 into the data stack. We update the minimum number as 2 and push it into the auxiliary stack since 2 is less the previous minimum number 3. It is same in the fourth step when we push 1. We also need to update the minimum number and push 1 into the auxiliary stack. We can notice that the top of auxiliary stack is always the minimum number if we push the minimum number into auxiliary stack in each step.\n\nWhenever we pop a number from data stack, we also pop a number from auxiliary stack. If the minimum number is popped, the next minimum number should be also on the top of auxiliary stack. In the fifth step we pop 1 from the data stack, and we also pop the number on the top of auxiliary (which is 1). We can see that the next minimum number 2 is now on the top of auxiliary stack. If we continue popping from both the data and auxiliary stacks, there are only two numbers 3 and 4 left in the data stack. The minimum number 3 is indeed on the top of the auxiliary stack. Therefore, it demonstrates that our solution is correct.\n\nNow we can develop the required stack. The stack is declared as the following:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nstd::stack<T>\u00a0\u00a0 m_min; // auxiliary stack, to store minimum numbers\n};\n\nThe function push, pop and min and top can be implemented as:\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\n// push the new number into data stack\nm_data.push(value);\n\n// push the new number into auxiliary stack\n// if it is less than the previous minimum number,\n// otherwise push a replication of the minimum number\nif (m_min.size() == 0 || value < m_min.top())\nm_min.push(value);\nelse\nm_min.push(m_min.top());\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nm_data.pop();\nm_min.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nreturn m_min.top();\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nreturn m_data.top();\n}\n\nThe length of auxiliary stack should be n if we push n numbers into data stack. Therefore, we need O( n ) auxiliary memory for this solution.\n\nSolution 2: Without Auxiliary Stack\n\nThe second solution is trickier without an auxiliary stack. We do not always push numbers into data stack directly, but we have some tricky calculation before pushing.\n\nSupposing that we are going to push a number value into a stack with minimum number min . If value is greater than or equal to the min , it is pushed directly into data stack. If it is less than min , we push 2* value - min , and update min as value since a new minimum number is pushed. How about to pop? We pop it directly if the top of data stack (it is denoted as top ) is greater than or equal to min . Otherwise the number top is not the real pushed number. The real pushed number is stored is min . After the current minimum number is popped, we need to restore the previous minimum number, which is 2* min - top .\n\n\nNow let us demonstrate its correctness of this solution. Since value is greater than or equal to min , it is pushed into data stack direct without updating min . Therefore, when we find that the top of data stack is greater than or equal to min , we can pop directly without updating min . However, if we find value is less then min , we push 2* value - min . We should notice that 2* value - min should be less than value . Then we update current min as value . Therefore, the new top of data stack ( top ) is less than the current min . Therefore, when we find that the top of data stack is less then min , the real top (real pushed number value ) is stored in min . After we pop the top of data stack, we have to restore the previous minimum number. Since top = 2* value -previous min and value is current min , pervious min is 2*current min - top .\n\nIt sounds great. We feel confident to write code now with the correctness demonstration. The following is the sample code:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nT\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_min; // minimum number\n};\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\nif (m_data.size() == 0)\n{\nm_data.push(value);\nm_min = value;\n}\nelse if (value >= m_min)\n{\nm_data.push(value);\n}\nelse\n{\nm_data.push(2 * value - m_min);\nm_min = value;\n}\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0);\n\nif (m_data.top() < m_min)\nm_min = 2 * m_min - m_data.top();\n\nm_data.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0);\n\nreturn m_min;\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nT top = m_data.top();\nif (top < m_min)\ntop = m_min;\n\nreturn top;\n}\n", "question": ""},
{"answer": "\nAnalysis: Our intuition for this problem might be that we sort all of numbers in the stack when we push a new one, and keep the minimum number on the top of stack. In this way we can get the minimum number in O(1) time. However, we cannot assure that the last number pushed in to container will be the first one to be popped out, so it is no longer a stack.\n\nWe may add a new member variable in a stack to keep the minimum number. When we push a new number which is less than the minimum number, we will update it. It sounds good. However, how to get the next minimum number when the current minimum one is popped? Fortunately, we have two solutions for this problem.\n\nSolution 1: With Auxiliary Stack\n\nIt is not enough to have only a member variable to keep the minimum number. When the minimum one is popped, we need to get the next minimum one. Therefore, we need to store the next minimum number before push the current minimum one.\n\nHow about to store each minimum number (the less value of current minimum number and the number to be pushed) into an auxiliary stack? We may analyze the process to push and pop numbers via some examples (Table 1).\n\nStep Operation Data Stack Auxiliary Stack Minimum 1 Push 3 3 3 3 2 Push 4 3, 4 3, 3 3 3 Push 2 3, 4, 2 3, 3, 2 2 4 Push 1 3, 4, 2, 1 3, 3, 2, 1 1 5 Pop 3, 4, 2 3, 3, 2 2 6 Pop 3, 4 3, 3 3 7 Push 0 3, 4, 0 3, 3, 0 0\nStep\nOperation\nData Stack\nAuxiliary Stack\nMinimum\n1\nPush 3\n3\n3\n3\n2\nPush 4\n3, 4\n3, 3\n3\n3\nPush 2\n3, 4, 2\n3, 3, 2\n2\n4\nPush 1\n3, 4, 2, 1\n3, 3, 2, 1\n1\n5\nPop\n3, 4, 2\n3, 3, 2\n2\n6\nPop\n3, 4\n3, 3\n3\n7\nPush 0\n3, 4, 0\n3, 3, 0\n0\nTable 1: The status of data stack, auxiliary stack, minimum value when we push 3, 4, 2, 1, pop twice, and then push 0\n\nAt first we push 3 into both data stack and auxiliary stack. Secondly we push 4 into the data stack. We push 3 again into the auxiliary stack because 4 is greater than 3. Thirdly, we continue pushing 2 into the data stack. We update the minimum number as 2 and push it into the auxiliary stack since 2 is less the previous minimum number 3. It is same in the fourth step when we push 1. We also need to update the minimum number and push 1 into the auxiliary stack. We can notice that the top of auxiliary stack is always the minimum number if we push the minimum number into auxiliary stack in each step.\n\nWhenever we pop a number from data stack, we also pop a number from auxiliary stack. If the minimum number is popped, the next minimum number should be also on the top of auxiliary stack. In the fifth step we pop 1 from the data stack, and we also pop the number on the top of auxiliary (which is 1). We can see that the next minimum number 2 is now on the top of auxiliary stack. If we continue popping from both the data and auxiliary stacks, there are only two numbers 3 and 4 left in the data stack. The minimum number 3 is indeed on the top of the auxiliary stack. Therefore, it demonstrates that our solution is correct.\n\nNow we can develop the required stack. The stack is declared as the following:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nstd::stack<T>\u00a0\u00a0 m_min; // auxiliary stack, to store minimum numbers\n};\n\nThe function push, pop and min and top can be implemented as:\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\n// push the new number into data stack\nm_data.push(value);\n\n// push the new number into auxiliary stack\n// if it is less than the previous minimum number,\n// otherwise push a replication of the minimum number\nif (m_min.size() == 0 || value < m_min.top())\nm_min.push(value);\nelse\nm_min.push(m_min.top());\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nm_data.pop();\nm_min.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nreturn m_min.top();\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nreturn m_data.top();\n}\n\nThe length of auxiliary stack should be n if we push n numbers into data stack. Therefore, we need O( n ) auxiliary memory for this solution.\n\nSolution 2: Without Auxiliary Stack\n\nThe second solution is trickier without an auxiliary stack. We do not always push numbers into data stack directly, but we have some tricky calculation before pushing.\n\nSupposing that we are going to push a number value into a stack with minimum number min . If value is greater than or equal to the min , it is pushed directly into data stack. If it is less than min , we push 2* value - min , and update min as value since a new minimum number is pushed. How about to pop? We pop it directly if the top of data stack (it is denoted as top ) is greater than or equal to min . Otherwise the number top is not the real pushed number. The real pushed number is stored is min . After the current minimum number is popped, we need to restore the previous minimum number, which is 2* min - top .\n\n\nNow let us demonstrate its correctness of this solution. Since value is greater than or equal to min , it is pushed into data stack direct without updating min . Therefore, when we find that the top of data stack is greater than or equal to min , we can pop directly without updating min . However, if we find value is less then min , we push 2* value - min . We should notice that 2* value - min should be less than value . Then we update current min as value . Therefore, the new top of data stack ( top ) is less than the current min . Therefore, when we find that the top of data stack is less then min , the real top (real pushed number value ) is stored in min . After we pop the top of data stack, we have to restore the previous minimum number. Since top = 2* value -previous min and value is current min , pervious min is 2*current min - top .\n\nIt sounds great. We feel confident to write code now with the correctness demonstration. The following is the sample code:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nT\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_min; // minimum number\n};\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\nif (m_data.size() == 0)\n{\nm_data.push(value);\nm_min = value;\n}\nelse if (value >= m_min)\n{\nm_data.push(value);\n}\nelse\n{\nm_data.push(2 * value - m_min);\nm_min = value;\n}\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0);\n\nif (m_data.top() < m_min)\nm_min = 2 * m_min - m_data.top();\n\nm_data.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0);\n\nreturn m_min;\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nT top = m_data.top();\nif (top < m_min)\ntop = m_min;\n\nreturn top;\n}\n", "question": ""},
{"answer": "\nAnalysis: Our intuition for this problem might be that we sort all of numbers in the stack when we push a new one, and keep the minimum number on the top of stack. In this way we can get the minimum number in O(1) time. However, we cannot assure that the last number pushed in to container will be the first one to be popped out, so it is no longer a stack.\n\nWe may add a new member variable in a stack to keep the minimum number. When we push a new number which is less than the minimum number, we will update it. It sounds good. However, how to get the next minimum number when the current minimum one is popped? Fortunately, we have two solutions for this problem.\n\nSolution 1: With Auxiliary Stack\n\nIt is not enough to have only a member variable to keep the minimum number. When the minimum one is popped, we need to get the next minimum one. Therefore, we need to store the next minimum number before push the current minimum one.\n\nHow about to store each minimum number (the less value of current minimum number and the number to be pushed) into an auxiliary stack? We may analyze the process to push and pop numbers via some examples (Table 1).\n\nStep Operation Data Stack Auxiliary Stack Minimum 1 Push 3 3 3 3 2 Push 4 3, 4 3, 3 3 3 Push 2 3, 4, 2 3, 3, 2 2 4 Push 1 3, 4, 2, 1 3, 3, 2, 1 1 5 Pop 3, 4, 2 3, 3, 2 2 6 Pop 3, 4 3, 3 3 7 Push 0 3, 4, 0 3, 3, 0 0\nStep\nOperation\nData Stack\nAuxiliary Stack\nMinimum\n1\nPush 3\n3\n3\n3\n2\nPush 4\n3, 4\n3, 3\n3\n3\nPush 2\n3, 4, 2\n3, 3, 2\n2\n4\nPush 1\n3, 4, 2, 1\n3, 3, 2, 1\n1\n5\nPop\n3, 4, 2\n3, 3, 2\n2\n6\nPop\n3, 4\n3, 3\n3\n7\nPush 0\n3, 4, 0\n3, 3, 0\n0\nTable 1: The status of data stack, auxiliary stack, minimum value when we push 3, 4, 2, 1, pop twice, and then push 0\n\nAt first we push 3 into both data stack and auxiliary stack. Secondly we push 4 into the data stack. We push 3 again into the auxiliary stack because 4 is greater than 3. Thirdly, we continue pushing 2 into the data stack. We update the minimum number as 2 and push it into the auxiliary stack since 2 is less the previous minimum number 3. It is same in the fourth step when we push 1. We also need to update the minimum number and push 1 into the auxiliary stack. We can notice that the top of auxiliary stack is always the minimum number if we push the minimum number into auxiliary stack in each step.\n\nWhenever we pop a number from data stack, we also pop a number from auxiliary stack. If the minimum number is popped, the next minimum number should be also on the top of auxiliary stack. In the fifth step we pop 1 from the data stack, and we also pop the number on the top of auxiliary (which is 1). We can see that the next minimum number 2 is now on the top of auxiliary stack. If we continue popping from both the data and auxiliary stacks, there are only two numbers 3 and 4 left in the data stack. The minimum number 3 is indeed on the top of the auxiliary stack. Therefore, it demonstrates that our solution is correct.\n\nNow we can develop the required stack. The stack is declared as the following:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nstd::stack<T>\u00a0\u00a0 m_min; // auxiliary stack, to store minimum numbers\n};\n\nThe function push, pop and min and top can be implemented as:\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\n// push the new number into data stack\nm_data.push(value);\n\n// push the new number into auxiliary stack\n// if it is less than the previous minimum number,\n// otherwise push a replication of the minimum number\nif (m_min.size() == 0 || value < m_min.top())\nm_min.push(value);\nelse\nm_min.push(m_min.top());\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nm_data.pop();\nm_min.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nreturn m_min.top();\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nreturn m_data.top();\n}\n\nThe length of auxiliary stack should be n if we push n numbers into data stack. Therefore, we need O( n ) auxiliary memory for this solution.\n\nSolution 2: Without Auxiliary Stack\n\nThe second solution is trickier without an auxiliary stack. We do not always push numbers into data stack directly, but we have some tricky calculation before pushing.\n\nSupposing that we are going to push a number value into a stack with minimum number min . If value is greater than or equal to the min , it is pushed directly into data stack. If it is less than min , we push 2* value - min , and update min as value since a new minimum number is pushed. How about to pop? We pop it directly if the top of data stack (it is denoted as top ) is greater than or equal to min . Otherwise the number top is not the real pushed number. The real pushed number is stored is min . After the current minimum number is popped, we need to restore the previous minimum number, which is 2* min - top .\n\n\nNow let us demonstrate its correctness of this solution. Since value is greater than or equal to min , it is pushed into data stack direct without updating min . Therefore, when we find that the top of data stack is greater than or equal to min , we can pop directly without updating min . However, if we find value is less then min , we push 2* value - min . We should notice that 2* value - min should be less than value . Then we update current min as value . Therefore, the new top of data stack ( top ) is less than the current min . Therefore, when we find that the top of data stack is less then min , the real top (real pushed number value ) is stored in min . After we pop the top of data stack, we have to restore the previous minimum number. Since top = 2* value -previous min and value is current min , pervious min is 2*current min - top .\n\nIt sounds great. We feel confident to write code now with the correctness demonstration. The following is the sample code:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nT\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_min; // minimum number\n};\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\nif (m_data.size() == 0)\n{\nm_data.push(value);\nm_min = value;\n}\nelse if (value >= m_min)\n{\nm_data.push(value);\n}\nelse\n{\nm_data.push(2 * value - m_min);\nm_min = value;\n}\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0);\n\nif (m_data.top() < m_min)\nm_min = 2 * m_min - m_data.top();\n\nm_data.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0);\n\nreturn m_min;\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nT top = m_data.top();\nif (top < m_min)\ntop = m_min;\n\nreturn top;\n}\n", "question": ""},
{"answer": "\nAnalysis: Our intuition for this problem might be that we sort all of numbers in the stack when we push a new one, and keep the minimum number on the top of stack. In this way we can get the minimum number in O(1) time. However, we cannot assure that the last number pushed in to container will be the first one to be popped out, so it is no longer a stack.\n\nWe may add a new member variable in a stack to keep the minimum number. When we push a new number which is less than the minimum number, we will update it. It sounds good. However, how to get the next minimum number when the current minimum one is popped? Fortunately, we have two solutions for this problem.\n\nSolution 1: With Auxiliary Stack\n\nIt is not enough to have only a member variable to keep the minimum number. When the minimum one is popped, we need to get the next minimum one. Therefore, we need to store the next minimum number before push the current minimum one.\n\nHow about to store each minimum number (the less value of current minimum number and the number to be pushed) into an auxiliary stack? We may analyze the process to push and pop numbers via some examples (Table 1).\n\nStep Operation Data Stack Auxiliary Stack Minimum 1 Push 3 3 3 3 2 Push 4 3, 4 3, 3 3 3 Push 2 3, 4, 2 3, 3, 2 2 4 Push 1 3, 4, 2, 1 3, 3, 2, 1 1 5 Pop 3, 4, 2 3, 3, 2 2 6 Pop 3, 4 3, 3 3 7 Push 0 3, 4, 0 3, 3, 0 0\nStep\nOperation\nData Stack\nAuxiliary Stack\nMinimum\n1\nPush 3\n3\n3\n3\n2\nPush 4\n3, 4\n3, 3\n3\n3\nPush 2\n3, 4, 2\n3, 3, 2\n2\n4\nPush 1\n3, 4, 2, 1\n3, 3, 2, 1\n1\n5\nPop\n3, 4, 2\n3, 3, 2\n2\n6\nPop\n3, 4\n3, 3\n3\n7\nPush 0\n3, 4, 0\n3, 3, 0\n0\nTable 1: The status of data stack, auxiliary stack, minimum value when we push 3, 4, 2, 1, pop twice, and then push 0\n\nAt first we push 3 into both data stack and auxiliary stack. Secondly we push 4 into the data stack. We push 3 again into the auxiliary stack because 4 is greater than 3. Thirdly, we continue pushing 2 into the data stack. We update the minimum number as 2 and push it into the auxiliary stack since 2 is less the previous minimum number 3. It is same in the fourth step when we push 1. We also need to update the minimum number and push 1 into the auxiliary stack. We can notice that the top of auxiliary stack is always the minimum number if we push the minimum number into auxiliary stack in each step.\n\nWhenever we pop a number from data stack, we also pop a number from auxiliary stack. If the minimum number is popped, the next minimum number should be also on the top of auxiliary stack. In the fifth step we pop 1 from the data stack, and we also pop the number on the top of auxiliary (which is 1). We can see that the next minimum number 2 is now on the top of auxiliary stack. If we continue popping from both the data and auxiliary stacks, there are only two numbers 3 and 4 left in the data stack. The minimum number 3 is indeed on the top of the auxiliary stack. Therefore, it demonstrates that our solution is correct.\n\nNow we can develop the required stack. The stack is declared as the following:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nstd::stack<T>\u00a0\u00a0 m_min; // auxiliary stack, to store minimum numbers\n};\n\nThe function push, pop and min and top can be implemented as:\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\n// push the new number into data stack\nm_data.push(value);\n\n// push the new number into auxiliary stack\n// if it is less than the previous minimum number,\n// otherwise push a replication of the minimum number\nif (m_min.size() == 0 || value < m_min.top())\nm_min.push(value);\nelse\nm_min.push(m_min.top());\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nm_data.pop();\nm_min.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nreturn m_min.top();\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nreturn m_data.top();\n}\n\nThe length of auxiliary stack should be n if we push n numbers into data stack. Therefore, we need O( n ) auxiliary memory for this solution.\n\nSolution 2: Without Auxiliary Stack\n\nThe second solution is trickier without an auxiliary stack. We do not always push numbers into data stack directly, but we have some tricky calculation before pushing.\n\nSupposing that we are going to push a number value into a stack with minimum number min . If value is greater than or equal to the min , it is pushed directly into data stack. If it is less than min , we push 2* value - min , and update min as value since a new minimum number is pushed. How about to pop? We pop it directly if the top of data stack (it is denoted as top ) is greater than or equal to min . Otherwise the number top is not the real pushed number. The real pushed number is stored is min . After the current minimum number is popped, we need to restore the previous minimum number, which is 2* min - top .\n\n\nNow let us demonstrate its correctness of this solution. Since value is greater than or equal to min , it is pushed into data stack direct without updating min . Therefore, when we find that the top of data stack is greater than or equal to min , we can pop directly without updating min . However, if we find value is less then min , we push 2* value - min . We should notice that 2* value - min should be less than value . Then we update current min as value . Therefore, the new top of data stack ( top ) is less than the current min . Therefore, when we find that the top of data stack is less then min , the real top (real pushed number value ) is stored in min . After we pop the top of data stack, we have to restore the previous minimum number. Since top = 2* value -previous min and value is current min , pervious min is 2*current min - top .\n\nIt sounds great. We feel confident to write code now with the correctness demonstration. The following is the sample code:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nT\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_min; // minimum number\n};\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\nif (m_data.size() == 0)\n{\nm_data.push(value);\nm_min = value;\n}\nelse if (value >= m_min)\n{\nm_data.push(value);\n}\nelse\n{\nm_data.push(2 * value - m_min);\nm_min = value;\n}\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0);\n\nif (m_data.top() < m_min)\nm_min = 2 * m_min - m_data.top();\n\nm_data.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0);\n\nreturn m_min;\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nT top = m_data.top();\nif (top < m_min)\ntop = m_min;\n\nreturn top;\n}\n", "question": ""},
{"answer": "\nAnalysis: Our intuition for this problem might be that we sort all of numbers in the stack when we push a new one, and keep the minimum number on the top of stack. In this way we can get the minimum number in O(1) time. However, we cannot assure that the last number pushed in to container will be the first one to be popped out, so it is no longer a stack.\n\nWe may add a new member variable in a stack to keep the minimum number. When we push a new number which is less than the minimum number, we will update it. It sounds good. However, how to get the next minimum number when the current minimum one is popped? Fortunately, we have two solutions for this problem.\n\nSolution 1: With Auxiliary Stack\n\nIt is not enough to have only a member variable to keep the minimum number. When the minimum one is popped, we need to get the next minimum one. Therefore, we need to store the next minimum number before push the current minimum one.\n\nHow about to store each minimum number (the less value of current minimum number and the number to be pushed) into an auxiliary stack? We may analyze the process to push and pop numbers via some examples (Table 1).\n\nStep Operation Data Stack Auxiliary Stack Minimum 1 Push 3 3 3 3 2 Push 4 3, 4 3, 3 3 3 Push 2 3, 4, 2 3, 3, 2 2 4 Push 1 3, 4, 2, 1 3, 3, 2, 1 1 5 Pop 3, 4, 2 3, 3, 2 2 6 Pop 3, 4 3, 3 3 7 Push 0 3, 4, 0 3, 3, 0 0\nStep\nOperation\nData Stack\nAuxiliary Stack\nMinimum\n1\nPush 3\n3\n3\n3\n2\nPush 4\n3, 4\n3, 3\n3\n3\nPush 2\n3, 4, 2\n3, 3, 2\n2\n4\nPush 1\n3, 4, 2, 1\n3, 3, 2, 1\n1\n5\nPop\n3, 4, 2\n3, 3, 2\n2\n6\nPop\n3, 4\n3, 3\n3\n7\nPush 0\n3, 4, 0\n3, 3, 0\n0\nTable 1: The status of data stack, auxiliary stack, minimum value when we push 3, 4, 2, 1, pop twice, and then push 0\n\nAt first we push 3 into both data stack and auxiliary stack. Secondly we push 4 into the data stack. We push 3 again into the auxiliary stack because 4 is greater than 3. Thirdly, we continue pushing 2 into the data stack. We update the minimum number as 2 and push it into the auxiliary stack since 2 is less the previous minimum number 3. It is same in the fourth step when we push 1. We also need to update the minimum number and push 1 into the auxiliary stack. We can notice that the top of auxiliary stack is always the minimum number if we push the minimum number into auxiliary stack in each step.\n\nWhenever we pop a number from data stack, we also pop a number from auxiliary stack. If the minimum number is popped, the next minimum number should be also on the top of auxiliary stack. In the fifth step we pop 1 from the data stack, and we also pop the number on the top of auxiliary (which is 1). We can see that the next minimum number 2 is now on the top of auxiliary stack. If we continue popping from both the data and auxiliary stacks, there are only two numbers 3 and 4 left in the data stack. The minimum number 3 is indeed on the top of the auxiliary stack. Therefore, it demonstrates that our solution is correct.\n\nNow we can develop the required stack. The stack is declared as the following:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nstd::stack<T>\u00a0\u00a0 m_min; // auxiliary stack, to store minimum numbers\n};\n\nThe function push, pop and min and top can be implemented as:\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\n// push the new number into data stack\nm_data.push(value);\n\n// push the new number into auxiliary stack\n// if it is less than the previous minimum number,\n// otherwise push a replication of the minimum number\nif (m_min.size() == 0 || value < m_min.top())\nm_min.push(value);\nelse\nm_min.push(m_min.top());\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nm_data.pop();\nm_min.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nreturn m_min.top();\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nreturn m_data.top();\n}\n\nThe length of auxiliary stack should be n if we push n numbers into data stack. Therefore, we need O( n ) auxiliary memory for this solution.\n\nSolution 2: Without Auxiliary Stack\n\nThe second solution is trickier without an auxiliary stack. We do not always push numbers into data stack directly, but we have some tricky calculation before pushing.\n\nSupposing that we are going to push a number value into a stack with minimum number min . If value is greater than or equal to the min , it is pushed directly into data stack. If it is less than min , we push 2* value - min , and update min as value since a new minimum number is pushed. How about to pop? We pop it directly if the top of data stack (it is denoted as top ) is greater than or equal to min . Otherwise the number top is not the real pushed number. The real pushed number is stored is min . After the current minimum number is popped, we need to restore the previous minimum number, which is 2* min - top .\n\n\nNow let us demonstrate its correctness of this solution. Since value is greater than or equal to min , it is pushed into data stack direct without updating min . Therefore, when we find that the top of data stack is greater than or equal to min , we can pop directly without updating min . However, if we find value is less then min , we push 2* value - min . We should notice that 2* value - min should be less than value . Then we update current min as value . Therefore, the new top of data stack ( top ) is less than the current min . Therefore, when we find that the top of data stack is less then min , the real top (real pushed number value ) is stored in min . After we pop the top of data stack, we have to restore the previous minimum number. Since top = 2* value -previous min and value is current min , pervious min is 2*current min - top .\n\nIt sounds great. We feel confident to write code now with the correctness demonstration. The following is the sample code:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nT\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_min; // minimum number\n};\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\nif (m_data.size() == 0)\n{\nm_data.push(value);\nm_min = value;\n}\nelse if (value >= m_min)\n{\nm_data.push(value);\n}\nelse\n{\nm_data.push(2 * value - m_min);\nm_min = value;\n}\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0);\n\nif (m_data.top() < m_min)\nm_min = 2 * m_min - m_data.top();\n\nm_data.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0);\n\nreturn m_min;\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nT top = m_data.top();\nif (top < m_min)\ntop = m_min;\n\nreturn top;\n}\n", "question": ""},
{"answer": "\nAnalysis: Our intuition for this problem might be that we sort all of numbers in the stack when we push a new one, and keep the minimum number on the top of stack. In this way we can get the minimum number in O(1) time. However, we cannot assure that the last number pushed in to container will be the first one to be popped out, so it is no longer a stack.\n\nWe may add a new member variable in a stack to keep the minimum number. When we push a new number which is less than the minimum number, we will update it. It sounds good. However, how to get the next minimum number when the current minimum one is popped? Fortunately, we have two solutions for this problem.\n\nSolution 1: With Auxiliary Stack\n\nIt is not enough to have only a member variable to keep the minimum number. When the minimum one is popped, we need to get the next minimum one. Therefore, we need to store the next minimum number before push the current minimum one.\n\nHow about to store each minimum number (the less value of current minimum number and the number to be pushed) into an auxiliary stack? We may analyze the process to push and pop numbers via some examples (Table 1).\n\nStep Operation Data Stack Auxiliary Stack Minimum 1 Push 3 3 3 3 2 Push 4 3, 4 3, 3 3 3 Push 2 3, 4, 2 3, 3, 2 2 4 Push 1 3, 4, 2, 1 3, 3, 2, 1 1 5 Pop 3, 4, 2 3, 3, 2 2 6 Pop 3, 4 3, 3 3 7 Push 0 3, 4, 0 3, 3, 0 0\nStep\nOperation\nData Stack\nAuxiliary Stack\nMinimum\n1\nPush 3\n3\n3\n3\n2\nPush 4\n3, 4\n3, 3\n3\n3\nPush 2\n3, 4, 2\n3, 3, 2\n2\n4\nPush 1\n3, 4, 2, 1\n3, 3, 2, 1\n1\n5\nPop\n3, 4, 2\n3, 3, 2\n2\n6\nPop\n3, 4\n3, 3\n3\n7\nPush 0\n3, 4, 0\n3, 3, 0\n0\nTable 1: The status of data stack, auxiliary stack, minimum value when we push 3, 4, 2, 1, pop twice, and then push 0\n\nAt first we push 3 into both data stack and auxiliary stack. Secondly we push 4 into the data stack. We push 3 again into the auxiliary stack because 4 is greater than 3. Thirdly, we continue pushing 2 into the data stack. We update the minimum number as 2 and push it into the auxiliary stack since 2 is less the previous minimum number 3. It is same in the fourth step when we push 1. We also need to update the minimum number and push 1 into the auxiliary stack. We can notice that the top of auxiliary stack is always the minimum number if we push the minimum number into auxiliary stack in each step.\n\nWhenever we pop a number from data stack, we also pop a number from auxiliary stack. If the minimum number is popped, the next minimum number should be also on the top of auxiliary stack. In the fifth step we pop 1 from the data stack, and we also pop the number on the top of auxiliary (which is 1). We can see that the next minimum number 2 is now on the top of auxiliary stack. If we continue popping from both the data and auxiliary stacks, there are only two numbers 3 and 4 left in the data stack. The minimum number 3 is indeed on the top of the auxiliary stack. Therefore, it demonstrates that our solution is correct.\n\nNow we can develop the required stack. The stack is declared as the following:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nstd::stack<T>\u00a0\u00a0 m_min; // auxiliary stack, to store minimum numbers\n};\n\nThe function push, pop and min and top can be implemented as:\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\n// push the new number into data stack\nm_data.push(value);\n\n// push the new number into auxiliary stack\n// if it is less than the previous minimum number,\n// otherwise push a replication of the minimum number\nif (m_min.size() == 0 || value < m_min.top())\nm_min.push(value);\nelse\nm_min.push(m_min.top());\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nm_data.pop();\nm_min.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nreturn m_min.top();\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nreturn m_data.top();\n}\n\nThe length of auxiliary stack should be n if we push n numbers into data stack. Therefore, we need O( n ) auxiliary memory for this solution.\n\nSolution 2: Without Auxiliary Stack\n\nThe second solution is trickier without an auxiliary stack. We do not always push numbers into data stack directly, but we have some tricky calculation before pushing.\n\nSupposing that we are going to push a number value into a stack with minimum number min . If value is greater than or equal to the min , it is pushed directly into data stack. If it is less than min , we push 2* value - min , and update min as value since a new minimum number is pushed. How about to pop? We pop it directly if the top of data stack (it is denoted as top ) is greater than or equal to min . Otherwise the number top is not the real pushed number. The real pushed number is stored is min . After the current minimum number is popped, we need to restore the previous minimum number, which is 2* min - top .\n\n\nNow let us demonstrate its correctness of this solution. Since value is greater than or equal to min , it is pushed into data stack direct without updating min . Therefore, when we find that the top of data stack is greater than or equal to min , we can pop directly without updating min . However, if we find value is less then min , we push 2* value - min . We should notice that 2* value - min should be less than value . Then we update current min as value . Therefore, the new top of data stack ( top ) is less than the current min . Therefore, when we find that the top of data stack is less then min , the real top (real pushed number value ) is stored in min . After we pop the top of data stack, we have to restore the previous minimum number. Since top = 2* value -previous min and value is current min , pervious min is 2*current min - top .\n\nIt sounds great. We feel confident to write code now with the correctness demonstration. The following is the sample code:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nT\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_min; // minimum number\n};\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\nif (m_data.size() == 0)\n{\nm_data.push(value);\nm_min = value;\n}\nelse if (value >= m_min)\n{\nm_data.push(value);\n}\nelse\n{\nm_data.push(2 * value - m_min);\nm_min = value;\n}\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0);\n\nif (m_data.top() < m_min)\nm_min = 2 * m_min - m_data.top();\n\nm_data.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0);\n\nreturn m_min;\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nT top = m_data.top();\nif (top < m_min)\ntop = m_min;\n\nreturn top;\n}\n", "question": ""},
{"answer": "\nAnalysis: Our intuition for this problem might be that we sort all of numbers in the stack when we push a new one, and keep the minimum number on the top of stack. In this way we can get the minimum number in O(1) time. However, we cannot assure that the last number pushed in to container will be the first one to be popped out, so it is no longer a stack.\n\nWe may add a new member variable in a stack to keep the minimum number. When we push a new number which is less than the minimum number, we will update it. It sounds good. However, how to get the next minimum number when the current minimum one is popped? Fortunately, we have two solutions for this problem.\n\nSolution 1: With Auxiliary Stack\n\nIt is not enough to have only a member variable to keep the minimum number. When the minimum one is popped, we need to get the next minimum one. Therefore, we need to store the next minimum number before push the current minimum one.\n\nHow about to store each minimum number (the less value of current minimum number and the number to be pushed) into an auxiliary stack? We may analyze the process to push and pop numbers via some examples (Table 1).\n\nStep Operation Data Stack Auxiliary Stack Minimum 1 Push 3 3 3 3 2 Push 4 3, 4 3, 3 3 3 Push 2 3, 4, 2 3, 3, 2 2 4 Push 1 3, 4, 2, 1 3, 3, 2, 1 1 5 Pop 3, 4, 2 3, 3, 2 2 6 Pop 3, 4 3, 3 3 7 Push 0 3, 4, 0 3, 3, 0 0\nStep\nOperation\nData Stack\nAuxiliary Stack\nMinimum\n1\nPush 3\n3\n3\n3\n2\nPush 4\n3, 4\n3, 3\n3\n3\nPush 2\n3, 4, 2\n3, 3, 2\n2\n4\nPush 1\n3, 4, 2, 1\n3, 3, 2, 1\n1\n5\nPop\n3, 4, 2\n3, 3, 2\n2\n6\nPop\n3, 4\n3, 3\n3\n7\nPush 0\n3, 4, 0\n3, 3, 0\n0\nTable 1: The status of data stack, auxiliary stack, minimum value when we push 3, 4, 2, 1, pop twice, and then push 0\n\nAt first we push 3 into both data stack and auxiliary stack. Secondly we push 4 into the data stack. We push 3 again into the auxiliary stack because 4 is greater than 3. Thirdly, we continue pushing 2 into the data stack. We update the minimum number as 2 and push it into the auxiliary stack since 2 is less the previous minimum number 3. It is same in the fourth step when we push 1. We also need to update the minimum number and push 1 into the auxiliary stack. We can notice that the top of auxiliary stack is always the minimum number if we push the minimum number into auxiliary stack in each step.\n\nWhenever we pop a number from data stack, we also pop a number from auxiliary stack. If the minimum number is popped, the next minimum number should be also on the top of auxiliary stack. In the fifth step we pop 1 from the data stack, and we also pop the number on the top of auxiliary (which is 1). We can see that the next minimum number 2 is now on the top of auxiliary stack. If we continue popping from both the data and auxiliary stacks, there are only two numbers 3 and 4 left in the data stack. The minimum number 3 is indeed on the top of the auxiliary stack. Therefore, it demonstrates that our solution is correct.\n\nNow we can develop the required stack. The stack is declared as the following:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nstd::stack<T>\u00a0\u00a0 m_min; // auxiliary stack, to store minimum numbers\n};\n\nThe function push, pop and min and top can be implemented as:\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\n// push the new number into data stack\nm_data.push(value);\n\n// push the new number into auxiliary stack\n// if it is less than the previous minimum number,\n// otherwise push a replication of the minimum number\nif (m_min.size() == 0 || value < m_min.top())\nm_min.push(value);\nelse\nm_min.push(m_min.top());\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nm_data.pop();\nm_min.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nreturn m_min.top();\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nreturn m_data.top();\n}\n\nThe length of auxiliary stack should be n if we push n numbers into data stack. Therefore, we need O( n ) auxiliary memory for this solution.\n\nSolution 2: Without Auxiliary Stack\n\nThe second solution is trickier without an auxiliary stack. We do not always push numbers into data stack directly, but we have some tricky calculation before pushing.\n\nSupposing that we are going to push a number value into a stack with minimum number min . If value is greater than or equal to the min , it is pushed directly into data stack. If it is less than min , we push 2* value - min , and update min as value since a new minimum number is pushed. How about to pop? We pop it directly if the top of data stack (it is denoted as top ) is greater than or equal to min . Otherwise the number top is not the real pushed number. The real pushed number is stored is min . After the current minimum number is popped, we need to restore the previous minimum number, which is 2* min - top .\n\n\nNow let us demonstrate its correctness of this solution. Since value is greater than or equal to min , it is pushed into data stack direct without updating min . Therefore, when we find that the top of data stack is greater than or equal to min , we can pop directly without updating min . However, if we find value is less then min , we push 2* value - min . We should notice that 2* value - min should be less than value . Then we update current min as value . Therefore, the new top of data stack ( top ) is less than the current min . Therefore, when we find that the top of data stack is less then min , the real top (real pushed number value ) is stored in min . After we pop the top of data stack, we have to restore the previous minimum number. Since top = 2* value -previous min and value is current min , pervious min is 2*current min - top .\n\nIt sounds great. We feel confident to write code now with the correctness demonstration. The following is the sample code:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nT\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_min; // minimum number\n};\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\nif (m_data.size() == 0)\n{\nm_data.push(value);\nm_min = value;\n}\nelse if (value >= m_min)\n{\nm_data.push(value);\n}\nelse\n{\nm_data.push(2 * value - m_min);\nm_min = value;\n}\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0);\n\nif (m_data.top() < m_min)\nm_min = 2 * m_min - m_data.top();\n\nm_data.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0);\n\nreturn m_min;\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nT top = m_data.top();\nif (top < m_min)\ntop = m_min;\n\nreturn top;\n}\n", "question": ""},
{"answer": "\nAnalysis: Our intuition for this problem might be that we sort all of numbers in the stack when we push a new one, and keep the minimum number on the top of stack. In this way we can get the minimum number in O(1) time. However, we cannot assure that the last number pushed in to container will be the first one to be popped out, so it is no longer a stack.\n\nWe may add a new member variable in a stack to keep the minimum number. When we push a new number which is less than the minimum number, we will update it. It sounds good. However, how to get the next minimum number when the current minimum one is popped? Fortunately, we have two solutions for this problem.\n\nSolution 1: With Auxiliary Stack\n\nIt is not enough to have only a member variable to keep the minimum number. When the minimum one is popped, we need to get the next minimum one. Therefore, we need to store the next minimum number before push the current minimum one.\n\nHow about to store each minimum number (the less value of current minimum number and the number to be pushed) into an auxiliary stack? We may analyze the process to push and pop numbers via some examples (Table 1).\n\nStep Operation Data Stack Auxiliary Stack Minimum 1 Push 3 3 3 3 2 Push 4 3, 4 3, 3 3 3 Push 2 3, 4, 2 3, 3, 2 2 4 Push 1 3, 4, 2, 1 3, 3, 2, 1 1 5 Pop 3, 4, 2 3, 3, 2 2 6 Pop 3, 4 3, 3 3 7 Push 0 3, 4, 0 3, 3, 0 0\nStep\nOperation\nData Stack\nAuxiliary Stack\nMinimum\n1\nPush 3\n3\n3\n3\n2\nPush 4\n3, 4\n3, 3\n3\n3\nPush 2\n3, 4, 2\n3, 3, 2\n2\n4\nPush 1\n3, 4, 2, 1\n3, 3, 2, 1\n1\n5\nPop\n3, 4, 2\n3, 3, 2\n2\n6\nPop\n3, 4\n3, 3\n3\n7\nPush 0\n3, 4, 0\n3, 3, 0\n0\nTable 1: The status of data stack, auxiliary stack, minimum value when we push 3, 4, 2, 1, pop twice, and then push 0\n\nAt first we push 3 into both data stack and auxiliary stack. Secondly we push 4 into the data stack. We push 3 again into the auxiliary stack because 4 is greater than 3. Thirdly, we continue pushing 2 into the data stack. We update the minimum number as 2 and push it into the auxiliary stack since 2 is less the previous minimum number 3. It is same in the fourth step when we push 1. We also need to update the minimum number and push 1 into the auxiliary stack. We can notice that the top of auxiliary stack is always the minimum number if we push the minimum number into auxiliary stack in each step.\n\nWhenever we pop a number from data stack, we also pop a number from auxiliary stack. If the minimum number is popped, the next minimum number should be also on the top of auxiliary stack. In the fifth step we pop 1 from the data stack, and we also pop the number on the top of auxiliary (which is 1). We can see that the next minimum number 2 is now on the top of auxiliary stack. If we continue popping from both the data and auxiliary stacks, there are only two numbers 3 and 4 left in the data stack. The minimum number 3 is indeed on the top of the auxiliary stack. Therefore, it demonstrates that our solution is correct.\n\nNow we can develop the required stack. The stack is declared as the following:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nstd::stack<T>\u00a0\u00a0 m_min; // auxiliary stack, to store minimum numbers\n};\n\nThe function push, pop and min and top can be implemented as:\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\n// push the new number into data stack\nm_data.push(value);\n\n// push the new number into auxiliary stack\n// if it is less than the previous minimum number,\n// otherwise push a replication of the minimum number\nif (m_min.size() == 0 || value < m_min.top())\nm_min.push(value);\nelse\nm_min.push(m_min.top());\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nm_data.pop();\nm_min.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nreturn m_min.top();\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nreturn m_data.top();\n}\n\nThe length of auxiliary stack should be n if we push n numbers into data stack. Therefore, we need O( n ) auxiliary memory for this solution.\n\nSolution 2: Without Auxiliary Stack\n\nThe second solution is trickier without an auxiliary stack. We do not always push numbers into data stack directly, but we have some tricky calculation before pushing.\n\nSupposing that we are going to push a number value into a stack with minimum number min . If value is greater than or equal to the min , it is pushed directly into data stack. If it is less than min , we push 2* value - min , and update min as value since a new minimum number is pushed. How about to pop? We pop it directly if the top of data stack (it is denoted as top ) is greater than or equal to min . Otherwise the number top is not the real pushed number. The real pushed number is stored is min . After the current minimum number is popped, we need to restore the previous minimum number, which is 2* min - top .\n\n\nNow let us demonstrate its correctness of this solution. Since value is greater than or equal to min , it is pushed into data stack direct without updating min . Therefore, when we find that the top of data stack is greater than or equal to min , we can pop directly without updating min . However, if we find value is less then min , we push 2* value - min . We should notice that 2* value - min should be less than value . Then we update current min as value . Therefore, the new top of data stack ( top ) is less than the current min . Therefore, when we find that the top of data stack is less then min , the real top (real pushed number value ) is stored in min . After we pop the top of data stack, we have to restore the previous minimum number. Since top = 2* value -previous min and value is current min , pervious min is 2*current min - top .\n\nIt sounds great. We feel confident to write code now with the correctness demonstration. The following is the sample code:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nT\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_min; // minimum number\n};\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\nif (m_data.size() == 0)\n{\nm_data.push(value);\nm_min = value;\n}\nelse if (value >= m_min)\n{\nm_data.push(value);\n}\nelse\n{\nm_data.push(2 * value - m_min);\nm_min = value;\n}\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0);\n\nif (m_data.top() < m_min)\nm_min = 2 * m_min - m_data.top();\n\nm_data.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0);\n\nreturn m_min;\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nT top = m_data.top();\nif (top < m_min)\ntop = m_min;\n\nreturn top;\n}\n", "question": ""},
{"answer": "\nAnalysis: Our intuition for this problem might be that we sort all of numbers in the stack when we push a new one, and keep the minimum number on the top of stack. In this way we can get the minimum number in O(1) time. However, we cannot assure that the last number pushed in to container will be the first one to be popped out, so it is no longer a stack.\n\nWe may add a new member variable in a stack to keep the minimum number. When we push a new number which is less than the minimum number, we will update it. It sounds good. However, how to get the next minimum number when the current minimum one is popped? Fortunately, we have two solutions for this problem.\n\nSolution 1: With Auxiliary Stack\n\nIt is not enough to have only a member variable to keep the minimum number. When the minimum one is popped, we need to get the next minimum one. Therefore, we need to store the next minimum number before push the current minimum one.\n\nHow about to store each minimum number (the less value of current minimum number and the number to be pushed) into an auxiliary stack? We may analyze the process to push and pop numbers via some examples (Table 1).\n\nStep Operation Data Stack Auxiliary Stack Minimum 1 Push 3 3 3 3 2 Push 4 3, 4 3, 3 3 3 Push 2 3, 4, 2 3, 3, 2 2 4 Push 1 3, 4, 2, 1 3, 3, 2, 1 1 5 Pop 3, 4, 2 3, 3, 2 2 6 Pop 3, 4 3, 3 3 7 Push 0 3, 4, 0 3, 3, 0 0\nStep\nOperation\nData Stack\nAuxiliary Stack\nMinimum\n1\nPush 3\n3\n3\n3\n2\nPush 4\n3, 4\n3, 3\n3\n3\nPush 2\n3, 4, 2\n3, 3, 2\n2\n4\nPush 1\n3, 4, 2, 1\n3, 3, 2, 1\n1\n5\nPop\n3, 4, 2\n3, 3, 2\n2\n6\nPop\n3, 4\n3, 3\n3\n7\nPush 0\n3, 4, 0\n3, 3, 0\n0\nTable 1: The status of data stack, auxiliary stack, minimum value when we push 3, 4, 2, 1, pop twice, and then push 0\n\nAt first we push 3 into both data stack and auxiliary stack. Secondly we push 4 into the data stack. We push 3 again into the auxiliary stack because 4 is greater than 3. Thirdly, we continue pushing 2 into the data stack. We update the minimum number as 2 and push it into the auxiliary stack since 2 is less the previous minimum number 3. It is same in the fourth step when we push 1. We also need to update the minimum number and push 1 into the auxiliary stack. We can notice that the top of auxiliary stack is always the minimum number if we push the minimum number into auxiliary stack in each step.\n\nWhenever we pop a number from data stack, we also pop a number from auxiliary stack. If the minimum number is popped, the next minimum number should be also on the top of auxiliary stack. In the fifth step we pop 1 from the data stack, and we also pop the number on the top of auxiliary (which is 1). We can see that the next minimum number 2 is now on the top of auxiliary stack. If we continue popping from both the data and auxiliary stacks, there are only two numbers 3 and 4 left in the data stack. The minimum number 3 is indeed on the top of the auxiliary stack. Therefore, it demonstrates that our solution is correct.\n\nNow we can develop the required stack. The stack is declared as the following:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nstd::stack<T>\u00a0\u00a0 m_min; // auxiliary stack, to store minimum numbers\n};\n\nThe function push, pop and min and top can be implemented as:\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\n// push the new number into data stack\nm_data.push(value);\n\n// push the new number into auxiliary stack\n// if it is less than the previous minimum number,\n// otherwise push a replication of the minimum number\nif (m_min.size() == 0 || value < m_min.top())\nm_min.push(value);\nelse\nm_min.push(m_min.top());\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nm_data.pop();\nm_min.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nreturn m_min.top();\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nreturn m_data.top();\n}\n\nThe length of auxiliary stack should be n if we push n numbers into data stack. Therefore, we need O( n ) auxiliary memory for this solution.\n\nSolution 2: Without Auxiliary Stack\n\nThe second solution is trickier without an auxiliary stack. We do not always push numbers into data stack directly, but we have some tricky calculation before pushing.\n\nSupposing that we are going to push a number value into a stack with minimum number min . If value is greater than or equal to the min , it is pushed directly into data stack. If it is less than min , we push 2* value - min , and update min as value since a new minimum number is pushed. How about to pop? We pop it directly if the top of data stack (it is denoted as top ) is greater than or equal to min . Otherwise the number top is not the real pushed number. The real pushed number is stored is min . After the current minimum number is popped, we need to restore the previous minimum number, which is 2* min - top .\n\n\nNow let us demonstrate its correctness of this solution. Since value is greater than or equal to min , it is pushed into data stack direct without updating min . Therefore, when we find that the top of data stack is greater than or equal to min , we can pop directly without updating min . However, if we find value is less then min , we push 2* value - min . We should notice that 2* value - min should be less than value . Then we update current min as value . Therefore, the new top of data stack ( top ) is less than the current min . Therefore, when we find that the top of data stack is less then min , the real top (real pushed number value ) is stored in min . After we pop the top of data stack, we have to restore the previous minimum number. Since top = 2* value -previous min and value is current min , pervious min is 2*current min - top .\n\nIt sounds great. We feel confident to write code now with the correctness demonstration. The following is the sample code:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nT\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_min; // minimum number\n};\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\nif (m_data.size() == 0)\n{\nm_data.push(value);\nm_min = value;\n}\nelse if (value >= m_min)\n{\nm_data.push(value);\n}\nelse\n{\nm_data.push(2 * value - m_min);\nm_min = value;\n}\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0);\n\nif (m_data.top() < m_min)\nm_min = 2 * m_min - m_data.top();\n\nm_data.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0);\n\nreturn m_min;\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nT top = m_data.top();\nif (top < m_min)\ntop = m_min;\n\nreturn top;\n}\n", "question": ""},
{"answer": "\nAnalysis: Our intuition for this problem might be that we sort all of numbers in the stack when we push a new one, and keep the minimum number on the top of stack. In this way we can get the minimum number in O(1) time. However, we cannot assure that the last number pushed in to container will be the first one to be popped out, so it is no longer a stack.\n\nWe may add a new member variable in a stack to keep the minimum number. When we push a new number which is less than the minimum number, we will update it. It sounds good. However, how to get the next minimum number when the current minimum one is popped? Fortunately, we have two solutions for this problem.\n\nSolution 1: With Auxiliary Stack\n\nIt is not enough to have only a member variable to keep the minimum number. When the minimum one is popped, we need to get the next minimum one. Therefore, we need to store the next minimum number before push the current minimum one.\n\nHow about to store each minimum number (the less value of current minimum number and the number to be pushed) into an auxiliary stack? We may analyze the process to push and pop numbers via some examples (Table 1).\n\nStep Operation Data Stack Auxiliary Stack Minimum 1 Push 3 3 3 3 2 Push 4 3, 4 3, 3 3 3 Push 2 3, 4, 2 3, 3, 2 2 4 Push 1 3, 4, 2, 1 3, 3, 2, 1 1 5 Pop 3, 4, 2 3, 3, 2 2 6 Pop 3, 4 3, 3 3 7 Push 0 3, 4, 0 3, 3, 0 0\nStep\nOperation\nData Stack\nAuxiliary Stack\nMinimum\n1\nPush 3\n3\n3\n3\n2\nPush 4\n3, 4\n3, 3\n3\n3\nPush 2\n3, 4, 2\n3, 3, 2\n2\n4\nPush 1\n3, 4, 2, 1\n3, 3, 2, 1\n1\n5\nPop\n3, 4, 2\n3, 3, 2\n2\n6\nPop\n3, 4\n3, 3\n3\n7\nPush 0\n3, 4, 0\n3, 3, 0\n0\nTable 1: The status of data stack, auxiliary stack, minimum value when we push 3, 4, 2, 1, pop twice, and then push 0\n\nAt first we push 3 into both data stack and auxiliary stack. Secondly we push 4 into the data stack. We push 3 again into the auxiliary stack because 4 is greater than 3. Thirdly, we continue pushing 2 into the data stack. We update the minimum number as 2 and push it into the auxiliary stack since 2 is less the previous minimum number 3. It is same in the fourth step when we push 1. We also need to update the minimum number and push 1 into the auxiliary stack. We can notice that the top of auxiliary stack is always the minimum number if we push the minimum number into auxiliary stack in each step.\n\nWhenever we pop a number from data stack, we also pop a number from auxiliary stack. If the minimum number is popped, the next minimum number should be also on the top of auxiliary stack. In the fifth step we pop 1 from the data stack, and we also pop the number on the top of auxiliary (which is 1). We can see that the next minimum number 2 is now on the top of auxiliary stack. If we continue popping from both the data and auxiliary stacks, there are only two numbers 3 and 4 left in the data stack. The minimum number 3 is indeed on the top of the auxiliary stack. Therefore, it demonstrates that our solution is correct.\n\nNow we can develop the required stack. The stack is declared as the following:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nstd::stack<T>\u00a0\u00a0 m_min; // auxiliary stack, to store minimum numbers\n};\n\nThe function push, pop and min and top can be implemented as:\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\n// push the new number into data stack\nm_data.push(value);\n\n// push the new number into auxiliary stack\n// if it is less than the previous minimum number,\n// otherwise push a replication of the minimum number\nif (m_min.size() == 0 || value < m_min.top())\nm_min.push(value);\nelse\nm_min.push(m_min.top());\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nm_data.pop();\nm_min.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nreturn m_min.top();\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nreturn m_data.top();\n}\n\nThe length of auxiliary stack should be n if we push n numbers into data stack. Therefore, we need O( n ) auxiliary memory for this solution.\n\nSolution 2: Without Auxiliary Stack\n\nThe second solution is trickier without an auxiliary stack. We do not always push numbers into data stack directly, but we have some tricky calculation before pushing.\n\nSupposing that we are going to push a number value into a stack with minimum number min . If value is greater than or equal to the min , it is pushed directly into data stack. If it is less than min , we push 2* value - min , and update min as value since a new minimum number is pushed. How about to pop? We pop it directly if the top of data stack (it is denoted as top ) is greater than or equal to min . Otherwise the number top is not the real pushed number. The real pushed number is stored is min . After the current minimum number is popped, we need to restore the previous minimum number, which is 2* min - top .\n\n\nNow let us demonstrate its correctness of this solution. Since value is greater than or equal to min , it is pushed into data stack direct without updating min . Therefore, when we find that the top of data stack is greater than or equal to min , we can pop directly without updating min . However, if we find value is less then min , we push 2* value - min . We should notice that 2* value - min should be less than value . Then we update current min as value . Therefore, the new top of data stack ( top ) is less than the current min . Therefore, when we find that the top of data stack is less then min , the real top (real pushed number value ) is stored in min . After we pop the top of data stack, we have to restore the previous minimum number. Since top = 2* value -previous min and value is current min , pervious min is 2*current min - top .\n\nIt sounds great. We feel confident to write code now with the correctness demonstration. The following is the sample code:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nT\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_min; // minimum number\n};\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\nif (m_data.size() == 0)\n{\nm_data.push(value);\nm_min = value;\n}\nelse if (value >= m_min)\n{\nm_data.push(value);\n}\nelse\n{\nm_data.push(2 * value - m_min);\nm_min = value;\n}\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0);\n\nif (m_data.top() < m_min)\nm_min = 2 * m_min - m_data.top();\n\nm_data.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0);\n\nreturn m_min;\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nT top = m_data.top();\nif (top < m_min)\ntop = m_min;\n\nreturn top;\n}\n", "question": ""},
{"answer": "\nAnalysis: Our intuition for this problem might be that we sort all of numbers in the stack when we push a new one, and keep the minimum number on the top of stack. In this way we can get the minimum number in O(1) time. However, we cannot assure that the last number pushed in to container will be the first one to be popped out, so it is no longer a stack.\n\nWe may add a new member variable in a stack to keep the minimum number. When we push a new number which is less than the minimum number, we will update it. It sounds good. However, how to get the next minimum number when the current minimum one is popped? Fortunately, we have two solutions for this problem.\n\nSolution 1: With Auxiliary Stack\n\nIt is not enough to have only a member variable to keep the minimum number. When the minimum one is popped, we need to get the next minimum one. Therefore, we need to store the next minimum number before push the current minimum one.\n\nHow about to store each minimum number (the less value of current minimum number and the number to be pushed) into an auxiliary stack? We may analyze the process to push and pop numbers via some examples (Table 1).\n\nStep Operation Data Stack Auxiliary Stack Minimum 1 Push 3 3 3 3 2 Push 4 3, 4 3, 3 3 3 Push 2 3, 4, 2 3, 3, 2 2 4 Push 1 3, 4, 2, 1 3, 3, 2, 1 1 5 Pop 3, 4, 2 3, 3, 2 2 6 Pop 3, 4 3, 3 3 7 Push 0 3, 4, 0 3, 3, 0 0\nStep\nOperation\nData Stack\nAuxiliary Stack\nMinimum\n1\nPush 3\n3\n3\n3\n2\nPush 4\n3, 4\n3, 3\n3\n3\nPush 2\n3, 4, 2\n3, 3, 2\n2\n4\nPush 1\n3, 4, 2, 1\n3, 3, 2, 1\n1\n5\nPop\n3, 4, 2\n3, 3, 2\n2\n6\nPop\n3, 4\n3, 3\n3\n7\nPush 0\n3, 4, 0\n3, 3, 0\n0\nTable 1: The status of data stack, auxiliary stack, minimum value when we push 3, 4, 2, 1, pop twice, and then push 0\n\nAt first we push 3 into both data stack and auxiliary stack. Secondly we push 4 into the data stack. We push 3 again into the auxiliary stack because 4 is greater than 3. Thirdly, we continue pushing 2 into the data stack. We update the minimum number as 2 and push it into the auxiliary stack since 2 is less the previous minimum number 3. It is same in the fourth step when we push 1. We also need to update the minimum number and push 1 into the auxiliary stack. We can notice that the top of auxiliary stack is always the minimum number if we push the minimum number into auxiliary stack in each step.\n\nWhenever we pop a number from data stack, we also pop a number from auxiliary stack. If the minimum number is popped, the next minimum number should be also on the top of auxiliary stack. In the fifth step we pop 1 from the data stack, and we also pop the number on the top of auxiliary (which is 1). We can see that the next minimum number 2 is now on the top of auxiliary stack. If we continue popping from both the data and auxiliary stacks, there are only two numbers 3 and 4 left in the data stack. The minimum number 3 is indeed on the top of the auxiliary stack. Therefore, it demonstrates that our solution is correct.\n\nNow we can develop the required stack. The stack is declared as the following:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nstd::stack<T>\u00a0\u00a0 m_min; // auxiliary stack, to store minimum numbers\n};\n\nThe function push, pop and min and top can be implemented as:\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\n// push the new number into data stack\nm_data.push(value);\n\n// push the new number into auxiliary stack\n// if it is less than the previous minimum number,\n// otherwise push a replication of the minimum number\nif (m_min.size() == 0 || value < m_min.top())\nm_min.push(value);\nelse\nm_min.push(m_min.top());\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nm_data.pop();\nm_min.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0 && m_min.size() > 0);\n\nreturn m_min.top();\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nreturn m_data.top();\n}\n\nThe length of auxiliary stack should be n if we push n numbers into data stack. Therefore, we need O( n ) auxiliary memory for this solution.\n\nSolution 2: Without Auxiliary Stack\n\nThe second solution is trickier without an auxiliary stack. We do not always push numbers into data stack directly, but we have some tricky calculation before pushing.\n\nSupposing that we are going to push a number value into a stack with minimum number min . If value is greater than or equal to the min , it is pushed directly into data stack. If it is less than min , we push 2* value - min , and update min as value since a new minimum number is pushed. How about to pop? We pop it directly if the top of data stack (it is denoted as top ) is greater than or equal to min . Otherwise the number top is not the real pushed number. The real pushed number is stored is min . After the current minimum number is popped, we need to restore the previous minimum number, which is 2* min - top .\n\n\nNow let us demonstrate its correctness of this solution. Since value is greater than or equal to min , it is pushed into data stack direct without updating min . Therefore, when we find that the top of data stack is greater than or equal to min , we can pop directly without updating min . However, if we find value is less then min , we push 2* value - min . We should notice that 2* value - min should be less than value . Then we update current min as value . Therefore, the new top of data stack ( top ) is less than the current min . Therefore, when we find that the top of data stack is less then min , the real top (real pushed number value ) is stored in min . After we pop the top of data stack, we have to restore the previous minimum number. Since top = 2* value -previous min and value is current min , pervious min is 2*current min - top .\n\nIt sounds great. We feel confident to write code now with the correctness demonstration. The following is the sample code:\n\ntemplate < typename T> class StackWithMin\n{\npublic :\nStackWithMin( void ) {}\nvirtual ~StackWithMin( void ) {}\n\nT& top( void );\n\nvoid push( const T& value);\nvoid pop( void );\n\nconst T& min( void ) const ;\n\nprivate :\nstd::stack<T>\u00a0\u00a0 m_data; // data stack, to store numbers\nT\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 m_min; // minimum number\n};\n\ntemplate < typename T> void StackWithMin<T>::push( const T& value)\n{\nif (m_data.size() == 0)\n{\nm_data.push(value);\nm_min = value;\n}\nelse if (value >= m_min)\n{\nm_data.push(value);\n}\nelse\n{\nm_data.push(2 * value - m_min);\nm_min = value;\n}\n}\n\ntemplate < typename T> void StackWithMin<T>::pop()\n{\nassert(m_data.size() > 0);\n\nif (m_data.top() < m_min)\nm_min = 2 * m_min - m_data.top();\n\nm_data.pop();\n}\n\ntemplate < typename T> const T& StackWithMin<T>::min() const\n{\nassert(m_data.size() > 0);\n\nreturn m_min;\n}\n\ntemplate < typename T> T& StackWithMin<T>::top()\n{\nT top = m_data.top();\nif (top < m_min)\ntop = m_min;\n\nreturn top;\n}\n", "question": ""},
{"answer": "\nAnalysis: During interviews, many candidates can solve it by enumerating all of sub-arrays and calculate their sum. An array with n elements has n(n+1)/2 sub-arrays. It costs O(n 2 ) time at least to calculate their sum. Usually the intuitive and forceful solution is not the most optimized one. Interviewers will tell us that there are better solutions.\n\nSolution 1: Analyze arrays number by number\n\nWe try to accumulate every number in the example array from first to end. We initialize sum as 0. At our first step, add the first number 1, and sum is 1. And then if we add the second number -2, sum becomes -1. At the third step, we add the third number 3. We can notice that sum is less than 0, so the new sum will be 2 and it is less than the third number 3 itself if we add it with a negative sum . Therefore, the accumulated sum can be discarded.\n\nWe continue accumulating from the third number with sum 3. When we add it with the fourth number 10, sum becomes 13, and it decreases to 9 when we add it with the fifth number -4. We can notice that the sum with -4 is less than the previous sum since -4 is a negative number. Therefore, we should store the previous sum 13, since it might be the max sum of sub-arrays. At the sixth step, we add the sixth number 7 and sum is 16. Now sum is greater than the previous max sum of sub-arrays, we need to update it to 16. It is same when we add the seventh number 2. The max sum of sub-arrays is updated to 18. Lastly we add -5 and sum becomes 13. Since it is less than the previous max sum of sub-arrays, it final max sum of sub-array is 18, and the sub-array is { 3, 10, -4, 7, 2 } accordingly. We can summarize the whole process with the Table 1:\n\nStep Operation Accumulated sum of sub-arrays Maximum sum 1 Add 1 1 1 2 Add -2 -1 1 3 Discard previous sum -1, add 3 3 3 4 Add 10 13 13 5 Add -4 9 13 6 Add 7 16 16 7 Add 2 18 18 8 Add -5 13 18\nStep\nOperation\nAccumulated sum of sub-arrays\nMaximum sum\n1\nAdd 1\n1\n1\n2\nAdd -2\n-1\n1\n3\nDiscard previous sum -1, add 3\n3\n3\n4\nAdd 10\n13\n13\n5\nAdd -4\n9\n13\n6\nAdd 7\n16\n16\n7\nAdd 2\n18\n18\n8\nAdd -5\n13\n18\nTable 1: The process to calculate the maximum sum of all sub-arrays in the array {1, -2, 3, 10, -4, 7, 2, -5}\n\nAfter we get clear ideas of this solution, we are ready to develop some code. The following is the sample code:\n\nbool g_InvalidInput = false ;\n\nint FindGreatestSumOfSubArray( int *pData, int nLength)\n{\nif ((pData == NULL) || (nLength <= 0))\n{\ng_InvalidInput = true ;\nreturn 0;\n}\n\ng_InvalidInput = false ;\n\nint nCurSum = 0;\nint nGreatestSum = 0x80000000;\nfor ( int i = 0; i < nLength; ++i)\n{\nif (nCurSum <= 0)\nnCurSum = pData[i];\nelse\nnCurSum += pData[i];\n\nif (nCurSum > nGreatestSum)\nnGreatestSum = nCurSum;\n}\n\nreturn nGreatestSum;\n}\n\nWe should keep invalid inputs during interview, such as the pointer parameter of array is NULL or its length is 0. What should be return for the invalid inputs? If it is 0, how can we distinguish the two situations: one is for the actual maximum sum of sub-arrays is 0 and the other is for invalid inputs? Therefore, we define a global variable to make whether inputs are invalid or not.\n\nSolution 2: Dynamic programming\n\nIf we have a deep understanding of algorithm, we may solve this problem with dynamic programming. If function f(i) stands for the maximum sum of a sum-array ended with the i th number, what it is to get is max[f(i)] . We can calculate f(i) with the following recursive equation:\n\n\n\nIn the equation above, if the sum of sub-array ended with the (i-1) th number is negative, the sum of sub-array ended with the i th number should be the i th number itself (it is the third step in the Table 1). Otherwise, we can get the sum of sub-array ended with the i th number by adding the i th number and the sum of sub-array ended with the previous number.\n", "question": "\nQuestion: A sub-array has one number of some continuous numbers. Given an integer array with positive numbers and negative numbers, get the maximum sum of all sub-arrays. Time complexity should be O(n).\n\nFor example, in the array { 1, -2, 3, 10, -4, 7, 2, -5 }, its sub-array { 3, 10, -4, 7, 2 } has the maximum sum 18.\n\n"},
{"answer": "\nAnalysis: During interviews, many candidates can solve it by enumerating all of sub-arrays and calculate their sum. An array with n elements has n(n+1)/2 sub-arrays. It costs O(n 2 ) time at least to calculate their sum. Usually the intuitive and forceful solution is not the most optimized one. Interviewers will tell us that there are better solutions.\n\nSolution 1: Analyze arrays number by number\n\nWe try to accumulate every number in the example array from first to end. We initialize sum as 0. At our first step, add the first number 1, and sum is 1. And then if we add the second number -2, sum becomes -1. At the third step, we add the third number 3. We can notice that sum is less than 0, so the new sum will be 2 and it is less than the third number 3 itself if we add it with a negative sum . Therefore, the accumulated sum can be discarded.\n\nWe continue accumulating from the third number with sum 3. When we add it with the fourth number 10, sum becomes 13, and it decreases to 9 when we add it with the fifth number -4. We can notice that the sum with -4 is less than the previous sum since -4 is a negative number. Therefore, we should store the previous sum 13, since it might be the max sum of sub-arrays. At the sixth step, we add the sixth number 7 and sum is 16. Now sum is greater than the previous max sum of sub-arrays, we need to update it to 16. It is same when we add the seventh number 2. The max sum of sub-arrays is updated to 18. Lastly we add -5 and sum becomes 13. Since it is less than the previous max sum of sub-arrays, it final max sum of sub-array is 18, and the sub-array is { 3, 10, -4, 7, 2 } accordingly. We can summarize the whole process with the Table 1:\n\nStep Operation Accumulated sum of sub-arrays Maximum sum 1 Add 1 1 1 2 Add -2 -1 1 3 Discard previous sum -1, add 3 3 3 4 Add 10 13 13 5 Add -4 9 13 6 Add 7 16 16 7 Add 2 18 18 8 Add -5 13 18\nStep\nOperation\nAccumulated sum of sub-arrays\nMaximum sum\n1\nAdd 1\n1\n1\n2\nAdd -2\n-1\n1\n3\nDiscard previous sum -1, add 3\n3\n3\n4\nAdd 10\n13\n13\n5\nAdd -4\n9\n13\n6\nAdd 7\n16\n16\n7\nAdd 2\n18\n18\n8\nAdd -5\n13\n18\nTable 1: The process to calculate the maximum sum of all sub-arrays in the array {1, -2, 3, 10, -4, 7, 2, -5}\n\nAfter we get clear ideas of this solution, we are ready to develop some code. The following is the sample code:\n\nbool g_InvalidInput = false ;\n\nint FindGreatestSumOfSubArray( int *pData, int nLength)\n{\nif ((pData == NULL) || (nLength <= 0))\n{\ng_InvalidInput = true ;\nreturn 0;\n}\n\ng_InvalidInput = false ;\n\nint nCurSum = 0;\nint nGreatestSum = 0x80000000;\nfor ( int i = 0; i < nLength; ++i)\n{\nif (nCurSum <= 0)\nnCurSum = pData[i];\nelse\nnCurSum += pData[i];\n\nif (nCurSum > nGreatestSum)\nnGreatestSum = nCurSum;\n}\n\nreturn nGreatestSum;\n}\n\nWe should keep invalid inputs during interview, such as the pointer parameter of array is NULL or its length is 0. What should be return for the invalid inputs? If it is 0, how can we distinguish the two situations: one is for the actual maximum sum of sub-arrays is 0 and the other is for invalid inputs? Therefore, we define a global variable to make whether inputs are invalid or not.\n\nSolution 2: Dynamic programming\n\nIf we have a deep understanding of algorithm, we may solve this problem with dynamic programming. If function f(i) stands for the maximum sum of a sum-array ended with the i th number, what it is to get is max[f(i)] . We can calculate f(i) with the following recursive equation:\n\n\n\nIn the equation above, if the sum of sub-array ended with the (i-1) th number is negative, the sum of sub-array ended with the i th number should be the i th number itself (it is the third step in the Table 1). Otherwise, we can get the sum of sub-array ended with the i th number by adding the i th number and the sum of sub-array ended with the previous number.\n", "question": "\nQuestion: A sub-array has one number of some continuous numbers. Given an integer array with positive numbers and negative numbers, get the maximum sum of all sub-arrays. Time complexity should be O(n).\n\nFor example, in the array { 1, -2, 3, 10, -4, 7, 2, -5 }, its sub-array { 3, 10, -4, 7, 2 } has the maximum sum 18.\n\n"},
{"answer": "\nAnalysis: During interviews, many candidates can solve it by enumerating all of sub-arrays and calculate their sum. An array with n elements has n(n+1)/2 sub-arrays. It costs O(n 2 ) time at least to calculate their sum. Usually the intuitive and forceful solution is not the most optimized one. Interviewers will tell us that there are better solutions.\n\nSolution 1: Analyze arrays number by number\n\nWe try to accumulate every number in the example array from first to end. We initialize sum as 0. At our first step, add the first number 1, and sum is 1. And then if we add the second number -2, sum becomes -1. At the third step, we add the third number 3. We can notice that sum is less than 0, so the new sum will be 2 and it is less than the third number 3 itself if we add it with a negative sum . Therefore, the accumulated sum can be discarded.\n\nWe continue accumulating from the third number with sum 3. When we add it with the fourth number 10, sum becomes 13, and it decreases to 9 when we add it with the fifth number -4. We can notice that the sum with -4 is less than the previous sum since -4 is a negative number. Therefore, we should store the previous sum 13, since it might be the max sum of sub-arrays. At the sixth step, we add the sixth number 7 and sum is 16. Now sum is greater than the previous max sum of sub-arrays, we need to update it to 16. It is same when we add the seventh number 2. The max sum of sub-arrays is updated to 18. Lastly we add -5 and sum becomes 13. Since it is less than the previous max sum of sub-arrays, it final max sum of sub-array is 18, and the sub-array is { 3, 10, -4, 7, 2 } accordingly. We can summarize the whole process with the Table 1:\n\nStep Operation Accumulated sum of sub-arrays Maximum sum 1 Add 1 1 1 2 Add -2 -1 1 3 Discard previous sum -1, add 3 3 3 4 Add 10 13 13 5 Add -4 9 13 6 Add 7 16 16 7 Add 2 18 18 8 Add -5 13 18\nStep\nOperation\nAccumulated sum of sub-arrays\nMaximum sum\n1\nAdd 1\n1\n1\n2\nAdd -2\n-1\n1\n3\nDiscard previous sum -1, add 3\n3\n3\n4\nAdd 10\n13\n13\n5\nAdd -4\n9\n13\n6\nAdd 7\n16\n16\n7\nAdd 2\n18\n18\n8\nAdd -5\n13\n18\nTable 1: The process to calculate the maximum sum of all sub-arrays in the array {1, -2, 3, 10, -4, 7, 2, -5}\n\nAfter we get clear ideas of this solution, we are ready to develop some code. The following is the sample code:\n\nbool g_InvalidInput = false ;\n\nint FindGreatestSumOfSubArray( int *pData, int nLength)\n{\nif ((pData == NULL) || (nLength <= 0))\n{\ng_InvalidInput = true ;\nreturn 0;\n}\n\ng_InvalidInput = false ;\n\nint nCurSum = 0;\nint nGreatestSum = 0x80000000;\nfor ( int i = 0; i < nLength; ++i)\n{\nif (nCurSum <= 0)\nnCurSum = pData[i];\nelse\nnCurSum += pData[i];\n\nif (nCurSum > nGreatestSum)\nnGreatestSum = nCurSum;\n}\n\nreturn nGreatestSum;\n}\n\nWe should keep invalid inputs during interview, such as the pointer parameter of array is NULL or its length is 0. What should be return for the invalid inputs? If it is 0, how can we distinguish the two situations: one is for the actual maximum sum of sub-arrays is 0 and the other is for invalid inputs? Therefore, we define a global variable to make whether inputs are invalid or not.\n\nSolution 2: Dynamic programming\n\nIf we have a deep understanding of algorithm, we may solve this problem with dynamic programming. If function f(i) stands for the maximum sum of a sum-array ended with the i th number, what it is to get is max[f(i)] . We can calculate f(i) with the following recursive equation:\n\n\n\nIn the equation above, if the sum of sub-array ended with the (i-1) th number is negative, the sum of sub-array ended with the i th number should be the i th number itself (it is the third step in the Table 1). Otherwise, we can get the sum of sub-array ended with the i th number by adding the i th number and the sum of sub-array ended with the previous number.\n", "question": "\nQuestion: A sub-array has one number of some continuous numbers. Given an integer array with positive numbers and negative numbers, get the maximum sum of all sub-arrays. Time complexity should be O(n).\n\nFor example, in the array { 1, -2, 3, 10, -4, 7, 2, -5 }, its sub-array { 3, 10, -4, 7, 2 } has the maximum sum 18.\n\n"},
{"answer": "\nAnalysis: During interviews, many candidates can solve it by enumerating all of sub-arrays and calculate their sum. An array with n elements has n(n+1)/2 sub-arrays. It costs O(n 2 ) time at least to calculate their sum. Usually the intuitive and forceful solution is not the most optimized one. Interviewers will tell us that there are better solutions.\n\nSolution 1: Analyze arrays number by number\n\nWe try to accumulate every number in the example array from first to end. We initialize sum as 0. At our first step, add the first number 1, and sum is 1. And then if we add the second number -2, sum becomes -1. At the third step, we add the third number 3. We can notice that sum is less than 0, so the new sum will be 2 and it is less than the third number 3 itself if we add it with a negative sum . Therefore, the accumulated sum can be discarded.\n\nWe continue accumulating from the third number with sum 3. When we add it with the fourth number 10, sum becomes 13, and it decreases to 9 when we add it with the fifth number -4. We can notice that the sum with -4 is less than the previous sum since -4 is a negative number. Therefore, we should store the previous sum 13, since it might be the max sum of sub-arrays. At the sixth step, we add the sixth number 7 and sum is 16. Now sum is greater than the previous max sum of sub-arrays, we need to update it to 16. It is same when we add the seventh number 2. The max sum of sub-arrays is updated to 18. Lastly we add -5 and sum becomes 13. Since it is less than the previous max sum of sub-arrays, it final max sum of sub-array is 18, and the sub-array is { 3, 10, -4, 7, 2 } accordingly. We can summarize the whole process with the Table 1:\n\nStep Operation Accumulated sum of sub-arrays Maximum sum 1 Add 1 1 1 2 Add -2 -1 1 3 Discard previous sum -1, add 3 3 3 4 Add 10 13 13 5 Add -4 9 13 6 Add 7 16 16 7 Add 2 18 18 8 Add -5 13 18\nStep\nOperation\nAccumulated sum of sub-arrays\nMaximum sum\n1\nAdd 1\n1\n1\n2\nAdd -2\n-1\n1\n3\nDiscard previous sum -1, add 3\n3\n3\n4\nAdd 10\n13\n13\n5\nAdd -4\n9\n13\n6\nAdd 7\n16\n16\n7\nAdd 2\n18\n18\n8\nAdd -5\n13\n18\nTable 1: The process to calculate the maximum sum of all sub-arrays in the array {1, -2, 3, 10, -4, 7, 2, -5}\n\nAfter we get clear ideas of this solution, we are ready to develop some code. The following is the sample code:\n\nbool g_InvalidInput = false ;\n\nint FindGreatestSumOfSubArray( int *pData, int nLength)\n{\nif ((pData == NULL) || (nLength <= 0))\n{\ng_InvalidInput = true ;\nreturn 0;\n}\n\ng_InvalidInput = false ;\n\nint nCurSum = 0;\nint nGreatestSum = 0x80000000;\nfor ( int i = 0; i < nLength; ++i)\n{\nif (nCurSum <= 0)\nnCurSum = pData[i];\nelse\nnCurSum += pData[i];\n\nif (nCurSum > nGreatestSum)\nnGreatestSum = nCurSum;\n}\n\nreturn nGreatestSum;\n}\n\nWe should keep invalid inputs during interview, such as the pointer parameter of array is NULL or its length is 0. What should be return for the invalid inputs? If it is 0, how can we distinguish the two situations: one is for the actual maximum sum of sub-arrays is 0 and the other is for invalid inputs? Therefore, we define a global variable to make whether inputs are invalid or not.\n\nSolution 2: Dynamic programming\n\nIf we have a deep understanding of algorithm, we may solve this problem with dynamic programming. If function f(i) stands for the maximum sum of a sum-array ended with the i th number, what it is to get is max[f(i)] . We can calculate f(i) with the following recursive equation:\n\n\n\nIn the equation above, if the sum of sub-array ended with the (i-1) th number is negative, the sum of sub-array ended with the i th number should be the i th number itself (it is the third step in the Table 1). Otherwise, we can get the sum of sub-array ended with the i th number by adding the i th number and the sum of sub-array ended with the previous number.\n", "question": "\nQuestion: A sub-array has one number of some continuous numbers. Given an integer array with positive numbers and negative numbers, get the maximum sum of all sub-arrays. Time complexity should be O(n).\n\nFor example, in the array { 1, -2, 3, 10, -4, 7, 2, -5 }, its sub-array { 3, 10, -4, 7, 2 } has the maximum sum 18.\n\n"},
{"answer": "\nAnalysis: A na\u00efve solution with brute force is quite straightforward: We can get the result for each number minus every number on its right side, and then get the maximal difference after comparisons. Since O(n) minus operations are required for each number in an array with n numbers, the overall time complexity is O(n 2 ). Brutal force solution usually is not the best solution. Let us try to reduce the times of minus operations.\n\nSolution 1: via divide and conquer\n\nWe divide an array into two sub-arrays with same size. The maximal difference of all pairs occurs in one of the three following situations: (1) two numbers of a pair are both in the first sub-array; (2) two numbers of a pair are both in the second sub-array; (3) the minuend is in the greatest number in the first sub-array, and the subtrahend is the least number in the second sub-array.\n\nIt is not a difficult to get the maximal number in the first sub-array and the minimal number in the second sub-array. How about to get the maximal difference of all pairs in two sub-arrays? They are actually sub-problems of the original problem, and we can solve them via recursion. The following are the sample code of this solution:\n\nint MaxDiff_Solution1( int numbers[], unsigned length)\n{\nif (numbers == NULL || length < 2)\nreturn 0;\n\nint max, min;\nreturn MaxDiffCore(numbers, numbers + length - 1, &max, &min);\n}\n\nint MaxDiffCore( int * start, int * end, int * max, int * min)\n{\nif (end == start)\n{\n*max = *min = *start;\nreturn 0x80000000;\n}\n\nint * middle = start + (end - start) / 2;\n\nint maxLeft, minLeft;\nint leftDiff = MaxDiffCore(start, middle, &maxLeft, &minLeft);\n\nint maxRight, minRight;\nint rightDiff = MaxDiffCore(middle + 1, end, &maxRight, &minRight);\n\nint crossDiff = maxLeft - minRight;\n\n*max = (maxLeft > maxRight) ? maxLeft : maxRight;\n*min = (minLeft < minRight) ? minLeft : minRight;\n\nint maxDiff = (leftDiff > rightDiff) ? leftDiff : rightDiff;\nmaxDiff = (maxDiff > crossDiff) ? maxDiff : crossDiff;\nreturn maxDiff;\n}\n\nIn the function MaxDiffCore , we get the maximal difference of pairs in the first sub-array ( leftDiff ), and then get the maximal difference of pairs in the second sub-array ( rightDiff ). We continue to calculate the difference between the maximum in the first sub-array and the minimal number in the second sub-array ( crossDiff ). The greatest value of the three differences is the maximal difference of the whole array.\n\nWe can get the minimal and maximal numbers, as well as their difference in O(1) time, based on the result of two sub-arrays, so the time complexity of the recursive solution is T(n)=2(n/2)+O(1). We can demonstrate its time complexity is O(n).\n\nSolution 2: get the maximum numbers while scanning\n\nLet us define diff[i] for the difference of a pair whose subtrahend is the i th number in an array. The minuend corresponding to the maximal diff[i] should be the maximum of all numbers on the left side of i th number in an array. We can get the maximal numbers on the left side of each i th number in an array while scanning the array once, and subtract the i th number for them. The following code is based on this solution:\n\nint MaxDiff_Solution3( int numbers[], unsigned length)\n{\nif (numbers == NULL || length < 2)\nreturn 0;\n\nint max = numbers[0];\nint maxDiff =\u00a0 max - numbers[1];\n\nfor ( int i = 2; i < length; ++i)\n{\nif (numbers[i - 1] > max)\nmax = numbers[i - 1];\n\nint currentDiff = max - numbers[i];\nif (currentDiff > maxDiff)\nmaxDiff = currentDiff;\n}\n\nreturn maxDiff;\n}\n\nIt is obviously that its time complexity is O(n) since it is only necessary to scan an array with length n once. It is more efficient than the first solution on memory requirement, which requires O( log n) memory for call stack for the recursion.", "question": "\nProblem: A pair contains two numbers, and its second number is on the right side of the first one in an array. The difference of a pair is the minus result while subtracting the second number from the first one. Please implement a function which gets the maximal difference of all pairs in an array. For example, the maximal difference in the array {2, 4, 1, 16, 7, 5, 11, 9} is 11, which is the minus result of pair (16, 5).\n"},
{"answer": "\nAnalysis: A na\u00efve solution with brute force is quite straightforward: We can get the result for each number minus every number on its right side, and then get the maximal difference after comparisons. Since O(n) minus operations are required for each number in an array with n numbers, the overall time complexity is O(n 2 ). Brutal force solution usually is not the best solution. Let us try to reduce the times of minus operations.\n\nSolution 1: via divide and conquer\n\nWe divide an array into two sub-arrays with same size. The maximal difference of all pairs occurs in one of the three following situations: (1) two numbers of a pair are both in the first sub-array; (2) two numbers of a pair are both in the second sub-array; (3) the minuend is in the greatest number in the first sub-array, and the subtrahend is the least number in the second sub-array.\n\nIt is not a difficult to get the maximal number in the first sub-array and the minimal number in the second sub-array. How about to get the maximal difference of all pairs in two sub-arrays? They are actually sub-problems of the original problem, and we can solve them via recursion. The following are the sample code of this solution:\n\nint MaxDiff_Solution1( int numbers[], unsigned length)\n{\nif (numbers == NULL || length < 2)\nreturn 0;\n\nint max, min;\nreturn MaxDiffCore(numbers, numbers + length - 1, &max, &min);\n}\n\nint MaxDiffCore( int * start, int * end, int * max, int * min)\n{\nif (end == start)\n{\n*max = *min = *start;\nreturn 0x80000000;\n}\n\nint * middle = start + (end - start) / 2;\n\nint maxLeft, minLeft;\nint leftDiff = MaxDiffCore(start, middle, &maxLeft, &minLeft);\n\nint maxRight, minRight;\nint rightDiff = MaxDiffCore(middle + 1, end, &maxRight, &minRight);\n\nint crossDiff = maxLeft - minRight;\n\n*max = (maxLeft > maxRight) ? maxLeft : maxRight;\n*min = (minLeft < minRight) ? minLeft : minRight;\n\nint maxDiff = (leftDiff > rightDiff) ? leftDiff : rightDiff;\nmaxDiff = (maxDiff > crossDiff) ? maxDiff : crossDiff;\nreturn maxDiff;\n}\n\nIn the function MaxDiffCore , we get the maximal difference of pairs in the first sub-array ( leftDiff ), and then get the maximal difference of pairs in the second sub-array ( rightDiff ). We continue to calculate the difference between the maximum in the first sub-array and the minimal number in the second sub-array ( crossDiff ). The greatest value of the three differences is the maximal difference of the whole array.\n\nWe can get the minimal and maximal numbers, as well as their difference in O(1) time, based on the result of two sub-arrays, so the time complexity of the recursive solution is T(n)=2(n/2)+O(1). We can demonstrate its time complexity is O(n).\n\nSolution 2: get the maximum numbers while scanning\n\nLet us define diff[i] for the difference of a pair whose subtrahend is the i th number in an array. The minuend corresponding to the maximal diff[i] should be the maximum of all numbers on the left side of i th number in an array. We can get the maximal numbers on the left side of each i th number in an array while scanning the array once, and subtract the i th number for them. The following code is based on this solution:\n\nint MaxDiff_Solution3( int numbers[], unsigned length)\n{\nif (numbers == NULL || length < 2)\nreturn 0;\n\nint max = numbers[0];\nint maxDiff =\u00a0 max - numbers[1];\n\nfor ( int i = 2; i < length; ++i)\n{\nif (numbers[i - 1] > max)\nmax = numbers[i - 1];\n\nint currentDiff = max - numbers[i];\nif (currentDiff > maxDiff)\nmaxDiff = currentDiff;\n}\n\nreturn maxDiff;\n}\n\nIt is obviously that its time complexity is O(n) since it is only necessary to scan an array with length n once. It is more efficient than the first solution on memory requirement, which requires O( log n) memory for call stack for the recursion.", "question": "\nProblem: A pair contains two numbers, and its second number is on the right side of the first one in an array. The difference of a pair is the minus result while subtracting the second number from the first one. Please implement a function which gets the maximal difference of all pairs in an array. For example, the maximal difference in the array {2, 4, 1, 16, 7, 5, 11, 9} is 11, which is the minus result of pair (16, 5).\n"},
{"answer": "\nAnalysis: A na\u00efve solution with brute force is quite straightforward: We can get the result for each number minus every number on its right side, and then get the maximal difference after comparisons. Since O(n) minus operations are required for each number in an array with n numbers, the overall time complexity is O(n 2 ). Brutal force solution usually is not the best solution. Let us try to reduce the times of minus operations.\n\nSolution 1: via divide and conquer\n\nWe divide an array into two sub-arrays with same size. The maximal difference of all pairs occurs in one of the three following situations: (1) two numbers of a pair are both in the first sub-array; (2) two numbers of a pair are both in the second sub-array; (3) the minuend is in the greatest number in the first sub-array, and the subtrahend is the least number in the second sub-array.\n\nIt is not a difficult to get the maximal number in the first sub-array and the minimal number in the second sub-array. How about to get the maximal difference of all pairs in two sub-arrays? They are actually sub-problems of the original problem, and we can solve them via recursion. The following are the sample code of this solution:\n\nint MaxDiff_Solution1( int numbers[], unsigned length)\n{\nif (numbers == NULL || length < 2)\nreturn 0;\n\nint max, min;\nreturn MaxDiffCore(numbers, numbers + length - 1, &max, &min);\n}\n\nint MaxDiffCore( int * start, int * end, int * max, int * min)\n{\nif (end == start)\n{\n*max = *min = *start;\nreturn 0x80000000;\n}\n\nint * middle = start + (end - start) / 2;\n\nint maxLeft, minLeft;\nint leftDiff = MaxDiffCore(start, middle, &maxLeft, &minLeft);\n\nint maxRight, minRight;\nint rightDiff = MaxDiffCore(middle + 1, end, &maxRight, &minRight);\n\nint crossDiff = maxLeft - minRight;\n\n*max = (maxLeft > maxRight) ? maxLeft : maxRight;\n*min = (minLeft < minRight) ? minLeft : minRight;\n\nint maxDiff = (leftDiff > rightDiff) ? leftDiff : rightDiff;\nmaxDiff = (maxDiff > crossDiff) ? maxDiff : crossDiff;\nreturn maxDiff;\n}\n\nIn the function MaxDiffCore , we get the maximal difference of pairs in the first sub-array ( leftDiff ), and then get the maximal difference of pairs in the second sub-array ( rightDiff ). We continue to calculate the difference between the maximum in the first sub-array and the minimal number in the second sub-array ( crossDiff ). The greatest value of the three differences is the maximal difference of the whole array.\n\nWe can get the minimal and maximal numbers, as well as their difference in O(1) time, based on the result of two sub-arrays, so the time complexity of the recursive solution is T(n)=2(n/2)+O(1). We can demonstrate its time complexity is O(n).\n\nSolution 2: get the maximum numbers while scanning\n\nLet us define diff[i] for the difference of a pair whose subtrahend is the i th number in an array. The minuend corresponding to the maximal diff[i] should be the maximum of all numbers on the left side of i th number in an array. We can get the maximal numbers on the left side of each i th number in an array while scanning the array once, and subtract the i th number for them. The following code is based on this solution:\n\nint MaxDiff_Solution3( int numbers[], unsigned length)\n{\nif (numbers == NULL || length < 2)\nreturn 0;\n\nint max = numbers[0];\nint maxDiff =\u00a0 max - numbers[1];\n\nfor ( int i = 2; i < length; ++i)\n{\nif (numbers[i - 1] > max)\nmax = numbers[i - 1];\n\nint currentDiff = max - numbers[i];\nif (currentDiff > maxDiff)\nmaxDiff = currentDiff;\n}\n\nreturn maxDiff;\n}\n\nIt is obviously that its time complexity is O(n) since it is only necessary to scan an array with length n once. It is more efficient than the first solution on memory requirement, which requires O( log n) memory for call stack for the recursion.", "question": "\nProblem: A pair contains two numbers, and its second number is on the right side of the first one in an array. The difference of a pair is the minus result while subtracting the second number from the first one. Please implement a function which gets the maximal difference of all pairs in an array. For example, the maximal difference in the array {2, 4, 1, 16, 7, 5, 11, 9} is 11, which is the minus result of pair (16, 5).\n"},
{"answer": "\nAnalysis: A na\u00efve solution with brute force is quite straightforward: We can get the result for each number minus every number on its right side, and then get the maximal difference after comparisons. Since O(n) minus operations are required for each number in an array with n numbers, the overall time complexity is O(n 2 ). Brutal force solution usually is not the best solution. Let us try to reduce the times of minus operations.\n\nSolution 1: via divide and conquer\n\nWe divide an array into two sub-arrays with same size. The maximal difference of all pairs occurs in one of the three following situations: (1) two numbers of a pair are both in the first sub-array; (2) two numbers of a pair are both in the second sub-array; (3) the minuend is in the greatest number in the first sub-array, and the subtrahend is the least number in the second sub-array.\n\nIt is not a difficult to get the maximal number in the first sub-array and the minimal number in the second sub-array. How about to get the maximal difference of all pairs in two sub-arrays? They are actually sub-problems of the original problem, and we can solve them via recursion. The following are the sample code of this solution:\n\nint MaxDiff_Solution1( int numbers[], unsigned length)\n{\nif (numbers == NULL || length < 2)\nreturn 0;\n\nint max, min;\nreturn MaxDiffCore(numbers, numbers + length - 1, &max, &min);\n}\n\nint MaxDiffCore( int * start, int * end, int * max, int * min)\n{\nif (end == start)\n{\n*max = *min = *start;\nreturn 0x80000000;\n}\n\nint * middle = start + (end - start) / 2;\n\nint maxLeft, minLeft;\nint leftDiff = MaxDiffCore(start, middle, &maxLeft, &minLeft);\n\nint maxRight, minRight;\nint rightDiff = MaxDiffCore(middle + 1, end, &maxRight, &minRight);\n\nint crossDiff = maxLeft - minRight;\n\n*max = (maxLeft > maxRight) ? maxLeft : maxRight;\n*min = (minLeft < minRight) ? minLeft : minRight;\n\nint maxDiff = (leftDiff > rightDiff) ? leftDiff : rightDiff;\nmaxDiff = (maxDiff > crossDiff) ? maxDiff : crossDiff;\nreturn maxDiff;\n}\n\nIn the function MaxDiffCore , we get the maximal difference of pairs in the first sub-array ( leftDiff ), and then get the maximal difference of pairs in the second sub-array ( rightDiff ). We continue to calculate the difference between the maximum in the first sub-array and the minimal number in the second sub-array ( crossDiff ). The greatest value of the three differences is the maximal difference of the whole array.\n\nWe can get the minimal and maximal numbers, as well as their difference in O(1) time, based on the result of two sub-arrays, so the time complexity of the recursive solution is T(n)=2(n/2)+O(1). We can demonstrate its time complexity is O(n).\n\nSolution 2: get the maximum numbers while scanning\n\nLet us define diff[i] for the difference of a pair whose subtrahend is the i th number in an array. The minuend corresponding to the maximal diff[i] should be the maximum of all numbers on the left side of i th number in an array. We can get the maximal numbers on the left side of each i th number in an array while scanning the array once, and subtract the i th number for them. The following code is based on this solution:\n\nint MaxDiff_Solution3( int numbers[], unsigned length)\n{\nif (numbers == NULL || length < 2)\nreturn 0;\n\nint max = numbers[0];\nint maxDiff =\u00a0 max - numbers[1];\n\nfor ( int i = 2; i < length; ++i)\n{\nif (numbers[i - 1] > max)\nmax = numbers[i - 1];\n\nint currentDiff = max - numbers[i];\nif (currentDiff > maxDiff)\nmaxDiff = currentDiff;\n}\n\nreturn maxDiff;\n}\n\nIt is obviously that its time complexity is O(n) since it is only necessary to scan an array with length n once. It is more efficient than the first solution on memory requirement, which requires O( log n) memory for call stack for the recursion.", "question": "\nProblem: A pair contains two numbers, and its second number is on the right side of the first one in an array. The difference of a pair is the minus result while subtracting the second number from the first one. Please implement a function which gets the maximal difference of all pairs in an array. For example, the maximal difference in the array {2, 4, 1, 16, 7, 5, 11, 9} is 11, which is the minus result of pair (16, 5).\n"},
{"answer": "\nAnalysis: A na\u00efve solution with brute force is quite straightforward: We can get the result for each number minus every number on its right side, and then get the maximal difference after comparisons. Since O(n) minus operations are required for each number in an array with n numbers, the overall time complexity is O(n 2 ). Brutal force solution usually is not the best solution. Let us try to reduce the times of minus operations.\n\nSolution 1: via divide and conquer\n\nWe divide an array into two sub-arrays with same size. The maximal difference of all pairs occurs in one of the three following situations: (1) two numbers of a pair are both in the first sub-array; (2) two numbers of a pair are both in the second sub-array; (3) the minuend is in the greatest number in the first sub-array, and the subtrahend is the least number in the second sub-array.\n\nIt is not a difficult to get the maximal number in the first sub-array and the minimal number in the second sub-array. How about to get the maximal difference of all pairs in two sub-arrays? They are actually sub-problems of the original problem, and we can solve them via recursion. The following are the sample code of this solution:\n\nint MaxDiff_Solution1( int numbers[], unsigned length)\n{\nif (numbers == NULL || length < 2)\nreturn 0;\n\nint max, min;\nreturn MaxDiffCore(numbers, numbers + length - 1, &max, &min);\n}\n\nint MaxDiffCore( int * start, int * end, int * max, int * min)\n{\nif (end == start)\n{\n*max = *min = *start;\nreturn 0x80000000;\n}\n\nint * middle = start + (end - start) / 2;\n\nint maxLeft, minLeft;\nint leftDiff = MaxDiffCore(start, middle, &maxLeft, &minLeft);\n\nint maxRight, minRight;\nint rightDiff = MaxDiffCore(middle + 1, end, &maxRight, &minRight);\n\nint crossDiff = maxLeft - minRight;\n\n*max = (maxLeft > maxRight) ? maxLeft : maxRight;\n*min = (minLeft < minRight) ? minLeft : minRight;\n\nint maxDiff = (leftDiff > rightDiff) ? leftDiff : rightDiff;\nmaxDiff = (maxDiff > crossDiff) ? maxDiff : crossDiff;\nreturn maxDiff;\n}\n\nIn the function MaxDiffCore , we get the maximal difference of pairs in the first sub-array ( leftDiff ), and then get the maximal difference of pairs in the second sub-array ( rightDiff ). We continue to calculate the difference between the maximum in the first sub-array and the minimal number in the second sub-array ( crossDiff ). The greatest value of the three differences is the maximal difference of the whole array.\n\nWe can get the minimal and maximal numbers, as well as their difference in O(1) time, based on the result of two sub-arrays, so the time complexity of the recursive solution is T(n)=2(n/2)+O(1). We can demonstrate its time complexity is O(n).\n\nSolution 2: get the maximum numbers while scanning\n\nLet us define diff[i] for the difference of a pair whose subtrahend is the i th number in an array. The minuend corresponding to the maximal diff[i] should be the maximum of all numbers on the left side of i th number in an array. We can get the maximal numbers on the left side of each i th number in an array while scanning the array once, and subtract the i th number for them. The following code is based on this solution:\n\nint MaxDiff_Solution3( int numbers[], unsigned length)\n{\nif (numbers == NULL || length < 2)\nreturn 0;\n\nint max = numbers[0];\nint maxDiff =\u00a0 max - numbers[1];\n\nfor ( int i = 2; i < length; ++i)\n{\nif (numbers[i - 1] > max)\nmax = numbers[i - 1];\n\nint currentDiff = max - numbers[i];\nif (currentDiff > maxDiff)\nmaxDiff = currentDiff;\n}\n\nreturn maxDiff;\n}\n\nIt is obviously that its time complexity is O(n) since it is only necessary to scan an array with length n once. It is more efficient than the first solution on memory requirement, which requires O( log n) memory for call stack for the recursion.", "question": "\nProblem: A pair contains two numbers, and its second number is on the right side of the first one in an array. The difference of a pair is the minus result while subtracting the second number from the first one. Please implement a function which gets the maximal difference of all pairs in an array. For example, the maximal difference in the array {2, 4, 1, 16, 7, 5, 11, 9} is 11, which is the minus result of pair (16, 5).\n"},
{"answer": "\nAnalysis: A na\u00efve solution with brute force is quite straightforward: We can get the result for each number minus every number on its right side, and then get the maximal difference after comparisons. Since O(n) minus operations are required for each number in an array with n numbers, the overall time complexity is O(n 2 ). Brutal force solution usually is not the best solution. Let us try to reduce the times of minus operations.\n\nSolution 1: via divide and conquer\n\nWe divide an array into two sub-arrays with same size. The maximal difference of all pairs occurs in one of the three following situations: (1) two numbers of a pair are both in the first sub-array; (2) two numbers of a pair are both in the second sub-array; (3) the minuend is in the greatest number in the first sub-array, and the subtrahend is the least number in the second sub-array.\n\nIt is not a difficult to get the maximal number in the first sub-array and the minimal number in the second sub-array. How about to get the maximal difference of all pairs in two sub-arrays? They are actually sub-problems of the original problem, and we can solve them via recursion. The following are the sample code of this solution:\n\nint MaxDiff_Solution1( int numbers[], unsigned length)\n{\nif (numbers == NULL || length < 2)\nreturn 0;\n\nint max, min;\nreturn MaxDiffCore(numbers, numbers + length - 1, &max, &min);\n}\n\nint MaxDiffCore( int * start, int * end, int * max, int * min)\n{\nif (end == start)\n{\n*max = *min = *start;\nreturn 0x80000000;\n}\n\nint * middle = start + (end - start) / 2;\n\nint maxLeft, minLeft;\nint leftDiff = MaxDiffCore(start, middle, &maxLeft, &minLeft);\n\nint maxRight, minRight;\nint rightDiff = MaxDiffCore(middle + 1, end, &maxRight, &minRight);\n\nint crossDiff = maxLeft - minRight;\n\n*max = (maxLeft > maxRight) ? maxLeft : maxRight;\n*min = (minLeft < minRight) ? minLeft : minRight;\n\nint maxDiff = (leftDiff > rightDiff) ? leftDiff : rightDiff;\nmaxDiff = (maxDiff > crossDiff) ? maxDiff : crossDiff;\nreturn maxDiff;\n}\n\nIn the function MaxDiffCore , we get the maximal difference of pairs in the first sub-array ( leftDiff ), and then get the maximal difference of pairs in the second sub-array ( rightDiff ). We continue to calculate the difference between the maximum in the first sub-array and the minimal number in the second sub-array ( crossDiff ). The greatest value of the three differences is the maximal difference of the whole array.\n\nWe can get the minimal and maximal numbers, as well as their difference in O(1) time, based on the result of two sub-arrays, so the time complexity of the recursive solution is T(n)=2(n/2)+O(1). We can demonstrate its time complexity is O(n).\n\nSolution 2: get the maximum numbers while scanning\n\nLet us define diff[i] for the difference of a pair whose subtrahend is the i th number in an array. The minuend corresponding to the maximal diff[i] should be the maximum of all numbers on the left side of i th number in an array. We can get the maximal numbers on the left side of each i th number in an array while scanning the array once, and subtract the i th number for them. The following code is based on this solution:\n\nint MaxDiff_Solution3( int numbers[], unsigned length)\n{\nif (numbers == NULL || length < 2)\nreturn 0;\n\nint max = numbers[0];\nint maxDiff =\u00a0 max - numbers[1];\n\nfor ( int i = 2; i < length; ++i)\n{\nif (numbers[i - 1] > max)\nmax = numbers[i - 1];\n\nint currentDiff = max - numbers[i];\nif (currentDiff > maxDiff)\nmaxDiff = currentDiff;\n}\n\nreturn maxDiff;\n}\n\nIt is obviously that its time complexity is O(n) since it is only necessary to scan an array with length n once. It is more efficient than the first solution on memory requirement, which requires O( log n) memory for call stack for the recursion.", "question": "\nProblem: A pair contains two numbers, and its second number is on the right side of the first one in an array. The difference of a pair is the minus result while subtracting the second number from the first one. Please implement a function which gets the maximal difference of all pairs in an array. For example, the maximal difference in the array {2, 4, 1, 16, 7, 5, 11, 9} is 11, which is the minus result of pair (16, 5).\n"},
{"answer": "\nAnalysis: It is not difficult to get a solution with brute force: Scan numbers in every sliding window to get its maximal value. The overall time complexity is O( nk ) if the length of array is n and the size of sliding windows is k .\n\nThe na\u00efve solution is not the best solution. Let us explore better solutions.\n\nSolution 1: Maximal value in a queue\n\nA window can be viewed as a queue. When it slides, a number is pushed into its back, and its front is popped off. Therefore, the problem is solved if we can get the maximal value of a queue.\n\nThere are no straightforward approaches to getting the maximal value of a queue. However, there are solutions to get the maximal value of a stack, which is similar to the solution introduced in the blog \u201c Stack with Function min() \u201d. Additionally, a queue can also be implemented with two stacks (details are discussed in another blog \u201c Queue implemented with Two Stacks \u201d).\n\nIf a new type of queue is implemented with two stacks, in which a function max() is defined to get the maximal value, the maximal value in a queue is the greater number of the two maximal numbers in two stacks.\n\nThis solution is workable. However, we may not have enough time to write all code to implement our own queue and stack data structures during interviews. Let us continue exploring a more concise solution.\n\nSolution 2: Saving the maximal value into the front of a queue\n\nInstead of pushing every numbers inside a sliding window into a queue, we try to push the candidates of maximum only into a queue. Let us take the array {2, 3, 4, 2, 6, 2, 5, 1} as an example to analyze the solution step by step.\n\nThe first number in the array is 2, we push it into a queue. The second number is 3, which is greater than the previous number 2. The number 2 should be popped off, because it is less than 3 and it has no chance to be the maximal value. There is only one number left in the queue when we pop 2 at the back and push 3 at the back. The operations are similar when we push the next number 4. There is only a number 4 remaining in the queue. Now the sliding window already has three elements, we can get the maximum value at the front of the queue.\n\nWe continue to push the fourth number.\u00a0 It is pushed at the back of queue, because it is less than the previous number 4 and it might be a maximal number in the future when the previous numbers are popped off. There are two numbers, 4 and 2, in the queue, and 4 is the maximum.\n\nThe next number to be pushed is 6. Since it is greater than the existing numbers, 4 and 2, these two numbers can be popped off because they have no chance to be the maximum. Now there is only one number in the queue, which is 6, after the current number is pushed. Of course, the maximum is 6.\nThe next number is 2, which is pushed into the back of the queue because it is less than the previous number 6. There are two numbers in the queue, 6 and 2, and the number 6 at the front of the queue is the maximal value.\n\nIt is time to push the number 5. Because it is greater than the number 2 at the back of the queue, 2 is popped off and then 5 is pushed. There are two numbers in the queue, 6 and 5, and the number 6 at the front of the queue is the maximal value.\n\nNow let us push the last number 1. It can be pushed into the queue. It is noticeable that the number at the front is beyond the scope the current sliding window, and it should be popped off.\u00a0 How do we know whether the number at the front of the queue is out of sliding window? Rather than storing numbers in the queue directly, we can store indices instead. If the distance between the index at the front of queue and the index of the current number to be pushed is greater than or equal to the window size, the number corresponding to be the index at the font of queue is out of sliding window.\n\nThe analysis process above is summarized in Table 2.\n\nStep Number to Be Pushed Numbers in Sliding Window Indices in queue Maximum in Window 1 2 2 0(2) 2 3 2, 3 1(3) 3 4 2, 3, 4 2(4) 4 4 2 3, 4, 2 2(4), 3(2) 4 5 6 4, 2, 6 4(6) 6 6 2 2, 6, 2 4(6), 5(2) 6 7 5 6, 2, 5 4(6), 6(5) 6 8 1 2, 5, 1 6(5), 7(1) 5\nStep\nNumber to Be Pushed\nNumbers in Sliding Window\nIndices in queue\nMaximum in Window\n1\n2\n2\n0(2)\n\n2\n3\n2, 3\n1(3)\n\n3\n4\n2, 3, 4\n2(4)\n4\n4\n2\n3, 4, 2\n2(4), 3(2)\n4\n5\n6\n4, 2, 6\n4(6)\n6\n6\n2\n2, 6, 2\n4(6), 5(2)\n6\n7\n5\n6, 2, 5\n4(6), 6(5)\n6\n8\n1\n2, 5, 1\n6(5), 7(1)\n5\nTable 2: The process to get the maximal number in all sliding windows with window size 3 in the array {2, 3, 4, 2, 6, 2, 5, 1}. In the column \u201cIndices in queue\u201d, the number inside a pair of parentheses is the number indexed by the number before it in the array.\n\nWe can implement a solution based on the analysis above. Some sample code in C++ is shown below, which utilizes the type deque of STL.\n\nvector< int > maxInWindows( const vector< int >& numbers, int windowSize)\n{\nvector< int > maxInSlidingWindows;\nif (numbers.size() >= windowSize && windowSize > 1)\n{\ndeque< int > indices;\n\nfor ( int i = 0; i < windowSize; ++i)\n{\nwhile (!indices.empty() && numbers[i] >= numbers[indices.back()])\nindices.pop_back();\n\nindices.push_back(i);\n}\n\nfor ( int i = windowSize; i < numbers.size(); ++i)\n{\nmaxInSlidingWindows.push_back(numbers[indices.front()]);\n\nwhile (!indices.empty() && numbers[i] >= numbers[indices.back()])\nindices.pop_back();\nif (!indices.empty() && indices.front() <= i - windowSize)\nindices.pop_front();\n\nindices.push_back(i);\n}\nmaxInSlidingWindows.push_back(numbers[indices.front()]);\n}\n\nreturn maxInSlidingWindows;\n}\n\nExtension: Another solution to get the maximum of a queue\n\nAs we mentioned before, a sliding window can be viewed as a queue. Therefore, we can implement a new solution to get the maximal value of a queue based on the second solution to get the maximums of sliding windows.\n\nThe following is the sample code:\n\ntemplate < typename T> class QueueWithMax\n{\npublic :\nQueueWithMax(): currentIndex(0)\n{\n}\n\nvoid push_back(T number)\n{\nwhile (!maximums.empty() && number >= maximums.back().number)\nmaximums.pop_back();\n\nInternalData internalData = {number, currentIndex};\ndata.push_back(internalData);\nmaximums.push_back(internalData);\n\n++currentIndex;\n}\n\nvoid pop_front()\n{\nif (maximums.empty())\nthrow new exception( \"queue is empty\" );\n\nif (maximums.front().index == data.front().index)\nmaximums.pop_front();\n\ndata.pop_front();\n}\n\nT max() const\n{\nif (maximums.empty())\nthrow new exception( \"queue is empty\" );\n\nreturn maximums.front().number;\n}\n\nprivate :\nstruct InternalData\n{\nT number;\nint index;\n};\n\ndeque<InternalData> data;\ndeque<InternalData> maximums;\nint currentIndex;\n};\n\nSince this solution is similar to the second solution to get maximums of sliding windows, we won\u2019t analyze the process step by step, and leave it as an exercise if you are interested.", "question": "\nQuestion: Given an array of numbers and a sliding window size, how to get the maximal numbers in all sliding windows?\n\nFor example, if the input array is {2, 3, 4, 2, 6, 2, 5, 1} and the size of sliding windows is 3, the output of maximums are {4, 4, 6, 6, 6, 5}, as illustrated in Table1.\n\nSliding Windows in an Array Maximums in Sliding Windows [2, 3, 4] , 2, 6, 2, 5, 1 4 2, [3, 4, 2] , 6, 2, 5, 1 4 2, 3, [4, 2, 6] , 2, 5, 1 6 2, 3, 4, [2, 6, 2] , 5, 1 6 2, 3, 4, 2, [6, 2, 5] , 1 6 2, 3, 4, 2, 6, [2, 5, 1] 5\nSliding Windows in an Array\nMaximums in Sliding Windows\n[2, 3, 4] , 2, 6, 2, 5, 1\n4\n2, [3, 4, 2] , 6, 2, 5, 1\n4\n2, 3, [4, 2, 6] , 2, 5, 1\n6\n2, 3, 4, [2, 6, 2] , 5, 1\n6\n2, 3, 4, 2, [6, 2, 5] , 1\n6\n2, 3, 4, 2, 6, [2, 5, 1]\n5\nTable 1: Maximums of all sliding windows with size 3 in an array {2, 3, 4, 2, 6, 2, 5, 1}. A pair of brackets indicates a sliding window.\n"},
{"answer": "\nAnalysis: It is not difficult to get a solution with brute force: Scan numbers in every sliding window to get its maximal value. The overall time complexity is O( nk ) if the length of array is n and the size of sliding windows is k .\n\nThe na\u00efve solution is not the best solution. Let us explore better solutions.\n\nSolution 1: Maximal value in a queue\n\nA window can be viewed as a queue. When it slides, a number is pushed into its back, and its front is popped off. Therefore, the problem is solved if we can get the maximal value of a queue.\n\nThere are no straightforward approaches to getting the maximal value of a queue. However, there are solutions to get the maximal value of a stack, which is similar to the solution introduced in the blog \u201c Stack with Function min() \u201d. Additionally, a queue can also be implemented with two stacks (details are discussed in another blog \u201c Queue implemented with Two Stacks \u201d).\n\nIf a new type of queue is implemented with two stacks, in which a function max() is defined to get the maximal value, the maximal value in a queue is the greater number of the two maximal numbers in two stacks.\n\nThis solution is workable. However, we may not have enough time to write all code to implement our own queue and stack data structures during interviews. Let us continue exploring a more concise solution.\n\nSolution 2: Saving the maximal value into the front of a queue\n\nInstead of pushing every numbers inside a sliding window into a queue, we try to push the candidates of maximum only into a queue. Let us take the array {2, 3, 4, 2, 6, 2, 5, 1} as an example to analyze the solution step by step.\n\nThe first number in the array is 2, we push it into a queue. The second number is 3, which is greater than the previous number 2. The number 2 should be popped off, because it is less than 3 and it has no chance to be the maximal value. There is only one number left in the queue when we pop 2 at the back and push 3 at the back. The operations are similar when we push the next number 4. There is only a number 4 remaining in the queue. Now the sliding window already has three elements, we can get the maximum value at the front of the queue.\n\nWe continue to push the fourth number.\u00a0 It is pushed at the back of queue, because it is less than the previous number 4 and it might be a maximal number in the future when the previous numbers are popped off. There are two numbers, 4 and 2, in the queue, and 4 is the maximum.\n\nThe next number to be pushed is 6. Since it is greater than the existing numbers, 4 and 2, these two numbers can be popped off because they have no chance to be the maximum. Now there is only one number in the queue, which is 6, after the current number is pushed. Of course, the maximum is 6.\nThe next number is 2, which is pushed into the back of the queue because it is less than the previous number 6. There are two numbers in the queue, 6 and 2, and the number 6 at the front of the queue is the maximal value.\n\nIt is time to push the number 5. Because it is greater than the number 2 at the back of the queue, 2 is popped off and then 5 is pushed. There are two numbers in the queue, 6 and 5, and the number 6 at the front of the queue is the maximal value.\n\nNow let us push the last number 1. It can be pushed into the queue. It is noticeable that the number at the front is beyond the scope the current sliding window, and it should be popped off.\u00a0 How do we know whether the number at the front of the queue is out of sliding window? Rather than storing numbers in the queue directly, we can store indices instead. If the distance between the index at the front of queue and the index of the current number to be pushed is greater than or equal to the window size, the number corresponding to be the index at the font of queue is out of sliding window.\n\nThe analysis process above is summarized in Table 2.\n\nStep Number to Be Pushed Numbers in Sliding Window Indices in queue Maximum in Window 1 2 2 0(2) 2 3 2, 3 1(3) 3 4 2, 3, 4 2(4) 4 4 2 3, 4, 2 2(4), 3(2) 4 5 6 4, 2, 6 4(6) 6 6 2 2, 6, 2 4(6), 5(2) 6 7 5 6, 2, 5 4(6), 6(5) 6 8 1 2, 5, 1 6(5), 7(1) 5\nStep\nNumber to Be Pushed\nNumbers in Sliding Window\nIndices in queue\nMaximum in Window\n1\n2\n2\n0(2)\n\n2\n3\n2, 3\n1(3)\n\n3\n4\n2, 3, 4\n2(4)\n4\n4\n2\n3, 4, 2\n2(4), 3(2)\n4\n5\n6\n4, 2, 6\n4(6)\n6\n6\n2\n2, 6, 2\n4(6), 5(2)\n6\n7\n5\n6, 2, 5\n4(6), 6(5)\n6\n8\n1\n2, 5, 1\n6(5), 7(1)\n5\nTable 2: The process to get the maximal number in all sliding windows with window size 3 in the array {2, 3, 4, 2, 6, 2, 5, 1}. In the column \u201cIndices in queue\u201d, the number inside a pair of parentheses is the number indexed by the number before it in the array.\n\nWe can implement a solution based on the analysis above. Some sample code in C++ is shown below, which utilizes the type deque of STL.\n\nvector< int > maxInWindows( const vector< int >& numbers, int windowSize)\n{\nvector< int > maxInSlidingWindows;\nif (numbers.size() >= windowSize && windowSize > 1)\n{\ndeque< int > indices;\n\nfor ( int i = 0; i < windowSize; ++i)\n{\nwhile (!indices.empty() && numbers[i] >= numbers[indices.back()])\nindices.pop_back();\n\nindices.push_back(i);\n}\n\nfor ( int i = windowSize; i < numbers.size(); ++i)\n{\nmaxInSlidingWindows.push_back(numbers[indices.front()]);\n\nwhile (!indices.empty() && numbers[i] >= numbers[indices.back()])\nindices.pop_back();\nif (!indices.empty() && indices.front() <= i - windowSize)\nindices.pop_front();\n\nindices.push_back(i);\n}\nmaxInSlidingWindows.push_back(numbers[indices.front()]);\n}\n\nreturn maxInSlidingWindows;\n}\n\nExtension: Another solution to get the maximum of a queue\n\nAs we mentioned before, a sliding window can be viewed as a queue. Therefore, we can implement a new solution to get the maximal value of a queue based on the second solution to get the maximums of sliding windows.\n\nThe following is the sample code:\n\ntemplate < typename T> class QueueWithMax\n{\npublic :\nQueueWithMax(): currentIndex(0)\n{\n}\n\nvoid push_back(T number)\n{\nwhile (!maximums.empty() && number >= maximums.back().number)\nmaximums.pop_back();\n\nInternalData internalData = {number, currentIndex};\ndata.push_back(internalData);\nmaximums.push_back(internalData);\n\n++currentIndex;\n}\n\nvoid pop_front()\n{\nif (maximums.empty())\nthrow new exception( \"queue is empty\" );\n\nif (maximums.front().index == data.front().index)\nmaximums.pop_front();\n\ndata.pop_front();\n}\n\nT max() const\n{\nif (maximums.empty())\nthrow new exception( \"queue is empty\" );\n\nreturn maximums.front().number;\n}\n\nprivate :\nstruct InternalData\n{\nT number;\nint index;\n};\n\ndeque<InternalData> data;\ndeque<InternalData> maximums;\nint currentIndex;\n};\n\nSince this solution is similar to the second solution to get maximums of sliding windows, we won\u2019t analyze the process step by step, and leave it as an exercise if you are interested.", "question": "\nQuestion: Given an array of numbers and a sliding window size, how to get the maximal numbers in all sliding windows?\n\nFor example, if the input array is {2, 3, 4, 2, 6, 2, 5, 1} and the size of sliding windows is 3, the output of maximums are {4, 4, 6, 6, 6, 5}, as illustrated in Table1.\n\nSliding Windows in an Array Maximums in Sliding Windows [2, 3, 4] , 2, 6, 2, 5, 1 4 2, [3, 4, 2] , 6, 2, 5, 1 4 2, 3, [4, 2, 6] , 2, 5, 1 6 2, 3, 4, [2, 6, 2] , 5, 1 6 2, 3, 4, 2, [6, 2, 5] , 1 6 2, 3, 4, 2, 6, [2, 5, 1] 5\nSliding Windows in an Array\nMaximums in Sliding Windows\n[2, 3, 4] , 2, 6, 2, 5, 1\n4\n2, [3, 4, 2] , 6, 2, 5, 1\n4\n2, 3, [4, 2, 6] , 2, 5, 1\n6\n2, 3, 4, [2, 6, 2] , 5, 1\n6\n2, 3, 4, 2, [6, 2, 5] , 1\n6\n2, 3, 4, 2, 6, [2, 5, 1]\n5\nTable 1: Maximums of all sliding windows with size 3 in an array {2, 3, 4, 2, 6, 2, 5, 1}. A pair of brackets indicates a sliding window.\n"},
{"answer": "\nAnalysis: In a previous blog , we discussed how to check whether there are two numbers in a sorted array whose sum equals a given value. In order to solve this problem, we initialize a number num1 as the smallest number in the array, and initialize num2 as the greatest one. If the sum of num1 and num2 is same as the given value, two required numbers have been found. If the sum is greater than the given value, we move num2 to the previous number in the array (with less value). Similarly, we move num1 to the next number in the array (with greater value) if the sum is less than the given value.\nInspired by the solution, we may find two nodes with a given sum in a binary search tree with similar strategy. Firstly we initialize a pointer P1 to the smallest node in the tree, and another pointer P2 to the greatest node. When the sum of two values in the nodes pointed by P1 and P2 is same as the given value, two required nodes have been found. If their sum is greater than the given value, we move P2 to the previous node (containing less value). Moreover, we move P1 to the next node (containing greater value) if their sum is less than the given value.\nIt is not difficult to get the least and greatest value of a binary search tree. If we move along the links to left children, and the leaf node we arrive at finally contains the least value. For instance, if we move along the links to left children in Figure 1, the nodes on the path contain value 32, 24, 21 and 14, and 14 is the least value in the binary search tree.\nSimilarly, if we move along links to right children, and the leaf node we arrive at finally contains the greatest value.\nThe key to solve this problem is how to get the next nodes (with greater values) and the previous nodes (with less values) in a binary search tree. Let\u2019s utilize stacks.\nIn order to get next nodes,\u00a0we scan the tree along the links to leaf children, and push the scanned nodes into a stack. That\u2019s to say, there are four nodes in the stack (nodes 32, 24, 21 and 14), and node 14 is on the top.\nWhen the top of the stack is popped, node 21 on the top of stack is the next node of 14. And when the node 21 is popped, the node 24 on the top is the next node of 21.\nThe steps to get the next node of node 24 are more complex, because the node 24 has a right child. We pop the node 24, and push its right child, node 28, into the stack. And then, we scan the nodes from the right child along the links to left children. Therefore, the node 31 will also be pushed into the stack. At this time, there are three nodes in the stack (nodes 32, 28 and 25), and the top on the stack (node 25) is the next node of node 24.\nLet\u2019s summarize the steps to get next nodes. If the node on the top does not have a right child, the node is popped off, and the next node is on the top again. If the node on the top has a right child, after the node is popped off and then the right child is pushed, and all nodes along the links to left children are pushed into the stack. The last pushed node on the top is the next node. We continue the steps to pop and push until the stack is empty.\nIf you are interested, please try to analyze the steps to the next nodes after the node 25 by yourself.\nThe steps to get previous nodes are quite similar. At first we push the root node, and nodes along the links to right children. The node with least is on the top of stack. In order to get the previous nodes with less values, the top is popped off. If the top does not have a left child, the previous node is the new top node in the stack. If the top has the left child, we push its left child, as well as nodes along links to right children. The last pushed node is the previous node of the node popped.\nOur solution can be implemented with the following C++ code:\n bool hasTwoNodes(BinaryTreeNode* pRoot, int sum)\n     BinaryTreeNode* pNext = getNext(nextNodes);\n         if (currentSum < sum)\n     return false ;\n void buildNextNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n void buildPrevNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n BinaryTreeNode* getNext(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pRight = pNext->m_pRight;\n     return pNext;\n BinaryTreeNode* getPrev(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pLeft = pPrev->m_pLeft;\n     return pPrev;\nThis solution costs O( n ) time. The space complexity is O(height of tree), which is O(log n ) on average, and O( n ) in the worst cases.", "question": ""},
{"answer": "\nAnalysis: In a previous blog , we discussed how to check whether there are two numbers in a sorted array whose sum equals a given value. In order to solve this problem, we initialize a number num1 as the smallest number in the array, and initialize num2 as the greatest one. If the sum of num1 and num2 is same as the given value, two required numbers have been found. If the sum is greater than the given value, we move num2 to the previous number in the array (with less value). Similarly, we move num1 to the next number in the array (with greater value) if the sum is less than the given value.\nInspired by the solution, we may find two nodes with a given sum in a binary search tree with similar strategy. Firstly we initialize a pointer P1 to the smallest node in the tree, and another pointer P2 to the greatest node. When the sum of two values in the nodes pointed by P1 and P2 is same as the given value, two required nodes have been found. If their sum is greater than the given value, we move P2 to the previous node (containing less value). Moreover, we move P1 to the next node (containing greater value) if their sum is less than the given value.\nIt is not difficult to get the least and greatest value of a binary search tree. If we move along the links to left children, and the leaf node we arrive at finally contains the least value. For instance, if we move along the links to left children in Figure 1, the nodes on the path contain value 32, 24, 21 and 14, and 14 is the least value in the binary search tree.\nSimilarly, if we move along links to right children, and the leaf node we arrive at finally contains the greatest value.\nThe key to solve this problem is how to get the next nodes (with greater values) and the previous nodes (with less values) in a binary search tree. Let\u2019s utilize stacks.\nIn order to get next nodes,\u00a0we scan the tree along the links to leaf children, and push the scanned nodes into a stack. That\u2019s to say, there are four nodes in the stack (nodes 32, 24, 21 and 14), and node 14 is on the top.\nWhen the top of the stack is popped, node 21 on the top of stack is the next node of 14. And when the node 21 is popped, the node 24 on the top is the next node of 21.\nThe steps to get the next node of node 24 are more complex, because the node 24 has a right child. We pop the node 24, and push its right child, node 28, into the stack. And then, we scan the nodes from the right child along the links to left children. Therefore, the node 31 will also be pushed into the stack. At this time, there are three nodes in the stack (nodes 32, 28 and 25), and the top on the stack (node 25) is the next node of node 24.\nLet\u2019s summarize the steps to get next nodes. If the node on the top does not have a right child, the node is popped off, and the next node is on the top again. If the node on the top has a right child, after the node is popped off and then the right child is pushed, and all nodes along the links to left children are pushed into the stack. The last pushed node on the top is the next node. We continue the steps to pop and push until the stack is empty.\nIf you are interested, please try to analyze the steps to the next nodes after the node 25 by yourself.\nThe steps to get previous nodes are quite similar. At first we push the root node, and nodes along the links to right children. The node with least is on the top of stack. In order to get the previous nodes with less values, the top is popped off. If the top does not have a left child, the previous node is the new top node in the stack. If the top has the left child, we push its left child, as well as nodes along links to right children. The last pushed node is the previous node of the node popped.\nOur solution can be implemented with the following C++ code:\n bool hasTwoNodes(BinaryTreeNode* pRoot, int sum)\n     BinaryTreeNode* pNext = getNext(nextNodes);\n         if (currentSum < sum)\n     return false ;\n void buildNextNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n void buildPrevNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n BinaryTreeNode* getNext(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pRight = pNext->m_pRight;\n     return pNext;\n BinaryTreeNode* getPrev(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pLeft = pPrev->m_pLeft;\n     return pPrev;\nThis solution costs O( n ) time. The space complexity is O(height of tree), which is O(log n ) on average, and O( n ) in the worst cases.", "question": ""},
{"answer": "\nAnalysis: In a previous blog , we discussed how to check whether there are two numbers in a sorted array whose sum equals a given value. In order to solve this problem, we initialize a number num1 as the smallest number in the array, and initialize num2 as the greatest one. If the sum of num1 and num2 is same as the given value, two required numbers have been found. If the sum is greater than the given value, we move num2 to the previous number in the array (with less value). Similarly, we move num1 to the next number in the array (with greater value) if the sum is less than the given value.\nInspired by the solution, we may find two nodes with a given sum in a binary search tree with similar strategy. Firstly we initialize a pointer P1 to the smallest node in the tree, and another pointer P2 to the greatest node. When the sum of two values in the nodes pointed by P1 and P2 is same as the given value, two required nodes have been found. If their sum is greater than the given value, we move P2 to the previous node (containing less value). Moreover, we move P1 to the next node (containing greater value) if their sum is less than the given value.\nIt is not difficult to get the least and greatest value of a binary search tree. If we move along the links to left children, and the leaf node we arrive at finally contains the least value. For instance, if we move along the links to left children in Figure 1, the nodes on the path contain value 32, 24, 21 and 14, and 14 is the least value in the binary search tree.\nSimilarly, if we move along links to right children, and the leaf node we arrive at finally contains the greatest value.\nThe key to solve this problem is how to get the next nodes (with greater values) and the previous nodes (with less values) in a binary search tree. Let\u2019s utilize stacks.\nIn order to get next nodes,\u00a0we scan the tree along the links to leaf children, and push the scanned nodes into a stack. That\u2019s to say, there are four nodes in the stack (nodes 32, 24, 21 and 14), and node 14 is on the top.\nWhen the top of the stack is popped, node 21 on the top of stack is the next node of 14. And when the node 21 is popped, the node 24 on the top is the next node of 21.\nThe steps to get the next node of node 24 are more complex, because the node 24 has a right child. We pop the node 24, and push its right child, node 28, into the stack. And then, we scan the nodes from the right child along the links to left children. Therefore, the node 31 will also be pushed into the stack. At this time, there are three nodes in the stack (nodes 32, 28 and 25), and the top on the stack (node 25) is the next node of node 24.\nLet\u2019s summarize the steps to get next nodes. If the node on the top does not have a right child, the node is popped off, and the next node is on the top again. If the node on the top has a right child, after the node is popped off and then the right child is pushed, and all nodes along the links to left children are pushed into the stack. The last pushed node on the top is the next node. We continue the steps to pop and push until the stack is empty.\nIf you are interested, please try to analyze the steps to the next nodes after the node 25 by yourself.\nThe steps to get previous nodes are quite similar. At first we push the root node, and nodes along the links to right children. The node with least is on the top of stack. In order to get the previous nodes with less values, the top is popped off. If the top does not have a left child, the previous node is the new top node in the stack. If the top has the left child, we push its left child, as well as nodes along links to right children. The last pushed node is the previous node of the node popped.\nOur solution can be implemented with the following C++ code:\n bool hasTwoNodes(BinaryTreeNode* pRoot, int sum)\n     BinaryTreeNode* pNext = getNext(nextNodes);\n         if (currentSum < sum)\n     return false ;\n void buildNextNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n void buildPrevNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n BinaryTreeNode* getNext(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pRight = pNext->m_pRight;\n     return pNext;\n BinaryTreeNode* getPrev(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pLeft = pPrev->m_pLeft;\n     return pPrev;\nThis solution costs O( n ) time. The space complexity is O(height of tree), which is O(log n ) on average, and O( n ) in the worst cases.", "question": ""},
{"answer": "\nAnalysis: In a previous blog , we discussed how to check whether there are two numbers in a sorted array whose sum equals a given value. In order to solve this problem, we initialize a number num1 as the smallest number in the array, and initialize num2 as the greatest one. If the sum of num1 and num2 is same as the given value, two required numbers have been found. If the sum is greater than the given value, we move num2 to the previous number in the array (with less value). Similarly, we move num1 to the next number in the array (with greater value) if the sum is less than the given value.\nInspired by the solution, we may find two nodes with a given sum in a binary search tree with similar strategy. Firstly we initialize a pointer P1 to the smallest node in the tree, and another pointer P2 to the greatest node. When the sum of two values in the nodes pointed by P1 and P2 is same as the given value, two required nodes have been found. If their sum is greater than the given value, we move P2 to the previous node (containing less value). Moreover, we move P1 to the next node (containing greater value) if their sum is less than the given value.\nIt is not difficult to get the least and greatest value of a binary search tree. If we move along the links to left children, and the leaf node we arrive at finally contains the least value. For instance, if we move along the links to left children in Figure 1, the nodes on the path contain value 32, 24, 21 and 14, and 14 is the least value in the binary search tree.\nSimilarly, if we move along links to right children, and the leaf node we arrive at finally contains the greatest value.\nThe key to solve this problem is how to get the next nodes (with greater values) and the previous nodes (with less values) in a binary search tree. Let\u2019s utilize stacks.\nIn order to get next nodes,\u00a0we scan the tree along the links to leaf children, and push the scanned nodes into a stack. That\u2019s to say, there are four nodes in the stack (nodes 32, 24, 21 and 14), and node 14 is on the top.\nWhen the top of the stack is popped, node 21 on the top of stack is the next node of 14. And when the node 21 is popped, the node 24 on the top is the next node of 21.\nThe steps to get the next node of node 24 are more complex, because the node 24 has a right child. We pop the node 24, and push its right child, node 28, into the stack. And then, we scan the nodes from the right child along the links to left children. Therefore, the node 31 will also be pushed into the stack. At this time, there are three nodes in the stack (nodes 32, 28 and 25), and the top on the stack (node 25) is the next node of node 24.\nLet\u2019s summarize the steps to get next nodes. If the node on the top does not have a right child, the node is popped off, and the next node is on the top again. If the node on the top has a right child, after the node is popped off and then the right child is pushed, and all nodes along the links to left children are pushed into the stack. The last pushed node on the top is the next node. We continue the steps to pop and push until the stack is empty.\nIf you are interested, please try to analyze the steps to the next nodes after the node 25 by yourself.\nThe steps to get previous nodes are quite similar. At first we push the root node, and nodes along the links to right children. The node with least is on the top of stack. In order to get the previous nodes with less values, the top is popped off. If the top does not have a left child, the previous node is the new top node in the stack. If the top has the left child, we push its left child, as well as nodes along links to right children. The last pushed node is the previous node of the node popped.\nOur solution can be implemented with the following C++ code:\n bool hasTwoNodes(BinaryTreeNode* pRoot, int sum)\n     BinaryTreeNode* pNext = getNext(nextNodes);\n         if (currentSum < sum)\n     return false ;\n void buildNextNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n void buildPrevNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n BinaryTreeNode* getNext(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pRight = pNext->m_pRight;\n     return pNext;\n BinaryTreeNode* getPrev(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pLeft = pPrev->m_pLeft;\n     return pPrev;\nThis solution costs O( n ) time. The space complexity is O(height of tree), which is O(log n ) on average, and O( n ) in the worst cases.", "question": ""},
{"answer": "\nAnalysis: In a previous blog , we discussed how to check whether there are two numbers in a sorted array whose sum equals a given value. In order to solve this problem, we initialize a number num1 as the smallest number in the array, and initialize num2 as the greatest one. If the sum of num1 and num2 is same as the given value, two required numbers have been found. If the sum is greater than the given value, we move num2 to the previous number in the array (with less value). Similarly, we move num1 to the next number in the array (with greater value) if the sum is less than the given value.\nInspired by the solution, we may find two nodes with a given sum in a binary search tree with similar strategy. Firstly we initialize a pointer P1 to the smallest node in the tree, and another pointer P2 to the greatest node. When the sum of two values in the nodes pointed by P1 and P2 is same as the given value, two required nodes have been found. If their sum is greater than the given value, we move P2 to the previous node (containing less value). Moreover, we move P1 to the next node (containing greater value) if their sum is less than the given value.\nIt is not difficult to get the least and greatest value of a binary search tree. If we move along the links to left children, and the leaf node we arrive at finally contains the least value. For instance, if we move along the links to left children in Figure 1, the nodes on the path contain value 32, 24, 21 and 14, and 14 is the least value in the binary search tree.\nSimilarly, if we move along links to right children, and the leaf node we arrive at finally contains the greatest value.\nThe key to solve this problem is how to get the next nodes (with greater values) and the previous nodes (with less values) in a binary search tree. Let\u2019s utilize stacks.\nIn order to get next nodes,\u00a0we scan the tree along the links to leaf children, and push the scanned nodes into a stack. That\u2019s to say, there are four nodes in the stack (nodes 32, 24, 21 and 14), and node 14 is on the top.\nWhen the top of the stack is popped, node 21 on the top of stack is the next node of 14. And when the node 21 is popped, the node 24 on the top is the next node of 21.\nThe steps to get the next node of node 24 are more complex, because the node 24 has a right child. We pop the node 24, and push its right child, node 28, into the stack. And then, we scan the nodes from the right child along the links to left children. Therefore, the node 31 will also be pushed into the stack. At this time, there are three nodes in the stack (nodes 32, 28 and 25), and the top on the stack (node 25) is the next node of node 24.\nLet\u2019s summarize the steps to get next nodes. If the node on the top does not have a right child, the node is popped off, and the next node is on the top again. If the node on the top has a right child, after the node is popped off and then the right child is pushed, and all nodes along the links to left children are pushed into the stack. The last pushed node on the top is the next node. We continue the steps to pop and push until the stack is empty.\nIf you are interested, please try to analyze the steps to the next nodes after the node 25 by yourself.\nThe steps to get previous nodes are quite similar. At first we push the root node, and nodes along the links to right children. The node with least is on the top of stack. In order to get the previous nodes with less values, the top is popped off. If the top does not have a left child, the previous node is the new top node in the stack. If the top has the left child, we push its left child, as well as nodes along links to right children. The last pushed node is the previous node of the node popped.\nOur solution can be implemented with the following C++ code:\n bool hasTwoNodes(BinaryTreeNode* pRoot, int sum)\n     BinaryTreeNode* pNext = getNext(nextNodes);\n         if (currentSum < sum)\n     return false ;\n void buildNextNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n void buildPrevNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n BinaryTreeNode* getNext(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pRight = pNext->m_pRight;\n     return pNext;\n BinaryTreeNode* getPrev(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pLeft = pPrev->m_pLeft;\n     return pPrev;\nThis solution costs O( n ) time. The space complexity is O(height of tree), which is O(log n ) on average, and O( n ) in the worst cases.", "question": ""},
{"answer": "\nAnalysis: In a previous blog , we discussed how to check whether there are two numbers in a sorted array whose sum equals a given value. In order to solve this problem, we initialize a number num1 as the smallest number in the array, and initialize num2 as the greatest one. If the sum of num1 and num2 is same as the given value, two required numbers have been found. If the sum is greater than the given value, we move num2 to the previous number in the array (with less value). Similarly, we move num1 to the next number in the array (with greater value) if the sum is less than the given value.\nInspired by the solution, we may find two nodes with a given sum in a binary search tree with similar strategy. Firstly we initialize a pointer P1 to the smallest node in the tree, and another pointer P2 to the greatest node. When the sum of two values in the nodes pointed by P1 and P2 is same as the given value, two required nodes have been found. If their sum is greater than the given value, we move P2 to the previous node (containing less value). Moreover, we move P1 to the next node (containing greater value) if their sum is less than the given value.\nIt is not difficult to get the least and greatest value of a binary search tree. If we move along the links to left children, and the leaf node we arrive at finally contains the least value. For instance, if we move along the links to left children in Figure 1, the nodes on the path contain value 32, 24, 21 and 14, and 14 is the least value in the binary search tree.\nSimilarly, if we move along links to right children, and the leaf node we arrive at finally contains the greatest value.\nThe key to solve this problem is how to get the next nodes (with greater values) and the previous nodes (with less values) in a binary search tree. Let\u2019s utilize stacks.\nIn order to get next nodes,\u00a0we scan the tree along the links to leaf children, and push the scanned nodes into a stack. That\u2019s to say, there are four nodes in the stack (nodes 32, 24, 21 and 14), and node 14 is on the top.\nWhen the top of the stack is popped, node 21 on the top of stack is the next node of 14. And when the node 21 is popped, the node 24 on the top is the next node of 21.\nThe steps to get the next node of node 24 are more complex, because the node 24 has a right child. We pop the node 24, and push its right child, node 28, into the stack. And then, we scan the nodes from the right child along the links to left children. Therefore, the node 31 will also be pushed into the stack. At this time, there are three nodes in the stack (nodes 32, 28 and 25), and the top on the stack (node 25) is the next node of node 24.\nLet\u2019s summarize the steps to get next nodes. If the node on the top does not have a right child, the node is popped off, and the next node is on the top again. If the node on the top has a right child, after the node is popped off and then the right child is pushed, and all nodes along the links to left children are pushed into the stack. The last pushed node on the top is the next node. We continue the steps to pop and push until the stack is empty.\nIf you are interested, please try to analyze the steps to the next nodes after the node 25 by yourself.\nThe steps to get previous nodes are quite similar. At first we push the root node, and nodes along the links to right children. The node with least is on the top of stack. In order to get the previous nodes with less values, the top is popped off. If the top does not have a left child, the previous node is the new top node in the stack. If the top has the left child, we push its left child, as well as nodes along links to right children. The last pushed node is the previous node of the node popped.\nOur solution can be implemented with the following C++ code:\n bool hasTwoNodes(BinaryTreeNode* pRoot, int sum)\n     BinaryTreeNode* pNext = getNext(nextNodes);\n         if (currentSum < sum)\n     return false ;\n void buildNextNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n void buildPrevNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n BinaryTreeNode* getNext(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pRight = pNext->m_pRight;\n     return pNext;\n BinaryTreeNode* getPrev(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pLeft = pPrev->m_pLeft;\n     return pPrev;\nThis solution costs O( n ) time. The space complexity is O(height of tree), which is O(log n ) on average, and O( n ) in the worst cases.", "question": ""},
{"answer": "\nAnalysis: In a previous blog , we discussed how to check whether there are two numbers in a sorted array whose sum equals a given value. In order to solve this problem, we initialize a number num1 as the smallest number in the array, and initialize num2 as the greatest one. If the sum of num1 and num2 is same as the given value, two required numbers have been found. If the sum is greater than the given value, we move num2 to the previous number in the array (with less value). Similarly, we move num1 to the next number in the array (with greater value) if the sum is less than the given value.\nInspired by the solution, we may find two nodes with a given sum in a binary search tree with similar strategy. Firstly we initialize a pointer P1 to the smallest node in the tree, and another pointer P2 to the greatest node. When the sum of two values in the nodes pointed by P1 and P2 is same as the given value, two required nodes have been found. If their sum is greater than the given value, we move P2 to the previous node (containing less value). Moreover, we move P1 to the next node (containing greater value) if their sum is less than the given value.\nIt is not difficult to get the least and greatest value of a binary search tree. If we move along the links to left children, and the leaf node we arrive at finally contains the least value. For instance, if we move along the links to left children in Figure 1, the nodes on the path contain value 32, 24, 21 and 14, and 14 is the least value in the binary search tree.\nSimilarly, if we move along links to right children, and the leaf node we arrive at finally contains the greatest value.\nThe key to solve this problem is how to get the next nodes (with greater values) and the previous nodes (with less values) in a binary search tree. Let\u2019s utilize stacks.\nIn order to get next nodes,\u00a0we scan the tree along the links to leaf children, and push the scanned nodes into a stack. That\u2019s to say, there are four nodes in the stack (nodes 32, 24, 21 and 14), and node 14 is on the top.\nWhen the top of the stack is popped, node 21 on the top of stack is the next node of 14. And when the node 21 is popped, the node 24 on the top is the next node of 21.\nThe steps to get the next node of node 24 are more complex, because the node 24 has a right child. We pop the node 24, and push its right child, node 28, into the stack. And then, we scan the nodes from the right child along the links to left children. Therefore, the node 31 will also be pushed into the stack. At this time, there are three nodes in the stack (nodes 32, 28 and 25), and the top on the stack (node 25) is the next node of node 24.\nLet\u2019s summarize the steps to get next nodes. If the node on the top does not have a right child, the node is popped off, and the next node is on the top again. If the node on the top has a right child, after the node is popped off and then the right child is pushed, and all nodes along the links to left children are pushed into the stack. The last pushed node on the top is the next node. We continue the steps to pop and push until the stack is empty.\nIf you are interested, please try to analyze the steps to the next nodes after the node 25 by yourself.\nThe steps to get previous nodes are quite similar. At first we push the root node, and nodes along the links to right children. The node with least is on the top of stack. In order to get the previous nodes with less values, the top is popped off. If the top does not have a left child, the previous node is the new top node in the stack. If the top has the left child, we push its left child, as well as nodes along links to right children. The last pushed node is the previous node of the node popped.\nOur solution can be implemented with the following C++ code:\n bool hasTwoNodes(BinaryTreeNode* pRoot, int sum)\n     BinaryTreeNode* pNext = getNext(nextNodes);\n         if (currentSum < sum)\n     return false ;\n void buildNextNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n void buildPrevNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n BinaryTreeNode* getNext(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pRight = pNext->m_pRight;\n     return pNext;\n BinaryTreeNode* getPrev(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pLeft = pPrev->m_pLeft;\n     return pPrev;\nThis solution costs O( n ) time. The space complexity is O(height of tree), which is O(log n ) on average, and O( n ) in the worst cases.", "question": ""},
{"answer": "\nAnalysis: In a previous blog , we discussed how to check whether there are two numbers in a sorted array whose sum equals a given value. In order to solve this problem, we initialize a number num1 as the smallest number in the array, and initialize num2 as the greatest one. If the sum of num1 and num2 is same as the given value, two required numbers have been found. If the sum is greater than the given value, we move num2 to the previous number in the array (with less value). Similarly, we move num1 to the next number in the array (with greater value) if the sum is less than the given value.\nInspired by the solution, we may find two nodes with a given sum in a binary search tree with similar strategy. Firstly we initialize a pointer P1 to the smallest node in the tree, and another pointer P2 to the greatest node. When the sum of two values in the nodes pointed by P1 and P2 is same as the given value, two required nodes have been found. If their sum is greater than the given value, we move P2 to the previous node (containing less value). Moreover, we move P1 to the next node (containing greater value) if their sum is less than the given value.\nIt is not difficult to get the least and greatest value of a binary search tree. If we move along the links to left children, and the leaf node we arrive at finally contains the least value. For instance, if we move along the links to left children in Figure 1, the nodes on the path contain value 32, 24, 21 and 14, and 14 is the least value in the binary search tree.\nSimilarly, if we move along links to right children, and the leaf node we arrive at finally contains the greatest value.\nThe key to solve this problem is how to get the next nodes (with greater values) and the previous nodes (with less values) in a binary search tree. Let\u2019s utilize stacks.\nIn order to get next nodes,\u00a0we scan the tree along the links to leaf children, and push the scanned nodes into a stack. That\u2019s to say, there are four nodes in the stack (nodes 32, 24, 21 and 14), and node 14 is on the top.\nWhen the top of the stack is popped, node 21 on the top of stack is the next node of 14. And when the node 21 is popped, the node 24 on the top is the next node of 21.\nThe steps to get the next node of node 24 are more complex, because the node 24 has a right child. We pop the node 24, and push its right child, node 28, into the stack. And then, we scan the nodes from the right child along the links to left children. Therefore, the node 31 will also be pushed into the stack. At this time, there are three nodes in the stack (nodes 32, 28 and 25), and the top on the stack (node 25) is the next node of node 24.\nLet\u2019s summarize the steps to get next nodes. If the node on the top does not have a right child, the node is popped off, and the next node is on the top again. If the node on the top has a right child, after the node is popped off and then the right child is pushed, and all nodes along the links to left children are pushed into the stack. The last pushed node on the top is the next node. We continue the steps to pop and push until the stack is empty.\nIf you are interested, please try to analyze the steps to the next nodes after the node 25 by yourself.\nThe steps to get previous nodes are quite similar. At first we push the root node, and nodes along the links to right children. The node with least is on the top of stack. In order to get the previous nodes with less values, the top is popped off. If the top does not have a left child, the previous node is the new top node in the stack. If the top has the left child, we push its left child, as well as nodes along links to right children. The last pushed node is the previous node of the node popped.\nOur solution can be implemented with the following C++ code:\n bool hasTwoNodes(BinaryTreeNode* pRoot, int sum)\n     BinaryTreeNode* pNext = getNext(nextNodes);\n         if (currentSum < sum)\n     return false ;\n void buildNextNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n void buildPrevNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n BinaryTreeNode* getNext(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pRight = pNext->m_pRight;\n     return pNext;\n BinaryTreeNode* getPrev(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pLeft = pPrev->m_pLeft;\n     return pPrev;\nThis solution costs O( n ) time. The space complexity is O(height of tree), which is O(log n ) on average, and O( n ) in the worst cases.", "question": ""},
{"answer": "\nAnalysis: In a previous blog , we discussed how to check whether there are two numbers in a sorted array whose sum equals a given value. In order to solve this problem, we initialize a number num1 as the smallest number in the array, and initialize num2 as the greatest one. If the sum of num1 and num2 is same as the given value, two required numbers have been found. If the sum is greater than the given value, we move num2 to the previous number in the array (with less value). Similarly, we move num1 to the next number in the array (with greater value) if the sum is less than the given value.\nInspired by the solution, we may find two nodes with a given sum in a binary search tree with similar strategy. Firstly we initialize a pointer P1 to the smallest node in the tree, and another pointer P2 to the greatest node. When the sum of two values in the nodes pointed by P1 and P2 is same as the given value, two required nodes have been found. If their sum is greater than the given value, we move P2 to the previous node (containing less value). Moreover, we move P1 to the next node (containing greater value) if their sum is less than the given value.\nIt is not difficult to get the least and greatest value of a binary search tree. If we move along the links to left children, and the leaf node we arrive at finally contains the least value. For instance, if we move along the links to left children in Figure 1, the nodes on the path contain value 32, 24, 21 and 14, and 14 is the least value in the binary search tree.\nSimilarly, if we move along links to right children, and the leaf node we arrive at finally contains the greatest value.\nThe key to solve this problem is how to get the next nodes (with greater values) and the previous nodes (with less values) in a binary search tree. Let\u2019s utilize stacks.\nIn order to get next nodes,\u00a0we scan the tree along the links to leaf children, and push the scanned nodes into a stack. That\u2019s to say, there are four nodes in the stack (nodes 32, 24, 21 and 14), and node 14 is on the top.\nWhen the top of the stack is popped, node 21 on the top of stack is the next node of 14. And when the node 21 is popped, the node 24 on the top is the next node of 21.\nThe steps to get the next node of node 24 are more complex, because the node 24 has a right child. We pop the node 24, and push its right child, node 28, into the stack. And then, we scan the nodes from the right child along the links to left children. Therefore, the node 31 will also be pushed into the stack. At this time, there are three nodes in the stack (nodes 32, 28 and 25), and the top on the stack (node 25) is the next node of node 24.\nLet\u2019s summarize the steps to get next nodes. If the node on the top does not have a right child, the node is popped off, and the next node is on the top again. If the node on the top has a right child, after the node is popped off and then the right child is pushed, and all nodes along the links to left children are pushed into the stack. The last pushed node on the top is the next node. We continue the steps to pop and push until the stack is empty.\nIf you are interested, please try to analyze the steps to the next nodes after the node 25 by yourself.\nThe steps to get previous nodes are quite similar. At first we push the root node, and nodes along the links to right children. The node with least is on the top of stack. In order to get the previous nodes with less values, the top is popped off. If the top does not have a left child, the previous node is the new top node in the stack. If the top has the left child, we push its left child, as well as nodes along links to right children. The last pushed node is the previous node of the node popped.\nOur solution can be implemented with the following C++ code:\n bool hasTwoNodes(BinaryTreeNode* pRoot, int sum)\n     BinaryTreeNode* pNext = getNext(nextNodes);\n         if (currentSum < sum)\n     return false ;\n void buildNextNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n void buildPrevNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n BinaryTreeNode* getNext(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pRight = pNext->m_pRight;\n     return pNext;\n BinaryTreeNode* getPrev(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pLeft = pPrev->m_pLeft;\n     return pPrev;\nThis solution costs O( n ) time. The space complexity is O(height of tree), which is O(log n ) on average, and O( n ) in the worst cases.", "question": ""},
{"answer": "\nAnalysis: In a previous blog , we discussed how to check whether there are two numbers in a sorted array whose sum equals a given value. In order to solve this problem, we initialize a number num1 as the smallest number in the array, and initialize num2 as the greatest one. If the sum of num1 and num2 is same as the given value, two required numbers have been found. If the sum is greater than the given value, we move num2 to the previous number in the array (with less value). Similarly, we move num1 to the next number in the array (with greater value) if the sum is less than the given value.\nInspired by the solution, we may find two nodes with a given sum in a binary search tree with similar strategy. Firstly we initialize a pointer P1 to the smallest node in the tree, and another pointer P2 to the greatest node. When the sum of two values in the nodes pointed by P1 and P2 is same as the given value, two required nodes have been found. If their sum is greater than the given value, we move P2 to the previous node (containing less value). Moreover, we move P1 to the next node (containing greater value) if their sum is less than the given value.\nIt is not difficult to get the least and greatest value of a binary search tree. If we move along the links to left children, and the leaf node we arrive at finally contains the least value. For instance, if we move along the links to left children in Figure 1, the nodes on the path contain value 32, 24, 21 and 14, and 14 is the least value in the binary search tree.\nSimilarly, if we move along links to right children, and the leaf node we arrive at finally contains the greatest value.\nThe key to solve this problem is how to get the next nodes (with greater values) and the previous nodes (with less values) in a binary search tree. Let\u2019s utilize stacks.\nIn order to get next nodes,\u00a0we scan the tree along the links to leaf children, and push the scanned nodes into a stack. That\u2019s to say, there are four nodes in the stack (nodes 32, 24, 21 and 14), and node 14 is on the top.\nWhen the top of the stack is popped, node 21 on the top of stack is the next node of 14. And when the node 21 is popped, the node 24 on the top is the next node of 21.\nThe steps to get the next node of node 24 are more complex, because the node 24 has a right child. We pop the node 24, and push its right child, node 28, into the stack. And then, we scan the nodes from the right child along the links to left children. Therefore, the node 31 will also be pushed into the stack. At this time, there are three nodes in the stack (nodes 32, 28 and 25), and the top on the stack (node 25) is the next node of node 24.\nLet\u2019s summarize the steps to get next nodes. If the node on the top does not have a right child, the node is popped off, and the next node is on the top again. If the node on the top has a right child, after the node is popped off and then the right child is pushed, and all nodes along the links to left children are pushed into the stack. The last pushed node on the top is the next node. We continue the steps to pop and push until the stack is empty.\nIf you are interested, please try to analyze the steps to the next nodes after the node 25 by yourself.\nThe steps to get previous nodes are quite similar. At first we push the root node, and nodes along the links to right children. The node with least is on the top of stack. In order to get the previous nodes with less values, the top is popped off. If the top does not have a left child, the previous node is the new top node in the stack. If the top has the left child, we push its left child, as well as nodes along links to right children. The last pushed node is the previous node of the node popped.\nOur solution can be implemented with the following C++ code:\n bool hasTwoNodes(BinaryTreeNode* pRoot, int sum)\n     BinaryTreeNode* pNext = getNext(nextNodes);\n         if (currentSum < sum)\n     return false ;\n void buildNextNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n void buildPrevNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n BinaryTreeNode* getNext(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pRight = pNext->m_pRight;\n     return pNext;\n BinaryTreeNode* getPrev(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pLeft = pPrev->m_pLeft;\n     return pPrev;\nThis solution costs O( n ) time. The space complexity is O(height of tree), which is O(log n ) on average, and O( n ) in the worst cases.", "question": ""},
{"answer": "\nAnalysis: In a previous blog , we discussed how to check whether there are two numbers in a sorted array whose sum equals a given value. In order to solve this problem, we initialize a number num1 as the smallest number in the array, and initialize num2 as the greatest one. If the sum of num1 and num2 is same as the given value, two required numbers have been found. If the sum is greater than the given value, we move num2 to the previous number in the array (with less value). Similarly, we move num1 to the next number in the array (with greater value) if the sum is less than the given value.\nInspired by the solution, we may find two nodes with a given sum in a binary search tree with similar strategy. Firstly we initialize a pointer P1 to the smallest node in the tree, and another pointer P2 to the greatest node. When the sum of two values in the nodes pointed by P1 and P2 is same as the given value, two required nodes have been found. If their sum is greater than the given value, we move P2 to the previous node (containing less value). Moreover, we move P1 to the next node (containing greater value) if their sum is less than the given value.\nIt is not difficult to get the least and greatest value of a binary search tree. If we move along the links to left children, and the leaf node we arrive at finally contains the least value. For instance, if we move along the links to left children in Figure 1, the nodes on the path contain value 32, 24, 21 and 14, and 14 is the least value in the binary search tree.\nSimilarly, if we move along links to right children, and the leaf node we arrive at finally contains the greatest value.\nThe key to solve this problem is how to get the next nodes (with greater values) and the previous nodes (with less values) in a binary search tree. Let\u2019s utilize stacks.\nIn order to get next nodes,\u00a0we scan the tree along the links to leaf children, and push the scanned nodes into a stack. That\u2019s to say, there are four nodes in the stack (nodes 32, 24, 21 and 14), and node 14 is on the top.\nWhen the top of the stack is popped, node 21 on the top of stack is the next node of 14. And when the node 21 is popped, the node 24 on the top is the next node of 21.\nThe steps to get the next node of node 24 are more complex, because the node 24 has a right child. We pop the node 24, and push its right child, node 28, into the stack. And then, we scan the nodes from the right child along the links to left children. Therefore, the node 31 will also be pushed into the stack. At this time, there are three nodes in the stack (nodes 32, 28 and 25), and the top on the stack (node 25) is the next node of node 24.\nLet\u2019s summarize the steps to get next nodes. If the node on the top does not have a right child, the node is popped off, and the next node is on the top again. If the node on the top has a right child, after the node is popped off and then the right child is pushed, and all nodes along the links to left children are pushed into the stack. The last pushed node on the top is the next node. We continue the steps to pop and push until the stack is empty.\nIf you are interested, please try to analyze the steps to the next nodes after the node 25 by yourself.\nThe steps to get previous nodes are quite similar. At first we push the root node, and nodes along the links to right children. The node with least is on the top of stack. In order to get the previous nodes with less values, the top is popped off. If the top does not have a left child, the previous node is the new top node in the stack. If the top has the left child, we push its left child, as well as nodes along links to right children. The last pushed node is the previous node of the node popped.\nOur solution can be implemented with the following C++ code:\n bool hasTwoNodes(BinaryTreeNode* pRoot, int sum)\n     BinaryTreeNode* pNext = getNext(nextNodes);\n         if (currentSum < sum)\n     return false ;\n void buildNextNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n void buildPrevNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n BinaryTreeNode* getNext(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pRight = pNext->m_pRight;\n     return pNext;\n BinaryTreeNode* getPrev(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pLeft = pPrev->m_pLeft;\n     return pPrev;\nThis solution costs O( n ) time. The space complexity is O(height of tree), which is O(log n ) on average, and O( n ) in the worst cases.", "question": ""},
{"answer": "\nAnalysis: In a previous blog , we discussed how to check whether there are two numbers in a sorted array whose sum equals a given value. In order to solve this problem, we initialize a number num1 as the smallest number in the array, and initialize num2 as the greatest one. If the sum of num1 and num2 is same as the given value, two required numbers have been found. If the sum is greater than the given value, we move num2 to the previous number in the array (with less value). Similarly, we move num1 to the next number in the array (with greater value) if the sum is less than the given value.\nInspired by the solution, we may find two nodes with a given sum in a binary search tree with similar strategy. Firstly we initialize a pointer P1 to the smallest node in the tree, and another pointer P2 to the greatest node. When the sum of two values in the nodes pointed by P1 and P2 is same as the given value, two required nodes have been found. If their sum is greater than the given value, we move P2 to the previous node (containing less value). Moreover, we move P1 to the next node (containing greater value) if their sum is less than the given value.\nIt is not difficult to get the least and greatest value of a binary search tree. If we move along the links to left children, and the leaf node we arrive at finally contains the least value. For instance, if we move along the links to left children in Figure 1, the nodes on the path contain value 32, 24, 21 and 14, and 14 is the least value in the binary search tree.\nSimilarly, if we move along links to right children, and the leaf node we arrive at finally contains the greatest value.\nThe key to solve this problem is how to get the next nodes (with greater values) and the previous nodes (with less values) in a binary search tree. Let\u2019s utilize stacks.\nIn order to get next nodes,\u00a0we scan the tree along the links to leaf children, and push the scanned nodes into a stack. That\u2019s to say, there are four nodes in the stack (nodes 32, 24, 21 and 14), and node 14 is on the top.\nWhen the top of the stack is popped, node 21 on the top of stack is the next node of 14. And when the node 21 is popped, the node 24 on the top is the next node of 21.\nThe steps to get the next node of node 24 are more complex, because the node 24 has a right child. We pop the node 24, and push its right child, node 28, into the stack. And then, we scan the nodes from the right child along the links to left children. Therefore, the node 31 will also be pushed into the stack. At this time, there are three nodes in the stack (nodes 32, 28 and 25), and the top on the stack (node 25) is the next node of node 24.\nLet\u2019s summarize the steps to get next nodes. If the node on the top does not have a right child, the node is popped off, and the next node is on the top again. If the node on the top has a right child, after the node is popped off and then the right child is pushed, and all nodes along the links to left children are pushed into the stack. The last pushed node on the top is the next node. We continue the steps to pop and push until the stack is empty.\nIf you are interested, please try to analyze the steps to the next nodes after the node 25 by yourself.\nThe steps to get previous nodes are quite similar. At first we push the root node, and nodes along the links to right children. The node with least is on the top of stack. In order to get the previous nodes with less values, the top is popped off. If the top does not have a left child, the previous node is the new top node in the stack. If the top has the left child, we push its left child, as well as nodes along links to right children. The last pushed node is the previous node of the node popped.\nOur solution can be implemented with the following C++ code:\n bool hasTwoNodes(BinaryTreeNode* pRoot, int sum)\n     BinaryTreeNode* pNext = getNext(nextNodes);\n         if (currentSum < sum)\n     return false ;\n void buildNextNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n void buildPrevNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n BinaryTreeNode* getNext(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pRight = pNext->m_pRight;\n     return pNext;\n BinaryTreeNode* getPrev(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pLeft = pPrev->m_pLeft;\n     return pPrev;\nThis solution costs O( n ) time. The space complexity is O(height of tree), which is O(log n ) on average, and O( n ) in the worst cases.", "question": ""},
{"answer": "\nAnalysis: In a previous blog , we discussed how to check whether there are two numbers in a sorted array whose sum equals a given value. In order to solve this problem, we initialize a number num1 as the smallest number in the array, and initialize num2 as the greatest one. If the sum of num1 and num2 is same as the given value, two required numbers have been found. If the sum is greater than the given value, we move num2 to the previous number in the array (with less value). Similarly, we move num1 to the next number in the array (with greater value) if the sum is less than the given value.\nInspired by the solution, we may find two nodes with a given sum in a binary search tree with similar strategy. Firstly we initialize a pointer P1 to the smallest node in the tree, and another pointer P2 to the greatest node. When the sum of two values in the nodes pointed by P1 and P2 is same as the given value, two required nodes have been found. If their sum is greater than the given value, we move P2 to the previous node (containing less value). Moreover, we move P1 to the next node (containing greater value) if their sum is less than the given value.\nIt is not difficult to get the least and greatest value of a binary search tree. If we move along the links to left children, and the leaf node we arrive at finally contains the least value. For instance, if we move along the links to left children in Figure 1, the nodes on the path contain value 32, 24, 21 and 14, and 14 is the least value in the binary search tree.\nSimilarly, if we move along links to right children, and the leaf node we arrive at finally contains the greatest value.\nThe key to solve this problem is how to get the next nodes (with greater values) and the previous nodes (with less values) in a binary search tree. Let\u2019s utilize stacks.\nIn order to get next nodes,\u00a0we scan the tree along the links to leaf children, and push the scanned nodes into a stack. That\u2019s to say, there are four nodes in the stack (nodes 32, 24, 21 and 14), and node 14 is on the top.\nWhen the top of the stack is popped, node 21 on the top of stack is the next node of 14. And when the node 21 is popped, the node 24 on the top is the next node of 21.\nThe steps to get the next node of node 24 are more complex, because the node 24 has a right child. We pop the node 24, and push its right child, node 28, into the stack. And then, we scan the nodes from the right child along the links to left children. Therefore, the node 31 will also be pushed into the stack. At this time, there are three nodes in the stack (nodes 32, 28 and 25), and the top on the stack (node 25) is the next node of node 24.\nLet\u2019s summarize the steps to get next nodes. If the node on the top does not have a right child, the node is popped off, and the next node is on the top again. If the node on the top has a right child, after the node is popped off and then the right child is pushed, and all nodes along the links to left children are pushed into the stack. The last pushed node on the top is the next node. We continue the steps to pop and push until the stack is empty.\nIf you are interested, please try to analyze the steps to the next nodes after the node 25 by yourself.\nThe steps to get previous nodes are quite similar. At first we push the root node, and nodes along the links to right children. The node with least is on the top of stack. In order to get the previous nodes with less values, the top is popped off. If the top does not have a left child, the previous node is the new top node in the stack. If the top has the left child, we push its left child, as well as nodes along links to right children. The last pushed node is the previous node of the node popped.\nOur solution can be implemented with the following C++ code:\n bool hasTwoNodes(BinaryTreeNode* pRoot, int sum)\n     BinaryTreeNode* pNext = getNext(nextNodes);\n         if (currentSum < sum)\n     return false ;\n void buildNextNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n void buildPrevNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n BinaryTreeNode* getNext(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pRight = pNext->m_pRight;\n     return pNext;\n BinaryTreeNode* getPrev(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pLeft = pPrev->m_pLeft;\n     return pPrev;\nThis solution costs O( n ) time. The space complexity is O(height of tree), which is O(log n ) on average, and O( n ) in the worst cases.", "question": ""},
{"answer": "\nAnalysis: In a previous blog , we discussed how to check whether there are two numbers in a sorted array whose sum equals a given value. In order to solve this problem, we initialize a number num1 as the smallest number in the array, and initialize num2 as the greatest one. If the sum of num1 and num2 is same as the given value, two required numbers have been found. If the sum is greater than the given value, we move num2 to the previous number in the array (with less value). Similarly, we move num1 to the next number in the array (with greater value) if the sum is less than the given value.\nInspired by the solution, we may find two nodes with a given sum in a binary search tree with similar strategy. Firstly we initialize a pointer P1 to the smallest node in the tree, and another pointer P2 to the greatest node. When the sum of two values in the nodes pointed by P1 and P2 is same as the given value, two required nodes have been found. If their sum is greater than the given value, we move P2 to the previous node (containing less value). Moreover, we move P1 to the next node (containing greater value) if their sum is less than the given value.\nIt is not difficult to get the least and greatest value of a binary search tree. If we move along the links to left children, and the leaf node we arrive at finally contains the least value. For instance, if we move along the links to left children in Figure 1, the nodes on the path contain value 32, 24, 21 and 14, and 14 is the least value in the binary search tree.\nSimilarly, if we move along links to right children, and the leaf node we arrive at finally contains the greatest value.\nThe key to solve this problem is how to get the next nodes (with greater values) and the previous nodes (with less values) in a binary search tree. Let\u2019s utilize stacks.\nIn order to get next nodes,\u00a0we scan the tree along the links to leaf children, and push the scanned nodes into a stack. That\u2019s to say, there are four nodes in the stack (nodes 32, 24, 21 and 14), and node 14 is on the top.\nWhen the top of the stack is popped, node 21 on the top of stack is the next node of 14. And when the node 21 is popped, the node 24 on the top is the next node of 21.\nThe steps to get the next node of node 24 are more complex, because the node 24 has a right child. We pop the node 24, and push its right child, node 28, into the stack. And then, we scan the nodes from the right child along the links to left children. Therefore, the node 31 will also be pushed into the stack. At this time, there are three nodes in the stack (nodes 32, 28 and 25), and the top on the stack (node 25) is the next node of node 24.\nLet\u2019s summarize the steps to get next nodes. If the node on the top does not have a right child, the node is popped off, and the next node is on the top again. If the node on the top has a right child, after the node is popped off and then the right child is pushed, and all nodes along the links to left children are pushed into the stack. The last pushed node on the top is the next node. We continue the steps to pop and push until the stack is empty.\nIf you are interested, please try to analyze the steps to the next nodes after the node 25 by yourself.\nThe steps to get previous nodes are quite similar. At first we push the root node, and nodes along the links to right children. The node with least is on the top of stack. In order to get the previous nodes with less values, the top is popped off. If the top does not have a left child, the previous node is the new top node in the stack. If the top has the left child, we push its left child, as well as nodes along links to right children. The last pushed node is the previous node of the node popped.\nOur solution can be implemented with the following C++ code:\n bool hasTwoNodes(BinaryTreeNode* pRoot, int sum)\n     BinaryTreeNode* pNext = getNext(nextNodes);\n         if (currentSum < sum)\n     return false ;\n void buildNextNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n void buildPrevNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n BinaryTreeNode* getNext(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pRight = pNext->m_pRight;\n     return pNext;\n BinaryTreeNode* getPrev(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pLeft = pPrev->m_pLeft;\n     return pPrev;\nThis solution costs O( n ) time. The space complexity is O(height of tree), which is O(log n ) on average, and O( n ) in the worst cases.", "question": ""},
{"answer": "\nAnalysis: Let\u2019s analyze this problem step by step, taking the binary search in Figure 1 and 29 as an example.\nWe start from the root node with value 32, and the distance to 29 is 3. Since the value 32 is greater than 29, and all values in the right sub-tree are greater than 32, distances to 29 in the right sub-tree should be greater than 3. We move to the left sub-tree.\nThe next node to be visited contains value 24, and the distance to 29 is 5. Since 5 is greater than the previous closest distance 3, the closest node up to now remains the node with value 32. Additionally, the current value 24 is less than 29, and all values in the left sub-tree\u00a0are less than 24, so distances to 29 in the left sub-tree will be greater than 5. We move on to visit the right sub-tree.\nThe next node to be visited contains value 28, and the distance to 29 is 1. Since 1 is less than the previous closest distance 3, the closest node is updated to the node with value 28. Additionally, the value 28 is less than 29, and all values in the left sub-tree areless than 28, so distances to 29 in the left sub-tree will be greater than 1. Let\u2019s continue to visit the right sub-tree.\nFinally we reach a left node with value 31. The distance to 29 is 2 and it is greater than the previous closest distance 1, so the closest node to 29 is still the node with value 28.\nAccording to the step-by-step analysis above, we could implement the following code:\n         if (distance == 0)\n         if (pNode->m_nValue > value)\n     return pClosest;", "question": ""},
{"answer": "\nAnalysis: Let\u2019s analyze this problem step by step, taking the binary search in Figure 1 and 29 as an example.\nWe start from the root node with value 32, and the distance to 29 is 3. Since the value 32 is greater than 29, and all values in the right sub-tree are greater than 32, distances to 29 in the right sub-tree should be greater than 3. We move to the left sub-tree.\nThe next node to be visited contains value 24, and the distance to 29 is 5. Since 5 is greater than the previous closest distance 3, the closest node up to now remains the node with value 32. Additionally, the current value 24 is less than 29, and all values in the left sub-tree\u00a0are less than 24, so distances to 29 in the left sub-tree will be greater than 5. We move on to visit the right sub-tree.\nThe next node to be visited contains value 28, and the distance to 29 is 1. Since 1 is less than the previous closest distance 3, the closest node is updated to the node with value 28. Additionally, the value 28 is less than 29, and all values in the left sub-tree areless than 28, so distances to 29 in the left sub-tree will be greater than 1. Let\u2019s continue to visit the right sub-tree.\nFinally we reach a left node with value 31. The distance to 29 is 2 and it is greater than the previous closest distance 1, so the closest node to 29 is still the node with value 28.\nAccording to the step-by-step analysis above, we could implement the following code:\n         if (distance == 0)\n         if (pNode->m_nValue > value)\n     return pClosest;", "question": ""},
{"answer": "\nAnalysis: Let\u2019s analyze this problem step by step, taking the binary search in Figure 1 and 29 as an example.\nWe start from the root node with value 32, and the distance to 29 is 3. Since the value 32 is greater than 29, and all values in the right sub-tree are greater than 32, distances to 29 in the right sub-tree should be greater than 3. We move to the left sub-tree.\nThe next node to be visited contains value 24, and the distance to 29 is 5. Since 5 is greater than the previous closest distance 3, the closest node up to now remains the node with value 32. Additionally, the current value 24 is less than 29, and all values in the left sub-tree\u00a0are less than 24, so distances to 29 in the left sub-tree will be greater than 5. We move on to visit the right sub-tree.\nThe next node to be visited contains value 28, and the distance to 29 is 1. Since 1 is less than the previous closest distance 3, the closest node is updated to the node with value 28. Additionally, the value 28 is less than 29, and all values in the left sub-tree areless than 28, so distances to 29 in the left sub-tree will be greater than 1. Let\u2019s continue to visit the right sub-tree.\nFinally we reach a left node with value 31. The distance to 29 is 2 and it is greater than the previous closest distance 1, so the closest node to 29 is still the node with value 28.\nAccording to the step-by-step analysis above, we could implement the following code:\n         if (distance == 0)\n         if (pNode->m_nValue > value)\n     return pClosest;", "question": ""},
{"answer": "\nAnalysis: Let\u2019s analyze this problem step by step, taking the binary search in Figure 1 and 29 as an example.\nWe start from the root node with value 32, and the distance to 29 is 3. Since the value 32 is greater than 29, and all values in the right sub-tree are greater than 32, distances to 29 in the right sub-tree should be greater than 3. We move to the left sub-tree.\nThe next node to be visited contains value 24, and the distance to 29 is 5. Since 5 is greater than the previous closest distance 3, the closest node up to now remains the node with value 32. Additionally, the current value 24 is less than 29, and all values in the left sub-tree\u00a0are less than 24, so distances to 29 in the left sub-tree will be greater than 5. We move on to visit the right sub-tree.\nThe next node to be visited contains value 28, and the distance to 29 is 1. Since 1 is less than the previous closest distance 3, the closest node is updated to the node with value 28. Additionally, the value 28 is less than 29, and all values in the left sub-tree areless than 28, so distances to 29 in the left sub-tree will be greater than 1. Let\u2019s continue to visit the right sub-tree.\nFinally we reach a left node with value 31. The distance to 29 is 2 and it is greater than the previous closest distance 1, so the closest node to 29 is still the node with value 28.\nAccording to the step-by-step analysis above, we could implement the following code:\n         if (distance == 0)\n         if (pNode->m_nValue > value)\n     return pClosest;", "question": ""},
{"answer": "\nAnalysis: Let\u2019s analyze this problem step by step, taking the binary search in Figure 1 and 29 as an example.\nWe start from the root node with value 32, and the distance to 29 is 3. Since the value 32 is greater than 29, and all values in the right sub-tree are greater than 32, distances to 29 in the right sub-tree should be greater than 3. We move to the left sub-tree.\nThe next node to be visited contains value 24, and the distance to 29 is 5. Since 5 is greater than the previous closest distance 3, the closest node up to now remains the node with value 32. Additionally, the current value 24 is less than 29, and all values in the left sub-tree\u00a0are less than 24, so distances to 29 in the left sub-tree will be greater than 5. We move on to visit the right sub-tree.\nThe next node to be visited contains value 28, and the distance to 29 is 1. Since 1 is less than the previous closest distance 3, the closest node is updated to the node with value 28. Additionally, the value 28 is less than 29, and all values in the left sub-tree areless than 28, so distances to 29 in the left sub-tree will be greater than 1. Let\u2019s continue to visit the right sub-tree.\nFinally we reach a left node with value 31. The distance to 29 is 2 and it is greater than the previous closest distance 1, so the closest node to 29 is still the node with value 28.\nAccording to the step-by-step analysis above, we could implement the following code:\n         if (distance == 0)\n         if (pNode->m_nValue > value)\n     return pClosest;", "question": ""},
{"answer": "\nAnalysis: In a previous blog , we discussed how to check whether there are two numbers in a sorted array whose sum equals a given value. In order to solve this problem, we initialize a number num1 as the smallest number in the array, and initialize num2 as the greatest one. If the sum of num1 and num2 is same as the given value, two required numbers have been found. If the sum is greater than the given value, we move num2 to the previous number in the array (with less value). Similarly, we move num1 to the next number in the array (with greater value) if the sum is less than the given value.\nInspired by the solution, we may find two nodes with a given sum in a binary search tree with similar strategy. Firstly we initialize a pointer P1 to the smallest node in the tree, and another pointer P2 to the greatest node. When the sum of two values in the nodes pointed by P1 and P2 is same as the given value, two required nodes have been found. If their sum is greater than the given value, we move P2 to the previous node (containing less value). Moreover, we move P1 to the next node (containing greater value) if their sum is less than the given value.\nIt is not difficult to get the least and greatest value of a binary search tree. If we move along the links to left children, and the leaf node we arrive at finally contains the least value. For instance, if we move along the links to left children in Figure 1, the nodes on the path contain value 32, 24, 21 and 14, and 14 is the least value in the binary search tree.\nSimilarly, if we move along links to right children, and the leaf node we arrive at finally contains the greatest value.\nThe key to solve this problem is how to get the next nodes (with greater values) and the previous nodes (with less values) in a binary search tree. Let\u2019s utilize stacks.\nIn order to get next nodes,\u00a0we scan the tree along the links to leaf children, and push the scanned nodes into a stack. That\u2019s to say, there are four nodes in the stack (nodes 32, 24, 21 and 14), and node 14 is on the top.\nWhen the top of the stack is popped, node 21 on the top of stack is the next node of 14. And when the node 21 is popped, the node 24 on the top is the next node of 21.\nThe steps to get the next node of node 24 are more complex, because the node 24 has a right child. We pop the node 24, and push its right child, node 28, into the stack. And then, we scan the nodes from the right child along the links to left children. Therefore, the node 31 will also be pushed into the stack. At this time, there are three nodes in the stack (nodes 32, 28 and 25), and the top on the stack (node 25) is the next node of node 24.\nLet\u2019s summarize the steps to get next nodes. If the node on the top does not have a right child, the node is popped off, and the next node is on the top again. If the node on the top has a right child, after the node is popped off and then the right child is pushed, and all nodes along the links to left children are pushed into the stack. The last pushed node on the top is the next node. We continue the steps to pop and push until the stack is empty.\nIf you are interested, please try to analyze the steps to the next nodes after the node 25 by yourself.\nThe steps to get previous nodes are quite similar. At first we push the root node, and nodes along the links to right children. The node with least is on the top of stack. In order to get the previous nodes with less values, the top is popped off. If the top does not have a left child, the previous node is the new top node in the stack. If the top has the left child, we push its left child, as well as nodes along links to right children. The last pushed node is the previous node of the node popped.\nOur solution can be implemented with the following C++ code:\n bool hasTwoNodes(BinaryTreeNode* pRoot, int sum)\n     BinaryTreeNode* pNext = getNext(nextNodes);\n         if (currentSum < sum)\n     return false ;\n void buildNextNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n void buildPrevNodes(BinaryTreeNode* pRoot,stack<BinaryTreeNode*>& nodes)\n BinaryTreeNode* getNext(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pRight = pNext->m_pRight;\n     return pNext;\n BinaryTreeNode* getPrev(stack<BinaryTreeNode*>& nodes)\n         BinaryTreeNode* pLeft = pPrev->m_pLeft;\n     return pPrev;\nThis solution costs O( n ) time. The space complexity is O(height of tree), which is O(log n ) on average, and O( n ) in the worst cases.", "question": ""},
{"answer": "\nAnalysis: Let\u2019s analyze this problem step by step, taking the binary search in Figure 1 and 29 as an example.\nWe start from the root node with value 32, and the distance to 29 is 3. Since the value 32 is greater than 29, and all values in the right sub-tree are greater than 32, distances to 29 in the right sub-tree should be greater than 3. We move to the left sub-tree.\nThe next node to be visited contains value 24, and the distance to 29 is 5. Since 5 is greater than the previous closest distance 3, the closest node up to now remains the node with value 32. Additionally, the current value 24 is less than 29, and all values in the left sub-tree\u00a0are less than 24, so distances to 29 in the left sub-tree will be greater than 5. We move on to visit the right sub-tree.\nThe next node to be visited contains value 28, and the distance to 29 is 1. Since 1 is less than the previous closest distance 3, the closest node is updated to the node with value 28. Additionally, the value 28 is less than 29, and all values in the left sub-tree areless than 28, so distances to 29 in the left sub-tree will be greater than 1. Let\u2019s continue to visit the right sub-tree.\nFinally we reach a left node with value 31. The distance to 29 is 2 and it is greater than the previous closest distance 1, so the closest node to 29 is still the node with value 28.\nAccording to the step-by-step analysis above, we could implement the following code:\n         if (distance == 0)\n         if (pNode->m_nValue > value)\n     return pClosest;", "question": ""},
{"answer": "\nAnalysis: Let\u2019s analyze this problem step by step, taking the binary search in Figure 1 and 29 as an example.\nWe start from the root node with value 32, and the distance to 29 is 3. Since the value 32 is greater than 29, and all values in the right sub-tree are greater than 32, distances to 29 in the right sub-tree should be greater than 3. We move to the left sub-tree.\nThe next node to be visited contains value 24, and the distance to 29 is 5. Since 5 is greater than the previous closest distance 3, the closest node up to now remains the node with value 32. Additionally, the current value 24 is less than 29, and all values in the left sub-tree\u00a0are less than 24, so distances to 29 in the left sub-tree will be greater than 5. We move on to visit the right sub-tree.\nThe next node to be visited contains value 28, and the distance to 29 is 1. Since 1 is less than the previous closest distance 3, the closest node is updated to the node with value 28. Additionally, the value 28 is less than 29, and all values in the left sub-tree areless than 28, so distances to 29 in the left sub-tree will be greater than 1. Let\u2019s continue to visit the right sub-tree.\nFinally we reach a left node with value 31. The distance to 29 is 2 and it is greater than the previous closest distance 1, so the closest node to 29 is still the node with value 28.\nAccording to the step-by-step analysis above, we could implement the following code:\n         if (distance == 0)\n         if (pNode->m_nValue > value)\n     return pClosest;", "question": ""},
{"answer": "\nAnalysis: Let\u2019s analyze this problem step by step, taking the binary search in Figure 1 and 29 as an example.\nWe start from the root node with value 32, and the distance to 29 is 3. Since the value 32 is greater than 29, and all values in the right sub-tree are greater than 32, distances to 29 in the right sub-tree should be greater than 3. We move to the left sub-tree.\nThe next node to be visited contains value 24, and the distance to 29 is 5. Since 5 is greater than the previous closest distance 3, the closest node up to now remains the node with value 32. Additionally, the current value 24 is less than 29, and all values in the left sub-tree\u00a0are less than 24, so distances to 29 in the left sub-tree will be greater than 5. We move on to visit the right sub-tree.\nThe next node to be visited contains value 28, and the distance to 29 is 1. Since 1 is less than the previous closest distance 3, the closest node is updated to the node with value 28. Additionally, the value 28 is less than 29, and all values in the left sub-tree areless than 28, so distances to 29 in the left sub-tree will be greater than 1. Let\u2019s continue to visit the right sub-tree.\nFinally we reach a left node with value 31. The distance to 29 is 2 and it is greater than the previous closest distance 1, so the closest node to 29 is still the node with value 28.\nAccording to the step-by-step analysis above, we could implement the following code:\n         if (distance == 0)\n         if (pNode->m_nValue > value)\n     return pClosest;", "question": ""},
{"answer": "\nAnalysis: Binary search is suitable for sorted arrays. Let us try to utilize it on a rotation of a sorted array. Notice that a rotation of a sorted array can be partitioned into two sorted sub-arrays, and numbers in the first sub-array are greater than numbers in the second one.\nTwo pointers P1 and P2 are utilized. P1 references to the first element in the array, and P2 references to the last element. According to the rotation rule, the first element should be greater than the last one.\nThe algorithm always compares the number in middle with numbers pointed by P1 and P2 during binary search. If the middle number is in the first increasingly sorted sub-array, it is greater than the number pointed by P1.\nIf the value of target number to be search is between the number pointed by P1 and the middle number, we then search the target number in the first half sub-array. In such a case the first half sub-array is in the first increasing sub-array, we could utilize the binary search algorithm. For example, if we search the number 4 in a rotation {3, 4, 5, 1, 2}, we could search the target number 4 in the sub-array {3, 4, 5} because 4 is between the first number 3 and the middle number 5.\nIf the value of target number is not between the number pointed by P1 and the middle number, we search the target in the second half sub-array. Notice that the second half sub-array also contains two increasing sub-array and itself is also a rotation, so we could search recursively with the same strategy. For example, if we search the number 1 in a rotation {3, 4, 5, 1, 2}, we could search the target number 1 in the sub-array {5, 1, 2} recursively.\nThe analysis above is for two cases when the middle number is in the first increasing sub-array. Please analyze the other two cases when the middle number is in the second increasing sub-array yourself, when the middle number is less than the number pointed by P2.\nThe code implementing this algorithm is listed below, in C/C++:\nint searchInRotation( int numbers[], int length, int k)\n{\nif (numbers == NULL || length <= 0)\nreturn -1;\n\nreturn searchInRotation(numbers, k, 0, length - 1);\n}\n\nint searchInRotation( int numbers[], int k, int start, int end)\n{\nif (start > end)\nreturn -1;\n\nint middle = start + (end - start) / 2;\nif (numbers[middle] == k)\nreturn middle;\n\n// the middle number is in the first increasing sub-array\nif (numbers[middle] >= numbers[start])\n{\nif (k >= numbers[start] && k < numbers[middle])\nreturn binarySearch(numbers, k, start, middle - 1);\nreturn searchInRotation(numbers, k, middle + 1, end);\n}\n// the middle number is in the second increasing sub-array\nelse if (numbers[middle] <= numbers[end])\n{\nif (k > numbers[middle] && k <= numbers[end])\nreturn binarySearch(numbers, k, middle + 1, end);\nreturn searchInRotation(numbers, k, start, middle - 1);\n}\n\n// It should never reach here if the input is valid\nassert( false );\n}\nSince the function binarySearch is for the classic binary search algorithm, it is not listed here. You might implement your own binary search code if you are interested.\nIn each round of search, half of the array is excluded for the next round, so the time complexity is O(log n ).\nYou may wonder why we assume there are no duplications in the input array. We determine whether the middle number is in the first or second sub-array by comparing the middle number and the numbers pointed by P1 or P2. When the middle number, the number pointed by P1 and P2 are identical, we don\u2019t know whether the middle number is in the first or second increasing sub-array.\nLet\u2019s look at some examples. Two arrays {1, 0, 1, 1, 1} and {1, 1, 1, 0, 1} are both rotations of an increasingly sorted array {0, 1, 1, 1, 1}, which are visualized in Figure 1.\n\n\nFigure 1 : Two rotations of an increasingly sorted array {0, 1, 1, 1, 1}: {1, 0, 1, 1, 1} and {1, 1, 1, 0, 1}. Elements with gray background are in the second increasing sub-array.\nIn Figure 1, the elements pointed by P1 and P2, as well as the middle element are all 1. The middle element with index 2 is in the second sub-array in Figure 1 (a), while the middle element is in the first sub-array in Figure 1 (b).", "question": "\nQuestion: When some elements at the beginning of an array are moved to the end, it gets a rotation of the original array. Please implement a function to search a number in a rotation of an increasingly sorted array. Assume there are no duplicated numbers in the array.\nFor example, array {3, 4, 5, 1, 2} is a rotation of array {1, 2, 3, 4, 5}. If the target number to be searched is 4, the index of the number 4 in the rotation 1 should be returned. If the target number to be searched is 6, -1 should be returned because the number does not exist in the rotated array."},
{"answer": "\nAnalysis: Binary search is suitable for sorted arrays. Let us try to utilize it on a rotation of a sorted array. Notice that a rotation of a sorted array can be partitioned into two sorted sub-arrays, and numbers in the first sub-array are greater than numbers in the second one.\nTwo pointers P1 and P2 are utilized. P1 references to the first element in the array, and P2 references to the last element. According to the rotation rule, the first element should be greater than the last one.\nThe algorithm always compares the number in middle with numbers pointed by P1 and P2 during binary search. If the middle number is in the first increasingly sorted sub-array, it is greater than the number pointed by P1.\nIf the value of target number to be search is between the number pointed by P1 and the middle number, we then search the target number in the first half sub-array. In such a case the first half sub-array is in the first increasing sub-array, we could utilize the binary search algorithm. For example, if we search the number 4 in a rotation {3, 4, 5, 1, 2}, we could search the target number 4 in the sub-array {3, 4, 5} because 4 is between the first number 3 and the middle number 5.\nIf the value of target number is not between the number pointed by P1 and the middle number, we search the target in the second half sub-array. Notice that the second half sub-array also contains two increasing sub-array and itself is also a rotation, so we could search recursively with the same strategy. For example, if we search the number 1 in a rotation {3, 4, 5, 1, 2}, we could search the target number 1 in the sub-array {5, 1, 2} recursively.\nThe analysis above is for two cases when the middle number is in the first increasing sub-array. Please analyze the other two cases when the middle number is in the second increasing sub-array yourself, when the middle number is less than the number pointed by P2.\nThe code implementing this algorithm is listed below, in C/C++:\nint searchInRotation( int numbers[], int length, int k)\n{\nif (numbers == NULL || length <= 0)\nreturn -1;\n\nreturn searchInRotation(numbers, k, 0, length - 1);\n}\n\nint searchInRotation( int numbers[], int k, int start, int end)\n{\nif (start > end)\nreturn -1;\n\nint middle = start + (end - start) / 2;\nif (numbers[middle] == k)\nreturn middle;\n\n// the middle number is in the first increasing sub-array\nif (numbers[middle] >= numbers[start])\n{\nif (k >= numbers[start] && k < numbers[middle])\nreturn binarySearch(numbers, k, start, middle - 1);\nreturn searchInRotation(numbers, k, middle + 1, end);\n}\n// the middle number is in the second increasing sub-array\nelse if (numbers[middle] <= numbers[end])\n{\nif (k > numbers[middle] && k <= numbers[end])\nreturn binarySearch(numbers, k, middle + 1, end);\nreturn searchInRotation(numbers, k, start, middle - 1);\n}\n\n// It should never reach here if the input is valid\nassert( false );\n}\nSince the function binarySearch is for the classic binary search algorithm, it is not listed here. You might implement your own binary search code if you are interested.\nIn each round of search, half of the array is excluded for the next round, so the time complexity is O(log n ).\nYou may wonder why we assume there are no duplications in the input array. We determine whether the middle number is in the first or second sub-array by comparing the middle number and the numbers pointed by P1 or P2. When the middle number, the number pointed by P1 and P2 are identical, we don\u2019t know whether the middle number is in the first or second increasing sub-array.\nLet\u2019s look at some examples. Two arrays {1, 0, 1, 1, 1} and {1, 1, 1, 0, 1} are both rotations of an increasingly sorted array {0, 1, 1, 1, 1}, which are visualized in Figure 1.\n\n\nFigure 1 : Two rotations of an increasingly sorted array {0, 1, 1, 1, 1}: {1, 0, 1, 1, 1} and {1, 1, 1, 0, 1}. Elements with gray background are in the second increasing sub-array.\nIn Figure 1, the elements pointed by P1 and P2, as well as the middle element are all 1. The middle element with index 2 is in the second sub-array in Figure 1 (a), while the middle element is in the first sub-array in Figure 1 (b).", "question": "\nQuestion: When some elements at the beginning of an array are moved to the end, it gets a rotation of the original array. Please implement a function to search a number in a rotation of an increasingly sorted array. Assume there are no duplicated numbers in the array.\nFor example, array {3, 4, 5, 1, 2} is a rotation of array {1, 2, 3, 4, 5}. If the target number to be searched is 4, the index of the number 4 in the rotation 1 should be returned. If the target number to be searched is 6, -1 should be returned because the number does not exist in the rotated array."},
{"answer": "\nAnalysis: Binary search is suitable for sorted arrays. Let us try to utilize it on a rotation of a sorted array. Notice that a rotation of a sorted array can be partitioned into two sorted sub-arrays, and numbers in the first sub-array are greater than numbers in the second one.\nTwo pointers P1 and P2 are utilized. P1 references to the first element in the array, and P2 references to the last element. According to the rotation rule, the first element should be greater than the last one.\nThe algorithm always compares the number in middle with numbers pointed by P1 and P2 during binary search. If the middle number is in the first increasingly sorted sub-array, it is greater than the number pointed by P1.\nIf the value of target number to be search is between the number pointed by P1 and the middle number, we then search the target number in the first half sub-array. In such a case the first half sub-array is in the first increasing sub-array, we could utilize the binary search algorithm. For example, if we search the number 4 in a rotation {3, 4, 5, 1, 2}, we could search the target number 4 in the sub-array {3, 4, 5} because 4 is between the first number 3 and the middle number 5.\nIf the value of target number is not between the number pointed by P1 and the middle number, we search the target in the second half sub-array. Notice that the second half sub-array also contains two increasing sub-array and itself is also a rotation, so we could search recursively with the same strategy. For example, if we search the number 1 in a rotation {3, 4, 5, 1, 2}, we could search the target number 1 in the sub-array {5, 1, 2} recursively.\nThe analysis above is for two cases when the middle number is in the first increasing sub-array. Please analyze the other two cases when the middle number is in the second increasing sub-array yourself, when the middle number is less than the number pointed by P2.\nThe code implementing this algorithm is listed below, in C/C++:\nint searchInRotation( int numbers[], int length, int k)\n{\nif (numbers == NULL || length <= 0)\nreturn -1;\n\nreturn searchInRotation(numbers, k, 0, length - 1);\n}\n\nint searchInRotation( int numbers[], int k, int start, int end)\n{\nif (start > end)\nreturn -1;\n\nint middle = start + (end - start) / 2;\nif (numbers[middle] == k)\nreturn middle;\n\n// the middle number is in the first increasing sub-array\nif (numbers[middle] >= numbers[start])\n{\nif (k >= numbers[start] && k < numbers[middle])\nreturn binarySearch(numbers, k, start, middle - 1);\nreturn searchInRotation(numbers, k, middle + 1, end);\n}\n// the middle number is in the second increasing sub-array\nelse if (numbers[middle] <= numbers[end])\n{\nif (k > numbers[middle] && k <= numbers[end])\nreturn binarySearch(numbers, k, middle + 1, end);\nreturn searchInRotation(numbers, k, start, middle - 1);\n}\n\n// It should never reach here if the input is valid\nassert( false );\n}\nSince the function binarySearch is for the classic binary search algorithm, it is not listed here. You might implement your own binary search code if you are interested.\nIn each round of search, half of the array is excluded for the next round, so the time complexity is O(log n ).\nYou may wonder why we assume there are no duplications in the input array. We determine whether the middle number is in the first or second sub-array by comparing the middle number and the numbers pointed by P1 or P2. When the middle number, the number pointed by P1 and P2 are identical, we don\u2019t know whether the middle number is in the first or second increasing sub-array.\nLet\u2019s look at some examples. Two arrays {1, 0, 1, 1, 1} and {1, 1, 1, 0, 1} are both rotations of an increasingly sorted array {0, 1, 1, 1, 1}, which are visualized in Figure 1.\n\n\nFigure 1 : Two rotations of an increasingly sorted array {0, 1, 1, 1, 1}: {1, 0, 1, 1, 1} and {1, 1, 1, 0, 1}. Elements with gray background are in the second increasing sub-array.\nIn Figure 1, the elements pointed by P1 and P2, as well as the middle element are all 1. The middle element with index 2 is in the second sub-array in Figure 1 (a), while the middle element is in the first sub-array in Figure 1 (b).", "question": "\nQuestion: When some elements at the beginning of an array are moved to the end, it gets a rotation of the original array. Please implement a function to search a number in a rotation of an increasingly sorted array. Assume there are no duplicated numbers in the array.\nFor example, array {3, 4, 5, 1, 2} is a rotation of array {1, 2, 3, 4, 5}. If the target number to be searched is 4, the index of the number 4 in the rotation 1 should be returned. If the target number to be searched is 6, -1 should be returned because the number does not exist in the rotated array."},
{"answer": "\nAnalysis: Binary search is suitable for sorted arrays. Let us try to utilize it on a rotation of a sorted array. Notice that a rotation of a sorted array can be partitioned into two sorted sub-arrays, and numbers in the first sub-array are greater than numbers in the second one.\nTwo pointers P1 and P2 are utilized. P1 references to the first element in the array, and P2 references to the last element. According to the rotation rule, the first element should be greater than the last one.\nThe algorithm always compares the number in middle with numbers pointed by P1 and P2 during binary search. If the middle number is in the first increasingly sorted sub-array, it is greater than the number pointed by P1.\nIf the value of target number to be search is between the number pointed by P1 and the middle number, we then search the target number in the first half sub-array. In such a case the first half sub-array is in the first increasing sub-array, we could utilize the binary search algorithm. For example, if we search the number 4 in a rotation {3, 4, 5, 1, 2}, we could search the target number 4 in the sub-array {3, 4, 5} because 4 is between the first number 3 and the middle number 5.\nIf the value of target number is not between the number pointed by P1 and the middle number, we search the target in the second half sub-array. Notice that the second half sub-array also contains two increasing sub-array and itself is also a rotation, so we could search recursively with the same strategy. For example, if we search the number 1 in a rotation {3, 4, 5, 1, 2}, we could search the target number 1 in the sub-array {5, 1, 2} recursively.\nThe analysis above is for two cases when the middle number is in the first increasing sub-array. Please analyze the other two cases when the middle number is in the second increasing sub-array yourself, when the middle number is less than the number pointed by P2.\nThe code implementing this algorithm is listed below, in C/C++:\nint searchInRotation( int numbers[], int length, int k)\n{\nif (numbers == NULL || length <= 0)\nreturn -1;\n\nreturn searchInRotation(numbers, k, 0, length - 1);\n}\n\nint searchInRotation( int numbers[], int k, int start, int end)\n{\nif (start > end)\nreturn -1;\n\nint middle = start + (end - start) / 2;\nif (numbers[middle] == k)\nreturn middle;\n\n// the middle number is in the first increasing sub-array\nif (numbers[middle] >= numbers[start])\n{\nif (k >= numbers[start] && k < numbers[middle])\nreturn binarySearch(numbers, k, start, middle - 1);\nreturn searchInRotation(numbers, k, middle + 1, end);\n}\n// the middle number is in the second increasing sub-array\nelse if (numbers[middle] <= numbers[end])\n{\nif (k > numbers[middle] && k <= numbers[end])\nreturn binarySearch(numbers, k, middle + 1, end);\nreturn searchInRotation(numbers, k, start, middle - 1);\n}\n\n// It should never reach here if the input is valid\nassert( false );\n}\nSince the function binarySearch is for the classic binary search algorithm, it is not listed here. You might implement your own binary search code if you are interested.\nIn each round of search, half of the array is excluded for the next round, so the time complexity is O(log n ).\nYou may wonder why we assume there are no duplications in the input array. We determine whether the middle number is in the first or second sub-array by comparing the middle number and the numbers pointed by P1 or P2. When the middle number, the number pointed by P1 and P2 are identical, we don\u2019t know whether the middle number is in the first or second increasing sub-array.\nLet\u2019s look at some examples. Two arrays {1, 0, 1, 1, 1} and {1, 1, 1, 0, 1} are both rotations of an increasingly sorted array {0, 1, 1, 1, 1}, which are visualized in Figure 1.\n\n\nFigure 1 : Two rotations of an increasingly sorted array {0, 1, 1, 1, 1}: {1, 0, 1, 1, 1} and {1, 1, 1, 0, 1}. Elements with gray background are in the second increasing sub-array.\nIn Figure 1, the elements pointed by P1 and P2, as well as the middle element are all 1. The middle element with index 2 is in the second sub-array in Figure 1 (a), while the middle element is in the first sub-array in Figure 1 (b).", "question": "\nQuestion: When some elements at the beginning of an array are moved to the end, it gets a rotation of the original array. Please implement a function to search a number in a rotation of an increasingly sorted array. Assume there are no duplicated numbers in the array.\nFor example, array {3, 4, 5, 1, 2} is a rotation of array {1, 2, 3, 4, 5}. If the target number to be searched is 4, the index of the number 4 in the rotation 1 should be returned. If the target number to be searched is 6, -1 should be returned because the number does not exist in the rotated array."},
{"answer": "\nAnalysis: Binary search is suitable for sorted arrays. Let us try to utilize it on a rotation of a sorted array. Notice that a rotation of a sorted array can be partitioned into two sorted sub-arrays, and numbers in the first sub-array are greater than numbers in the second one.\nTwo pointers P1 and P2 are utilized. P1 references to the first element in the array, and P2 references to the last element. According to the rotation rule, the first element should be greater than the last one.\nThe algorithm always compares the number in middle with numbers pointed by P1 and P2 during binary search. If the middle number is in the first increasingly sorted sub-array, it is greater than the number pointed by P1.\nIf the value of target number to be search is between the number pointed by P1 and the middle number, we then search the target number in the first half sub-array. In such a case the first half sub-array is in the first increasing sub-array, we could utilize the binary search algorithm. For example, if we search the number 4 in a rotation {3, 4, 5, 1, 2}, we could search the target number 4 in the sub-array {3, 4, 5} because 4 is between the first number 3 and the middle number 5.\nIf the value of target number is not between the number pointed by P1 and the middle number, we search the target in the second half sub-array. Notice that the second half sub-array also contains two increasing sub-array and itself is also a rotation, so we could search recursively with the same strategy. For example, if we search the number 1 in a rotation {3, 4, 5, 1, 2}, we could search the target number 1 in the sub-array {5, 1, 2} recursively.\nThe analysis above is for two cases when the middle number is in the first increasing sub-array. Please analyze the other two cases when the middle number is in the second increasing sub-array yourself, when the middle number is less than the number pointed by P2.\nThe code implementing this algorithm is listed below, in C/C++:\nint searchInRotation( int numbers[], int length, int k)\n{\nif (numbers == NULL || length <= 0)\nreturn -1;\n\nreturn searchInRotation(numbers, k, 0, length - 1);\n}\n\nint searchInRotation( int numbers[], int k, int start, int end)\n{\nif (start > end)\nreturn -1;\n\nint middle = start + (end - start) / 2;\nif (numbers[middle] == k)\nreturn middle;\n\n// the middle number is in the first increasing sub-array\nif (numbers[middle] >= numbers[start])\n{\nif (k >= numbers[start] && k < numbers[middle])\nreturn binarySearch(numbers, k, start, middle - 1);\nreturn searchInRotation(numbers, k, middle + 1, end);\n}\n// the middle number is in the second increasing sub-array\nelse if (numbers[middle] <= numbers[end])\n{\nif (k > numbers[middle] && k <= numbers[end])\nreturn binarySearch(numbers, k, middle + 1, end);\nreturn searchInRotation(numbers, k, start, middle - 1);\n}\n\n// It should never reach here if the input is valid\nassert( false );\n}\nSince the function binarySearch is for the classic binary search algorithm, it is not listed here. You might implement your own binary search code if you are interested.\nIn each round of search, half of the array is excluded for the next round, so the time complexity is O(log n ).\nYou may wonder why we assume there are no duplications in the input array. We determine whether the middle number is in the first or second sub-array by comparing the middle number and the numbers pointed by P1 or P2. When the middle number, the number pointed by P1 and P2 are identical, we don\u2019t know whether the middle number is in the first or second increasing sub-array.\nLet\u2019s look at some examples. Two arrays {1, 0, 1, 1, 1} and {1, 1, 1, 0, 1} are both rotations of an increasingly sorted array {0, 1, 1, 1, 1}, which are visualized in Figure 1.\n\n\nFigure 1 : Two rotations of an increasingly sorted array {0, 1, 1, 1, 1}: {1, 0, 1, 1, 1} and {1, 1, 1, 0, 1}. Elements with gray background are in the second increasing sub-array.\nIn Figure 1, the elements pointed by P1 and P2, as well as the middle element are all 1. The middle element with index 2 is in the second sub-array in Figure 1 (a), while the middle element is in the first sub-array in Figure 1 (b).", "question": "\nQuestion: When some elements at the beginning of an array are moved to the end, it gets a rotation of the original array. Please implement a function to search a number in a rotation of an increasingly sorted array. Assume there are no duplicated numbers in the array.\nFor example, array {3, 4, 5, 1, 2} is a rotation of array {1, 2, 3, 4, 5}. If the target number to be searched is 4, the index of the number 4 in the rotation 1 should be returned. If the target number to be searched is 6, -1 should be returned because the number does not exist in the rotated array."},
{"answer": "", "question": ""},
{"answer": "\nAnalysis: Let us firstly have a try to select two numbers (denoted as num1 and num2 ) of the input array. If their sum equals to s , we are fortunate because the required numbers have been found. If the sum is less than s , we may replace num1 with its next number, because the array is increasingly sorted and its next number should be greater. If the sum is greater than s , num2 can be replaced with its previous number in the sorted array, which should be less than num2 .\n\nTake the array { 1 , 2 , 4 , 7 , 11 , 15 } and number 15 as an example. We define two pointers. At the first step, they point to the first number (also the least one) 1 and the last number (also the greatest one) 15. We move the second pointer forward to number 11, since their sum 16 and it is greater than 15.\n\nAt the second step, the two numbers are 1 and 11, and their sum 12 is less than 15. Therefore, we can move the first pointer afterward and let it point to 2.\n\nThe two numbers are 2 and 11 accordingly at the third step. Since their sum 13 is less than 15, we move the first pointer afterward again.\n\nNow the two numbers are 4 and 11, and their sum is 15 which is the expected sum. Therefore, we have found two numbers whose sum is 15.\n\nThe process is summarized as in Table 1:\n\nStep Num1 Num2 Sum Comparing with s Operation 1 1 15 16 Greater Select the previous   number of Num2 2 1 11 12 Less Select the next number of Num1 3 2 11 13 Less Select the next number   of Num1 4 4 11 15 Equal\nStep\nNum1\nNum2\nSum\nComparing with s\nOperation\n1\n1\n15\n16\nGreater\nSelect the previous   number of Num2\n2\n1\n11\n12\nLess\nSelect the next number of Num1\n3\n2\n11\n13\nLess\nSelect the next number   of Num1\n4\n4\n11\n15\nEqual\n\nTable 1: Find a pair of numbers with sum 15 out of array {1 \u3001 2 \u3001 4 \u3001 7 \u3001 11 \u3001 15}\n\nAfter interviewers approve our solution, we can begin to write code. The following is a piece of sample code:\n\nbool FindNumbersWithSum( int data[], int length, int sum,\nint * num1, int * num2)\n{\nbool found = false ;\nif (length < 1 || num1 == NULL || num2 == NULL)\nreturn found;\n\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\n*num1 = data[behind];\n*num2 = data[ahead];\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\n\nIn the code above, ahead is the index of the first number, and behind is the index of the second number. Since we only need to scan the input array once, its time complexity is O(n).\n\n\nAnalysis: This problem is also required to find some numbers with a given array and sum, it is similar to the first problem. We may get some hints from the solution above.\n\nSince the input of the previous problem is an increasingly sorted array, we can also firstly sort the input array increasingly. Secondly we scan the array. When we reach the i-th number with value n , we try to find whether there are two numbers whose sum is \u2013n in the array excluding the i-th number.\n\nIt is time for us to write some code. We modify the function FindNumbersWithSum above a little bit:\n\nbool FindNumbersWithSum( int data[], int length, int sum, int excludeIndex)\n{\nbool found = false ;\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nif (ahead == excludeIndex)\nahead --;\nif (behind == excludeIndex)\nbehind ++;\n\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\nIt determines whether there are two numbers whose sum is sum in array data excluding the number with index excludeIndex . We can determine whether there are three numbers in an array with sum 0 based on this function:\nbool HasThreeNumbersWithSum0( int data[], int length)\n{\nbool found = false ;\nif (data == NULL || length < 3)\nreturn found;\n\nstd::sort(data, data + length - 1);\n\nfor ( int i = 0; i < length; ++i)\n{\nint sum = -data[i];\nint num1, num2;\nfound = FindNumbersWithSum(data, length, sum, i);\n\nif (found)\nbreak ;\n}\n\nreturn found;\n}\n\n\nIt contains two steps in function HasThreeNumbersWithSum0 . It costs O(n log n)time to sort n numbers at its first step. At its second step it costs O(n) time for each number to call FindNumberWithSum , so it costs O(n 2 ) time in the for loop. Therefore, its overall time complexity is O(n 2 ).", "question": "\nProblem 1: Given an increasingly sorted array and a number s , please find two numbers whose sum is s. If there are multiple pairs with sum s, just output any one of them.\n\nFor example, if the inputs are an array { 1 , 2 , 4 , 7 , 11 , 15 } and a number 15, please out two numbers 4 and 11 since 4+11=15.\n\n\nProblem 2: Given an array, please determine whether it contains three numbers whose sum equals to 0.\n"},
{"answer": "\nAnalysis: Let us firstly have a try to select two numbers (denoted as num1 and num2 ) of the input array. If their sum equals to s , we are fortunate because the required numbers have been found. If the sum is less than s , we may replace num1 with its next number, because the array is increasingly sorted and its next number should be greater. If the sum is greater than s , num2 can be replaced with its previous number in the sorted array, which should be less than num2 .\n\nTake the array { 1 , 2 , 4 , 7 , 11 , 15 } and number 15 as an example. We define two pointers. At the first step, they point to the first number (also the least one) 1 and the last number (also the greatest one) 15. We move the second pointer forward to number 11, since their sum 16 and it is greater than 15.\n\nAt the second step, the two numbers are 1 and 11, and their sum 12 is less than 15. Therefore, we can move the first pointer afterward and let it point to 2.\n\nThe two numbers are 2 and 11 accordingly at the third step. Since their sum 13 is less than 15, we move the first pointer afterward again.\n\nNow the two numbers are 4 and 11, and their sum is 15 which is the expected sum. Therefore, we have found two numbers whose sum is 15.\n\nThe process is summarized as in Table 1:\n\nStep Num1 Num2 Sum Comparing with s Operation 1 1 15 16 Greater Select the previous   number of Num2 2 1 11 12 Less Select the next number of Num1 3 2 11 13 Less Select the next number   of Num1 4 4 11 15 Equal\nStep\nNum1\nNum2\nSum\nComparing with s\nOperation\n1\n1\n15\n16\nGreater\nSelect the previous   number of Num2\n2\n1\n11\n12\nLess\nSelect the next number of Num1\n3\n2\n11\n13\nLess\nSelect the next number   of Num1\n4\n4\n11\n15\nEqual\n\nTable 1: Find a pair of numbers with sum 15 out of array {1 \u3001 2 \u3001 4 \u3001 7 \u3001 11 \u3001 15}\n\nAfter interviewers approve our solution, we can begin to write code. The following is a piece of sample code:\n\nbool FindNumbersWithSum( int data[], int length, int sum,\nint * num1, int * num2)\n{\nbool found = false ;\nif (length < 1 || num1 == NULL || num2 == NULL)\nreturn found;\n\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\n*num1 = data[behind];\n*num2 = data[ahead];\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\n\nIn the code above, ahead is the index of the first number, and behind is the index of the second number. Since we only need to scan the input array once, its time complexity is O(n).\n\n\nAnalysis: This problem is also required to find some numbers with a given array and sum, it is similar to the first problem. We may get some hints from the solution above.\n\nSince the input of the previous problem is an increasingly sorted array, we can also firstly sort the input array increasingly. Secondly we scan the array. When we reach the i-th number with value n , we try to find whether there are two numbers whose sum is \u2013n in the array excluding the i-th number.\n\nIt is time for us to write some code. We modify the function FindNumbersWithSum above a little bit:\n\nbool FindNumbersWithSum( int data[], int length, int sum, int excludeIndex)\n{\nbool found = false ;\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nif (ahead == excludeIndex)\nahead --;\nif (behind == excludeIndex)\nbehind ++;\n\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\nIt determines whether there are two numbers whose sum is sum in array data excluding the number with index excludeIndex . We can determine whether there are three numbers in an array with sum 0 based on this function:\nbool HasThreeNumbersWithSum0( int data[], int length)\n{\nbool found = false ;\nif (data == NULL || length < 3)\nreturn found;\n\nstd::sort(data, data + length - 1);\n\nfor ( int i = 0; i < length; ++i)\n{\nint sum = -data[i];\nint num1, num2;\nfound = FindNumbersWithSum(data, length, sum, i);\n\nif (found)\nbreak ;\n}\n\nreturn found;\n}\n\n\nIt contains two steps in function HasThreeNumbersWithSum0 . It costs O(n log n)time to sort n numbers at its first step. At its second step it costs O(n) time for each number to call FindNumberWithSum , so it costs O(n 2 ) time in the for loop. Therefore, its overall time complexity is O(n 2 ).", "question": "\nProblem 1: Given an increasingly sorted array and a number s , please find two numbers whose sum is s. If there are multiple pairs with sum s, just output any one of them.\n\nFor example, if the inputs are an array { 1 , 2 , 4 , 7 , 11 , 15 } and a number 15, please out two numbers 4 and 11 since 4+11=15.\n\n\nProblem 2: Given an array, please determine whether it contains three numbers whose sum equals to 0.\n"},
{"answer": "\nAnalysis: Let us firstly have a try to select two numbers (denoted as num1 and num2 ) of the input array. If their sum equals to s , we are fortunate because the required numbers have been found. If the sum is less than s , we may replace num1 with its next number, because the array is increasingly sorted and its next number should be greater. If the sum is greater than s , num2 can be replaced with its previous number in the sorted array, which should be less than num2 .\n\nTake the array { 1 , 2 , 4 , 7 , 11 , 15 } and number 15 as an example. We define two pointers. At the first step, they point to the first number (also the least one) 1 and the last number (also the greatest one) 15. We move the second pointer forward to number 11, since their sum 16 and it is greater than 15.\n\nAt the second step, the two numbers are 1 and 11, and their sum 12 is less than 15. Therefore, we can move the first pointer afterward and let it point to 2.\n\nThe two numbers are 2 and 11 accordingly at the third step. Since their sum 13 is less than 15, we move the first pointer afterward again.\n\nNow the two numbers are 4 and 11, and their sum is 15 which is the expected sum. Therefore, we have found two numbers whose sum is 15.\n\nThe process is summarized as in Table 1:\n\nStep Num1 Num2 Sum Comparing with s Operation 1 1 15 16 Greater Select the previous   number of Num2 2 1 11 12 Less Select the next number of Num1 3 2 11 13 Less Select the next number   of Num1 4 4 11 15 Equal\nStep\nNum1\nNum2\nSum\nComparing with s\nOperation\n1\n1\n15\n16\nGreater\nSelect the previous   number of Num2\n2\n1\n11\n12\nLess\nSelect the next number of Num1\n3\n2\n11\n13\nLess\nSelect the next number   of Num1\n4\n4\n11\n15\nEqual\n\nTable 1: Find a pair of numbers with sum 15 out of array {1 \u3001 2 \u3001 4 \u3001 7 \u3001 11 \u3001 15}\n\nAfter interviewers approve our solution, we can begin to write code. The following is a piece of sample code:\n\nbool FindNumbersWithSum( int data[], int length, int sum,\nint * num1, int * num2)\n{\nbool found = false ;\nif (length < 1 || num1 == NULL || num2 == NULL)\nreturn found;\n\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\n*num1 = data[behind];\n*num2 = data[ahead];\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\n\nIn the code above, ahead is the index of the first number, and behind is the index of the second number. Since we only need to scan the input array once, its time complexity is O(n).\n\n\nAnalysis: This problem is also required to find some numbers with a given array and sum, it is similar to the first problem. We may get some hints from the solution above.\n\nSince the input of the previous problem is an increasingly sorted array, we can also firstly sort the input array increasingly. Secondly we scan the array. When we reach the i-th number with value n , we try to find whether there are two numbers whose sum is \u2013n in the array excluding the i-th number.\n\nIt is time for us to write some code. We modify the function FindNumbersWithSum above a little bit:\n\nbool FindNumbersWithSum( int data[], int length, int sum, int excludeIndex)\n{\nbool found = false ;\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nif (ahead == excludeIndex)\nahead --;\nif (behind == excludeIndex)\nbehind ++;\n\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\nIt determines whether there are two numbers whose sum is sum in array data excluding the number with index excludeIndex . We can determine whether there are three numbers in an array with sum 0 based on this function:\nbool HasThreeNumbersWithSum0( int data[], int length)\n{\nbool found = false ;\nif (data == NULL || length < 3)\nreturn found;\n\nstd::sort(data, data + length - 1);\n\nfor ( int i = 0; i < length; ++i)\n{\nint sum = -data[i];\nint num1, num2;\nfound = FindNumbersWithSum(data, length, sum, i);\n\nif (found)\nbreak ;\n}\n\nreturn found;\n}\n\n\nIt contains two steps in function HasThreeNumbersWithSum0 . It costs O(n log n)time to sort n numbers at its first step. At its second step it costs O(n) time for each number to call FindNumberWithSum , so it costs O(n 2 ) time in the for loop. Therefore, its overall time complexity is O(n 2 ).", "question": "\nProblem 1: Given an increasingly sorted array and a number s , please find two numbers whose sum is s. If there are multiple pairs with sum s, just output any one of them.\n\nFor example, if the inputs are an array { 1 , 2 , 4 , 7 , 11 , 15 } and a number 15, please out two numbers 4 and 11 since 4+11=15.\n\n\nProblem 2: Given an array, please determine whether it contains three numbers whose sum equals to 0.\n"},
{"answer": "\nAnalysis: Let us firstly have a try to select two numbers (denoted as num1 and num2 ) of the input array. If their sum equals to s , we are fortunate because the required numbers have been found. If the sum is less than s , we may replace num1 with its next number, because the array is increasingly sorted and its next number should be greater. If the sum is greater than s , num2 can be replaced with its previous number in the sorted array, which should be less than num2 .\n\nTake the array { 1 , 2 , 4 , 7 , 11 , 15 } and number 15 as an example. We define two pointers. At the first step, they point to the first number (also the least one) 1 and the last number (also the greatest one) 15. We move the second pointer forward to number 11, since their sum 16 and it is greater than 15.\n\nAt the second step, the two numbers are 1 and 11, and their sum 12 is less than 15. Therefore, we can move the first pointer afterward and let it point to 2.\n\nThe two numbers are 2 and 11 accordingly at the third step. Since their sum 13 is less than 15, we move the first pointer afterward again.\n\nNow the two numbers are 4 and 11, and their sum is 15 which is the expected sum. Therefore, we have found two numbers whose sum is 15.\n\nThe process is summarized as in Table 1:\n\nStep Num1 Num2 Sum Comparing with s Operation 1 1 15 16 Greater Select the previous   number of Num2 2 1 11 12 Less Select the next number of Num1 3 2 11 13 Less Select the next number   of Num1 4 4 11 15 Equal\nStep\nNum1\nNum2\nSum\nComparing with s\nOperation\n1\n1\n15\n16\nGreater\nSelect the previous   number of Num2\n2\n1\n11\n12\nLess\nSelect the next number of Num1\n3\n2\n11\n13\nLess\nSelect the next number   of Num1\n4\n4\n11\n15\nEqual\n\nTable 1: Find a pair of numbers with sum 15 out of array {1 \u3001 2 \u3001 4 \u3001 7 \u3001 11 \u3001 15}\n\nAfter interviewers approve our solution, we can begin to write code. The following is a piece of sample code:\n\nbool FindNumbersWithSum( int data[], int length, int sum,\nint * num1, int * num2)\n{\nbool found = false ;\nif (length < 1 || num1 == NULL || num2 == NULL)\nreturn found;\n\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\n*num1 = data[behind];\n*num2 = data[ahead];\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\n\nIn the code above, ahead is the index of the first number, and behind is the index of the second number. Since we only need to scan the input array once, its time complexity is O(n).\n\n\nAnalysis: This problem is also required to find some numbers with a given array and sum, it is similar to the first problem. We may get some hints from the solution above.\n\nSince the input of the previous problem is an increasingly sorted array, we can also firstly sort the input array increasingly. Secondly we scan the array. When we reach the i-th number with value n , we try to find whether there are two numbers whose sum is \u2013n in the array excluding the i-th number.\n\nIt is time for us to write some code. We modify the function FindNumbersWithSum above a little bit:\n\nbool FindNumbersWithSum( int data[], int length, int sum, int excludeIndex)\n{\nbool found = false ;\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nif (ahead == excludeIndex)\nahead --;\nif (behind == excludeIndex)\nbehind ++;\n\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\nIt determines whether there are two numbers whose sum is sum in array data excluding the number with index excludeIndex . We can determine whether there are three numbers in an array with sum 0 based on this function:\nbool HasThreeNumbersWithSum0( int data[], int length)\n{\nbool found = false ;\nif (data == NULL || length < 3)\nreturn found;\n\nstd::sort(data, data + length - 1);\n\nfor ( int i = 0; i < length; ++i)\n{\nint sum = -data[i];\nint num1, num2;\nfound = FindNumbersWithSum(data, length, sum, i);\n\nif (found)\nbreak ;\n}\n\nreturn found;\n}\n\n\nIt contains two steps in function HasThreeNumbersWithSum0 . It costs O(n log n)time to sort n numbers at its first step. At its second step it costs O(n) time for each number to call FindNumberWithSum , so it costs O(n 2 ) time in the for loop. Therefore, its overall time complexity is O(n 2 ).", "question": "\nProblem 1: Given an increasingly sorted array and a number s , please find two numbers whose sum is s. If there are multiple pairs with sum s, just output any one of them.\n\nFor example, if the inputs are an array { 1 , 2 , 4 , 7 , 11 , 15 } and a number 15, please out two numbers 4 and 11 since 4+11=15.\n\n\nProblem 2: Given an array, please determine whether it contains three numbers whose sum equals to 0.\n"},
{"answer": "\nAnalysis: Let us firstly have a try to select two numbers (denoted as num1 and num2 ) of the input array. If their sum equals to s , we are fortunate because the required numbers have been found. If the sum is less than s , we may replace num1 with its next number, because the array is increasingly sorted and its next number should be greater. If the sum is greater than s , num2 can be replaced with its previous number in the sorted array, which should be less than num2 .\n\nTake the array { 1 , 2 , 4 , 7 , 11 , 15 } and number 15 as an example. We define two pointers. At the first step, they point to the first number (also the least one) 1 and the last number (also the greatest one) 15. We move the second pointer forward to number 11, since their sum 16 and it is greater than 15.\n\nAt the second step, the two numbers are 1 and 11, and their sum 12 is less than 15. Therefore, we can move the first pointer afterward and let it point to 2.\n\nThe two numbers are 2 and 11 accordingly at the third step. Since their sum 13 is less than 15, we move the first pointer afterward again.\n\nNow the two numbers are 4 and 11, and their sum is 15 which is the expected sum. Therefore, we have found two numbers whose sum is 15.\n\nThe process is summarized as in Table 1:\n\nStep Num1 Num2 Sum Comparing with s Operation 1 1 15 16 Greater Select the previous   number of Num2 2 1 11 12 Less Select the next number of Num1 3 2 11 13 Less Select the next number   of Num1 4 4 11 15 Equal\nStep\nNum1\nNum2\nSum\nComparing with s\nOperation\n1\n1\n15\n16\nGreater\nSelect the previous   number of Num2\n2\n1\n11\n12\nLess\nSelect the next number of Num1\n3\n2\n11\n13\nLess\nSelect the next number   of Num1\n4\n4\n11\n15\nEqual\n\nTable 1: Find a pair of numbers with sum 15 out of array {1 \u3001 2 \u3001 4 \u3001 7 \u3001 11 \u3001 15}\n\nAfter interviewers approve our solution, we can begin to write code. The following is a piece of sample code:\n\nbool FindNumbersWithSum( int data[], int length, int sum,\nint * num1, int * num2)\n{\nbool found = false ;\nif (length < 1 || num1 == NULL || num2 == NULL)\nreturn found;\n\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\n*num1 = data[behind];\n*num2 = data[ahead];\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\n\nIn the code above, ahead is the index of the first number, and behind is the index of the second number. Since we only need to scan the input array once, its time complexity is O(n).\n\n\nAnalysis: This problem is also required to find some numbers with a given array and sum, it is similar to the first problem. We may get some hints from the solution above.\n\nSince the input of the previous problem is an increasingly sorted array, we can also firstly sort the input array increasingly. Secondly we scan the array. When we reach the i-th number with value n , we try to find whether there are two numbers whose sum is \u2013n in the array excluding the i-th number.\n\nIt is time for us to write some code. We modify the function FindNumbersWithSum above a little bit:\n\nbool FindNumbersWithSum( int data[], int length, int sum, int excludeIndex)\n{\nbool found = false ;\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nif (ahead == excludeIndex)\nahead --;\nif (behind == excludeIndex)\nbehind ++;\n\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\nIt determines whether there are two numbers whose sum is sum in array data excluding the number with index excludeIndex . We can determine whether there are three numbers in an array with sum 0 based on this function:\nbool HasThreeNumbersWithSum0( int data[], int length)\n{\nbool found = false ;\nif (data == NULL || length < 3)\nreturn found;\n\nstd::sort(data, data + length - 1);\n\nfor ( int i = 0; i < length; ++i)\n{\nint sum = -data[i];\nint num1, num2;\nfound = FindNumbersWithSum(data, length, sum, i);\n\nif (found)\nbreak ;\n}\n\nreturn found;\n}\n\n\nIt contains two steps in function HasThreeNumbersWithSum0 . It costs O(n log n)time to sort n numbers at its first step. At its second step it costs O(n) time for each number to call FindNumberWithSum , so it costs O(n 2 ) time in the for loop. Therefore, its overall time complexity is O(n 2 ).", "question": "\nProblem 1: Given an increasingly sorted array and a number s , please find two numbers whose sum is s. If there are multiple pairs with sum s, just output any one of them.\n\nFor example, if the inputs are an array { 1 , 2 , 4 , 7 , 11 , 15 } and a number 15, please out two numbers 4 and 11 since 4+11=15.\n\n\nProblem 2: Given an array, please determine whether it contains three numbers whose sum equals to 0.\n"},
{"answer": "\nAnalysis: Let us firstly have a try to select two numbers (denoted as num1 and num2 ) of the input array. If their sum equals to s , we are fortunate because the required numbers have been found. If the sum is less than s , we may replace num1 with its next number, because the array is increasingly sorted and its next number should be greater. If the sum is greater than s , num2 can be replaced with its previous number in the sorted array, which should be less than num2 .\n\nTake the array { 1 , 2 , 4 , 7 , 11 , 15 } and number 15 as an example. We define two pointers. At the first step, they point to the first number (also the least one) 1 and the last number (also the greatest one) 15. We move the second pointer forward to number 11, since their sum 16 and it is greater than 15.\n\nAt the second step, the two numbers are 1 and 11, and their sum 12 is less than 15. Therefore, we can move the first pointer afterward and let it point to 2.\n\nThe two numbers are 2 and 11 accordingly at the third step. Since their sum 13 is less than 15, we move the first pointer afterward again.\n\nNow the two numbers are 4 and 11, and their sum is 15 which is the expected sum. Therefore, we have found two numbers whose sum is 15.\n\nThe process is summarized as in Table 1:\n\nStep Num1 Num2 Sum Comparing with s Operation 1 1 15 16 Greater Select the previous   number of Num2 2 1 11 12 Less Select the next number of Num1 3 2 11 13 Less Select the next number   of Num1 4 4 11 15 Equal\nStep\nNum1\nNum2\nSum\nComparing with s\nOperation\n1\n1\n15\n16\nGreater\nSelect the previous   number of Num2\n2\n1\n11\n12\nLess\nSelect the next number of Num1\n3\n2\n11\n13\nLess\nSelect the next number   of Num1\n4\n4\n11\n15\nEqual\n\nTable 1: Find a pair of numbers with sum 15 out of array {1 \u3001 2 \u3001 4 \u3001 7 \u3001 11 \u3001 15}\n\nAfter interviewers approve our solution, we can begin to write code. The following is a piece of sample code:\n\nbool FindNumbersWithSum( int data[], int length, int sum,\nint * num1, int * num2)\n{\nbool found = false ;\nif (length < 1 || num1 == NULL || num2 == NULL)\nreturn found;\n\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\n*num1 = data[behind];\n*num2 = data[ahead];\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\n\nIn the code above, ahead is the index of the first number, and behind is the index of the second number. Since we only need to scan the input array once, its time complexity is O(n).\n\n\nAnalysis: This problem is also required to find some numbers with a given array and sum, it is similar to the first problem. We may get some hints from the solution above.\n\nSince the input of the previous problem is an increasingly sorted array, we can also firstly sort the input array increasingly. Secondly we scan the array. When we reach the i-th number with value n , we try to find whether there are two numbers whose sum is \u2013n in the array excluding the i-th number.\n\nIt is time for us to write some code. We modify the function FindNumbersWithSum above a little bit:\n\nbool FindNumbersWithSum( int data[], int length, int sum, int excludeIndex)\n{\nbool found = false ;\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nif (ahead == excludeIndex)\nahead --;\nif (behind == excludeIndex)\nbehind ++;\n\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\nIt determines whether there are two numbers whose sum is sum in array data excluding the number with index excludeIndex . We can determine whether there are three numbers in an array with sum 0 based on this function:\nbool HasThreeNumbersWithSum0( int data[], int length)\n{\nbool found = false ;\nif (data == NULL || length < 3)\nreturn found;\n\nstd::sort(data, data + length - 1);\n\nfor ( int i = 0; i < length; ++i)\n{\nint sum = -data[i];\nint num1, num2;\nfound = FindNumbersWithSum(data, length, sum, i);\n\nif (found)\nbreak ;\n}\n\nreturn found;\n}\n\n\nIt contains two steps in function HasThreeNumbersWithSum0 . It costs O(n log n)time to sort n numbers at its first step. At its second step it costs O(n) time for each number to call FindNumberWithSum , so it costs O(n 2 ) time in the for loop. Therefore, its overall time complexity is O(n 2 ).", "question": "\nProblem 1: Given an increasingly sorted array and a number s , please find two numbers whose sum is s. If there are multiple pairs with sum s, just output any one of them.\n\nFor example, if the inputs are an array { 1 , 2 , 4 , 7 , 11 , 15 } and a number 15, please out two numbers 4 and 11 since 4+11=15.\n\n\nProblem 2: Given an array, please determine whether it contains three numbers whose sum equals to 0.\n"},
{"answer": "\nAnalysis: Let us firstly have a try to select two numbers (denoted as num1 and num2 ) of the input array. If their sum equals to s , we are fortunate because the required numbers have been found. If the sum is less than s , we may replace num1 with its next number, because the array is increasingly sorted and its next number should be greater. If the sum is greater than s , num2 can be replaced with its previous number in the sorted array, which should be less than num2 .\n\nTake the array { 1 , 2 , 4 , 7 , 11 , 15 } and number 15 as an example. We define two pointers. At the first step, they point to the first number (also the least one) 1 and the last number (also the greatest one) 15. We move the second pointer forward to number 11, since their sum 16 and it is greater than 15.\n\nAt the second step, the two numbers are 1 and 11, and their sum 12 is less than 15. Therefore, we can move the first pointer afterward and let it point to 2.\n\nThe two numbers are 2 and 11 accordingly at the third step. Since their sum 13 is less than 15, we move the first pointer afterward again.\n\nNow the two numbers are 4 and 11, and their sum is 15 which is the expected sum. Therefore, we have found two numbers whose sum is 15.\n\nThe process is summarized as in Table 1:\n\nStep Num1 Num2 Sum Comparing with s Operation 1 1 15 16 Greater Select the previous   number of Num2 2 1 11 12 Less Select the next number of Num1 3 2 11 13 Less Select the next number   of Num1 4 4 11 15 Equal\nStep\nNum1\nNum2\nSum\nComparing with s\nOperation\n1\n1\n15\n16\nGreater\nSelect the previous   number of Num2\n2\n1\n11\n12\nLess\nSelect the next number of Num1\n3\n2\n11\n13\nLess\nSelect the next number   of Num1\n4\n4\n11\n15\nEqual\n\nTable 1: Find a pair of numbers with sum 15 out of array {1 \u3001 2 \u3001 4 \u3001 7 \u3001 11 \u3001 15}\n\nAfter interviewers approve our solution, we can begin to write code. The following is a piece of sample code:\n\nbool FindNumbersWithSum( int data[], int length, int sum,\nint * num1, int * num2)\n{\nbool found = false ;\nif (length < 1 || num1 == NULL || num2 == NULL)\nreturn found;\n\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\n*num1 = data[behind];\n*num2 = data[ahead];\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\n\nIn the code above, ahead is the index of the first number, and behind is the index of the second number. Since we only need to scan the input array once, its time complexity is O(n).\n\n\nAnalysis: This problem is also required to find some numbers with a given array and sum, it is similar to the first problem. We may get some hints from the solution above.\n\nSince the input of the previous problem is an increasingly sorted array, we can also firstly sort the input array increasingly. Secondly we scan the array. When we reach the i-th number with value n , we try to find whether there are two numbers whose sum is \u2013n in the array excluding the i-th number.\n\nIt is time for us to write some code. We modify the function FindNumbersWithSum above a little bit:\n\nbool FindNumbersWithSum( int data[], int length, int sum, int excludeIndex)\n{\nbool found = false ;\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nif (ahead == excludeIndex)\nahead --;\nif (behind == excludeIndex)\nbehind ++;\n\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\nIt determines whether there are two numbers whose sum is sum in array data excluding the number with index excludeIndex . We can determine whether there are three numbers in an array with sum 0 based on this function:\nbool HasThreeNumbersWithSum0( int data[], int length)\n{\nbool found = false ;\nif (data == NULL || length < 3)\nreturn found;\n\nstd::sort(data, data + length - 1);\n\nfor ( int i = 0; i < length; ++i)\n{\nint sum = -data[i];\nint num1, num2;\nfound = FindNumbersWithSum(data, length, sum, i);\n\nif (found)\nbreak ;\n}\n\nreturn found;\n}\n\n\nIt contains two steps in function HasThreeNumbersWithSum0 . It costs O(n log n)time to sort n numbers at its first step. At its second step it costs O(n) time for each number to call FindNumberWithSum , so it costs O(n 2 ) time in the for loop. Therefore, its overall time complexity is O(n 2 ).", "question": "\nProblem 1: Given an increasingly sorted array and a number s , please find two numbers whose sum is s. If there are multiple pairs with sum s, just output any one of them.\n\nFor example, if the inputs are an array { 1 , 2 , 4 , 7 , 11 , 15 } and a number 15, please out two numbers 4 and 11 since 4+11=15.\n\n\nProblem 2: Given an array, please determine whether it contains three numbers whose sum equals to 0.\n"},
{"answer": "\nAnalysis: Binary search is suitable for sorted arrays. Let us try to utilize it on a rotation of a sorted array. Notice that a rotation of a sorted array can be partitioned into two sorted sub-arrays, and numbers in the first sub-array are greater than numbers in the second one.\nTwo pointers P1 and P2 are utilized. P1 references to the first element in the array, and P2 references to the last element. According to the rotation rule, the first element should be greater than the last one.\nThe algorithm always compares the number in middle with numbers pointed by P1 and P2 during binary search. If the middle number is in the first increasingly sorted sub-array, it is greater than the number pointed by P1.\nIf the value of target number to be search is between the number pointed by P1 and the middle number, we then search the target number in the first half sub-array. In such a case the first half sub-array is in the first increasing sub-array, we could utilize the binary search algorithm. For example, if we search the number 4 in a rotation {3, 4, 5, 1, 2}, we could search the target number 4 in the sub-array {3, 4, 5} because 4 is between the first number 3 and the middle number 5.\nIf the value of target number is not between the number pointed by P1 and the middle number, we search the target in the second half sub-array. Notice that the second half sub-array also contains two increasing sub-array and itself is also a rotation, so we could search recursively with the same strategy. For example, if we search the number 1 in a rotation {3, 4, 5, 1, 2}, we could search the target number 1 in the sub-array {5, 1, 2} recursively.\nThe analysis above is for two cases when the middle number is in the first increasing sub-array. Please analyze the other two cases when the middle number is in the second increasing sub-array yourself, when the middle number is less than the number pointed by P2.\nThe code implementing this algorithm is listed below, in C/C++:\nint searchInRotation( int numbers[], int length, int k)\n{\nif (numbers == NULL || length <= 0)\nreturn -1;\n\nreturn searchInRotation(numbers, k, 0, length - 1);\n}\n\nint searchInRotation( int numbers[], int k, int start, int end)\n{\nif (start > end)\nreturn -1;\n\nint middle = start + (end - start) / 2;\nif (numbers[middle] == k)\nreturn middle;\n\n// the middle number is in the first increasing sub-array\nif (numbers[middle] >= numbers[start])\n{\nif (k >= numbers[start] && k < numbers[middle])\nreturn binarySearch(numbers, k, start, middle - 1);\nreturn searchInRotation(numbers, k, middle + 1, end);\n}\n// the middle number is in the second increasing sub-array\nelse if (numbers[middle] <= numbers[end])\n{\nif (k > numbers[middle] && k <= numbers[end])\nreturn binarySearch(numbers, k, middle + 1, end);\nreturn searchInRotation(numbers, k, start, middle - 1);\n}\n\n// It should never reach here if the input is valid\nassert( false );\n}\nSince the function binarySearch is for the classic binary search algorithm, it is not listed here. You might implement your own binary search code if you are interested.\nIn each round of search, half of the array is excluded for the next round, so the time complexity is O(log n ).\nYou may wonder why we assume there are no duplications in the input array. We determine whether the middle number is in the first or second sub-array by comparing the middle number and the numbers pointed by P1 or P2. When the middle number, the number pointed by P1 and P2 are identical, we don\u2019t know whether the middle number is in the first or second increasing sub-array.\nLet\u2019s look at some examples. Two arrays {1, 0, 1, 1, 1} and {1, 1, 1, 0, 1} are both rotations of an increasingly sorted array {0, 1, 1, 1, 1}, which are visualized in Figure 1.\n\n\nFigure 1 : Two rotations of an increasingly sorted array {0, 1, 1, 1, 1}: {1, 0, 1, 1, 1} and {1, 1, 1, 0, 1}. Elements with gray background are in the second increasing sub-array.\nIn Figure 1, the elements pointed by P1 and P2, as well as the middle element are all 1. The middle element with index 2 is in the second sub-array in Figure 1 (a), while the middle element is in the first sub-array in Figure 1 (b).", "question": "\nQuestion: When some elements at the beginning of an array are moved to the end, it gets a rotation of the original array. Please implement a function to search a number in a rotation of an increasingly sorted array. Assume there are no duplicated numbers in the array.\nFor example, array {3, 4, 5, 1, 2} is a rotation of array {1, 2, 3, 4, 5}. If the target number to be searched is 4, the index of the number 4 in the rotation 1 should be returned. If the target number to be searched is 6, -1 should be returned because the number does not exist in the rotated array."},
{"answer": "\nAnalysis: Let us firstly have a try to select two numbers (denoted as num1 and num2 ) of the input array. If their sum equals to s , we are fortunate because the required numbers have been found. If the sum is less than s , we may replace num1 with its next number, because the array is increasingly sorted and its next number should be greater. If the sum is greater than s , num2 can be replaced with its previous number in the sorted array, which should be less than num2 .\n\nTake the array { 1 , 2 , 4 , 7 , 11 , 15 } and number 15 as an example. We define two pointers. At the first step, they point to the first number (also the least one) 1 and the last number (also the greatest one) 15. We move the second pointer forward to number 11, since their sum 16 and it is greater than 15.\n\nAt the second step, the two numbers are 1 and 11, and their sum 12 is less than 15. Therefore, we can move the first pointer afterward and let it point to 2.\n\nThe two numbers are 2 and 11 accordingly at the third step. Since their sum 13 is less than 15, we move the first pointer afterward again.\n\nNow the two numbers are 4 and 11, and their sum is 15 which is the expected sum. Therefore, we have found two numbers whose sum is 15.\n\nThe process is summarized as in Table 1:\n\nStep Num1 Num2 Sum Comparing with s Operation 1 1 15 16 Greater Select the previous   number of Num2 2 1 11 12 Less Select the next number of Num1 3 2 11 13 Less Select the next number   of Num1 4 4 11 15 Equal\nStep\nNum1\nNum2\nSum\nComparing with s\nOperation\n1\n1\n15\n16\nGreater\nSelect the previous   number of Num2\n2\n1\n11\n12\nLess\nSelect the next number of Num1\n3\n2\n11\n13\nLess\nSelect the next number   of Num1\n4\n4\n11\n15\nEqual\n\nTable 1: Find a pair of numbers with sum 15 out of array {1 \u3001 2 \u3001 4 \u3001 7 \u3001 11 \u3001 15}\n\nAfter interviewers approve our solution, we can begin to write code. The following is a piece of sample code:\n\nbool FindNumbersWithSum( int data[], int length, int sum,\nint * num1, int * num2)\n{\nbool found = false ;\nif (length < 1 || num1 == NULL || num2 == NULL)\nreturn found;\n\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\n*num1 = data[behind];\n*num2 = data[ahead];\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\n\nIn the code above, ahead is the index of the first number, and behind is the index of the second number. Since we only need to scan the input array once, its time complexity is O(n).\n\n\nAnalysis: This problem is also required to find some numbers with a given array and sum, it is similar to the first problem. We may get some hints from the solution above.\n\nSince the input of the previous problem is an increasingly sorted array, we can also firstly sort the input array increasingly. Secondly we scan the array. When we reach the i-th number with value n , we try to find whether there are two numbers whose sum is \u2013n in the array excluding the i-th number.\n\nIt is time for us to write some code. We modify the function FindNumbersWithSum above a little bit:\n\nbool FindNumbersWithSum( int data[], int length, int sum, int excludeIndex)\n{\nbool found = false ;\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nif (ahead == excludeIndex)\nahead --;\nif (behind == excludeIndex)\nbehind ++;\n\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\nIt determines whether there are two numbers whose sum is sum in array data excluding the number with index excludeIndex . We can determine whether there are three numbers in an array with sum 0 based on this function:\nbool HasThreeNumbersWithSum0( int data[], int length)\n{\nbool found = false ;\nif (data == NULL || length < 3)\nreturn found;\n\nstd::sort(data, data + length - 1);\n\nfor ( int i = 0; i < length; ++i)\n{\nint sum = -data[i];\nint num1, num2;\nfound = FindNumbersWithSum(data, length, sum, i);\n\nif (found)\nbreak ;\n}\n\nreturn found;\n}\n\n\nIt contains two steps in function HasThreeNumbersWithSum0 . It costs O(n log n)time to sort n numbers at its first step. At its second step it costs O(n) time for each number to call FindNumberWithSum , so it costs O(n 2 ) time in the for loop. Therefore, its overall time complexity is O(n 2 ).", "question": "\nProblem 1: Given an increasingly sorted array and a number s , please find two numbers whose sum is s. If there are multiple pairs with sum s, just output any one of them.\n\nFor example, if the inputs are an array { 1 , 2 , 4 , 7 , 11 , 15 } and a number 15, please out two numbers 4 and 11 since 4+11=15.\n\n\nProblem 2: Given an array, please determine whether it contains three numbers whose sum equals to 0.\n"},
{"answer": "\nAnalysis: Let us firstly have a try to select two numbers (denoted as num1 and num2 ) of the input array. If their sum equals to s , we are fortunate because the required numbers have been found. If the sum is less than s , we may replace num1 with its next number, because the array is increasingly sorted and its next number should be greater. If the sum is greater than s , num2 can be replaced with its previous number in the sorted array, which should be less than num2 .\n\nTake the array { 1 , 2 , 4 , 7 , 11 , 15 } and number 15 as an example. We define two pointers. At the first step, they point to the first number (also the least one) 1 and the last number (also the greatest one) 15. We move the second pointer forward to number 11, since their sum 16 and it is greater than 15.\n\nAt the second step, the two numbers are 1 and 11, and their sum 12 is less than 15. Therefore, we can move the first pointer afterward and let it point to 2.\n\nThe two numbers are 2 and 11 accordingly at the third step. Since their sum 13 is less than 15, we move the first pointer afterward again.\n\nNow the two numbers are 4 and 11, and their sum is 15 which is the expected sum. Therefore, we have found two numbers whose sum is 15.\n\nThe process is summarized as in Table 1:\n\nStep Num1 Num2 Sum Comparing with s Operation 1 1 15 16 Greater Select the previous   number of Num2 2 1 11 12 Less Select the next number of Num1 3 2 11 13 Less Select the next number   of Num1 4 4 11 15 Equal\nStep\nNum1\nNum2\nSum\nComparing with s\nOperation\n1\n1\n15\n16\nGreater\nSelect the previous   number of Num2\n2\n1\n11\n12\nLess\nSelect the next number of Num1\n3\n2\n11\n13\nLess\nSelect the next number   of Num1\n4\n4\n11\n15\nEqual\n\nTable 1: Find a pair of numbers with sum 15 out of array {1 \u3001 2 \u3001 4 \u3001 7 \u3001 11 \u3001 15}\n\nAfter interviewers approve our solution, we can begin to write code. The following is a piece of sample code:\n\nbool FindNumbersWithSum( int data[], int length, int sum,\nint * num1, int * num2)\n{\nbool found = false ;\nif (length < 1 || num1 == NULL || num2 == NULL)\nreturn found;\n\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\n*num1 = data[behind];\n*num2 = data[ahead];\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\n\nIn the code above, ahead is the index of the first number, and behind is the index of the second number. Since we only need to scan the input array once, its time complexity is O(n).\n\n\nAnalysis: This problem is also required to find some numbers with a given array and sum, it is similar to the first problem. We may get some hints from the solution above.\n\nSince the input of the previous problem is an increasingly sorted array, we can also firstly sort the input array increasingly. Secondly we scan the array. When we reach the i-th number with value n , we try to find whether there are two numbers whose sum is \u2013n in the array excluding the i-th number.\n\nIt is time for us to write some code. We modify the function FindNumbersWithSum above a little bit:\n\nbool FindNumbersWithSum( int data[], int length, int sum, int excludeIndex)\n{\nbool found = false ;\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nif (ahead == excludeIndex)\nahead --;\nif (behind == excludeIndex)\nbehind ++;\n\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\nIt determines whether there are two numbers whose sum is sum in array data excluding the number with index excludeIndex . We can determine whether there are three numbers in an array with sum 0 based on this function:\nbool HasThreeNumbersWithSum0( int data[], int length)\n{\nbool found = false ;\nif (data == NULL || length < 3)\nreturn found;\n\nstd::sort(data, data + length - 1);\n\nfor ( int i = 0; i < length; ++i)\n{\nint sum = -data[i];\nint num1, num2;\nfound = FindNumbersWithSum(data, length, sum, i);\n\nif (found)\nbreak ;\n}\n\nreturn found;\n}\n\n\nIt contains two steps in function HasThreeNumbersWithSum0 . It costs O(n log n)time to sort n numbers at its first step. At its second step it costs O(n) time for each number to call FindNumberWithSum , so it costs O(n 2 ) time in the for loop. Therefore, its overall time complexity is O(n 2 ).", "question": "\nProblem 1: Given an increasingly sorted array and a number s , please find two numbers whose sum is s. If there are multiple pairs with sum s, just output any one of them.\n\nFor example, if the inputs are an array { 1 , 2 , 4 , 7 , 11 , 15 } and a number 15, please out two numbers 4 and 11 since 4+11=15.\n\n\nProblem 2: Given an array, please determine whether it contains three numbers whose sum equals to 0.\n"},
{"answer": "\nAnalysis: Let us firstly have a try to select two numbers (denoted as num1 and num2 ) of the input array. If their sum equals to s , we are fortunate because the required numbers have been found. If the sum is less than s , we may replace num1 with its next number, because the array is increasingly sorted and its next number should be greater. If the sum is greater than s , num2 can be replaced with its previous number in the sorted array, which should be less than num2 .\n\nTake the array { 1 , 2 , 4 , 7 , 11 , 15 } and number 15 as an example. We define two pointers. At the first step, they point to the first number (also the least one) 1 and the last number (also the greatest one) 15. We move the second pointer forward to number 11, since their sum 16 and it is greater than 15.\n\nAt the second step, the two numbers are 1 and 11, and their sum 12 is less than 15. Therefore, we can move the first pointer afterward and let it point to 2.\n\nThe two numbers are 2 and 11 accordingly at the third step. Since their sum 13 is less than 15, we move the first pointer afterward again.\n\nNow the two numbers are 4 and 11, and their sum is 15 which is the expected sum. Therefore, we have found two numbers whose sum is 15.\n\nThe process is summarized as in Table 1:\n\nStep Num1 Num2 Sum Comparing with s Operation 1 1 15 16 Greater Select the previous   number of Num2 2 1 11 12 Less Select the next number of Num1 3 2 11 13 Less Select the next number   of Num1 4 4 11 15 Equal\nStep\nNum1\nNum2\nSum\nComparing with s\nOperation\n1\n1\n15\n16\nGreater\nSelect the previous   number of Num2\n2\n1\n11\n12\nLess\nSelect the next number of Num1\n3\n2\n11\n13\nLess\nSelect the next number   of Num1\n4\n4\n11\n15\nEqual\n\nTable 1: Find a pair of numbers with sum 15 out of array {1 \u3001 2 \u3001 4 \u3001 7 \u3001 11 \u3001 15}\n\nAfter interviewers approve our solution, we can begin to write code. The following is a piece of sample code:\n\nbool FindNumbersWithSum( int data[], int length, int sum,\nint * num1, int * num2)\n{\nbool found = false ;\nif (length < 1 || num1 == NULL || num2 == NULL)\nreturn found;\n\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\n*num1 = data[behind];\n*num2 = data[ahead];\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\n\nIn the code above, ahead is the index of the first number, and behind is the index of the second number. Since we only need to scan the input array once, its time complexity is O(n).\n\n\nAnalysis: This problem is also required to find some numbers with a given array and sum, it is similar to the first problem. We may get some hints from the solution above.\n\nSince the input of the previous problem is an increasingly sorted array, we can also firstly sort the input array increasingly. Secondly we scan the array. When we reach the i-th number with value n , we try to find whether there are two numbers whose sum is \u2013n in the array excluding the i-th number.\n\nIt is time for us to write some code. We modify the function FindNumbersWithSum above a little bit:\n\nbool FindNumbersWithSum( int data[], int length, int sum, int excludeIndex)\n{\nbool found = false ;\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nif (ahead == excludeIndex)\nahead --;\nif (behind == excludeIndex)\nbehind ++;\n\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\nIt determines whether there are two numbers whose sum is sum in array data excluding the number with index excludeIndex . We can determine whether there are three numbers in an array with sum 0 based on this function:\nbool HasThreeNumbersWithSum0( int data[], int length)\n{\nbool found = false ;\nif (data == NULL || length < 3)\nreturn found;\n\nstd::sort(data, data + length - 1);\n\nfor ( int i = 0; i < length; ++i)\n{\nint sum = -data[i];\nint num1, num2;\nfound = FindNumbersWithSum(data, length, sum, i);\n\nif (found)\nbreak ;\n}\n\nreturn found;\n}\n\n\nIt contains two steps in function HasThreeNumbersWithSum0 . It costs O(n log n)time to sort n numbers at its first step. At its second step it costs O(n) time for each number to call FindNumberWithSum , so it costs O(n 2 ) time in the for loop. Therefore, its overall time complexity is O(n 2 ).", "question": "\nProblem 1: Given an increasingly sorted array and a number s , please find two numbers whose sum is s. If there are multiple pairs with sum s, just output any one of them.\n\nFor example, if the inputs are an array { 1 , 2 , 4 , 7 , 11 , 15 } and a number 15, please out two numbers 4 and 11 since 4+11=15.\n\n\nProblem 2: Given an array, please determine whether it contains three numbers whose sum equals to 0.\n"},
{"answer": "\nAnalysis: Let us firstly have a try to select two numbers (denoted as num1 and num2 ) of the input array. If their sum equals to s , we are fortunate because the required numbers have been found. If the sum is less than s , we may replace num1 with its next number, because the array is increasingly sorted and its next number should be greater. If the sum is greater than s , num2 can be replaced with its previous number in the sorted array, which should be less than num2 .\n\nTake the array { 1 , 2 , 4 , 7 , 11 , 15 } and number 15 as an example. We define two pointers. At the first step, they point to the first number (also the least one) 1 and the last number (also the greatest one) 15. We move the second pointer forward to number 11, since their sum 16 and it is greater than 15.\n\nAt the second step, the two numbers are 1 and 11, and their sum 12 is less than 15. Therefore, we can move the first pointer afterward and let it point to 2.\n\nThe two numbers are 2 and 11 accordingly at the third step. Since their sum 13 is less than 15, we move the first pointer afterward again.\n\nNow the two numbers are 4 and 11, and their sum is 15 which is the expected sum. Therefore, we have found two numbers whose sum is 15.\n\nThe process is summarized as in Table 1:\n\nStep Num1 Num2 Sum Comparing with s Operation 1 1 15 16 Greater Select the previous   number of Num2 2 1 11 12 Less Select the next number of Num1 3 2 11 13 Less Select the next number   of Num1 4 4 11 15 Equal\nStep\nNum1\nNum2\nSum\nComparing with s\nOperation\n1\n1\n15\n16\nGreater\nSelect the previous   number of Num2\n2\n1\n11\n12\nLess\nSelect the next number of Num1\n3\n2\n11\n13\nLess\nSelect the next number   of Num1\n4\n4\n11\n15\nEqual\n\nTable 1: Find a pair of numbers with sum 15 out of array {1 \u3001 2 \u3001 4 \u3001 7 \u3001 11 \u3001 15}\n\nAfter interviewers approve our solution, we can begin to write code. The following is a piece of sample code:\n\nbool FindNumbersWithSum( int data[], int length, int sum,\nint * num1, int * num2)\n{\nbool found = false ;\nif (length < 1 || num1 == NULL || num2 == NULL)\nreturn found;\n\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\n*num1 = data[behind];\n*num2 = data[ahead];\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\n\nIn the code above, ahead is the index of the first number, and behind is the index of the second number. Since we only need to scan the input array once, its time complexity is O(n).\n\n\nAnalysis: This problem is also required to find some numbers with a given array and sum, it is similar to the first problem. We may get some hints from the solution above.\n\nSince the input of the previous problem is an increasingly sorted array, we can also firstly sort the input array increasingly. Secondly we scan the array. When we reach the i-th number with value n , we try to find whether there are two numbers whose sum is \u2013n in the array excluding the i-th number.\n\nIt is time for us to write some code. We modify the function FindNumbersWithSum above a little bit:\n\nbool FindNumbersWithSum( int data[], int length, int sum, int excludeIndex)\n{\nbool found = false ;\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nif (ahead == excludeIndex)\nahead --;\nif (behind == excludeIndex)\nbehind ++;\n\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\nIt determines whether there are two numbers whose sum is sum in array data excluding the number with index excludeIndex . We can determine whether there are three numbers in an array with sum 0 based on this function:\nbool HasThreeNumbersWithSum0( int data[], int length)\n{\nbool found = false ;\nif (data == NULL || length < 3)\nreturn found;\n\nstd::sort(data, data + length - 1);\n\nfor ( int i = 0; i < length; ++i)\n{\nint sum = -data[i];\nint num1, num2;\nfound = FindNumbersWithSum(data, length, sum, i);\n\nif (found)\nbreak ;\n}\n\nreturn found;\n}\n\n\nIt contains two steps in function HasThreeNumbersWithSum0 . It costs O(n log n)time to sort n numbers at its first step. At its second step it costs O(n) time for each number to call FindNumberWithSum , so it costs O(n 2 ) time in the for loop. Therefore, its overall time complexity is O(n 2 ).", "question": "\nProblem 1: Given an increasingly sorted array and a number s , please find two numbers whose sum is s. If there are multiple pairs with sum s, just output any one of them.\n\nFor example, if the inputs are an array { 1 , 2 , 4 , 7 , 11 , 15 } and a number 15, please out two numbers 4 and 11 since 4+11=15.\n\n\nProblem 2: Given an array, please determine whether it contains three numbers whose sum equals to 0.\n"},
{"answer": "\nAnalysis: Let us firstly have a try to select two numbers (denoted as num1 and num2 ) of the input array. If their sum equals to s , we are fortunate because the required numbers have been found. If the sum is less than s , we may replace num1 with its next number, because the array is increasingly sorted and its next number should be greater. If the sum is greater than s , num2 can be replaced with its previous number in the sorted array, which should be less than num2 .\n\nTake the array { 1 , 2 , 4 , 7 , 11 , 15 } and number 15 as an example. We define two pointers. At the first step, they point to the first number (also the least one) 1 and the last number (also the greatest one) 15. We move the second pointer forward to number 11, since their sum 16 and it is greater than 15.\n\nAt the second step, the two numbers are 1 and 11, and their sum 12 is less than 15. Therefore, we can move the first pointer afterward and let it point to 2.\n\nThe two numbers are 2 and 11 accordingly at the third step. Since their sum 13 is less than 15, we move the first pointer afterward again.\n\nNow the two numbers are 4 and 11, and their sum is 15 which is the expected sum. Therefore, we have found two numbers whose sum is 15.\n\nThe process is summarized as in Table 1:\n\nStep Num1 Num2 Sum Comparing with s Operation 1 1 15 16 Greater Select the previous   number of Num2 2 1 11 12 Less Select the next number of Num1 3 2 11 13 Less Select the next number   of Num1 4 4 11 15 Equal\nStep\nNum1\nNum2\nSum\nComparing with s\nOperation\n1\n1\n15\n16\nGreater\nSelect the previous   number of Num2\n2\n1\n11\n12\nLess\nSelect the next number of Num1\n3\n2\n11\n13\nLess\nSelect the next number   of Num1\n4\n4\n11\n15\nEqual\n\nTable 1: Find a pair of numbers with sum 15 out of array {1 \u3001 2 \u3001 4 \u3001 7 \u3001 11 \u3001 15}\n\nAfter interviewers approve our solution, we can begin to write code. The following is a piece of sample code:\n\nbool FindNumbersWithSum( int data[], int length, int sum,\nint * num1, int * num2)\n{\nbool found = false ;\nif (length < 1 || num1 == NULL || num2 == NULL)\nreturn found;\n\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\n*num1 = data[behind];\n*num2 = data[ahead];\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\n\nIn the code above, ahead is the index of the first number, and behind is the index of the second number. Since we only need to scan the input array once, its time complexity is O(n).\n\n\nAnalysis: This problem is also required to find some numbers with a given array and sum, it is similar to the first problem. We may get some hints from the solution above.\n\nSince the input of the previous problem is an increasingly sorted array, we can also firstly sort the input array increasingly. Secondly we scan the array. When we reach the i-th number with value n , we try to find whether there are two numbers whose sum is \u2013n in the array excluding the i-th number.\n\nIt is time for us to write some code. We modify the function FindNumbersWithSum above a little bit:\n\nbool FindNumbersWithSum( int data[], int length, int sum, int excludeIndex)\n{\nbool found = false ;\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nif (ahead == excludeIndex)\nahead --;\nif (behind == excludeIndex)\nbehind ++;\n\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\nIt determines whether there are two numbers whose sum is sum in array data excluding the number with index excludeIndex . We can determine whether there are three numbers in an array with sum 0 based on this function:\nbool HasThreeNumbersWithSum0( int data[], int length)\n{\nbool found = false ;\nif (data == NULL || length < 3)\nreturn found;\n\nstd::sort(data, data + length - 1);\n\nfor ( int i = 0; i < length; ++i)\n{\nint sum = -data[i];\nint num1, num2;\nfound = FindNumbersWithSum(data, length, sum, i);\n\nif (found)\nbreak ;\n}\n\nreturn found;\n}\n\n\nIt contains two steps in function HasThreeNumbersWithSum0 . It costs O(n log n)time to sort n numbers at its first step. At its second step it costs O(n) time for each number to call FindNumberWithSum , so it costs O(n 2 ) time in the for loop. Therefore, its overall time complexity is O(n 2 ).", "question": "\nProblem 1: Given an increasingly sorted array and a number s , please find two numbers whose sum is s. If there are multiple pairs with sum s, just output any one of them.\n\nFor example, if the inputs are an array { 1 , 2 , 4 , 7 , 11 , 15 } and a number 15, please out two numbers 4 and 11 since 4+11=15.\n\n\nProblem 2: Given an array, please determine whether it contains three numbers whose sum equals to 0.\n"},
{"answer": "\nAnalysis: Let us firstly have a try to select two numbers (denoted as num1 and num2 ) of the input array. If their sum equals to s , we are fortunate because the required numbers have been found. If the sum is less than s , we may replace num1 with its next number, because the array is increasingly sorted and its next number should be greater. If the sum is greater than s , num2 can be replaced with its previous number in the sorted array, which should be less than num2 .\n\nTake the array { 1 , 2 , 4 , 7 , 11 , 15 } and number 15 as an example. We define two pointers. At the first step, they point to the first number (also the least one) 1 and the last number (also the greatest one) 15. We move the second pointer forward to number 11, since their sum 16 and it is greater than 15.\n\nAt the second step, the two numbers are 1 and 11, and their sum 12 is less than 15. Therefore, we can move the first pointer afterward and let it point to 2.\n\nThe two numbers are 2 and 11 accordingly at the third step. Since their sum 13 is less than 15, we move the first pointer afterward again.\n\nNow the two numbers are 4 and 11, and their sum is 15 which is the expected sum. Therefore, we have found two numbers whose sum is 15.\n\nThe process is summarized as in Table 1:\n\nStep Num1 Num2 Sum Comparing with s Operation 1 1 15 16 Greater Select the previous   number of Num2 2 1 11 12 Less Select the next number of Num1 3 2 11 13 Less Select the next number   of Num1 4 4 11 15 Equal\nStep\nNum1\nNum2\nSum\nComparing with s\nOperation\n1\n1\n15\n16\nGreater\nSelect the previous   number of Num2\n2\n1\n11\n12\nLess\nSelect the next number of Num1\n3\n2\n11\n13\nLess\nSelect the next number   of Num1\n4\n4\n11\n15\nEqual\n\nTable 1: Find a pair of numbers with sum 15 out of array {1 \u3001 2 \u3001 4 \u3001 7 \u3001 11 \u3001 15}\n\nAfter interviewers approve our solution, we can begin to write code. The following is a piece of sample code:\n\nbool FindNumbersWithSum( int data[], int length, int sum,\nint * num1, int * num2)\n{\nbool found = false ;\nif (length < 1 || num1 == NULL || num2 == NULL)\nreturn found;\n\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\n*num1 = data[behind];\n*num2 = data[ahead];\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\n\nIn the code above, ahead is the index of the first number, and behind is the index of the second number. Since we only need to scan the input array once, its time complexity is O(n).\n\n\nAnalysis: This problem is also required to find some numbers with a given array and sum, it is similar to the first problem. We may get some hints from the solution above.\n\nSince the input of the previous problem is an increasingly sorted array, we can also firstly sort the input array increasingly. Secondly we scan the array. When we reach the i-th number with value n , we try to find whether there are two numbers whose sum is \u2013n in the array excluding the i-th number.\n\nIt is time for us to write some code. We modify the function FindNumbersWithSum above a little bit:\n\nbool FindNumbersWithSum( int data[], int length, int sum, int excludeIndex)\n{\nbool found = false ;\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nif (ahead == excludeIndex)\nahead --;\nif (behind == excludeIndex)\nbehind ++;\n\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\nIt determines whether there are two numbers whose sum is sum in array data excluding the number with index excludeIndex . We can determine whether there are three numbers in an array with sum 0 based on this function:\nbool HasThreeNumbersWithSum0( int data[], int length)\n{\nbool found = false ;\nif (data == NULL || length < 3)\nreturn found;\n\nstd::sort(data, data + length - 1);\n\nfor ( int i = 0; i < length; ++i)\n{\nint sum = -data[i];\nint num1, num2;\nfound = FindNumbersWithSum(data, length, sum, i);\n\nif (found)\nbreak ;\n}\n\nreturn found;\n}\n\n\nIt contains two steps in function HasThreeNumbersWithSum0 . It costs O(n log n)time to sort n numbers at its first step. At its second step it costs O(n) time for each number to call FindNumberWithSum , so it costs O(n 2 ) time in the for loop. Therefore, its overall time complexity is O(n 2 ).", "question": "\nProblem 1: Given an increasingly sorted array and a number s , please find two numbers whose sum is s. If there are multiple pairs with sum s, just output any one of them.\n\nFor example, if the inputs are an array { 1 , 2 , 4 , 7 , 11 , 15 } and a number 15, please out two numbers 4 and 11 since 4+11=15.\n\n\nProblem 2: Given an array, please determine whether it contains three numbers whose sum equals to 0.\n"},
{"answer": "\nAnalysis: Let us firstly have a try to select two numbers (denoted as num1 and num2 ) of the input array. If their sum equals to s , we are fortunate because the required numbers have been found. If the sum is less than s , we may replace num1 with its next number, because the array is increasingly sorted and its next number should be greater. If the sum is greater than s , num2 can be replaced with its previous number in the sorted array, which should be less than num2 .\n\nTake the array { 1 , 2 , 4 , 7 , 11 , 15 } and number 15 as an example. We define two pointers. At the first step, they point to the first number (also the least one) 1 and the last number (also the greatest one) 15. We move the second pointer forward to number 11, since their sum 16 and it is greater than 15.\n\nAt the second step, the two numbers are 1 and 11, and their sum 12 is less than 15. Therefore, we can move the first pointer afterward and let it point to 2.\n\nThe two numbers are 2 and 11 accordingly at the third step. Since their sum 13 is less than 15, we move the first pointer afterward again.\n\nNow the two numbers are 4 and 11, and their sum is 15 which is the expected sum. Therefore, we have found two numbers whose sum is 15.\n\nThe process is summarized as in Table 1:\n\nStep Num1 Num2 Sum Comparing with s Operation 1 1 15 16 Greater Select the previous   number of Num2 2 1 11 12 Less Select the next number of Num1 3 2 11 13 Less Select the next number   of Num1 4 4 11 15 Equal\nStep\nNum1\nNum2\nSum\nComparing with s\nOperation\n1\n1\n15\n16\nGreater\nSelect the previous   number of Num2\n2\n1\n11\n12\nLess\nSelect the next number of Num1\n3\n2\n11\n13\nLess\nSelect the next number   of Num1\n4\n4\n11\n15\nEqual\n\nTable 1: Find a pair of numbers with sum 15 out of array {1 \u3001 2 \u3001 4 \u3001 7 \u3001 11 \u3001 15}\n\nAfter interviewers approve our solution, we can begin to write code. The following is a piece of sample code:\n\nbool FindNumbersWithSum( int data[], int length, int sum,\nint * num1, int * num2)\n{\nbool found = false ;\nif (length < 1 || num1 == NULL || num2 == NULL)\nreturn found;\n\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\n*num1 = data[behind];\n*num2 = data[ahead];\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\n\nIn the code above, ahead is the index of the first number, and behind is the index of the second number. Since we only need to scan the input array once, its time complexity is O(n).\n\n\nAnalysis: This problem is also required to find some numbers with a given array and sum, it is similar to the first problem. We may get some hints from the solution above.\n\nSince the input of the previous problem is an increasingly sorted array, we can also firstly sort the input array increasingly. Secondly we scan the array. When we reach the i-th number with value n , we try to find whether there are two numbers whose sum is \u2013n in the array excluding the i-th number.\n\nIt is time for us to write some code. We modify the function FindNumbersWithSum above a little bit:\n\nbool FindNumbersWithSum( int data[], int length, int sum, int excludeIndex)\n{\nbool found = false ;\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nif (ahead == excludeIndex)\nahead --;\nif (behind == excludeIndex)\nbehind ++;\n\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\nIt determines whether there are two numbers whose sum is sum in array data excluding the number with index excludeIndex . We can determine whether there are three numbers in an array with sum 0 based on this function:\nbool HasThreeNumbersWithSum0( int data[], int length)\n{\nbool found = false ;\nif (data == NULL || length < 3)\nreturn found;\n\nstd::sort(data, data + length - 1);\n\nfor ( int i = 0; i < length; ++i)\n{\nint sum = -data[i];\nint num1, num2;\nfound = FindNumbersWithSum(data, length, sum, i);\n\nif (found)\nbreak ;\n}\n\nreturn found;\n}\n\n\nIt contains two steps in function HasThreeNumbersWithSum0 . It costs O(n log n)time to sort n numbers at its first step. At its second step it costs O(n) time for each number to call FindNumberWithSum , so it costs O(n 2 ) time in the for loop. Therefore, its overall time complexity is O(n 2 ).", "question": "\nProblem 1: Given an increasingly sorted array and a number s , please find two numbers whose sum is s. If there are multiple pairs with sum s, just output any one of them.\n\nFor example, if the inputs are an array { 1 , 2 , 4 , 7 , 11 , 15 } and a number 15, please out two numbers 4 and 11 since 4+11=15.\n\n\nProblem 2: Given an array, please determine whether it contains three numbers whose sum equals to 0.\n"},
{"answer": "\nAnalysis: Let us firstly have a try to select two numbers (denoted as num1 and num2 ) of the input array. If their sum equals to s , we are fortunate because the required numbers have been found. If the sum is less than s , we may replace num1 with its next number, because the array is increasingly sorted and its next number should be greater. If the sum is greater than s , num2 can be replaced with its previous number in the sorted array, which should be less than num2 .\n\nTake the array { 1 , 2 , 4 , 7 , 11 , 15 } and number 15 as an example. We define two pointers. At the first step, they point to the first number (also the least one) 1 and the last number (also the greatest one) 15. We move the second pointer forward to number 11, since their sum 16 and it is greater than 15.\n\nAt the second step, the two numbers are 1 and 11, and their sum 12 is less than 15. Therefore, we can move the first pointer afterward and let it point to 2.\n\nThe two numbers are 2 and 11 accordingly at the third step. Since their sum 13 is less than 15, we move the first pointer afterward again.\n\nNow the two numbers are 4 and 11, and their sum is 15 which is the expected sum. Therefore, we have found two numbers whose sum is 15.\n\nThe process is summarized as in Table 1:\n\nStep Num1 Num2 Sum Comparing with s Operation 1 1 15 16 Greater Select the previous   number of Num2 2 1 11 12 Less Select the next number of Num1 3 2 11 13 Less Select the next number   of Num1 4 4 11 15 Equal\nStep\nNum1\nNum2\nSum\nComparing with s\nOperation\n1\n1\n15\n16\nGreater\nSelect the previous   number of Num2\n2\n1\n11\n12\nLess\nSelect the next number of Num1\n3\n2\n11\n13\nLess\nSelect the next number   of Num1\n4\n4\n11\n15\nEqual\n\nTable 1: Find a pair of numbers with sum 15 out of array {1 \u3001 2 \u3001 4 \u3001 7 \u3001 11 \u3001 15}\n\nAfter interviewers approve our solution, we can begin to write code. The following is a piece of sample code:\n\nbool FindNumbersWithSum( int data[], int length, int sum,\nint * num1, int * num2)\n{\nbool found = false ;\nif (length < 1 || num1 == NULL || num2 == NULL)\nreturn found;\n\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\n*num1 = data[behind];\n*num2 = data[ahead];\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\n\nIn the code above, ahead is the index of the first number, and behind is the index of the second number. Since we only need to scan the input array once, its time complexity is O(n).\n\n\nAnalysis: This problem is also required to find some numbers with a given array and sum, it is similar to the first problem. We may get some hints from the solution above.\n\nSince the input of the previous problem is an increasingly sorted array, we can also firstly sort the input array increasingly. Secondly we scan the array. When we reach the i-th number with value n , we try to find whether there are two numbers whose sum is \u2013n in the array excluding the i-th number.\n\nIt is time for us to write some code. We modify the function FindNumbersWithSum above a little bit:\n\nbool FindNumbersWithSum( int data[], int length, int sum, int excludeIndex)\n{\nbool found = false ;\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nif (ahead == excludeIndex)\nahead --;\nif (behind == excludeIndex)\nbehind ++;\n\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\nIt determines whether there are two numbers whose sum is sum in array data excluding the number with index excludeIndex . We can determine whether there are three numbers in an array with sum 0 based on this function:\nbool HasThreeNumbersWithSum0( int data[], int length)\n{\nbool found = false ;\nif (data == NULL || length < 3)\nreturn found;\n\nstd::sort(data, data + length - 1);\n\nfor ( int i = 0; i < length; ++i)\n{\nint sum = -data[i];\nint num1, num2;\nfound = FindNumbersWithSum(data, length, sum, i);\n\nif (found)\nbreak ;\n}\n\nreturn found;\n}\n\n\nIt contains two steps in function HasThreeNumbersWithSum0 . It costs O(n log n)time to sort n numbers at its first step. At its second step it costs O(n) time for each number to call FindNumberWithSum , so it costs O(n 2 ) time in the for loop. Therefore, its overall time complexity is O(n 2 ).", "question": "\nProblem 1: Given an increasingly sorted array and a number s , please find two numbers whose sum is s. If there are multiple pairs with sum s, just output any one of them.\n\nFor example, if the inputs are an array { 1 , 2 , 4 , 7 , 11 , 15 } and a number 15, please out two numbers 4 and 11 since 4+11=15.\n\n\nProblem 2: Given an array, please determine whether it contains three numbers whose sum equals to 0.\n"},
{"answer": "\nAnalysis: Let us firstly have a try to select two numbers (denoted as num1 and num2 ) of the input array. If their sum equals to s , we are fortunate because the required numbers have been found. If the sum is less than s , we may replace num1 with its next number, because the array is increasingly sorted and its next number should be greater. If the sum is greater than s , num2 can be replaced with its previous number in the sorted array, which should be less than num2 .\n\nTake the array { 1 , 2 , 4 , 7 , 11 , 15 } and number 15 as an example. We define two pointers. At the first step, they point to the first number (also the least one) 1 and the last number (also the greatest one) 15. We move the second pointer forward to number 11, since their sum 16 and it is greater than 15.\n\nAt the second step, the two numbers are 1 and 11, and their sum 12 is less than 15. Therefore, we can move the first pointer afterward and let it point to 2.\n\nThe two numbers are 2 and 11 accordingly at the third step. Since their sum 13 is less than 15, we move the first pointer afterward again.\n\nNow the two numbers are 4 and 11, and their sum is 15 which is the expected sum. Therefore, we have found two numbers whose sum is 15.\n\nThe process is summarized as in Table 1:\n\nStep Num1 Num2 Sum Comparing with s Operation 1 1 15 16 Greater Select the previous   number of Num2 2 1 11 12 Less Select the next number of Num1 3 2 11 13 Less Select the next number   of Num1 4 4 11 15 Equal\nStep\nNum1\nNum2\nSum\nComparing with s\nOperation\n1\n1\n15\n16\nGreater\nSelect the previous   number of Num2\n2\n1\n11\n12\nLess\nSelect the next number of Num1\n3\n2\n11\n13\nLess\nSelect the next number   of Num1\n4\n4\n11\n15\nEqual\n\nTable 1: Find a pair of numbers with sum 15 out of array {1 \u3001 2 \u3001 4 \u3001 7 \u3001 11 \u3001 15}\n\nAfter interviewers approve our solution, we can begin to write code. The following is a piece of sample code:\n\nbool FindNumbersWithSum( int data[], int length, int sum,\nint * num1, int * num2)\n{\nbool found = false ;\nif (length < 1 || num1 == NULL || num2 == NULL)\nreturn found;\n\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\n*num1 = data[behind];\n*num2 = data[ahead];\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\n\nIn the code above, ahead is the index of the first number, and behind is the index of the second number. Since we only need to scan the input array once, its time complexity is O(n).\n\n\nAnalysis: This problem is also required to find some numbers with a given array and sum, it is similar to the first problem. We may get some hints from the solution above.\n\nSince the input of the previous problem is an increasingly sorted array, we can also firstly sort the input array increasingly. Secondly we scan the array. When we reach the i-th number with value n , we try to find whether there are two numbers whose sum is \u2013n in the array excluding the i-th number.\n\nIt is time for us to write some code. We modify the function FindNumbersWithSum above a little bit:\n\nbool FindNumbersWithSum( int data[], int length, int sum, int excludeIndex)\n{\nbool found = false ;\nint ahead = length - 1;\nint behind = 0;\n\nwhile (ahead > behind)\n{\nif (ahead == excludeIndex)\nahead --;\nif (behind == excludeIndex)\nbehind ++;\n\nlong long curSum = data[ahead] + data[behind];\n\nif (curSum == sum)\n{\nfound = true ;\nbreak ;\n}\nelse if (curSum > sum)\nahead --;\nelse\nbehind ++;\n}\n\nreturn found;\n}\nIt determines whether there are two numbers whose sum is sum in array data excluding the number with index excludeIndex . We can determine whether there are three numbers in an array with sum 0 based on this function:\nbool HasThreeNumbersWithSum0( int data[], int length)\n{\nbool found = false ;\nif (data == NULL || length < 3)\nreturn found;\n\nstd::sort(data, data + length - 1);\n\nfor ( int i = 0; i < length; ++i)\n{\nint sum = -data[i];\nint num1, num2;\nfound = FindNumbersWithSum(data, length, sum, i);\n\nif (found)\nbreak ;\n}\n\nreturn found;\n}\n\n\nIt contains two steps in function HasThreeNumbersWithSum0 . It costs O(n log n)time to sort n numbers at its first step. At its second step it costs O(n) time for each number to call FindNumberWithSum , so it costs O(n 2 ) time in the for loop. Therefore, its overall time complexity is O(n 2 ).", "question": "\nProblem 1: Given an increasingly sorted array and a number s , please find two numbers whose sum is s. If there are multiple pairs with sum s, just output any one of them.\n\nFor example, if the inputs are an array { 1 , 2 , 4 , 7 , 11 , 15 } and a number 15, please out two numbers 4 and 11 since 4+11=15.\n\n\nProblem 2: Given an array, please determine whether it contains three numbers whose sum equals to 0.\n"},
{"answer": "\nAnalysis: The most straightforward solution for this problem is to scan the whole array from the beginning to end. When a target number is scanned, remove it and move all number behind it backward. The overall complexity is O( n 2 ), since we have to move O( n ) numbers when a target value is removed.\n\nWe can notice that it is not required to keep the order for the remaining numbers, and it does not care what numbers left beyond the new length. Therefore, we can move all target numbers to be removed to the end of the array.\n\nTwo pointers are defined to solve this problem: The first pointer (denoted as p1 ) moves forward until it reaches a number equal to the target value, which is initialized to the beginning of array. The other (denoted as p2 ) moves backward until it reaches a number not equal to the target value, which is initialized to the end of array. Two numbers pointed by p1 and p2 are swapped. We repeat the moving and swapping operations until all target numbers are scanned.\n\nThe sample code is shown as below:\n\nunsigned int Remove( int * numbers, unsigned int length, int n)\n{\nif (numbers == NULL || length < 1)\nreturn 0;\n\nint * p1 = numbers;\nint * p2 = numbers + length - 1;\nwhile (p1 < p2)\n{\nwhile (*p1 != n && (p1 - numbers) < length)\n++p1;\nwhile (*p2 == n && (p2 - numbers) > 0)\n--p2;\n\nif (p1 < p2)\n{\n*p1 = *p2;\n*p2 = n;\n}\n}\n\nreturn p1 - numbers;\n}\n\nBecause p1 points to the first target number in the array after scanning and swap, all elements at the left side of p2 are the remaining numbers. The new length can be calculated by the difference between the beginning of array and p1 .\n\nSince it is only required to scan the whole array once, and it costs O(1) time to swap a target value to the end of array, the overall time complexity is O( n ) for an array with n numbers.", "question": "\nQuestion: Given an array and a value, how to implement a function to remove all instances of that value in place and return the new length? The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\nFor example, if the input array is {4, 3, 2, 1, 2, 3, 6}, the result array after removing value 2 contains numbers {4, 3, 1, 3, 6}, and the new length of the remaining array is 5."},
{"answer": "\nAnalysis: The most straightforward solution for this problem is to scan the whole array from the beginning to end. When a target number is scanned, remove it and move all number behind it backward. The overall complexity is O( n 2 ), since we have to move O( n ) numbers when a target value is removed.\n\nWe can notice that it is not required to keep the order for the remaining numbers, and it does not care what numbers left beyond the new length. Therefore, we can move all target numbers to be removed to the end of the array.\n\nTwo pointers are defined to solve this problem: The first pointer (denoted as p1 ) moves forward until it reaches a number equal to the target value, which is initialized to the beginning of array. The other (denoted as p2 ) moves backward until it reaches a number not equal to the target value, which is initialized to the end of array. Two numbers pointed by p1 and p2 are swapped. We repeat the moving and swapping operations until all target numbers are scanned.\n\nThe sample code is shown as below:\n\nunsigned int Remove( int * numbers, unsigned int length, int n)\n{\nif (numbers == NULL || length < 1)\nreturn 0;\n\nint * p1 = numbers;\nint * p2 = numbers + length - 1;\nwhile (p1 < p2)\n{\nwhile (*p1 != n && (p1 - numbers) < length)\n++p1;\nwhile (*p2 == n && (p2 - numbers) > 0)\n--p2;\n\nif (p1 < p2)\n{\n*p1 = *p2;\n*p2 = n;\n}\n}\n\nreturn p1 - numbers;\n}\n\nBecause p1 points to the first target number in the array after scanning and swap, all elements at the left side of p2 are the remaining numbers. The new length can be calculated by the difference between the beginning of array and p1 .\n\nSince it is only required to scan the whole array once, and it costs O(1) time to swap a target value to the end of array, the overall time complexity is O( n ) for an array with n numbers.", "question": "\nQuestion: Given an array and a value, how to implement a function to remove all instances of that value in place and return the new length? The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\nFor example, if the input array is {4, 3, 2, 1, 2, 3, 6}, the result array after removing value 2 contains numbers {4, 3, 1, 3, 6}, and the new length of the remaining array is 5."},
{"answer": "\nAnalysis: The most straightforward solution for this problem is to scan the whole array from the beginning to end. When a target number is scanned, remove it and move all number behind it backward. The overall complexity is O( n 2 ), since we have to move O( n ) numbers when a target value is removed.\n\nWe can notice that it is not required to keep the order for the remaining numbers, and it does not care what numbers left beyond the new length. Therefore, we can move all target numbers to be removed to the end of the array.\n\nTwo pointers are defined to solve this problem: The first pointer (denoted as p1 ) moves forward until it reaches a number equal to the target value, which is initialized to the beginning of array. The other (denoted as p2 ) moves backward until it reaches a number not equal to the target value, which is initialized to the end of array. Two numbers pointed by p1 and p2 are swapped. We repeat the moving and swapping operations until all target numbers are scanned.\n\nThe sample code is shown as below:\n\nunsigned int Remove( int * numbers, unsigned int length, int n)\n{\nif (numbers == NULL || length < 1)\nreturn 0;\n\nint * p1 = numbers;\nint * p2 = numbers + length - 1;\nwhile (p1 < p2)\n{\nwhile (*p1 != n && (p1 - numbers) < length)\n++p1;\nwhile (*p2 == n && (p2 - numbers) > 0)\n--p2;\n\nif (p1 < p2)\n{\n*p1 = *p2;\n*p2 = n;\n}\n}\n\nreturn p1 - numbers;\n}\n\nBecause p1 points to the first target number in the array after scanning and swap, all elements at the left side of p2 are the remaining numbers. The new length can be calculated by the difference between the beginning of array and p1 .\n\nSince it is only required to scan the whole array once, and it costs O(1) time to swap a target value to the end of array, the overall time complexity is O( n ) for an array with n numbers.", "question": "\nQuestion: Given an array and a value, how to implement a function to remove all instances of that value in place and return the new length? The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\nFor example, if the input array is {4, 3, 2, 1, 2, 3, 6}, the result array after removing value 2 contains numbers {4, 3, 1, 3, 6}, and the new length of the remaining array is 5."},
{"answer": "\nAnalysis: The most straightforward solution for this problem is to scan the whole array from the beginning to end. When a target number is scanned, remove it and move all number behind it backward. The overall complexity is O( n 2 ), since we have to move O( n ) numbers when a target value is removed.\n\nWe can notice that it is not required to keep the order for the remaining numbers, and it does not care what numbers left beyond the new length. Therefore, we can move all target numbers to be removed to the end of the array.\n\nTwo pointers are defined to solve this problem: The first pointer (denoted as p1 ) moves forward until it reaches a number equal to the target value, which is initialized to the beginning of array. The other (denoted as p2 ) moves backward until it reaches a number not equal to the target value, which is initialized to the end of array. Two numbers pointed by p1 and p2 are swapped. We repeat the moving and swapping operations until all target numbers are scanned.\n\nThe sample code is shown as below:\n\nunsigned int Remove( int * numbers, unsigned int length, int n)\n{\nif (numbers == NULL || length < 1)\nreturn 0;\n\nint * p1 = numbers;\nint * p2 = numbers + length - 1;\nwhile (p1 < p2)\n{\nwhile (*p1 != n && (p1 - numbers) < length)\n++p1;\nwhile (*p2 == n && (p2 - numbers) > 0)\n--p2;\n\nif (p1 < p2)\n{\n*p1 = *p2;\n*p2 = n;\n}\n}\n\nreturn p1 - numbers;\n}\n\nBecause p1 points to the first target number in the array after scanning and swap, all elements at the left side of p2 are the remaining numbers. The new length can be calculated by the difference between the beginning of array and p1 .\n\nSince it is only required to scan the whole array once, and it costs O(1) time to swap a target value to the end of array, the overall time complexity is O( n ) for an array with n numbers.", "question": "\nQuestion: Given an array and a value, how to implement a function to remove all instances of that value in place and return the new length? The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\nFor example, if the input array is {4, 3, 2, 1, 2, 3, 6}, the result array after removing value 2 contains numbers {4, 3, 1, 3, 6}, and the new length of the remaining array is 5."},
{"answer": "\nAnalysis: The most straightforward solution for this problem is to scan the whole array from the beginning to end. When a target number is scanned, remove it and move all number behind it backward. The overall complexity is O( n 2 ), since we have to move O( n ) numbers when a target value is removed.\n\nWe can notice that it is not required to keep the order for the remaining numbers, and it does not care what numbers left beyond the new length. Therefore, we can move all target numbers to be removed to the end of the array.\n\nTwo pointers are defined to solve this problem: The first pointer (denoted as p1 ) moves forward until it reaches a number equal to the target value, which is initialized to the beginning of array. The other (denoted as p2 ) moves backward until it reaches a number not equal to the target value, which is initialized to the end of array. Two numbers pointed by p1 and p2 are swapped. We repeat the moving and swapping operations until all target numbers are scanned.\n\nThe sample code is shown as below:\n\nunsigned int Remove( int * numbers, unsigned int length, int n)\n{\nif (numbers == NULL || length < 1)\nreturn 0;\n\nint * p1 = numbers;\nint * p2 = numbers + length - 1;\nwhile (p1 < p2)\n{\nwhile (*p1 != n && (p1 - numbers) < length)\n++p1;\nwhile (*p2 == n && (p2 - numbers) > 0)\n--p2;\n\nif (p1 < p2)\n{\n*p1 = *p2;\n*p2 = n;\n}\n}\n\nreturn p1 - numbers;\n}\n\nBecause p1 points to the first target number in the array after scanning and swap, all elements at the left side of p2 are the remaining numbers. The new length can be calculated by the difference between the beginning of array and p1 .\n\nSince it is only required to scan the whole array once, and it costs O(1) time to swap a target value to the end of array, the overall time complexity is O( n ) for an array with n numbers.", "question": "\nQuestion: Given an array and a value, how to implement a function to remove all instances of that value in place and return the new length? The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\nFor example, if the input array is {4, 3, 2, 1, 2, 3, 6}, the result array after removing value 2 contains numbers {4, 3, 1, 3, 6}, and the new length of the remaining array is 5."},
{"answer": "\nAnalysis: The most straightforward solution for this problem is to scan the whole array from the beginning to end. When a target number is scanned, remove it and move all number behind it backward. The overall complexity is O( n 2 ), since we have to move O( n ) numbers when a target value is removed.\n\nWe can notice that it is not required to keep the order for the remaining numbers, and it does not care what numbers left beyond the new length. Therefore, we can move all target numbers to be removed to the end of the array.\n\nTwo pointers are defined to solve this problem: The first pointer (denoted as p1 ) moves forward until it reaches a number equal to the target value, which is initialized to the beginning of array. The other (denoted as p2 ) moves backward until it reaches a number not equal to the target value, which is initialized to the end of array. Two numbers pointed by p1 and p2 are swapped. We repeat the moving and swapping operations until all target numbers are scanned.\n\nThe sample code is shown as below:\n\nunsigned int Remove( int * numbers, unsigned int length, int n)\n{\nif (numbers == NULL || length < 1)\nreturn 0;\n\nint * p1 = numbers;\nint * p2 = numbers + length - 1;\nwhile (p1 < p2)\n{\nwhile (*p1 != n && (p1 - numbers) < length)\n++p1;\nwhile (*p2 == n && (p2 - numbers) > 0)\n--p2;\n\nif (p1 < p2)\n{\n*p1 = *p2;\n*p2 = n;\n}\n}\n\nreturn p1 - numbers;\n}\n\nBecause p1 points to the first target number in the array after scanning and swap, all elements at the left side of p2 are the remaining numbers. The new length can be calculated by the difference between the beginning of array and p1 .\n\nSince it is only required to scan the whole array once, and it costs O(1) time to swap a target value to the end of array, the overall time complexity is O( n ) for an array with n numbers.", "question": "\nQuestion: Given an array and a value, how to implement a function to remove all instances of that value in place and return the new length? The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\nFor example, if the input array is {4, 3, 2, 1, 2, 3, 6}, the result array after removing value 2 contains numbers {4, 3, 1, 3, 6}, and the new length of the remaining array is 5."},
{"answer": "\nAnalysis: The most straightforward solution for this problem is to scan the whole array from the beginning to end. When a target number is scanned, remove it and move all number behind it backward. The overall complexity is O( n 2 ), since we have to move O( n ) numbers when a target value is removed.\n\nWe can notice that it is not required to keep the order for the remaining numbers, and it does not care what numbers left beyond the new length. Therefore, we can move all target numbers to be removed to the end of the array.\n\nTwo pointers are defined to solve this problem: The first pointer (denoted as p1 ) moves forward until it reaches a number equal to the target value, which is initialized to the beginning of array. The other (denoted as p2 ) moves backward until it reaches a number not equal to the target value, which is initialized to the end of array. Two numbers pointed by p1 and p2 are swapped. We repeat the moving and swapping operations until all target numbers are scanned.\n\nThe sample code is shown as below:\n\nunsigned int Remove( int * numbers, unsigned int length, int n)\n{\nif (numbers == NULL || length < 1)\nreturn 0;\n\nint * p1 = numbers;\nint * p2 = numbers + length - 1;\nwhile (p1 < p2)\n{\nwhile (*p1 != n && (p1 - numbers) < length)\n++p1;\nwhile (*p2 == n && (p2 - numbers) > 0)\n--p2;\n\nif (p1 < p2)\n{\n*p1 = *p2;\n*p2 = n;\n}\n}\n\nreturn p1 - numbers;\n}\n\nBecause p1 points to the first target number in the array after scanning and swap, all elements at the left side of p2 are the remaining numbers. The new length can be calculated by the difference between the beginning of array and p1 .\n\nSince it is only required to scan the whole array once, and it costs O(1) time to swap a target value to the end of array, the overall time complexity is O( n ) for an array with n numbers.", "question": "\nQuestion: Given an array and a value, how to implement a function to remove all instances of that value in place and return the new length? The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\nFor example, if the input array is {4, 3, 2, 1, 2, 3, 6}, the result array after removing value 2 contains numbers {4, 3, 1, 3, 6}, and the new length of the remaining array is 5."},
{"answer": "\nAnalysis: The most straightforward solution for this problem is to scan the whole array from the beginning to end. When a target number is scanned, remove it and move all number behind it backward. The overall complexity is O( n 2 ), since we have to move O( n ) numbers when a target value is removed.\n\nWe can notice that it is not required to keep the order for the remaining numbers, and it does not care what numbers left beyond the new length. Therefore, we can move all target numbers to be removed to the end of the array.\n\nTwo pointers are defined to solve this problem: The first pointer (denoted as p1 ) moves forward until it reaches a number equal to the target value, which is initialized to the beginning of array. The other (denoted as p2 ) moves backward until it reaches a number not equal to the target value, which is initialized to the end of array. Two numbers pointed by p1 and p2 are swapped. We repeat the moving and swapping operations until all target numbers are scanned.\n\nThe sample code is shown as below:\n\nunsigned int Remove( int * numbers, unsigned int length, int n)\n{\nif (numbers == NULL || length < 1)\nreturn 0;\n\nint * p1 = numbers;\nint * p2 = numbers + length - 1;\nwhile (p1 < p2)\n{\nwhile (*p1 != n && (p1 - numbers) < length)\n++p1;\nwhile (*p2 == n && (p2 - numbers) > 0)\n--p2;\n\nif (p1 < p2)\n{\n*p1 = *p2;\n*p2 = n;\n}\n}\n\nreturn p1 - numbers;\n}\n\nBecause p1 points to the first target number in the array after scanning and swap, all elements at the left side of p2 are the remaining numbers. The new length can be calculated by the difference between the beginning of array and p1 .\n\nSince it is only required to scan the whole array once, and it costs O(1) time to swap a target value to the end of array, the overall time complexity is O( n ) for an array with n numbers.", "question": "\nQuestion: Given an array and a value, how to implement a function to remove all instances of that value in place and return the new length? The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\nFor example, if the input array is {4, 3, 2, 1, 2, 3, 6}, the result array after removing value 2 contains numbers {4, 3, 1, 3, 6}, and the new length of the remaining array is 5."},
{"answer": "\nAnalysis: The most straightforward solution for this problem is to scan the whole array from the beginning to end. When a target number is scanned, remove it and move all number behind it backward. The overall complexity is O( n 2 ), since we have to move O( n ) numbers when a target value is removed.\n\nWe can notice that it is not required to keep the order for the remaining numbers, and it does not care what numbers left beyond the new length. Therefore, we can move all target numbers to be removed to the end of the array.\n\nTwo pointers are defined to solve this problem: The first pointer (denoted as p1 ) moves forward until it reaches a number equal to the target value, which is initialized to the beginning of array. The other (denoted as p2 ) moves backward until it reaches a number not equal to the target value, which is initialized to the end of array. Two numbers pointed by p1 and p2 are swapped. We repeat the moving and swapping operations until all target numbers are scanned.\n\nThe sample code is shown as below:\n\nunsigned int Remove( int * numbers, unsigned int length, int n)\n{\nif (numbers == NULL || length < 1)\nreturn 0;\n\nint * p1 = numbers;\nint * p2 = numbers + length - 1;\nwhile (p1 < p2)\n{\nwhile (*p1 != n && (p1 - numbers) < length)\n++p1;\nwhile (*p2 == n && (p2 - numbers) > 0)\n--p2;\n\nif (p1 < p2)\n{\n*p1 = *p2;\n*p2 = n;\n}\n}\n\nreturn p1 - numbers;\n}\n\nBecause p1 points to the first target number in the array after scanning and swap, all elements at the left side of p2 are the remaining numbers. The new length can be calculated by the difference between the beginning of array and p1 .\n\nSince it is only required to scan the whole array once, and it costs O(1) time to swap a target value to the end of array, the overall time complexity is O( n ) for an array with n numbers.", "question": "\nQuestion: Given an array and a value, how to implement a function to remove all instances of that value in place and return the new length? The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\nFor example, if the input array is {4, 3, 2, 1, 2, 3, 6}, the result array after removing value 2 contains numbers {4, 3, 1, 3, 6}, and the new length of the remaining array is 5."},
{"answer": "\nAnalysis: The most straightforward solution for this problem is to scan the whole array from the beginning to end. When a target number is scanned, remove it and move all number behind it backward. The overall complexity is O( n 2 ), since we have to move O( n ) numbers when a target value is removed.\n\nWe can notice that it is not required to keep the order for the remaining numbers, and it does not care what numbers left beyond the new length. Therefore, we can move all target numbers to be removed to the end of the array.\n\nTwo pointers are defined to solve this problem: The first pointer (denoted as p1 ) moves forward until it reaches a number equal to the target value, which is initialized to the beginning of array. The other (denoted as p2 ) moves backward until it reaches a number not equal to the target value, which is initialized to the end of array. Two numbers pointed by p1 and p2 are swapped. We repeat the moving and swapping operations until all target numbers are scanned.\n\nThe sample code is shown as below:\n\nunsigned int Remove( int * numbers, unsigned int length, int n)\n{\nif (numbers == NULL || length < 1)\nreturn 0;\n\nint * p1 = numbers;\nint * p2 = numbers + length - 1;\nwhile (p1 < p2)\n{\nwhile (*p1 != n && (p1 - numbers) < length)\n++p1;\nwhile (*p2 == n && (p2 - numbers) > 0)\n--p2;\n\nif (p1 < p2)\n{\n*p1 = *p2;\n*p2 = n;\n}\n}\n\nreturn p1 - numbers;\n}\n\nBecause p1 points to the first target number in the array after scanning and swap, all elements at the left side of p2 are the remaining numbers. The new length can be calculated by the difference between the beginning of array and p1 .\n\nSince it is only required to scan the whole array once, and it costs O(1) time to swap a target value to the end of array, the overall time complexity is O( n ) for an array with n numbers.", "question": "\nQuestion: Given an array and a value, how to implement a function to remove all instances of that value in place and return the new length? The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\nFor example, if the input array is {4, 3, 2, 1, 2, 3, 6}, the result array after removing value 2 contains numbers {4, 3, 1, 3, 6}, and the new length of the remaining array is 5."},
{"answer": "\nAnalysis: The most straightforward solution for this problem is to scan the whole array from the beginning to end. When a target number is scanned, remove it and move all number behind it backward. The overall complexity is O( n 2 ), since we have to move O( n ) numbers when a target value is removed.\n\nWe can notice that it is not required to keep the order for the remaining numbers, and it does not care what numbers left beyond the new length. Therefore, we can move all target numbers to be removed to the end of the array.\n\nTwo pointers are defined to solve this problem: The first pointer (denoted as p1 ) moves forward until it reaches a number equal to the target value, which is initialized to the beginning of array. The other (denoted as p2 ) moves backward until it reaches a number not equal to the target value, which is initialized to the end of array. Two numbers pointed by p1 and p2 are swapped. We repeat the moving and swapping operations until all target numbers are scanned.\n\nThe sample code is shown as below:\n\nunsigned int Remove( int * numbers, unsigned int length, int n)\n{\nif (numbers == NULL || length < 1)\nreturn 0;\n\nint * p1 = numbers;\nint * p2 = numbers + length - 1;\nwhile (p1 < p2)\n{\nwhile (*p1 != n && (p1 - numbers) < length)\n++p1;\nwhile (*p2 == n && (p2 - numbers) > 0)\n--p2;\n\nif (p1 < p2)\n{\n*p1 = *p2;\n*p2 = n;\n}\n}\n\nreturn p1 - numbers;\n}\n\nBecause p1 points to the first target number in the array after scanning and swap, all elements at the left side of p2 are the remaining numbers. The new length can be calculated by the difference between the beginning of array and p1 .\n\nSince it is only required to scan the whole array once, and it costs O(1) time to swap a target value to the end of array, the overall time complexity is O( n ) for an array with n numbers.", "question": "\nQuestion: Given an array and a value, how to implement a function to remove all instances of that value in place and return the new length? The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\nFor example, if the input array is {4, 3, 2, 1, 2, 3, 6}, the result array after removing value 2 contains numbers {4, 3, 1, 3, 6}, and the new length of the remaining array is 5."},
{"answer": "\nAnalysis: The most straightforward solution for this problem is to scan the whole array from the beginning to end. When a target number is scanned, remove it and move all number behind it backward. The overall complexity is O( n 2 ), since we have to move O( n ) numbers when a target value is removed.\n\nWe can notice that it is not required to keep the order for the remaining numbers, and it does not care what numbers left beyond the new length. Therefore, we can move all target numbers to be removed to the end of the array.\n\nTwo pointers are defined to solve this problem: The first pointer (denoted as p1 ) moves forward until it reaches a number equal to the target value, which is initialized to the beginning of array. The other (denoted as p2 ) moves backward until it reaches a number not equal to the target value, which is initialized to the end of array. Two numbers pointed by p1 and p2 are swapped. We repeat the moving and swapping operations until all target numbers are scanned.\n\nThe sample code is shown as below:\n\nunsigned int Remove( int * numbers, unsigned int length, int n)\n{\nif (numbers == NULL || length < 1)\nreturn 0;\n\nint * p1 = numbers;\nint * p2 = numbers + length - 1;\nwhile (p1 < p2)\n{\nwhile (*p1 != n && (p1 - numbers) < length)\n++p1;\nwhile (*p2 == n && (p2 - numbers) > 0)\n--p2;\n\nif (p1 < p2)\n{\n*p1 = *p2;\n*p2 = n;\n}\n}\n\nreturn p1 - numbers;\n}\n\nBecause p1 points to the first target number in the array after scanning and swap, all elements at the left side of p2 are the remaining numbers. The new length can be calculated by the difference between the beginning of array and p1 .\n\nSince it is only required to scan the whole array once, and it costs O(1) time to swap a target value to the end of array, the overall time complexity is O( n ) for an array with n numbers.", "question": "\nQuestion: Given an array and a value, how to implement a function to remove all instances of that value in place and return the new length? The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\nFor example, if the input array is {4, 3, 2, 1, 2, 3, 6}, the result array after removing value 2 contains numbers {4, 3, 1, 3, 6}, and the new length of the remaining array is 5."},
{"answer": "\nAnalysis: The most straightforward solution for this problem is to scan the whole array from the beginning to end. When a target number is scanned, remove it and move all number behind it backward. The overall complexity is O( n 2 ), since we have to move O( n ) numbers when a target value is removed.\n\nWe can notice that it is not required to keep the order for the remaining numbers, and it does not care what numbers left beyond the new length. Therefore, we can move all target numbers to be removed to the end of the array.\n\nTwo pointers are defined to solve this problem: The first pointer (denoted as p1 ) moves forward until it reaches a number equal to the target value, which is initialized to the beginning of array. The other (denoted as p2 ) moves backward until it reaches a number not equal to the target value, which is initialized to the end of array. Two numbers pointed by p1 and p2 are swapped. We repeat the moving and swapping operations until all target numbers are scanned.\n\nThe sample code is shown as below:\n\nunsigned int Remove( int * numbers, unsigned int length, int n)\n{\nif (numbers == NULL || length < 1)\nreturn 0;\n\nint * p1 = numbers;\nint * p2 = numbers + length - 1;\nwhile (p1 < p2)\n{\nwhile (*p1 != n && (p1 - numbers) < length)\n++p1;\nwhile (*p2 == n && (p2 - numbers) > 0)\n--p2;\n\nif (p1 < p2)\n{\n*p1 = *p2;\n*p2 = n;\n}\n}\n\nreturn p1 - numbers;\n}\n\nBecause p1 points to the first target number in the array after scanning and swap, all elements at the left side of p2 are the remaining numbers. The new length can be calculated by the difference between the beginning of array and p1 .\n\nSince it is only required to scan the whole array once, and it costs O(1) time to swap a target value to the end of array, the overall time complexity is O( n ) for an array with n numbers.", "question": "\nQuestion: Given an array and a value, how to implement a function to remove all instances of that value in place and return the new length? The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\nFor example, if the input array is {4, 3, 2, 1, 2, 3, 6}, the result array after removing value 2 contains numbers {4, 3, 1, 3, 6}, and the new length of the remaining array is 5."},
{"answer": "\nAnalysis : It is a typical problem about dynamic programming. Firstly let\u2019s analyze it with recursion. A function f ( i , j ) is defined for the maximal value of gifts when reaching the cell ( i , j ). There are two possible cells before the cell ( i , j ) is reached: One is ( i - 1, j ), and the other is the cell ( i , j -1). Therefore, f ( i , j )= max ( f ( i -1, j ), f ( i , j -1)) + gift[ i , j ].\nEven though it\u2019s a recursive equation, it\u2019s not a good idea to write code in recursion, because there might be many over-lapping sub-problems. A better solution is to solve is with iteration. A 2-D matrix is utilized, and the value in each cell ( i , j ) is the maximal value of gift when reaching the cell ( i , j ) on the board.\nThe iterative solution can be implemented in the following Java code:\n public static int getMaxValue( int [][] values) {\nOptimization\n\nThe maximal value of gifts when reaching the cell ( i , j ) depends on the cells ( i -1, j ) and ( i , j -1) only, so it is not necessary to save the value of the cells in the rows i -2 and above. Therefore, we can replace the 2-D matrix with an array, as the following code shows:\n\n public static int getMaxValue( int [][] values)  {\n     int rows = values.length;\n     int cols = values[0].length;\n\n     int [] maxValues = new int [cols];\n     for ( int i = 0; i < rows; ++i)  {\n         for ( int j = 0; j < cols; ++j)  {\n             int left = 0;\n             int up = 0;\n\n             if (i > 0)  {\n                 up = maxValues[j];\n             }\n\n             if (j > 0)  {\n                 left = maxValues[j - 1];\n             }\n\n             maxValues[j] = Math .max(left, up) +values[i][j];\n         }\n     }\n\n     return maxValues[cols - 1];\n }", "question": "\nQuestion : A board has n * m cells, and there is a gift with some value (value is greater than 0) in every cell. You can get gifts starting from the top-left cell, and move right or down in each step, and finally reach the cell at the bottom-right cell. What\u2019s the maximal value of gifts you can get from the board?\n\n\nFor example, the maximal value of gift from the board above is 53, and the path is highlighted in red."},
{"answer": "\nAnalysis : It is a typical problem about dynamic programming. Firstly let\u2019s analyze it with recursion. A function f ( i , j ) is defined for the maximal value of gifts when reaching the cell ( i , j ). There are two possible cells before the cell ( i , j ) is reached: One is ( i - 1, j ), and the other is the cell ( i , j -1). Therefore, f ( i , j )= max ( f ( i -1, j ), f ( i , j -1)) + gift[ i , j ].\nEven though it\u2019s a recursive equation, it\u2019s not a good idea to write code in recursion, because there might be many over-lapping sub-problems. A better solution is to solve is with iteration. A 2-D matrix is utilized, and the value in each cell ( i , j ) is the maximal value of gift when reaching the cell ( i , j ) on the board.\nThe iterative solution can be implemented in the following Java code:\n public static int getMaxValue( int [][] values) {\nOptimization\n\nThe maximal value of gifts when reaching the cell ( i , j ) depends on the cells ( i -1, j ) and ( i , j -1) only, so it is not necessary to save the value of the cells in the rows i -2 and above. Therefore, we can replace the 2-D matrix with an array, as the following code shows:\n\n public static int getMaxValue( int [][] values)  {\n     int rows = values.length;\n     int cols = values[0].length;\n\n     int [] maxValues = new int [cols];\n     for ( int i = 0; i < rows; ++i)  {\n         for ( int j = 0; j < cols; ++j)  {\n             int left = 0;\n             int up = 0;\n\n             if (i > 0)  {\n                 up = maxValues[j];\n             }\n\n             if (j > 0)  {\n                 left = maxValues[j - 1];\n             }\n\n             maxValues[j] = Math .max(left, up) +values[i][j];\n         }\n     }\n\n     return maxValues[cols - 1];\n }", "question": "\nQuestion : A board has n * m cells, and there is a gift with some value (value is greater than 0) in every cell. You can get gifts starting from the top-left cell, and move right or down in each step, and finally reach the cell at the bottom-right cell. What\u2019s the maximal value of gifts you can get from the board?\n\n\nFor example, the maximal value of gift from the board above is 53, and the path is highlighted in red."},
{"answer": "\nAnalysis: If we scan all integers in the array from beginning to end, we may check whether every element equals its index. Obviously, this solution costs O( n ) time.\nSince numbers are sorted in the array, let's try to utilize the binary search algorithm to optimize. Supposing we reach the i th element in the array at some step. If the value of element is also i , it is a target integer and let's return it.\nWhat would happen when the value m is greater than the index i ? For any k ( k >0), the value of element with index i + k should be greater than or equal to m + k , because integers are unique and increasingly sorted in the array. Additionally because m > k , m + k > i + k . Therefore, every element on the right side of index i should be greater than its index in such a case.\nSimilarly, when the value of element with index i is less than i ,\u00a0every integer on the left side should be less than its index. Please prove it if you are interested.\nTherefore, we could reduce the search scope to half for the next step, and it is a typical process for binary search. The solution can be implemented with the following Java code:\n public static int getNumberSameAsIndex( int [] numbers) {\n     if (numbers == null || numbers.length == 0) {\n         return -1;\n     }\n        \n     int left = 0;\n     int right = numbers.length - 1;\n     while (left <= right) {\n         int middle = left + ((right - left) >>> 1);\n         if (numbers[middle] == middle) {\n             return middle;\n         }\n            \n         if (numbers[middle] > middle) {\n             right = middle - 1;\n         }\n         else {\n             left= middle + 1;\n         }\n     }\n        \n     return -1;\n }", "question": "\nProblem: Integers in an array are unique and increasingly sorted. Please write a function/method to find an integer from the array who equals to its index. For example, in the array {-3, -1, 1, 3, 5}, the number 3 equals its index 3."},
{"answer": "\nAnalysis: If we scan all integers in the array from beginning to end, we may check whether every element equals its index. Obviously, this solution costs O( n ) time.\nSince numbers are sorted in the array, let's try to utilize the binary search algorithm to optimize. Supposing we reach the i th element in the array at some step. If the value of element is also i , it is a target integer and let's return it.\nWhat would happen when the value m is greater than the index i ? For any k ( k >0), the value of element with index i + k should be greater than or equal to m + k , because integers are unique and increasingly sorted in the array. Additionally because m > k , m + k > i + k . Therefore, every element on the right side of index i should be greater than its index in such a case.\nSimilarly, when the value of element with index i is less than i ,\u00a0every integer on the left side should be less than its index. Please prove it if you are interested.\nTherefore, we could reduce the search scope to half for the next step, and it is a typical process for binary search. The solution can be implemented with the following Java code:\n public static int getNumberSameAsIndex( int [] numbers) {\n     if (numbers == null || numbers.length == 0) {\n         return -1;\n     }\n        \n     int left = 0;\n     int right = numbers.length - 1;\n     while (left <= right) {\n         int middle = left + ((right - left) >>> 1);\n         if (numbers[middle] == middle) {\n             return middle;\n         }\n            \n         if (numbers[middle] > middle) {\n             right = middle - 1;\n         }\n         else {\n             left= middle + 1;\n         }\n     }\n        \n     return -1;\n }", "question": "\nProblem: Integers in an array are unique and increasingly sorted. Please write a function/method to find an integer from the array who equals to its index. For example, in the array {-3, -1, 1, 3, 5}, the number 3 equals its index 3."},
{"answer": "\nAnalysis: If we scan all integers in the array from beginning to end, we may check whether every element equals its index. Obviously, this solution costs O( n ) time.\nSince numbers are sorted in the array, let's try to utilize the binary search algorithm to optimize. Supposing we reach the i th element in the array at some step. If the value of element is also i , it is a target integer and let's return it.\nWhat would happen when the value m is greater than the index i ? For any k ( k >0), the value of element with index i + k should be greater than or equal to m + k , because integers are unique and increasingly sorted in the array. Additionally because m > k , m + k > i + k . Therefore, every element on the right side of index i should be greater than its index in such a case.\nSimilarly, when the value of element with index i is less than i ,\u00a0every integer on the left side should be less than its index. Please prove it if you are interested.\nTherefore, we could reduce the search scope to half for the next step, and it is a typical process for binary search. The solution can be implemented with the following Java code:\n public static int getNumberSameAsIndex( int [] numbers) {\n     if (numbers == null || numbers.length == 0) {\n         return -1;\n     }\n        \n     int left = 0;\n     int right = numbers.length - 1;\n     while (left <= right) {\n         int middle = left + ((right - left) >>> 1);\n         if (numbers[middle] == middle) {\n             return middle;\n         }\n            \n         if (numbers[middle] > middle) {\n             right = middle - 1;\n         }\n         else {\n             left= middle + 1;\n         }\n     }\n        \n     return -1;\n }", "question": "\nProblem: Integers in an array are unique and increasingly sorted. Please write a function/method to find an integer from the array who equals to its index. For example, in the array {-3, -1, 1, 3, 5}, the number 3 equals its index 3."},
{"answer": "\nAnalysis: If we scan all integers in the array from beginning to end, we may check whether every element equals its index. Obviously, this solution costs O( n ) time.\nSince numbers are sorted in the array, let's try to utilize the binary search algorithm to optimize. Supposing we reach the i th element in the array at some step. If the value of element is also i , it is a target integer and let's return it.\nWhat would happen when the value m is greater than the index i ? For any k ( k >0), the value of element with index i + k should be greater than or equal to m + k , because integers are unique and increasingly sorted in the array. Additionally because m > k , m + k > i + k . Therefore, every element on the right side of index i should be greater than its index in such a case.\nSimilarly, when the value of element with index i is less than i ,\u00a0every integer on the left side should be less than its index. Please prove it if you are interested.\nTherefore, we could reduce the search scope to half for the next step, and it is a typical process for binary search. The solution can be implemented with the following Java code:\n public static int getNumberSameAsIndex( int [] numbers) {\n     if (numbers == null || numbers.length == 0) {\n         return -1;\n     }\n        \n     int left = 0;\n     int right = numbers.length - 1;\n     while (left <= right) {\n         int middle = left + ((right - left) >>> 1);\n         if (numbers[middle] == middle) {\n             return middle;\n         }\n            \n         if (numbers[middle] > middle) {\n             right = middle - 1;\n         }\n         else {\n             left= middle + 1;\n         }\n     }\n        \n     return -1;\n }", "question": "\nProblem: Integers in an array are unique and increasingly sorted. Please write a function/method to find an integer from the array who equals to its index. For example, in the array {-3, -1, 1, 3, 5}, the number 3 equals its index 3."},
{"answer": "\nAnalysis: If we scan all integers in the array from beginning to end, we may check whether every element equals its index. Obviously, this solution costs O( n ) time.\nSince numbers are sorted in the array, let's try to utilize the binary search algorithm to optimize. Supposing we reach the i th element in the array at some step. If the value of element is also i , it is a target integer and let's return it.\nWhat would happen when the value m is greater than the index i ? For any k ( k >0), the value of element with index i + k should be greater than or equal to m + k , because integers are unique and increasingly sorted in the array. Additionally because m > k , m + k > i + k . Therefore, every element on the right side of index i should be greater than its index in such a case.\nSimilarly, when the value of element with index i is less than i ,\u00a0every integer on the left side should be less than its index. Please prove it if you are interested.\nTherefore, we could reduce the search scope to half for the next step, and it is a typical process for binary search. The solution can be implemented with the following Java code:\n public static int getNumberSameAsIndex( int [] numbers) {\n     if (numbers == null || numbers.length == 0) {\n         return -1;\n     }\n        \n     int left = 0;\n     int right = numbers.length - 1;\n     while (left <= right) {\n         int middle = left + ((right - left) >>> 1);\n         if (numbers[middle] == middle) {\n             return middle;\n         }\n            \n         if (numbers[middle] > middle) {\n             right = middle - 1;\n         }\n         else {\n             left= middle + 1;\n         }\n     }\n        \n     return -1;\n }", "question": "\nProblem: Integers in an array are unique and increasingly sorted. Please write a function/method to find an integer from the array who equals to its index. For example, in the array {-3, -1, 1, 3, 5}, the number 3 equals its index 3."},
{"answer": "\nAnalysis: If we scan all integers in the array from beginning to end, we may check whether every element equals its index. Obviously, this solution costs O( n ) time.\nSince numbers are sorted in the array, let's try to utilize the binary search algorithm to optimize. Supposing we reach the i th element in the array at some step. If the value of element is also i , it is a target integer and let's return it.\nWhat would happen when the value m is greater than the index i ? For any k ( k >0), the value of element with index i + k should be greater than or equal to m + k , because integers are unique and increasingly sorted in the array. Additionally because m > k , m + k > i + k . Therefore, every element on the right side of index i should be greater than its index in such a case.\nSimilarly, when the value of element with index i is less than i ,\u00a0every integer on the left side should be less than its index. Please prove it if you are interested.\nTherefore, we could reduce the search scope to half for the next step, and it is a typical process for binary search. The solution can be implemented with the following Java code:\n public static int getNumberSameAsIndex( int [] numbers) {\n     if (numbers == null || numbers.length == 0) {\n         return -1;\n     }\n        \n     int left = 0;\n     int right = numbers.length - 1;\n     while (left <= right) {\n         int middle = left + ((right - left) >>> 1);\n         if (numbers[middle] == middle) {\n             return middle;\n         }\n            \n         if (numbers[middle] > middle) {\n             right = middle - 1;\n         }\n         else {\n             left= middle + 1;\n         }\n     }\n        \n     return -1;\n }", "question": "\nProblem: Integers in an array are unique and increasingly sorted. Please write a function/method to find an integer from the array who equals to its index. For example, in the array {-3, -1, 1, 3, 5}, the number 3 equals its index 3."},
{"answer": "\nAnalysis: If we scan all integers in the array from beginning to end, we may check whether every element equals its index. Obviously, this solution costs O( n ) time.\nSince numbers are sorted in the array, let's try to utilize the binary search algorithm to optimize. Supposing we reach the i th element in the array at some step. If the value of element is also i , it is a target integer and let's return it.\nWhat would happen when the value m is greater than the index i ? For any k ( k >0), the value of element with index i + k should be greater than or equal to m + k , because integers are unique and increasingly sorted in the array. Additionally because m > k , m + k > i + k . Therefore, every element on the right side of index i should be greater than its index in such a case.\nSimilarly, when the value of element with index i is less than i ,\u00a0every integer on the left side should be less than its index. Please prove it if you are interested.\nTherefore, we could reduce the search scope to half for the next step, and it is a typical process for binary search. The solution can be implemented with the following Java code:\n public static int getNumberSameAsIndex( int [] numbers) {\n     if (numbers == null || numbers.length == 0) {\n         return -1;\n     }\n        \n     int left = 0;\n     int right = numbers.length - 1;\n     while (left <= right) {\n         int middle = left + ((right - left) >>> 1);\n         if (numbers[middle] == middle) {\n             return middle;\n         }\n            \n         if (numbers[middle] > middle) {\n             right = middle - 1;\n         }\n         else {\n             left= middle + 1;\n         }\n     }\n        \n     return -1;\n }", "question": "\nProblem: Integers in an array are unique and increasingly sorted. Please write a function/method to find an integer from the array who equals to its index. For example, in the array {-3, -1, 1, 3, 5}, the number 3 equals its index 3."},
{"answer": "\nAnalysis: If we scan all integers in the array from beginning to end, we may check whether every element equals its index. Obviously, this solution costs O( n ) time.\nSince numbers are sorted in the array, let's try to utilize the binary search algorithm to optimize. Supposing we reach the i th element in the array at some step. If the value of element is also i , it is a target integer and let's return it.\nWhat would happen when the value m is greater than the index i ? For any k ( k >0), the value of element with index i + k should be greater than or equal to m + k , because integers are unique and increasingly sorted in the array. Additionally because m > k , m + k > i + k . Therefore, every element on the right side of index i should be greater than its index in such a case.\nSimilarly, when the value of element with index i is less than i ,\u00a0every integer on the left side should be less than its index. Please prove it if you are interested.\nTherefore, we could reduce the search scope to half for the next step, and it is a typical process for binary search. The solution can be implemented with the following Java code:\n public static int getNumberSameAsIndex( int [] numbers) {\n     if (numbers == null || numbers.length == 0) {\n         return -1;\n     }\n        \n     int left = 0;\n     int right = numbers.length - 1;\n     while (left <= right) {\n         int middle = left + ((right - left) >>> 1);\n         if (numbers[middle] == middle) {\n             return middle;\n         }\n            \n         if (numbers[middle] > middle) {\n             right = middle - 1;\n         }\n         else {\n             left= middle + 1;\n         }\n     }\n        \n     return -1;\n }", "question": "\nProblem: Integers in an array are unique and increasingly sorted. Please write a function/method to find an integer from the array who equals to its index. For example, in the array {-3, -1, 1, 3, 5}, the number 3 equals its index 3."},
{"answer": "", "question": ""},
{"answer": "", "question": ""},
{"answer": "", "question": ""}]